(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports={"styles":{"composer":".composer {\r\n  line-height: 2;\r\n}\r\n\r\n.composer-node {\r\n\r\n}\r\n\r\n.composer-node__toolbar {\r\n  min-height: 3em;\r\n\r\n  background: #666;\r\n  color: #fff;\r\n  border: 0.0625rem solid #887;\r\n  border-bottom: 0.0625rem solid #445;\r\n  border-right: 0.0625rem solid #445;\r\n  box-shadow: 0.125rem 0.125rem 0.5rem rgba( 0, 0, 0, 0.25 );\r\n  text-shadow: 0.0625rem 0.0625rem 0 #335;\r\n}\r\n\r\n.composer-node__title {\r\n  line-height: 3;\r\n  padding: 0 1rem;\r\n}\r\n\r\n.composer-node__children > .composer-node__toolbar {\r\n  background: #05b;\r\n  border: 0.0625rem solid #27c;\r\n  border-bottom: 0.0625rem solid #04b;\r\n  border-right: 0.0625rem solid #04b;\r\n  text-shadow: 0.0625rem 0.0625rem 0 #03b;\r\n}\r\n\r\n.composer-node--empty > .composer-node__toolbar {\r\n  background: #eee;\r\n  color: #222;\r\n  border: 0.0625rem solid #ffe;\r\n  border-bottom: 0.0625rem solid #ccd;\r\n  border-right: 0.0625rem solid #ccd;\r\n  text-shadow: 0.0625rem 0.0625rem 0 #bbd;\r\n}\r\n\r\n.composer-node:not( [data-depth=\"0\"] ) > .composer-node__toolbar {\r\n  cursor: move;\r\n}\r\n\r\n.composer-node__view {\r\n  margin-bottom: 1em;\r\n  overflow: hidden;\r\n}\r\n\r\n.composer-node__view:last-child {\r\n  margin-bottom: 0;\r\n}\r\n\r\n.composer-node__main {\r\n  padding: 0.75rem;\r\n  margin: 0.25rem;\r\n  margin-top: 0;\r\n\r\n  background: #fff;\r\n  box-shadow: 0.125rem 0.125rem 0.5rem rgba( 0, 0, 0, 0.25 );\r\n  border-bottom: 0.0625rem solid #eee;\r\n}\r\n\r\n.composer-node--collapsed > .composer-node__main,\r\n.composer-node__children--collapsed > .composer-node__main {\r\n  height: 0;\r\n  margin: 0;\r\n  padding: 0;\r\n  border: 0;\r\n  overflow: hidden;\r\n}\r\n\r\n.composer-node__children {\r\n  overflow: hidden;\r\n\r\n  box-shadow: inset 0.125rem 0.125rem 0.5rem rgba( 0, 0, 0, 0.25 );\r\n  background: #eef;\r\n}\r\n\r\n.composer-node__children > ul {\r\n  margin: 0;\r\n  padding: 0.5rem;\r\n  list-style: none;\r\n}\r\n\r\n.composer-node__children--collapsed > ul {\r\n  height: 0;\r\n  padding: 0;\r\n  overflow: hidden;\r\n}\r\n\r\n.composer-node__children > ul > li {\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n\r\n.composer-node__actions {\r\n  display: block;\r\n  float: right;\r\n}\r\n\r\n.composer-node__actions > li {\r\n  display: block;\r\n  float: left;\r\n}\r\n\r\n.composer-node__action {\r\n  display: block;\r\n  padding: 0;\r\n  font-size: 1rem;\r\n  line-height: 1.875rem;\r\n  width: 1.875rem;\r\n  margin: 0.5rem 0;\r\n  text-align: center;\r\n  cursor: default;\r\n\r\n  background: #39f;\r\n  color: #fff;\r\n  border: 0.0625rem solid #5bf;\r\n  border-right: 0.0625rem solid #17f;\r\n  border-bottom: 0.0625rem solid #17f;\r\n  text-shadow: 0.0625rem 0.0625rem 0 #06f;\r\n}\r\n\r\n.composer-node__actions > li:last-child .composer-node__action {\r\n  margin-right: 0.5rem;\r\n}\r\n\r\n.composer-node__delete {\r\n  background: #d22;\r\n  color: #fff;\r\n  border: 0.0625rem solid #f43;\r\n  border-right: 0.0625rem solid #b04;\r\n  border-bottom: 0.0625rem solid #b04;\r\n  text-shadow: 0.0625rem 0.0625rem 0 #a04;\r\n}\r\n","document":"* {\r\n  box-sizing: border-box;\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n\r\nhtml {\r\n  font-family: sans-serif;\r\n}\r\n\r\n.gu-unselectable {\r\n  list-style: none;\r\n}\r\n\r\n.gu-mirror {\r\n  position: fixed !important;\r\n  margin: 0 !important;\r\n  z-index: 9999 !important;\r\n  opacity: 0.8;\r\n  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=80)\";\r\n  filter: alpha(opacity=80);\r\n}\r\n\r\n.gu-hide {\r\n  display: none !important;\r\n}\r\n\r\n.gu-unselectable {\r\n  -webkit-user-select: none !important;\r\n  -moz-user-select: none !important;\r\n  -ms-user-select: none !important;\r\n  user-select: none !important;\r\n}\r\n\r\n.gu-transit {\r\n  opacity: 0.2;\r\n  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=20)\";\r\n  filter: alpha(opacity=20);\r\n}\r\n\r\n.ratio {\r\n  width: 4rem;\r\n  text-align: center;\r\n  position: relative;\r\n}\r\n\r\n.ratio .shim {\r\n  padding-bottom: 100%;\r\n}\r\n\r\n.ratio .viewport {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n}\r\n"},"templates":{"composer":{"value":{"nodeType":"documentFragment","_id":"documentfragment-52c0a8c919b49c4f6da91e73b9ed9e34"},"children":[{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer"},"_id":"element-9e83425d14cd8e24555dd81526868d45"},"children":[]}]},"composer-node":{"value":{"nodeType":"documentFragment","_id":"documentfragment-aa2e89aa69a358cd315e70de740bbd78"},"children":[{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer-node","data-tag":"nodeTag"},"_id":"element-54169493e76ba1071276c5ae97525bf6"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-b97cf88e82ec1232d552de6739a00439"},"children":[]},{"value":{"nodeType":"element","tagName":"header","attributes":{"class":"composer-node__toolbar"},"_id":"element-edc13d2e3ca5ee412dc7333cfe6d4dd3"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-ed186addf5810d0f4a59e4d55bd7ebc6"},"children":[]},{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__title","data-text":"title"},"_id":"element-9d860f60976de8fbbba411e101bb2000"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-9fcc851f0a9f6076e246f30cb1d25365"},"children":[]},{"value":{"nodeType":"element","tagName":"ul","attributes":{"class":"composer-node__actions"},"_id":"element-65dba38cc65e0ce6a383431e149f2f1b"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-a612705c37346928201846f1f604faf4"},"children":[]},{"value":{"nodeType":"element","tagName":"li","attributes":{},"_id":"element-7710d03551de22e2c572f7f3041e79c3"},"children":[{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__action composer-node__delete"},"_id":"element-327a030126c88d4e82382799497273c3"},"children":[{"value":{"nodeType":"element","tagName":"i","attributes":{"class":"fa fa-trash fa-lg"},"_id":"element-e243bd5df8f439f105746eef75181c7b"},"children":[]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-aefade49570b9366a9b20f67b75a8579"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-09b97626a0a6b93a4f9bfc6f3a221fc7"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n\r\n  ","_id":"text-5cf02afb752471e7d86da15a6b45620d"},"children":[]},{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer-node__main"},"_id":"element-5b1f9e6ec0089d69102566b4e7005db3"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-c65f7cf5e38c281e1273aaff0590269d"},"children":[]},{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer-node__view"},"_id":"element-be7568135698b5c76033ee920dc83bec"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-88541c275228fffa81997c3e76d1f204"},"children":[]},{"value":{"nodeType":"element","tagName":"code","attributes":{"data-html":"preview"},"_id":"element-f9037a3012352474c24dcbe43a69ea6d"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-cd3be02f0d59bb3fd4963023d5df6802"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n\r\n    ","_id":"text-1f435517f82f22dc58cef8308cd4d026"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-not":"isEmpty"},"_id":"element-eaf5adce064f90651fec81519b50c7e0"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-33f5d8c6029d228b48291bd749ba184f"},"children":[]},{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer-node__children","data-tag":"childWrapperTag"},"_id":"element-9139ad7014e48b4008b467c297ea5d83"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n        ","_id":"text-1c1783a3e11a39ae7b5e3d4420f60aff"},"children":[]},{"value":{"nodeType":"element","tagName":"header","attributes":{"class":"composer-node__toolbar"},"_id":"element-15f98459edd097e3962601b7c408ab40"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n          ","_id":"text-479cafbdd9efac734cf68ba940f03118"},"children":[]},{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__title","data-text":"childrenTitle"},"_id":"element-b1fff2df35db68eca822bc4580bf5641"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n          ","_id":"text-b984ed3032bac7233255b2ed1c5df33a"},"children":[]},{"value":{"nodeType":"element","tagName":"ul","attributes":{"class":"composer-node__actions"},"_id":"element-f7b511dd23f4f539ab0de08f092b1cb9"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n            ","_id":"text-25c28ec2e680c9eb99e75175a1208317"},"children":[]},{"value":{"nodeType":"element","tagName":"li","attributes":{},"_id":"element-cb1d0459f3b20494b51a429fe4d0bb33"},"children":[{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__action composer-node__collapse-children"},"_id":"element-6ecc32ba1d8e49885a3e4d33471c0b87"},"children":[{"value":{"nodeType":"element","tagName":"i","attributes":{"class":"fa fa-minus-square fa-lg"},"_id":"element-fcbbe575bb5519de1d53e8d47bd335ca"},"children":[]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n            ","_id":"text-f23e120694f573a8cf69bd5ded2196fc"},"children":[]},{"value":{"nodeType":"element","tagName":"li","attributes":{},"_id":"element-6c921a620524dc0331737b2fb47a291f"},"children":[{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__action composer-node__expand-children"},"_id":"element-2344c7b2b77c9ac45c700b261ea7aa88"},"children":[{"value":{"nodeType":"element","tagName":"i","attributes":{"class":"fa fa-plus-square fa-lg"},"_id":"element-4fbf992325468d5068ae66ec7f16caaf"},"children":[]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n          ","_id":"text-7c837fc217f2363e792caf9ab0927a17"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n        ","_id":"text-5312f2741766616f1f875e1e630d8676"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n        ","_id":"text-7832449f594a1277c22edd93ceb42747"},"children":[]},{"value":{"nodeType":"element","tagName":"ul","attributes":{"data-dragsource":"composer"},"_id":"element-22321156d27578d7b9624ea782129632"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-ad8f99ec8c00392165a9102bff341274"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-d6e11d9aef727aa7faa447e1b15613c5"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-aebe001d175e09b2df90a2bd483a07eb"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-1a3786d8c172990f02d78032ba1cb231"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-286a8fa0f2a4289bf92d6f78038654e6"},"children":[]}]},"document":{"value":{"nodeType":"documentFragment","_id":"documentfragment-b0b705f617cbaad0bb876507b8c67211"},"children":[{"value":{"nodeType":"documentType","_id":"documentType-cb80fd6ab7941371a3e122f3536aad99","name":"html","publicId":"","systemId":""},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-0e85821e3cf28c94a6bd09d0e6bdc7cd"},"children":[]},{"value":{"nodeType":"element","tagName":"html","attributes":{"class":"no-js","lang":"en"},"_id":"element-d83997a287e9e64cbe5ccea93f95a10d"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-575ce7490cb3d1b36dd1b265aeec81b9"},"children":[]},{"value":{"nodeType":"element","tagName":"head","attributes":{},"_id":"element-3b57d0f78cdc985376222d01f93df564"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-4cfd922e6f400f8fcf96524cb1f0c6b4"},"children":[]},{"value":{"nodeType":"element","tagName":"meta","attributes":{"charset":"utf-8"},"_id":"element-5c62f1b3b6da9651d58619fc94a766ae"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-ab0b7e508e39b6a301d8f6f76688ef74"},"children":[]},{"value":{"nodeType":"element","tagName":"meta","attributes":{"name":"viewport","content":"width=device-width, initial-scale=1.0"},"_id":"element-675bac66cde97b447676c4b5345f8bd3"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-68990b4184e727c40433afd90816342c"},"children":[]},{"value":{"nodeType":"element","tagName":"title","attributes":{"data-text":"documentTitle"},"_id":"element-f06a983cf079cf456e3db858a47f3bb5"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-e3bbe6583f756423b0e1596cd3e656d1"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-each":"headStyles"},"_id":"element-2f4de2e39eabda0f7bb40b49aa9027d7"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-27a5c0c29c780ba4719d3550374b2dfb"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-include":"style"},"_id":"element-1f284786fcf07fcf3ed0dd1a5c92b3ac"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-8b063352142f46387a1ce885930aa0d4"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-63c7800bc90c7d8d95e1f727b56c33af"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-each":"headScripts"},"_id":"element-b433d7b2cc186be5479cf7af8bfeea94"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-93f8a2f3d856379507658c3f67ef6ebe"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-include":"script"},"_id":"element-eee82d686fa1e7ac5330644bbc249948"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-7c378ae25cbedaf0de902e48ba64bc87"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-e85529ed3c08a634851f041edb6ce918"},"children":[]}]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-9ba3b6f7582552e86f6daa22cab3379a"},"children":[]},{"value":{"nodeType":"element","tagName":"body","attributes":{},"_id":"element-f57dccc12aefb438b2f613e24d11b1f2"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-e3013f825ea25b06d75cba4b3db32eb6"},"children":[]},{"value":{"nodeType":"element","tagName":"div","attributes":{"data-container":"","data-html":"body"},"_id":"element-fcac61baa69686030790005528e45e1f"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-5d74861b889cd102bd5d321e061a7306"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-each":"scripts"},"_id":"element-074d098f60db56f62f5f2544bcfca049"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-df2a6e9dbd6bbf8a552b97f96af6478d"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-include":"script"},"_id":"element-57660bf7f84d9b1ef0e4ecd5c2a77234"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-b617f3280abf065b599860a1537ee752"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-3e8a131566f5fa3656fd66f204da5c75"},"children":[]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-eef43b62b212f8af61a63ebe20fd4fbc"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-de15e1d35c843a5575119741442d1db6"},"children":[]}]},"script":{"value":{"nodeType":"documentFragment","_id":"documentfragment-d25b46f5a58b845b947b25d5ac12e409"},"children":[{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-if":"text"},"_id":"element-d3677d0c2386f5f4f4b8e7cde86faf8c"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-eca5101c4b21a0c2221b80e113cc8bcc"},"children":[]},{"value":{"nodeType":"element","tagName":"script","attributes":{"data-html":"text"},"_id":"element-3f79ae6d893abe0818d9d70054095d68"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-a03e885e0ad26aa0200fe290f5d9ca3f"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-422634b0b01120295ec260bad6e5b40f"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-if":"src"},"_id":"element-7de4fb817ade5efcb1e93dd3ba33a3d5"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-daaaf965c89e17b074e4098e27d52da3"},"children":[]},{"value":{"nodeType":"element","tagName":"script","attributes":{"data-tag":"src"},"_id":"element-5509c0738702a04b74c29e458465e8f4"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-eeba6086045d31726b4c11959555cdef"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-f2aab8e83eb341484d3f8d60f1111cee"},"children":[]}]},"style":{"value":{"nodeType":"documentFragment","_id":"documentfragment-58eb638b9dffb2c8e05a22fcdfdf53ab"},"children":[{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-if":"text"},"_id":"element-fc06ae91d69b72eaf619873e75c76adc"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-7fa298ed041ba5da26541739b3ba31fb"},"children":[]},{"value":{"nodeType":"element","tagName":"style","attributes":{"data-html":"text"},"_id":"element-0c391d6db4fe67ff330c0895f990bde1"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-28072271d87ad11827ab0e3dce83a0a9"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-acb38dc5953dfde286c6f9500428ed23"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-if":"src"},"_id":"element-f1cb0bb906d334ed39006e643d60d9e4"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-f98aee93fabee90c8eaf999edead1da8"},"children":[]},{"value":{"nodeType":"element","tagName":"link","attributes":{"rel":"stylesheet","data-tag":"src"},"_id":"element-bd7696b56457408cecc0eb03ba773809"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-c6d252d35f5c0bef587eecd3f81d0a66"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-f6671dd61412e803238ba84b103029de"},"children":[]}]}},"schemas":{"composer-node":{"id":"composer-node","type":"object","properties":{"id":{"$ref":"nonEmptyString"},"title":{"$ref":"nonEmptyString"},"treeType":{"$ref":"nonEmptyString"},"nodeType":{"$ref":"nonEmptyString"},"depth":{"type":"integer"},"isEmpty":{"type":"boolean"},"isCollapsed":{"type":"boolean"},"isChildrenCollapsed":{"type":"boolean"},"preview":{"$ref":"nonEmptyString"},"childrenTitle":{"$ref":"nonEmptyString"}},"required":["id","title","treeType","nodeType","depth","preview","childrenTitle"]},"document":{"id":"document","type":"object","properties":{"documentTitle":{"$ref":"nonEmptyString"},"headStyles":{"type":"array","items":{"$ref":"style"}},"headScripts":{"type":"array","items":{"$ref":"script"}},"scripts":{"type":"array","items":{"$ref":"script"}}},"required":["documentTitle"]},"script":{"id":"script","$ref":"htmlResource"},"style":{"id":"style","$ref":"htmlResource"},"componentConfig":{"id":"componentConfig","type":"object","properties":{"containerSelector":{"$ref":"nonEmptyString"}}},"htmlResource":{"id":"htmlResource","oneOf":[{"$ref":"htmlResourceText"},{"$ref":"htmlResourceSrc"}]},"htmlResourceSrc":{"id":"htmlResourceSrc","type":"object","properties":{"src":{"type":"string"}},"required":["src"]},"htmlResourceText":{"id":"htmlResourceText","type":"object","properties":{"text":{"type":"string"}},"required":["text"]},"nonEmptyString":{"id":"nonEmptyString","type":"string","pattern":"^(?!\\s*$).+"}},"defaultModels":{"document":{"documentTitle":"New Document"}},"configs":{"composer":{"containerSelector":".composer"},"composer-node":{"containerSelector":".composer-node__children > ul"},"document":{"containerSelector":"body > [data-container]"}},"transforms":{"composer-node":{"nodeTag":[{"$if":[{"$value":"isCollapsed"},{"addClass":"composer-node--collapsed"}]},{"$if":[{"$value":"isEmpty"},{"addClass":"composer-node--empty"}]},{"attr":["id",{"$value":"id"}]},{"attr":["data-treeType",{"$value":"treeType"}]},{"attr":["data-nodeType",{"$value":"nodeType"}]},{"attr":["data-depth",{"$value":"depth"}]}],"childWrapperTag":[{"$if":[{"$value":"isChildrenCollapsed"},{"addClass":"composer-node__children--collapsed"}]},{"attr":["id",{"$value":"id"}]}]},"script":{"src":{"$if":[{"$value":"src"},{"attr":["src",{"$value":"src"}]}]}},"style":{"src":{"$if":[{"$value":"src"},{"attr":["href",{"$value":"src"}]}]}}},"componentNames":["composer","composer-node","document","script","style"],"components":{"composer":{"config":{"containerSelector":".composer"},"style":".composer {\r\n  line-height: 2;\r\n}\r\n\r\n.composer-node {\r\n\r\n}\r\n\r\n.composer-node__toolbar {\r\n  min-height: 3em;\r\n\r\n  background: #666;\r\n  color: #fff;\r\n  border: 0.0625rem solid #887;\r\n  border-bottom: 0.0625rem solid #445;\r\n  border-right: 0.0625rem solid #445;\r\n  box-shadow: 0.125rem 0.125rem 0.5rem rgba( 0, 0, 0, 0.25 );\r\n  text-shadow: 0.0625rem 0.0625rem 0 #335;\r\n}\r\n\r\n.composer-node__title {\r\n  line-height: 3;\r\n  padding: 0 1rem;\r\n}\r\n\r\n.composer-node__children > .composer-node__toolbar {\r\n  background: #05b;\r\n  border: 0.0625rem solid #27c;\r\n  border-bottom: 0.0625rem solid #04b;\r\n  border-right: 0.0625rem solid #04b;\r\n  text-shadow: 0.0625rem 0.0625rem 0 #03b;\r\n}\r\n\r\n.composer-node--empty > .composer-node__toolbar {\r\n  background: #eee;\r\n  color: #222;\r\n  border: 0.0625rem solid #ffe;\r\n  border-bottom: 0.0625rem solid #ccd;\r\n  border-right: 0.0625rem solid #ccd;\r\n  text-shadow: 0.0625rem 0.0625rem 0 #bbd;\r\n}\r\n\r\n.composer-node:not( [data-depth=\"0\"] ) > .composer-node__toolbar {\r\n  cursor: move;\r\n}\r\n\r\n.composer-node__view {\r\n  margin-bottom: 1em;\r\n  overflow: hidden;\r\n}\r\n\r\n.composer-node__view:last-child {\r\n  margin-bottom: 0;\r\n}\r\n\r\n.composer-node__main {\r\n  padding: 0.75rem;\r\n  margin: 0.25rem;\r\n  margin-top: 0;\r\n\r\n  background: #fff;\r\n  box-shadow: 0.125rem 0.125rem 0.5rem rgba( 0, 0, 0, 0.25 );\r\n  border-bottom: 0.0625rem solid #eee;\r\n}\r\n\r\n.composer-node--collapsed > .composer-node__main,\r\n.composer-node__children--collapsed > .composer-node__main {\r\n  height: 0;\r\n  margin: 0;\r\n  padding: 0;\r\n  border: 0;\r\n  overflow: hidden;\r\n}\r\n\r\n.composer-node__children {\r\n  overflow: hidden;\r\n\r\n  box-shadow: inset 0.125rem 0.125rem 0.5rem rgba( 0, 0, 0, 0.25 );\r\n  background: #eef;\r\n}\r\n\r\n.composer-node__children > ul {\r\n  margin: 0;\r\n  padding: 0.5rem;\r\n  list-style: none;\r\n}\r\n\r\n.composer-node__children--collapsed > ul {\r\n  height: 0;\r\n  padding: 0;\r\n  overflow: hidden;\r\n}\r\n\r\n.composer-node__children > ul > li {\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n\r\n.composer-node__actions {\r\n  display: block;\r\n  float: right;\r\n}\r\n\r\n.composer-node__actions > li {\r\n  display: block;\r\n  float: left;\r\n}\r\n\r\n.composer-node__action {\r\n  display: block;\r\n  padding: 0;\r\n  font-size: 1rem;\r\n  line-height: 1.875rem;\r\n  width: 1.875rem;\r\n  margin: 0.5rem 0;\r\n  text-align: center;\r\n  cursor: default;\r\n\r\n  background: #39f;\r\n  color: #fff;\r\n  border: 0.0625rem solid #5bf;\r\n  border-right: 0.0625rem solid #17f;\r\n  border-bottom: 0.0625rem solid #17f;\r\n  text-shadow: 0.0625rem 0.0625rem 0 #06f;\r\n}\r\n\r\n.composer-node__actions > li:last-child .composer-node__action {\r\n  margin-right: 0.5rem;\r\n}\r\n\r\n.composer-node__delete {\r\n  background: #d22;\r\n  color: #fff;\r\n  border: 0.0625rem solid #f43;\r\n  border-right: 0.0625rem solid #b04;\r\n  border-bottom: 0.0625rem solid #b04;\r\n  text-shadow: 0.0625rem 0.0625rem 0 #a04;\r\n}\r\n","template":{"value":{"nodeType":"documentFragment","_id":"documentfragment-52c0a8c919b49c4f6da91e73b9ed9e34"},"children":[{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer"},"_id":"element-9e83425d14cd8e24555dd81526868d45"},"children":[]}]}},"composer-node":{"config":{"containerSelector":".composer-node__children > ul"},"schema":{"id":"composer-node","type":"object","properties":{"id":{"$ref":"nonEmptyString"},"title":{"$ref":"nonEmptyString"},"treeType":{"$ref":"nonEmptyString"},"nodeType":{"$ref":"nonEmptyString"},"depth":{"type":"integer"},"isEmpty":{"type":"boolean"},"isCollapsed":{"type":"boolean"},"isChildrenCollapsed":{"type":"boolean"},"preview":{"$ref":"nonEmptyString"},"childrenTitle":{"$ref":"nonEmptyString"}},"required":["id","title","treeType","nodeType","depth","preview","childrenTitle"]},"template":{"value":{"nodeType":"documentFragment","_id":"documentfragment-aa2e89aa69a358cd315e70de740bbd78"},"children":[{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer-node","data-tag":"nodeTag"},"_id":"element-54169493e76ba1071276c5ae97525bf6"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-b97cf88e82ec1232d552de6739a00439"},"children":[]},{"value":{"nodeType":"element","tagName":"header","attributes":{"class":"composer-node__toolbar"},"_id":"element-edc13d2e3ca5ee412dc7333cfe6d4dd3"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-ed186addf5810d0f4a59e4d55bd7ebc6"},"children":[]},{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__title","data-text":"title"},"_id":"element-9d860f60976de8fbbba411e101bb2000"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-9fcc851f0a9f6076e246f30cb1d25365"},"children":[]},{"value":{"nodeType":"element","tagName":"ul","attributes":{"class":"composer-node__actions"},"_id":"element-65dba38cc65e0ce6a383431e149f2f1b"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-a612705c37346928201846f1f604faf4"},"children":[]},{"value":{"nodeType":"element","tagName":"li","attributes":{},"_id":"element-7710d03551de22e2c572f7f3041e79c3"},"children":[{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__action composer-node__delete"},"_id":"element-327a030126c88d4e82382799497273c3"},"children":[{"value":{"nodeType":"element","tagName":"i","attributes":{"class":"fa fa-trash fa-lg"},"_id":"element-e243bd5df8f439f105746eef75181c7b"},"children":[]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-aefade49570b9366a9b20f67b75a8579"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-09b97626a0a6b93a4f9bfc6f3a221fc7"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n\r\n  ","_id":"text-5cf02afb752471e7d86da15a6b45620d"},"children":[]},{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer-node__main"},"_id":"element-5b1f9e6ec0089d69102566b4e7005db3"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-c65f7cf5e38c281e1273aaff0590269d"},"children":[]},{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer-node__view"},"_id":"element-be7568135698b5c76033ee920dc83bec"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-88541c275228fffa81997c3e76d1f204"},"children":[]},{"value":{"nodeType":"element","tagName":"code","attributes":{"data-html":"preview"},"_id":"element-f9037a3012352474c24dcbe43a69ea6d"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-cd3be02f0d59bb3fd4963023d5df6802"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n\r\n    ","_id":"text-1f435517f82f22dc58cef8308cd4d026"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-not":"isEmpty"},"_id":"element-eaf5adce064f90651fec81519b50c7e0"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-33f5d8c6029d228b48291bd749ba184f"},"children":[]},{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer-node__children","data-tag":"childWrapperTag"},"_id":"element-9139ad7014e48b4008b467c297ea5d83"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n        ","_id":"text-1c1783a3e11a39ae7b5e3d4420f60aff"},"children":[]},{"value":{"nodeType":"element","tagName":"header","attributes":{"class":"composer-node__toolbar"},"_id":"element-15f98459edd097e3962601b7c408ab40"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n          ","_id":"text-479cafbdd9efac734cf68ba940f03118"},"children":[]},{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__title","data-text":"childrenTitle"},"_id":"element-b1fff2df35db68eca822bc4580bf5641"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n          ","_id":"text-b984ed3032bac7233255b2ed1c5df33a"},"children":[]},{"value":{"nodeType":"element","tagName":"ul","attributes":{"class":"composer-node__actions"},"_id":"element-f7b511dd23f4f539ab0de08f092b1cb9"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n            ","_id":"text-25c28ec2e680c9eb99e75175a1208317"},"children":[]},{"value":{"nodeType":"element","tagName":"li","attributes":{},"_id":"element-cb1d0459f3b20494b51a429fe4d0bb33"},"children":[{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__action composer-node__collapse-children"},"_id":"element-6ecc32ba1d8e49885a3e4d33471c0b87"},"children":[{"value":{"nodeType":"element","tagName":"i","attributes":{"class":"fa fa-minus-square fa-lg"},"_id":"element-fcbbe575bb5519de1d53e8d47bd335ca"},"children":[]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n            ","_id":"text-f23e120694f573a8cf69bd5ded2196fc"},"children":[]},{"value":{"nodeType":"element","tagName":"li","attributes":{},"_id":"element-6c921a620524dc0331737b2fb47a291f"},"children":[{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__action composer-node__expand-children"},"_id":"element-2344c7b2b77c9ac45c700b261ea7aa88"},"children":[{"value":{"nodeType":"element","tagName":"i","attributes":{"class":"fa fa-plus-square fa-lg"},"_id":"element-4fbf992325468d5068ae66ec7f16caaf"},"children":[]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n          ","_id":"text-7c837fc217f2363e792caf9ab0927a17"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n        ","_id":"text-5312f2741766616f1f875e1e630d8676"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n        ","_id":"text-7832449f594a1277c22edd93ceb42747"},"children":[]},{"value":{"nodeType":"element","tagName":"ul","attributes":{"data-dragsource":"composer"},"_id":"element-22321156d27578d7b9624ea782129632"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-ad8f99ec8c00392165a9102bff341274"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-d6e11d9aef727aa7faa447e1b15613c5"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-aebe001d175e09b2df90a2bd483a07eb"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-1a3786d8c172990f02d78032ba1cb231"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-286a8fa0f2a4289bf92d6f78038654e6"},"children":[]}]},"transform":{"nodeTag":[{"$if":[{"$value":"isCollapsed"},{"addClass":"composer-node--collapsed"}]},{"$if":[{"$value":"isEmpty"},{"addClass":"composer-node--empty"}]},{"attr":["id",{"$value":"id"}]},{"attr":["data-treeType",{"$value":"treeType"}]},{"attr":["data-nodeType",{"$value":"nodeType"}]},{"attr":["data-depth",{"$value":"depth"}]}],"childWrapperTag":[{"$if":[{"$value":"isChildrenCollapsed"},{"addClass":"composer-node__children--collapsed"}]},{"attr":["id",{"$value":"id"}]}]}},"document":{"config":{"containerSelector":"body > [data-container]"},"defaultModel":{"documentTitle":"New Document"},"schema":{"id":"document","type":"object","properties":{"documentTitle":{"$ref":"nonEmptyString"},"headStyles":{"type":"array","items":{"$ref":"style"}},"headScripts":{"type":"array","items":{"$ref":"script"}},"scripts":{"type":"array","items":{"$ref":"script"}}},"required":["documentTitle"]},"style":"* {\r\n  box-sizing: border-box;\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n\r\nhtml {\r\n  font-family: sans-serif;\r\n}\r\n\r\n.gu-unselectable {\r\n  list-style: none;\r\n}\r\n\r\n.gu-mirror {\r\n  position: fixed !important;\r\n  margin: 0 !important;\r\n  z-index: 9999 !important;\r\n  opacity: 0.8;\r\n  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=80)\";\r\n  filter: alpha(opacity=80);\r\n}\r\n\r\n.gu-hide {\r\n  display: none !important;\r\n}\r\n\r\n.gu-unselectable {\r\n  -webkit-user-select: none !important;\r\n  -moz-user-select: none !important;\r\n  -ms-user-select: none !important;\r\n  user-select: none !important;\r\n}\r\n\r\n.gu-transit {\r\n  opacity: 0.2;\r\n  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=20)\";\r\n  filter: alpha(opacity=20);\r\n}\r\n\r\n.ratio {\r\n  width: 4rem;\r\n  text-align: center;\r\n  position: relative;\r\n}\r\n\r\n.ratio .shim {\r\n  padding-bottom: 100%;\r\n}\r\n\r\n.ratio .viewport {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n}\r\n","template":{"value":{"nodeType":"documentFragment","_id":"documentfragment-b0b705f617cbaad0bb876507b8c67211"},"children":[{"value":{"nodeType":"documentType","_id":"documentType-cb80fd6ab7941371a3e122f3536aad99","name":"html","publicId":"","systemId":""},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-0e85821e3cf28c94a6bd09d0e6bdc7cd"},"children":[]},{"value":{"nodeType":"element","tagName":"html","attributes":{"class":"no-js","lang":"en"},"_id":"element-d83997a287e9e64cbe5ccea93f95a10d"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-575ce7490cb3d1b36dd1b265aeec81b9"},"children":[]},{"value":{"nodeType":"element","tagName":"head","attributes":{},"_id":"element-3b57d0f78cdc985376222d01f93df564"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-4cfd922e6f400f8fcf96524cb1f0c6b4"},"children":[]},{"value":{"nodeType":"element","tagName":"meta","attributes":{"charset":"utf-8"},"_id":"element-5c62f1b3b6da9651d58619fc94a766ae"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-ab0b7e508e39b6a301d8f6f76688ef74"},"children":[]},{"value":{"nodeType":"element","tagName":"meta","attributes":{"name":"viewport","content":"width=device-width, initial-scale=1.0"},"_id":"element-675bac66cde97b447676c4b5345f8bd3"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-68990b4184e727c40433afd90816342c"},"children":[]},{"value":{"nodeType":"element","tagName":"title","attributes":{"data-text":"documentTitle"},"_id":"element-f06a983cf079cf456e3db858a47f3bb5"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-e3bbe6583f756423b0e1596cd3e656d1"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-each":"headStyles"},"_id":"element-2f4de2e39eabda0f7bb40b49aa9027d7"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-27a5c0c29c780ba4719d3550374b2dfb"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-include":"style"},"_id":"element-1f284786fcf07fcf3ed0dd1a5c92b3ac"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-8b063352142f46387a1ce885930aa0d4"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-63c7800bc90c7d8d95e1f727b56c33af"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-each":"headScripts"},"_id":"element-b433d7b2cc186be5479cf7af8bfeea94"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-93f8a2f3d856379507658c3f67ef6ebe"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-include":"script"},"_id":"element-eee82d686fa1e7ac5330644bbc249948"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-7c378ae25cbedaf0de902e48ba64bc87"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-e85529ed3c08a634851f041edb6ce918"},"children":[]}]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-9ba3b6f7582552e86f6daa22cab3379a"},"children":[]},{"value":{"nodeType":"element","tagName":"body","attributes":{},"_id":"element-f57dccc12aefb438b2f613e24d11b1f2"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-e3013f825ea25b06d75cba4b3db32eb6"},"children":[]},{"value":{"nodeType":"element","tagName":"div","attributes":{"data-container":"","data-html":"body"},"_id":"element-fcac61baa69686030790005528e45e1f"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-5d74861b889cd102bd5d321e061a7306"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-each":"scripts"},"_id":"element-074d098f60db56f62f5f2544bcfca049"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-df2a6e9dbd6bbf8a552b97f96af6478d"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-include":"script"},"_id":"element-57660bf7f84d9b1ef0e4ecd5c2a77234"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-b617f3280abf065b599860a1537ee752"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-3e8a131566f5fa3656fd66f204da5c75"},"children":[]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-eef43b62b212f8af61a63ebe20fd4fbc"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-de15e1d35c843a5575119741442d1db6"},"children":[]}]}},"script":{"schema":{"id":"script","$ref":"htmlResource"},"template":{"value":{"nodeType":"documentFragment","_id":"documentfragment-d25b46f5a58b845b947b25d5ac12e409"},"children":[{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-if":"text"},"_id":"element-d3677d0c2386f5f4f4b8e7cde86faf8c"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-eca5101c4b21a0c2221b80e113cc8bcc"},"children":[]},{"value":{"nodeType":"element","tagName":"script","attributes":{"data-html":"text"},"_id":"element-3f79ae6d893abe0818d9d70054095d68"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-a03e885e0ad26aa0200fe290f5d9ca3f"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-422634b0b01120295ec260bad6e5b40f"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-if":"src"},"_id":"element-7de4fb817ade5efcb1e93dd3ba33a3d5"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-daaaf965c89e17b074e4098e27d52da3"},"children":[]},{"value":{"nodeType":"element","tagName":"script","attributes":{"data-tag":"src"},"_id":"element-5509c0738702a04b74c29e458465e8f4"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-eeba6086045d31726b4c11959555cdef"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-f2aab8e83eb341484d3f8d60f1111cee"},"children":[]}]},"transform":{"src":{"$if":[{"$value":"src"},{"attr":["src",{"$value":"src"}]}]}}},"style":{"schema":{"id":"style","$ref":"htmlResource"},"template":{"value":{"nodeType":"documentFragment","_id":"documentfragment-58eb638b9dffb2c8e05a22fcdfdf53ab"},"children":[{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-if":"text"},"_id":"element-fc06ae91d69b72eaf619873e75c76adc"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-7fa298ed041ba5da26541739b3ba31fb"},"children":[]},{"value":{"nodeType":"element","tagName":"style","attributes":{"data-html":"text"},"_id":"element-0c391d6db4fe67ff330c0895f990bde1"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-28072271d87ad11827ab0e3dce83a0a9"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-acb38dc5953dfde286c6f9500428ed23"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-if":"src"},"_id":"element-f1cb0bb906d334ed39006e643d60d9e4"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-f98aee93fabee90c8eaf999edead1da8"},"children":[]},{"value":{"nodeType":"element","tagName":"link","attributes":{"rel":"stylesheet","data-tag":"src"},"_id":"element-bd7696b56457408cecc0eb03ba773809"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-c6d252d35f5c0bef587eecd3f81d0a66"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-f6671dd61412e803238ba84b103029de"},"children":[]}]},"transform":{"src":{"$if":[{"$value":"src"},{"attr":["href",{"$value":"src"}]}]}}}},"datas":{"data-small":{"value":{"nodeType":"fragment","_id":"fragment-e8d0915d6b361cdc45ade8243a925fe3"},"children":[{"value":{"nodeType":"tag","name":"strong","attr":{},"_id":"tag-9e19a4a49cb820b3c9de2657d111106e"},"children":[]},{"value":{"nodeType":"tag","name":"h2","attr":{"id":"myHeader","class":"primary-header"},"_id":"h2-fc3ad02e943cb8979ed95f008254e7c4"},"children":[{"value":{"data":"Hello ","nodeType":"text","_id":"text-e8430e778578dcb8a5cef17fcfdd9675"},"children":[]},{"value":{"nodeType":"text","data":"Chris","_id":"text-dfdea7742a24d7dccece3f0c6ca8ec80"},"children":[]}]}]}}}
},{}],2:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Tree = require('1tree');
var defaultAdapter = require('1tree/dist/adapter/default');

var basePlugins = Object.keys(Tree.plugins).map(function (key) {
  return Tree.plugins[key];
});

var Mtree = function Mtree() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var excludeBase = args.some(function (arg) {
    return typeof arg === 'boolean' && arg;
  });

  var adapter = defaultAdapter;
  var plugins = excludeBase ? [] : basePlugins;

  args.forEach(function (arg) {
    if (Array.isArray(arg)) {
      plugins = arg.concat(plugins);
    } else if (typeof arg === 'function') {
      plugins = [arg].concat(plugins);
    } else if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object') {
      adapter = arg;
    }
  });

  return Tree.adapter(adapter, plugins);
};

module.exports = Mtree;
},{"1tree":60,"1tree/dist/adapter/default":14}],3:[function(require,module,exports){
'use strict'

module.exports = require( './dist' )

},{"./dist":2}],4:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Tree = require('1tree');
var T = require('mtype');
var paths = require('./paths');

var pathFromNode = paths.pathFromNode,
    nodeFromPath = paths.nodeFromPath;


var t = T();

var valueTypes = ['string', 'number', 'boolean'];

var extendValue = function extendValue(node, value) {
  return node.value(Object.assign({}, node.value(), value));
};

var toNode = function toNode(jsonObj, parent) {
  var create = parent ? parent.createNode : Tree.createRoot;

  var nodeType = t.of(jsonObj);
  var value = { nodeType: nodeType };

  if (valueTypes.includes(nodeType)) value.nodeValue = jsonObj;

  var node = create(value);

  if (nodeType === 'array') {
    jsonObj.forEach(function (el, index) {
      var arrayItemNode = toNode(el, node);

      extendValue(arrayItemNode, { arrayIndex: index });

      node.append(arrayItemNode);
    });
  } else if (nodeType === 'object') {
    var propertyNames = Object.keys(jsonObj);

    propertyNames.forEach(function (name) {
      var propertyValue = jsonObj[name];
      var valueNode = toNode(propertyValue, node);

      extendValue(valueNode, { propertyName: name });

      node.append(valueNode);
    });
  }

  return node;
};

var toTree = function toTree(jsonObj) {
  return toNode(jsonObj, null);
};

var toJson = function toJson(tree) {
  var value = tree.value();
  var nodeType = value.nodeType;

  if (nodeType === 'null') return null;

  if (valueTypes.includes(nodeType)) return value.nodeValue;

  if (nodeType === 'array') return tree.getChildren().map(toJson);

  if (nodeType === 'object') {
    var _ret = function () {
      var obj = {};

      tree.getChildren().forEach(function (nameValueNode) {
        var value = nameValueNode.value();
        var propertyName = value.propertyName;

        var propertyValue = toJson(nameValueNode);

        obj[propertyName] = propertyValue;
      });

      return {
        v: obj
      };
    }();

    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
  }

  throw new Error('Unexpected node');
};

module.exports = { toTree: toTree, toJson: toJson, pathFromNode: pathFromNode, nodeFromPath: nodeFromPath };
},{"./paths":5,"1tree":60,"mtype":174}],5:[function(require,module,exports){
'use strict';

var slugFromNode = function slugFromNode(node) {
  var parent = node.getParent();

  if (!parent) return '$';

  var value = node.value();

  if (typeof value.propertyName === 'string') return value.propertyName;

  if (typeof value.arrayIndex === 'number') return value.arrayIndex + '';
};

var pathFromNode = function pathFromNode(node) {
  var parentWithSlug = node.closest(function (n) {
    return !!slugFromNode(n) && n.get() !== node.get();
  });

  if (!parentWithSlug) return '$';

  var parentPath = pathFromNode(parentWithSlug);
  var slug = slugFromNode(node);

  if (slug) return parentPath + '/' + slug;
};

var nodeFromPath = function nodeFromPath(tree, path) {
  return tree.find(function (node) {
    return path === pathFromNode(node);
  });
};

module.exports = { pathFromNode: pathFromNode, nodeFromPath: nodeFromPath };
},{}],6:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":4,"dup":3}],7:[function(require,module,exports){
'use strict';

var toTree = require('./toTree');
var toJson = require('./toJson');
var paths = require('./paths');

var pathFromNode = paths.pathFromNode,
    nodeFromPath = paths.nodeFromPath;


module.exports = { toTree: toTree, toJson: toJson, pathFromNode: pathFromNode, nodeFromPath: nodeFromPath };
},{"./paths":8,"./toJson":9,"./toTree":10}],8:[function(require,module,exports){
'use strict';

var slugFromNode = function slugFromNode(node) {
  var parent = node.getParent();

  if (!parent) return '$';

  var value = node.value();

  if (typeof value.propertyName === 'string') return value.propertyName;

  if (typeof value.arrayIndex === 'number') return value.arrayIndex + '';
};

var pathFromNode = function pathFromNode(node) {
  var parentWithSlug = node.closest(function (n) {
    return !!slugFromNode(n) && n.get() !== node.get();
  });

  if (!parentWithSlug) return '$';

  var nodePath = pathFromNode(parentWithSlug);
  var slug = slugFromNode(node);

  if (slug) nodePath += '/' + slug;

  return nodePath;
};

// this is easy but inefficent, it's very simple to use the path segments to
// traverse the tree, replace!
var nodeFromPath = function nodeFromPath(schemaTree, path) {
  return schemaTree.find(function (node) {
    return path === pathFromNode(node);
  });
};

module.exports = { pathFromNode: pathFromNode, nodeFromPath: nodeFromPath };
},{}],9:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var valueMapper = function valueMapper(node) {
  var value = node.value();

  var schema = Object.assign({}, value);

  if (value.type === 'union') {
    schema.type = value.typesUnion;

    delete schema.typesUnion;
  } else if (value.type === 'any') {
    delete schema.type;
  }

  return schema;
};

var deleteFromValue = function deleteFromValue(node, propertyName) {
  var value = node.value();

  delete value[propertyName];

  node.value(value);
};

var propertyPopulators = {
  propertyName: function propertyName(node, schema) {
    if (_typeof(schema.properties) !== 'object') schema.properties = {};

    var value = node.value();
    var propertyName = value.propertyName;


    deleteFromValue(node, 'propertyName');

    schema.properties[propertyName] = toJson(node);
  },
  propertyPattern: function propertyPattern(node, schema) {
    if (_typeof(schema.patternProperties) !== 'object') schema.patternProperties = {};

    var value = node.value();
    var pattern = value.propertyPattern;

    deleteFromValue(node, 'propertyPattern');

    schema.patternProperties[pattern] = toJson(node);
  },
  additionalPropertiesSchema: function additionalPropertiesSchema(node, schema) {
    deleteFromValue(node, 'additionalPropertiesSchema');

    schema.additionalProperties = toJson(node);
  },
  arrayItem: function arrayItem(node, schema) {
    deleteFromValue(node, 'arrayItem');

    schema.items = toJson(node);
  },
  arrayIndex: function arrayIndex(node, schema) {
    if (!Array.isArray(schema.items)) schema.items = [];

    var value = node.value();
    var arrayIndex = value.arrayIndex;


    deleteFromValue(node, 'arrayIndex');

    schema.items[arrayIndex] = toJson(node);
  },
  anyOf: function anyOf(node, schema) {
    if (!Array.isArray(schema.anyOf)) schema.anyOf = [];

    deleteFromValue(node, 'anyOf');

    var childSchema = toJson(node);

    schema.anyOf.push(childSchema);
  },
  allOf: function allOf(node, schema) {
    if (!Array.isArray(schema.allOf)) schema.allOf = [];

    deleteFromValue(node, 'allOf');

    var childSchema = toJson(node);

    schema.allOf.push(childSchema);
  },
  oneOf: function oneOf(node, schema) {
    if (!Array.isArray(schema.oneOf)) schema.oneOf = [];

    deleteFromValue(node, 'oneOf');

    var childSchema = toJson(node);

    schema.oneOf.push(childSchema);
  },
  not: function not(node, schema) {
    deleteFromValue(node, 'not');

    schema.not = toJson(node);
  }
};

var populatorProperties = Object.keys(propertyPopulators);

var nestingMapper = function nestingMapper(node) {
  var schema = valueMapper(node);

  var children = node.getChildren();

  children.forEach(function (childNode) {
    var value = childNode.value();

    var populateFor = populatorProperties.filter(function (propertyName) {
      return propertyName in value;
    });

    populateFor.forEach(function (propertyName) {
      var populator = propertyPopulators[propertyName];

      populator(childNode, schema);
    });
  });

  return schema;
};

var valueMappers = {
  object: nestingMapper,
  array: nestingMapper,
  any: nestingMapper,
  union: nestingMapper,
  string: valueMapper,
  number: valueMapper,
  boolean: valueMapper,
  integer: valueMapper,
  null: valueMapper
};

var toJson = function toJson(node) {
  node = node.clone();

  var value = node.value();
  var schemaType = value.type;
  var mapper = valueMappers[schemaType];

  return mapper(node);
};

module.exports = toJson;
},{}],10:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Tree = require('1tree');

var createsNesting = {
  object: ['properties', 'additionalProperties', 'definitions', 'patternProperties', 'dependencies', 'allOf', 'anyOf', 'oneOf', 'not'],
  array: ['items']
};

createsNesting.any = createsNesting.object.concat(createsNesting.array);
createsNesting.union = createsNesting.any;

var valueMapper = function valueMapper(schema) {
  var value = Object.assign({}, schema);

  if (Array.isArray(schema.type)) {
    value.type = 'union';
    value.typesUnion = schema.type.slice();
  } else if (typeof schema.type !== 'string') {
    value.type = 'any';
  }

  return value;
};

var nestingMapper = function nestingMapper(schema) {
  var value = valueMapper(schema);

  var createsNestingDef = createsNesting[value.type];

  createsNestingDef.forEach(function (propertyName) {
    delete value[propertyName];
  });

  return value;
};

var nodeValueMappers = {
  string: valueMapper,
  number: valueMapper,
  integer: valueMapper,
  boolean: valueMapper,
  null: valueMapper,
  object: nestingMapper,
  array: nestingMapper,
  any: nestingMapper
};

var extendValue = function extendValue(node, value) {
  return node.value(Object.assign({}, node.value(), value));
};

var createPropertyNode = function createPropertyNode(schema, node, propertyName) {
  var propertySchema = schema.properties[propertyName];
  var propertyNode = toNode(propertySchema, node);

  extendValue(propertyNode, { propertyName: propertyName });

  return propertyNode;
};

var createAdditionalPropertiesNode = function createAdditionalPropertiesNode(schema, node) {
  var additionalPropertiesSchema = schema.additionalProperties;
  var additionalPropertiesNode = toNode(additionalPropertiesSchema, node);

  extendValue(additionalPropertiesNode, { additionalPropertiesSchema: true });

  return additionalPropertiesNode;
};

var createPatternPropertyNode = function createPatternPropertyNode(schema, node, pattern) {
  var patternPropertySchema = schema.patternProperties[pattern];
  var patternPropertyNode = toNode(patternPropertySchema, node);

  extendValue(patternPropertyNode, { propertyPattern: pattern });

  return patternPropertyNode;
};

var createCombiningNode = function createCombiningNode(combineSchema, node, combineName) {
  var combineNode = toNode(combineSchema, node);

  extendValue(combineNode, _defineProperty({}, combineName, true));

  return combineNode;
};

var createItemsNode = function createItemsNode(schema, node) {
  var itemsSchema = schema.items;
  var itemsNode = toNode(itemsSchema, node);

  extendValue(itemsNode, { arrayItem: true });

  return itemsNode;
};

var createItemTupleNode = function createItemTupleNode(tupleSchema, node, index) {
  var itemTupleNode = toNode(tupleSchema, node);

  extendValue(itemTupleNode, { arrayIndex: index });

  return itemTupleNode;
};

var combineArrayTypes = ['anyOf', 'allOf', 'oneOf'];

var childrenPopulators = {
  object: function object(schema, node) {
    if (schema.properties) {
      var propertyNames = Object.keys(schema.properties);

      propertyNames.forEach(function (propertyName) {
        var propertyNode = createPropertyNode(schema, node, propertyName);
        node.append(propertyNode);
      });
    }

    if (typeof schema.additionalProperties === 'boolean') {
      var value = node.value();

      value.additionalProperties = schema.additionalProperties;

      node.value(value);
    } else if (_typeof(schema.additionalProperties) === 'object') {
      var additionalPropertiesNode = createAdditionalPropertiesNode(schema, node);

      node.append(additionalPropertiesNode);
    }

    if (schema.definitions) throw new Error('definitions not supported');

    if (schema.patternProperties) {
      var patterns = Object.keys(schema.patternProperties);

      patterns.forEach(function (pattern) {
        var patternPropertyNode = createPatternPropertyNode(schema, node, pattern);
        node.append(patternPropertyNode);
      });
    }

    if (schema.dependencies) throw new Error('dependencies not supported');

    combineArrayTypes.forEach(function (combineName) {
      if (schema[combineName]) {
        var combineDef = schema[combineName];

        combineDef.forEach(function (combineSchema) {
          var combineNode = createCombiningNode(combineSchema, node, combineName);

          node.append(combineNode);
        });
      }
    });

    if (schema.not) {
      var combineSchema = schema.not;
      var combineNode = createCombiningNode(combineSchema, node, 'not');

      node.append(combineNode);
    }
  },
  array: function array(schema, node) {
    if (Array.isArray(schema.items)) {
      schema.items.forEach(function (tupleSchema, index) {
        var itemTupleNode = createItemTupleNode(tupleSchema, node, index);

        node.append(itemTupleNode);
      });
    } else if (_typeof(schema.items) === 'object') {
      var itemsNode = createItemsNode(schema, node);

      node.append(itemsNode);
    }
  },
  any: function any(schema, node) {
    childrenPopulators.object(schema, node);
    childrenPopulators.array(schema, node);
  }
};

var containerNodeTypes = Object.keys(childrenPopulators);

var toNode = function toNode(schema, parent) {
  var create = parent ? parent.createNode : Tree.createRoot;

  var schemaType = typeof schema.type === 'string' ? schema.type : 'any';
  var valueMapper = nodeValueMappers[schemaType];
  var value = valueMapper(schema);
  var node = create(value);

  if (containerNodeTypes.includes(schemaType)) {
    var childrenPopulator = childrenPopulators[schemaType];

    childrenPopulator(schema, node);
  }

  return node;
};

var toTree = function toTree(schema) {
  return toNode(schema, null);
};

module.exports = toTree;
},{"1tree":60}],11:[function(require,module,exports){
'use strict'

module.exports = require( './dist' )

},{"./dist":7}],12:[function(require,module,exports){
'use strict';

module.exports = {
  createNode: function createNode(value) {
    return {
      value: value,
      children: []
    };
  },
  argTypes: ['nodeValue'],
  returnType: 'node',
  categories: ['manipulation', 'adapter']
};
},{}],13:[function(require,module,exports){
'use strict';

module.exports = {
  getChildren: function getChildren(node) {
    return node.children;
  },
  argTypes: ['node'],
  returnType: '[node]',
  categories: ['traversal', 'adapter']
};
},{}],14:[function(require,module,exports){
'use strict';

var createNode = require('./createNode');
var getChildren = require('./getChildren');
var insertBefore = require('./insertBefore');
var remove = require('./remove');
var value = require('./value');

module.exports = { createNode: createNode, getChildren: getChildren, insertBefore: insertBefore, remove: remove, value: value };
},{"./createNode":12,"./getChildren":13,"./insertBefore":15,"./remove":16,"./value":17}],15:[function(require,module,exports){
'use strict';

module.exports = {
  insertBefore: function insertBefore(fn, root, parentNode, childNode, referenceNode) {
    if (root) fn.remove(fn, root, childNode);

    if (referenceNode) {
      var referenceIndex = parentNode.children.indexOf(referenceNode);

      parentNode.children.splice(referenceIndex, 0, childNode);
    } else {
      parentNode.children.push(childNode);
    }

    return childNode;
  },
  argTypes: ['fn', 'rootNode', 'node', 'node', 'node'],
  returnType: 'node',
  requires: ['remove'],
  categories: ['manipulation', 'adapter']
};
},{}],16:[function(require,module,exports){
'use strict';

module.exports = {
  remove: function remove(fn, root, node) {
    var parentNode = fn.getParent(fn, root, node);

    if (!parentNode) return;

    var index = parentNode.children.indexOf(node);

    parentNode.children.splice(index, 1);

    return node;
  },
  argTypes: ['fn', 'rootNode', 'node'],
  returnType: 'node',
  requires: ['getParent'],
  categories: ['manipulation', 'adapter']
};
},{}],17:[function(require,module,exports){
'use strict';

module.exports = {
  value: function value(node, _value) {
    if (_value !== undefined) {
      node.value = _value;
    }

    return node.value;
  },
  argTypes: ['node', 'nodeValue?'],
  returnType: 'nodeValue',
  categories: ['manipulation', 'adapter']
};
},{}],18:[function(require,module,exports){
'use strict';

module.exports = {
  createNode: function createNode() {
    throw new Error('Adapter does not implement createNode');
  },
  argTypes: ['nodeValue'],
  returnType: 'node',
  categories: ['manipulation', 'adapter']
};
},{}],19:[function(require,module,exports){
'use strict';

module.exports = {
  getChildren: function getChildren() {
    throw new Error('Adapter does not implement getChildren');
  },
  argTypes: ['node'],
  returnType: '[node]',
  categories: ['traversal', 'adapter']
};
},{}],20:[function(require,module,exports){
'use strict';

module.exports = {
  insertBefore: function insertBefore() {
    throw new Error('Adapter does not implement insertBefore');
  },
  argTypes: ['fn', 'rootNode', 'node', 'node', 'node'],
  returnType: 'node',
  requires: ['remove'],
  categories: ['manipulation', 'adapter']
};
},{}],21:[function(require,module,exports){
'use strict';

module.exports = {
  remove: function remove() {
    throw new Error('Adapter does not implement remove');
  },
  argTypes: ['fn', 'rootNode', 'node'],
  returnType: 'node',
  requires: ['getParent'],
  categories: ['manipulation', 'adapter']
};
},{}],22:[function(require,module,exports){
'use strict';

module.exports = {
  value: function value() {
    throw new Error('Adapter does not implement value');
  },
  argTypes: ['node', 'nodeValue?'],
  returnType: 'nodeValue',
  categories: ['manipulation', 'adapter']
};
},{}],23:[function(require,module,exports){
'use strict';

var append = require('./manipulation/append');
var empty = require('./manipulation/empty');
var insertAfter = require('./manipulation/insertAfter');
var insertAt = require('./manipulation/insertAt');
var prepend = require('./manipulation/prepend');
var removeAt = require('./manipulation/removeAt');
var replaceChild = require('./manipulation/replaceChild');
var unwrap = require('./manipulation/unwrap');
var wrap = require('./manipulation/wrap');

var ancestors = require('./traversal/ancestors');
var childAt = require('./traversal/childAt');
var closest = require('./traversal/closest');
var contains = require('./traversal/contains');
var descendents = require('./traversal/descendents');
var find = require('./traversal/find');
var findAll = require('./traversal/findAll');
var firstChild = require('./traversal/firstChild');
var getParent = require('./traversal/getParent');
var hasChildren = require('./traversal/hasChildren');
var isEmpty = require('./traversal/isEmpty');
var lastChild = require('./traversal/lastChild');
var nextSibling = require('./traversal/nextSibling');
var previousSibling = require('./traversal/previousSibling');
var siblings = require('./traversal/siblings');
var walk = require('./traversal/walk');
var walkUp = require('./traversal/walkUp');

var createNode = require('./adapter/createNode');
var getChildren = require('./adapter/getChildren');
var insertBefore = require('./adapter/insertBefore');
var remove = require('./adapter/remove');
var value = require('./adapter/value');

module.exports = {
  append: append, empty: empty, insertAfter: insertAfter, insertAt: insertAt, prepend: prepend, removeAt: removeAt, replaceChild: replaceChild,
  unwrap: unwrap, wrap: wrap, ancestors: ancestors, childAt: childAt, closest: closest, contains: contains, descendents: descendents, find: find,
  findAll: findAll, firstChild: firstChild, getParent: getParent, hasChildren: hasChildren, isEmpty: isEmpty, lastChild: lastChild, nextSibling: nextSibling,
  previousSibling: previousSibling, siblings: siblings, walk: walk, walkUp: walkUp, createNode: createNode, getChildren: getChildren,
  insertBefore: insertBefore, remove: remove, value: value
};
},{"./adapter/createNode":18,"./adapter/getChildren":19,"./adapter/insertBefore":20,"./adapter/remove":21,"./adapter/value":22,"./manipulation/append":24,"./manipulation/empty":25,"./manipulation/insertAfter":26,"./manipulation/insertAt":27,"./manipulation/prepend":28,"./manipulation/removeAt":29,"./manipulation/replaceChild":30,"./manipulation/unwrap":31,"./manipulation/wrap":32,"./traversal/ancestors":33,"./traversal/childAt":34,"./traversal/closest":35,"./traversal/contains":36,"./traversal/descendents":37,"./traversal/find":38,"./traversal/findAll":39,"./traversal/firstChild":40,"./traversal/getParent":41,"./traversal/hasChildren":42,"./traversal/isEmpty":43,"./traversal/lastChild":44,"./traversal/nextSibling":45,"./traversal/previousSibling":46,"./traversal/siblings":47,"./traversal/walk":48,"./traversal/walkUp":49}],24:[function(require,module,exports){
'use strict';

module.exports = {
  append: function append(fn, root, parentNode, childNode) {
    return fn.insertBefore(fn, root, parentNode, childNode);
  },
  argTypes: ['fn', 'rootNode', 'node', 'node'],
  returnType: 'node',
  requires: ['insertBefore'],
  categories: ['manipulation']
};
},{}],25:[function(require,module,exports){
'use strict';

module.exports = {
  empty: function empty(fn, root, parentNode) {
    var children = fn.getChildren(parentNode).slice();

    return children.reduce(function (removed, node) {
      removed.push(fn.remove(fn, parentNode, node));

      return removed;
    }, []);
  },
  argTypes: ['fn', 'rootNode', 'node'],
  returnType: '[node]',
  requires: ['getChildren', 'remove'],
  categories: ['manipulation']
};
},{}],26:[function(require,module,exports){
'use strict';

module.exports = {
  insertAfter: function insertAfter(fn, root, parentNode, childNode, referenceNode) {
    var children = fn.getChildren(parentNode);
    var referenceIndex = children.indexOf(referenceNode);
    var beforeNode = children[referenceIndex + 1];

    return fn.insertBefore(fn, root, parentNode, childNode, beforeNode);
  },
  argTypes: ['fn', 'rootNode', 'node', 'node', 'node'],
  returnType: 'node',
  requires: ['getChildren', 'insertBefore'],
  categories: ['manipulation']
};
},{}],27:[function(require,module,exports){
'use strict';

module.exports = {
  insertAt: function insertAt(fn, root, parentNode, childNode, index) {
    var children = fn.getChildren(parentNode);
    var referenceNode = children[index];

    return fn.insertBefore(fn, root, parentNode, childNode, referenceNode);
  },
  argTypes: ['fn', 'rootNode', 'node', 'node', 'integer'],
  returnType: 'node',
  requires: ['getChildren', 'insertBefore'],
  categories: ['manipulation']
};
},{}],28:[function(require,module,exports){
'use strict';

module.exports = {
  prepend: function prepend(fn, root, parentNode, childNode) {
    var children = fn.getChildren(parentNode);

    // if child[ 0 ] is undefined this is the same as append
    return fn.insertBefore(fn, root, parentNode, childNode, children[0]);
  },
  argTypes: ['fn', 'rootNode', 'node', 'node'],
  returnType: 'node',
  requires: ['getChildren', 'insertBefore'],
  categories: ['manipulation']
};
},{}],29:[function(require,module,exports){
'use strict';

module.exports = {
  removeAt: function removeAt(fn, root, parentNode, index) {
    var children = fn.getChildren(parentNode);
    var childNode = children[index];

    return fn.remove(fn, root, childNode);
  },
  argTypes: ['fn', 'rootNode', 'node', 'integer'],
  returnType: 'node',
  requires: ['getChildren', 'remove'],
  categories: ['manipulation']
};
},{}],30:[function(require,module,exports){
'use strict';

module.exports = {
  replaceChild: function replaceChild(fn, root, parentNode, newNode, oldNode) {
    fn.insertBefore(fn, root, parentNode, newNode, oldNode);

    return fn.remove(fn, root, oldNode);
  },
  argTypes: ['fn', 'rootNode', 'node', 'node', 'node'],
  returnType: 'node',
  requires: ['insertBefore', 'remove'],
  categories: ['manipulation']
};
},{}],31:[function(require,module,exports){
'use strict';

module.exports = {
  unwrap: function unwrap(fn, root, node) {
    var parent = fn.getParent(fn, root, node);
    var grandparent = fn.getParent(fn, root, parent);
    var children = fn.getChildren(parent);

    children.forEach(function (child) {
      return fn.insertBefore(fn, root, grandparent, child, parent);
    });

    return fn.remove(fn, root, parent);
  },
  argTypes: ['fn', 'rootNode', 'node'],
  returnType: 'node',
  requires: ['getParent', 'getChildren', 'insertBefore', 'remove'],
  categories: ['manipulation']
};
},{}],32:[function(require,module,exports){
'use strict';

module.exports = {
  wrap: function wrap(fn, root, node, newNode) {
    var parent = fn.getParent(fn, root, node);

    fn.insertBefore(fn, root, parent, newNode, node);
    fn.append(fn, root, newNode, node);

    return newNode;
  },
  argTypes: ['fn', 'rootNode', 'node', 'node'],
  returnType: 'node',
  requires: ['getParent', 'insertBefore', 'append'],
  categories: ['manipulation']
};
},{}],33:[function(require,module,exports){
'use strict';

module.exports = {
  ancestors: function ancestors(fn, root, node) {
    var parentNodes = [];

    var parent = fn.getParent(fn, root, node);

    if (parent) fn.walkUp(fn, root, parent, function (n) {
      parentNodes.push(n);
    });

    return parentNodes;
  },
  argTypes: ['fn', 'rootNode', 'node'],
  returnType: '[node]',
  requires: ['getParent', 'walkUp']
};
},{}],34:[function(require,module,exports){
'use strict';

module.exports = {
  childAt: function childAt(fn, node, i) {
    return fn.getChildren(node)[i];
  },
  argTypes: ['fn', 'node', 'integer'],
  returnType: 'node',
  requires: ['getChildren'],
  categories: ['traversal']
};
},{}],35:[function(require,module,exports){
'use strict';

module.exports = {
  closest: function closest(fn, root, node, predicate) {
    var targetNode = void 0;

    fn.walkUp(fn, root, node, function (currentNode) {
      if (predicate(currentNode)) {
        targetNode = currentNode;

        return true;
      }
    });

    return targetNode;
  },
  argTypes: ['fn', 'rootNode', 'node', 'node => boolean'],
  returnType: 'node',
  requires: ['walkUp'],
  categories: ['traversal']
};
},{}],36:[function(require,module,exports){
'use strict';

module.exports = {
  contains: function contains(fn, node, predicate) {
    return !!fn.find(fn, node, predicate);
  },
  argTypes: ['fn', 'node', 'node => boolean'],
  returnType: 'boolean',
  requires: ['find'],
  categories: ['traversal']
};
},{}],37:[function(require,module,exports){
'use strict';

module.exports = {
  descendents: function descendents(fn, node) {
    return fn.findAll(fn, node, function (n) {
      return n !== node;
    });
  },
  argTypes: ['fn', 'node'],
  returnType: '[node]',
  requires: ['findAll'],
  categories: ['traversal']
};
},{}],38:[function(require,module,exports){
'use strict';

module.exports = {
  find: function find(fn, node, predicate) {
    var targetNode = void 0;

    fn.walk(fn, node, function (currentNode) {
      if (predicate(currentNode)) {
        targetNode = currentNode;

        return true;
      }
    });

    return targetNode;
  },
  argTypes: ['fn', 'node', 'node => boolean'],
  returnType: 'node',
  requires: ['walk'],
  categories: ['traversal']
};
},{}],39:[function(require,module,exports){
'use strict';

module.exports = {
  findAll: function findAll(fn, node, predicate) {
    var nodes = [];

    fn.walk(fn, node, function (currentNode) {
      if (predicate(currentNode)) {
        nodes.push(currentNode);
      }
    });

    return nodes;
  },
  argTypes: ['fn', 'node', 'node => boolean'],
  returnType: '[node]',
  requires: ['walk'],
  categories: ['traversal']
};
},{}],40:[function(require,module,exports){
'use strict';

module.exports = {
  firstChild: function firstChild(fn, node) {
    return fn.getChildren(node)[0];
  },
  argTypes: ['fn', 'node'],
  returnType: 'node',
  requires: ['getChildren'],
  categories: ['traversal']
};
},{}],41:[function(require,module,exports){
'use strict';

module.exports = {
  getParent: function getParent(fn, root, node) {
    return fn.find(fn, root, function (currentNode) {
      return fn.getChildren(currentNode).includes(node);
    });
  },
  argTypes: ['fn', 'rootNode', 'node'],
  returnType: 'node',
  requires: ['find', 'getChildren'],
  categories: ['traversal']
};
},{}],42:[function(require,module,exports){
'use strict';

module.exports = {
  hasChildren: function hasChildren(fn, node) {
    return fn.getChildren(node).length > 0;
  },
  argTypes: ['fn', 'node'],
  returnType: 'boolean',
  requires: ['getChildren'],
  categories: ['traversal']
};
},{}],43:[function(require,module,exports){
'use strict';

module.exports = {
  isEmpty: function isEmpty(fn, node) {
    return false;
  }, //eslint-disable-line no-unused-vars
  argTypes: ['fn', 'node'],
  returnType: 'boolean',
  requires: [],
  categories: ['traversal']
};
},{}],44:[function(require,module,exports){
'use strict';

module.exports = {
  lastChild: function lastChild(fn, node) {
    var children = fn.getChildren(node);

    return children[children.length - 1];
  },
  argTypes: ['fn', 'node'],
  returnType: 'node',
  requires: ['getChildren'],
  categories: ['traversal']
};
},{}],45:[function(require,module,exports){
'use strict';

module.exports = {
  nextSibling: function nextSibling(fn, root, node) {
    var parent = fn.getParent(fn, root, node);
    var children = fn.getChildren(parent);

    var index = children.indexOf(node);

    return children[index + 1];
  },
  argTypes: ['fn', 'rootNode', 'node'],
  returnType: 'node',
  requires: ['getParent', 'getChildren'],
  categories: ['traversal']
};
},{}],46:[function(require,module,exports){
'use strict';

module.exports = {
  previousSibling: function previousSibling(fn, root, node) {
    var parent = fn.getParent(fn, root, node);
    var children = fn.getChildren(parent);

    var index = children.indexOf(node);

    return children[index - 1];
  },
  argTypes: ['fn', 'rootNode', 'node'],
  returnType: 'node',
  requires: ['getParent', 'getChildren'],
  categories: ['traversal']
};
},{}],47:[function(require,module,exports){
'use strict';

module.exports = {
  siblings: function siblings(fn, root, node) {
    var parent = fn.getParent(fn, root, node);
    var children = fn.getChildren(parent);

    return children.filter(function (child) {
      return child !== node;
    });
  },
  argTypes: ['fn', 'rootNode', 'node'],
  returnType: '[node]',
  requires: ['getParent', 'getChildren'],
  categories: ['traversal']
};
},{}],48:[function(require,module,exports){
'use strict';

module.exports = {
  walk: function walk(fn, node, callback) {
    var current = void 0,
        parent = void 0,
        depth = void 0,
        i = void 0,
        children = void 0,
        stop = void 0;
    var nodes = [node];
    var parents = [null];
    var depths = [0];

    while (nodes.length) {
      current = nodes.pop();
      parent = parents.pop();
      depth = depths.pop();

      stop = callback(current, parent, depth);

      if (stop) break;

      children = fn.getChildren(current);

      for (i = children.length - 1; i >= 0; i--) {
        nodes.push(children[i]);
        parents.push(current);
        depths.push(depth + 1);
      }
    }
  },
  argTypes: ['fn', 'node', '( node, node, integer ) => boolean'],
  requires: ['getChildren'],
  categories: ['traversal']
};
},{}],49:[function(require,module,exports){
'use strict';

module.exports = {
  walkUp: function walkUp(fn, root, node, callback) {
    var stop = callback(node);

    if (!stop) {
      var parent = fn.getParent(fn, root, node);
      while (parent && !stop) {
        stop = callback(parent);
        if (!stop) parent = fn.getParent(fn, root, parent);
      }
    }
  },
  argTypes: ['fn', 'rootNode', 'node', 'node => boolean'],
  requires: ['getParent'],
  categories: ['traversal']
};
},{}],50:[function(require,module,exports){
'use strict';

var baseDefs = require('./defs');

var mapper = function mapper(defs) {
  var makeFn = function makeFn(name) {
    var fnDef = defs[name];
    var fn = fnDef[name];

    fn.def = fnDef;

    return fn;
  };

  var fnames = Object.keys(defs);

  return fnames.reduce(function (fns, name) {
    fns[name] = makeFn(name);

    return fns;
  }, {});
};

var fnFactory = function fnFactory(adapter) {
  var adapterDefs = Object.keys(adapter).reduce(function (defs, fname) {
    var adapterDef = adapter[fname];

    if (typeof adapterDef === 'function') {
      var fn = adapterDef;
      adapterDef = adapterDef.def || baseDefs[fname] || {};
      adapterDef[fname] = fn;
    }

    defs[fname] = adapterDef;

    return defs;
  }, {});

  return mapper(Object.assign({}, baseDefs, adapterDefs));
};

module.exports = fnFactory;
},{"./defs":23}],51:[function(require,module,exports){
'use strict';

require('./polyfills');

var defaultAdapter = require('./adapter/default');
var fnFactory = require('./fn-factory');

var meta = require('./plugins/meta');
var parentMap = require('./plugins/parent-map');
var serializer = require('./plugins/serializer');
var wrapNodes = require('./plugins/wrap-nodes');
var accepts = require('./plugins/accepts');
var nodeType = require('./plugins/nodeType');
var id = require('./plugins/id');

var plugins = { parentMap: parentMap, accepts: accepts, nodeType: nodeType, id: id, serializer: serializer, meta: meta, wrapNodes: wrapNodes };
var pluginArray = Object.keys(plugins).map(function (key) {
  return plugins[key];
});

var treeFactory = function treeFactory(adapter, plugins) {
  var fn = fnFactory(adapter);

  if (Array.isArray(plugins)) plugins.forEach(function (plugin) {
    return plugin(fn);
  });

  // create wrapped API
  var Tree = function Tree(root) {
    return fn.createTree(root);
  };

  var fnames = Object.keys(fn);

  fnames.forEach(function (fname) {
    var func = fn[fname];
    var def = func.def || {};
    var argTypes = Array.isArray(def.argTypes) ? def.argTypes : [];

    Tree[fname] = function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (argTypes.includes('fn')) {
        return func.apply(undefined, [fn].concat(args));
      }

      return func.apply(undefined, args);
    };
  });

  Tree.createRoot = function (value) {
    return Tree(Tree.createNode(value));
  };
  Tree.fn = fn;
  Tree.adapter = treeFactory;
  Tree.plugin = function (plugin) {
    return plugin(fn);
  };
  Tree.plugins = plugins;

  return Tree;
};

module.exports = treeFactory(defaultAdapter, pluginArray);
},{"./adapter/default":14,"./fn-factory":50,"./plugins/accepts":52,"./plugins/id":53,"./plugins/meta":54,"./plugins/nodeType":55,"./plugins/parent-map":56,"./plugins/serializer":57,"./plugins/wrap-nodes":58,"./polyfills":59}],52:[function(require,module,exports){
'use strict';

var acceptsNode = function acceptsNode(fn) {
  var accepts = function accepts(fn, node, childNode) {
    return !fn.isEmpty(fn, node);
  }; //eslint-disable-line no-unused-vars

  accepts.def = {
    argTypes: ['fn', 'node', 'node'],
    returnType: 'boolean',
    require: ['isEmpty'],
    categories: ['node', 'plugin']
  };

  var originalInsertBefore = fn.insertBefore;

  var insertBefore = function insertBefore(fn, root, parentNode, childNode, referenceNode) {
    if (!fn.accepts(fn, parentNode, childNode)) throw new Error('Node cannot accept this child');

    return originalInsertBefore(fn, root, parentNode, childNode, referenceNode);
  };

  insertBefore.def = originalInsertBefore.def;

  return Object.assign(fn, { accepts: accepts, insertBefore: insertBefore });
};

module.exports = acceptsNode;
},{}],53:[function(require,module,exports){
'use strict';

var utils = require('mojule-utils');

var lazyId = function lazyId(fn) {
  var id = function id(fn, node) {
    var value = fn.value(node);

    if (value._id) return value._id;

    var nodeType = fn.nodeType(fn, node);
    var id = utils.id(nodeType);

    value._id = id;

    fn.value(node, value);

    return id;
  };

  id.def = {
    argTypes: ['fn', 'node'],
    returnType: 'string',
    require: ['value', 'nodeType'],
    categories: ['node', 'plugin']
  };

  return Object.assign(fn, { id: id });
};

module.exports = lazyId;
},{"mojule-utils":161}],54:[function(require,module,exports){
'use strict';

/*
  Get/set runtime data for nodes that aren't written to the nodes themselves

  For example, when visualising trees you might want to allow the user to
  collapse or expand nodes for the duration of the session, but not actually
  modify the nodes themselves
*/

var metaPlugin = function metaPlugin(fn) {
  var metaMap = new Map();

  var meta = function meta(fn, node, key, value) {
    if (!metaMap.has(node)) {
      metaMap.set(node, {});
    }

    var obj = metaMap.get(node);

    if (value !== undefined) {
      obj[key] = value;
    }

    return obj[key];
  };

  meta.def = {
    argTypes: ['fn', 'node', 'string', 'any'],
    returnType: 'any',
    requires: [],
    categories: ['meta', 'plugin']
  };

  return Object.assign(fn, { meta: meta });
};

module.exports = metaPlugin;
},{}],55:[function(require,module,exports){
'use strict';

var getNodeType = function getNodeType(fn) {
  var nodeType = function nodeType(fn, node) {
    var value = fn.value(node);

    if (typeof value.nodeType === 'string' && value.nodeType.length > 0) return value.nodeType;

    return 'treeNode';
  };

  nodeType.def = {
    argTypes: ['fn', 'node'],
    returnType: 'string',
    require: ['value'],
    categories: ['node', 'plugin']
  };

  return Object.assign(fn, { nodeType: nodeType });
};

module.exports = getNodeType;
},{}],56:[function(require,module,exports){
'use strict';

var parentMap = function parentMap(fn) {
  var parents = new Map();

  var original = {
    insertBefore: fn.insertBefore,
    remove: fn.remove,
    getParent: fn.getParent
  };

  var insertBefore = function insertBefore(fn, root, parentNode, childNode, referenceNode) {
    var value = original.insertBefore(fn, root, parentNode, childNode, referenceNode);

    parents.set(childNode, parentNode);

    return value;
  };

  var remove = function remove(fn, root, node) {
    var value = original.remove(fn, root, node);

    parents.set(node, null);

    return value;
  };

  var getParent = function getParent(fn, root, node) {
    var parent = parents.get(node);

    if (!parent && original.getParent) {
      parent = original.getParent(fn, root, node);
      parents.set(node, parent);
    }

    return parent;
  };

  var wrapped = { insertBefore: insertBefore, remove: remove, getParent: getParent };

  Object.keys(wrapped).forEach(function (fname) {
    wrapped[fname].def = Object.assign({
      wraps: original[fname]
    }, original[fname].def);

    wrapped[fname].def.categories.push('parentMap', 'plugin');
  });

  return Object.assign(fn, wrapped);
};

module.exports = parentMap;
},{}],57:[function(require,module,exports){
'use strict';

var cloneObj = function cloneObj(obj) {
  return JSON.parse(JSON.stringify(obj));
};

var serializer = function serializer(fn) {
  var serialize = function serialize(node) {
    return {
      value: fn.value(node),
      children: fn.getChildren(node).map(serialize)
    };
  };

  serialize.def = {
    argTypes: ['node'],
    returnType: 'object',
    requires: ['value', 'getChildren'],
    categories: ['serializer', 'plugin']
  };

  var deserialize = function deserialize(obj) {
    var parentNode = fn.createNode(obj.value);

    if (Array.isArray(obj.children)) {
      obj.children.forEach(function (child) {
        fn.append(fn, null, parentNode, deserialize(child));
      });
    }

    return parentNode;
  };

  deserialize.def = {
    argTypes: ['object'],
    returnType: 'node',
    requires: ['createNode', 'append'],
    categories: ['serializer', 'plugin']
  };

  var clone = function clone(fn, node) {
    return fn.deserialize(cloneObj(fn.serialize(node)));
  };

  clone.def = {
    argTypes: ['fn', 'node'],
    returnType: 'node',
    requires: ['serialize', 'deserialize'],
    categories: ['clone', 'plugin']
  };

  return Object.assign(fn, { serialize: serialize, deserialize: deserialize, clone: clone });
};

module.exports = serializer;
},{}],58:[function(require,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var signatureToDef = function signatureToDef(sig) {
  var segs = sig.split('=>');
  var argTypes = segs[0].replace('(', '').replace(')', '').split(',').map(function (arg) {
    return arg.trim();
  });
  var returnType = segs[1].trim();

  return { argTypes: argTypes, returnType: returnType };
};

var argsMap = function argsMap(fn, argTypes, map) {
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var wrappedArgs = argTypes.map(function (typeName, i) {
      var value = args[i];

      if (map[typeName]) {
        return map[typeName](value);
      }

      return value;
    });

    return fn.apply(undefined, _toConsumableArray(wrappedArgs));
  };
};

var clone = function clone(obj) {
  return JSON.parse(JSON.stringify(obj));
};

var wrapNodes = function wrapNodes(_fn) {
  var fnames = Object.keys(_fn);

  var wrappedFn = function wrappedFn(root, _node, fname) {
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var func = _fn[fname];
      var def = func.def || {};
      var argTypes = def && Array.isArray(def.argTypes) ? def.argTypes : [];

      var firstNode = false;

      var curryMap = {
        fn: function fn() {
          return _fn;
        },
        rootNode: function rootNode() {
          return root;
        },
        node: function node() {
          if (!firstNode) {
            firstNode = true;
            return _node;
          }

          return args.shift().get();
        },
        any: function any() {
          return args.shift();
        }
      };

      var argMap = {
        rootNode: function rootNode(n) {
          return wrappedNode(root, n);
        },
        node: function node(n) {
          return wrappedNode(root, n);
        }
      };

      var curried = argTypes.map(function (t) {
        if (curryMap[t]) return curryMap[t]();

        if (t.indexOf('=>') !== -1) {
          var _def = signatureToDef(t);
          var fnArg = args.shift();

          return argsMap(fnArg, _def.argTypes, argMap);
        }

        return curryMap.any();
      });

      var result = func.apply(undefined, _toConsumableArray(curried));

      if (def.returnType === 'node') {
        result = wrappedNode(root, result);
      } else if (def.returnType === '[node]') {
        result = result.map(function (n) {
          return wrappedNode(root, n);
        });
      }

      return result;
    };
  };

  var wrappedNode = function wrappedNode(root, node) {
    if (node === null || node === undefined) return node;

    var wrapped = fnames.reduce(function (wrappedNode, fname) {
      wrappedNode[fname] = wrappedFn(root, node, fname);

      return wrappedNode;
    }, {});

    wrapped.get = function () {
      return node;
    };
    wrapped.getRoot = function () {
      return root;
    };

    // assist with debugging
    Object.defineProperty(wrapped, '_value', {
      get: function get() {
        return clone(_fn.value(node));
      }
    });
    Object.defineProperty(wrapped, '_children', {
      get: function get() {
        return clone(_fn.getChildren(node));
      }
    });

    return wrapped;
  };

  var createTree = function createTree(root) {
    return wrappedNode(root, root);
  };

  createTree.def = {
    argTypes: ['nodeValue'],
    returnType: 'wrappedNode',
    requires: ['createNode'],
    categories: ['wrapped-nodes', 'plugin']
  };

  return Object.assign(_fn, { createTree: createTree });
};

module.exports = wrapNodes;
},{}],59:[function(require,module,exports){
'use strict';

/*eslint-disable */
if (!Array.prototype.includes) {
  Array.prototype.includes = function (searchElement /*, fromIndex*/) {
    'use strict';

    var O = Object(this);
    var len = parseInt(O.length) || 0;
    if (len === 0) {
      return false;
    }
    var n = parseInt(arguments[1]) || 0;
    var k;
    if (n >= 0) {
      k = n;
    } else {
      k = len + n;
      if (k < 0) {
        k = 0;
      }
    }
    var currentElement;
    while (k < len) {
      currentElement = O[k];
      if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {
        return true;
      }
      k++;
    }
    return false;
  };
}
/*eslint-enable */
},{}],60:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":51,"dup":3}],61:[function(require,module,exports){
module.exports = function atoa (a, n) { return Array.prototype.slice.call(a, n); }

},{}],62:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],63:[function(require,module,exports){
module.exports = {
	trueFunc: function trueFunc(){
		return true;
	},
	falseFunc: function falseFunc(){
		return false;
	}
};
},{}],64:[function(require,module,exports){

},{}],65:[function(require,module,exports){
(function (global){
'use strict';

var buffer = require('buffer');
var Buffer = buffer.Buffer;
var SlowBuffer = buffer.SlowBuffer;
var MAX_LEN = buffer.kMaxLength || 2147483647;
exports.alloc = function alloc(size, fill, encoding) {
  if (typeof Buffer.alloc === 'function') {
    return Buffer.alloc(size, fill, encoding);
  }
  if (typeof encoding === 'number') {
    throw new TypeError('encoding must not be number');
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  var enc = encoding;
  var _fill = fill;
  if (_fill === undefined) {
    enc = undefined;
    _fill = 0;
  }
  var buf = new Buffer(size);
  if (typeof _fill === 'string') {
    var fillBuf = new Buffer(_fill, enc);
    var flen = fillBuf.length;
    var i = -1;
    while (++i < size) {
      buf[i] = fillBuf[i % flen];
    }
  } else {
    buf.fill(_fill);
  }
  return buf;
}
exports.allocUnsafe = function allocUnsafe(size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    return Buffer.allocUnsafe(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new Buffer(size);
}
exports.from = function from(value, encodingOrOffset, length) {
  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof value === 'string') {
    return new Buffer(value, encodingOrOffset);
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    var offset = encodingOrOffset;
    if (arguments.length === 1) {
      return new Buffer(value);
    }
    if (typeof offset === 'undefined') {
      offset = 0;
    }
    var len = length;
    if (typeof len === 'undefined') {
      len = value.byteLength - offset;
    }
    if (offset >= value.byteLength) {
      throw new RangeError('\'offset\' is out of bounds');
    }
    if (len > value.byteLength - offset) {
      throw new RangeError('\'length\' is out of bounds');
    }
    return new Buffer(value.slice(offset, offset + len));
  }
  if (Buffer.isBuffer(value)) {
    var out = new Buffer(value.length);
    value.copy(out, 0, 0, value.length);
    return out;
  }
  if (value) {
    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
      return new Buffer(value);
    }
    if (value.type === 'Buffer' && Array.isArray(value.data)) {
      return new Buffer(value.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
}
exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
  if (typeof Buffer.allocUnsafeSlow === 'function') {
    return Buffer.allocUnsafeSlow(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size >= MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new SlowBuffer(size);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"buffer":66}],66:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":62,"ieee754":120,"isarray":123}],67:[function(require,module,exports){
'use strict';

var ticky = require('ticky');

module.exports = function debounce (fn, args, ctx) {
  if (!fn) { return; }
  ticky(function run () {
    fn.apply(ctx || null, args || []);
  });
};

},{"ticky":193}],68:[function(require,module,exports){
'use strict';

var atoa = require('atoa');
var debounce = require('./debounce');

module.exports = function emitter (thing, options) {
  var opts = options || {};
  var evt = {};
  if (thing === undefined) { thing = {}; }
  thing.on = function (type, fn) {
    if (!evt[type]) {
      evt[type] = [fn];
    } else {
      evt[type].push(fn);
    }
    return thing;
  };
  thing.once = function (type, fn) {
    fn._once = true; // thing.off(fn) still works!
    thing.on(type, fn);
    return thing;
  };
  thing.off = function (type, fn) {
    var c = arguments.length;
    if (c === 1) {
      delete evt[type];
    } else if (c === 0) {
      evt = {};
    } else {
      var et = evt[type];
      if (!et) { return thing; }
      et.splice(et.indexOf(fn), 1);
    }
    return thing;
  };
  thing.emit = function () {
    var args = atoa(arguments);
    return thing.emitterSnapshot(args.shift()).apply(this, args);
  };
  thing.emitterSnapshot = function (type) {
    var et = (evt[type] || []).slice(0);
    return function () {
      var args = atoa(arguments);
      var ctx = this || thing;
      if (type === 'error' && opts.throws !== false && !et.length) { throw args.length === 1 ? args[0] : args; }
      et.forEach(function emitter (listen) {
        if (opts.async) { debounce(listen, args, ctx); } else { listen.apply(ctx, args); }
        if (listen._once) { thing.off(type, listen); }
      });
      return thing;
    };
  };
  return thing;
};

},{"./debounce":67,"atoa":61}],69:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":122}],70:[function(require,module,exports){
(function (global){
'use strict';

var customEvent = require('custom-event');
var eventmap = require('./eventmap');
var doc = global.document;
var addEvent = addEventEasy;
var removeEvent = removeEventEasy;
var hardCache = [];

if (!global.addEventListener) {
  addEvent = addEventHard;
  removeEvent = removeEventHard;
}

module.exports = {
  add: addEvent,
  remove: removeEvent,
  fabricate: fabricateEvent
};

function addEventEasy (el, type, fn, capturing) {
  return el.addEventListener(type, fn, capturing);
}

function addEventHard (el, type, fn) {
  return el.attachEvent('on' + type, wrap(el, type, fn));
}

function removeEventEasy (el, type, fn, capturing) {
  return el.removeEventListener(type, fn, capturing);
}

function removeEventHard (el, type, fn) {
  var listener = unwrap(el, type, fn);
  if (listener) {
    return el.detachEvent('on' + type, listener);
  }
}

function fabricateEvent (el, type, model) {
  var e = eventmap.indexOf(type) === -1 ? makeCustomEvent() : makeClassicEvent();
  if (el.dispatchEvent) {
    el.dispatchEvent(e);
  } else {
    el.fireEvent('on' + type, e);
  }
  function makeClassicEvent () {
    var e;
    if (doc.createEvent) {
      e = doc.createEvent('Event');
      e.initEvent(type, true, true);
    } else if (doc.createEventObject) {
      e = doc.createEventObject();
    }
    return e;
  }
  function makeCustomEvent () {
    return new customEvent(type, { detail: model });
  }
}

function wrapperFactory (el, type, fn) {
  return function wrapper (originalEvent) {
    var e = originalEvent || global.event;
    e.target = e.target || e.srcElement;
    e.preventDefault = e.preventDefault || function preventDefault () { e.returnValue = false; };
    e.stopPropagation = e.stopPropagation || function stopPropagation () { e.cancelBubble = true; };
    e.which = e.which || e.keyCode;
    fn.call(el, e);
  };
}

function wrap (el, type, fn) {
  var wrapper = unwrap(el, type, fn) || wrapperFactory(el, type, fn);
  hardCache.push({
    wrapper: wrapper,
    element: el,
    type: type,
    fn: fn
  });
  return wrapper;
}

function unwrap (el, type, fn) {
  var i = find(el, type, fn);
  if (i) {
    var wrapper = hardCache[i].wrapper;
    hardCache.splice(i, 1); // free up a tad of memory
    return wrapper;
  }
}

function find (el, type, fn) {
  var i, item;
  for (i = 0; i < hardCache.length; i++) {
    item = hardCache[i];
    if (item.element === el && item.type === type && item.fn === fn) {
      return i;
    }
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./eventmap":71,"custom-event":81}],71:[function(require,module,exports){
(function (global){
'use strict';

var eventmap = [];
var eventname = '';
var ron = /^on/;

for (eventname in global) {
  if (ron.test(eventname)) {
    eventmap.push(eventname.slice(2));
  }
}

module.exports = eventmap;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],72:[function(require,module,exports){
'use strict'

module.exports = adapterFactory;

function adapterFactory(implementation){
	ensureImplementation(implementation);

	var adapter = {}

	var baseAdapter = {
		removeSubsets: function (nodes){
			return removeSubsets(adapter, nodes);
		},
		existsOne: function(test, elems){
			return existsOne(adapter, test, elems);
		},
		getSiblings: function(elem){
			return getSiblings(adapter, elem);
		},
		hasAttrib: function(elem, name){
			return hasAttrib(adapter, elem, name);
		},
		findOne: function(test, arr){
			return findOne(adapter, test, arr);
		},
		findAll: function(test, elems){
			return findAll(adapter, test, elems)
		}
	};

	Object.assign(adapter, baseAdapter, implementation);

	return adapter;
}

var expectImplemented = [
	"isTag", "getAttributeValue", "getChildren", "getName", "getParent",
	"getText"
];

function ensureImplementation(implementation){
	if(!implementation)	throw new TypeError("Expected implementation")

	var notImplemented = expectImplemented.filter(function(fname){
		return typeof implementation[fname] !== "function";
	});

	if(notImplemented.length){
		var notList = "(" + notImplemented.join(", ") + ")";
		var message = "Expected functions " + notList + " to be implemented";
		throw new Error(message);
	}
}

function removeSubsets(adapter, nodes){
	var idx = nodes.length, node, ancestor, replace;

	// Check if each node (or one of its ancestors) is already contained in the
	// array.
	while(--idx > -1){
		node = ancestor = nodes[idx];

		// Temporarily remove the node under consideration
		nodes[idx] = null;
		replace = true;

		while(ancestor){
			if(nodes.indexOf(ancestor) > -1){
				replace = false;
				nodes.splice(idx, 1);
				break;
			}
			ancestor = adapter.getParent(ancestor)
		}

		// If the node has been found to be unique, re-insert it.
		if(replace){
			nodes[idx] = node;
		}
	}

	return nodes;
}

function existsOne(adapter, test, elems){
	return elems.some(function(elem){
		return adapter.isTag(elem) ?
			test(elem) || adapter.existsOne(test, adapter.getChildren(elem)) :
			false;
	});
}

function getSiblings(adapter, elem){
	var parent = adapter.getParent(elem);
	return parent && adapter.getChildren(parent);
}


function hasAttrib(adapter, elem, name){
	return adapter.getAttributeValue(elem,name) !== undefined
}

function findOne(adapter, test, arr){
	var elem = null;

	for(var i = 0, l = arr.length; i < l && !elem; i++){
		if(test(arr[i])){
			elem = arr[i];
		} else {
			var childs = adapter.getChildren(arr[i]);
			if(childs && childs.length > 0){
				elem = adapter.findOne(test, childs);
			}
		}
	}

	return elem;
}

function findAll(adapter, test, elems){
	var result = [];

	for(var i = 0, j = elems.length; i < j; i++){
		if(!adapter.isTag(elems[i])) continue;
		if(test(elems[i])) result.push(elems[i]);
		var childs = adapter.getChildren(elems[i]);
		if(childs) result = result.concat(adapter.findAll(test, childs));
	}

	return result;
}

},{}],73:[function(require,module,exports){
"use strict";

module.exports = CSSselect;

var DomUtils       = require("domutils"),
	falseFunc      = require("boolbase").falseFunc,
	compileFactory = require("./lib/compile.js"),
	defaultCompile = compileFactory(DomUtils);

function adapterCompile(adapter){
	return adapter === DomUtils ? defaultCompile : compileFactory(adapter);
}

function getSelectorFunc(searchFunc){
	return function select(query, elems, options){
		options = options || {}
		options.adapter = options.adapter || DomUtils;
		var compile = adapterCompile(options.adapter);

		if(typeof query !== "function") query = compile.compileUnsafe(query, options, elems);
		if(query.shouldTestNextSiblings) elems = appendNextSiblings((options && options.context) || elems, options.adapter);
		if(!Array.isArray(elems)) elems = options.adapter.getChildren(elems);
		else elems = options.adapter.removeSubsets(elems);
		return searchFunc(query, elems, options);
	};
}

function getNextSiblings(elem, adapter){
	var siblings = adapter.getSiblings(elem);
	if(!Array.isArray(siblings)) return [];
	siblings = siblings.slice(0);
	while(siblings.shift() !== elem);
	return siblings;
}

function appendNextSiblings(elems, adapter){
	// Order matters because jQuery seems to check the children before the siblings
	if(!Array.isArray(elems)) elems = [elems];
	var newElems = elems.slice(0);

	for(var i = 0, len = elems.length; i < len; i++){
		var nextSiblings = getNextSiblings(newElems[i], adapter);
		newElems.push.apply(newElems, nextSiblings);
	}
	return newElems;
}

var selectAll = getSelectorFunc(function selectAll(query, elems, options){
	return (query === falseFunc || !elems || elems.length === 0) ? [] : options.adapter.findAll(query, elems);
});

var selectOne = getSelectorFunc(function selectOne(query, elems, options){
	return (query === falseFunc || !elems || elems.length === 0) ? null : options.adapter.findOne(query, elems);
});

function is(elem, query, options){
	options = options || {}
	options.adapter = options.adapter || DomUtils;
	var compile = adapterCompile(options.adapter);
	return (typeof query === "function" ? query : compile(query, options))(elem);
}

/*
	the exported interface
*/
function CSSselect(query, elems, options){
	return selectAll(query, elems, options);
}

CSSselect.compile = defaultCompile;
CSSselect.filters = defaultCompile.Pseudos.filters;
CSSselect.pseudos = defaultCompile.Pseudos.pseudos;

CSSselect.selectAll = selectAll;
CSSselect.selectOne = selectOne;

CSSselect.is = is;

//legacy methods (might be removed)
CSSselect.parse = defaultCompile;
CSSselect.iterate = selectAll;

//hooks
CSSselect._compileUnsafe = defaultCompile.compileUnsafe;
CSSselect._compileToken = defaultCompile.compileToken;

},{"./lib/compile.js":75,"boolbase":63,"domutils":88}],74:[function(require,module,exports){
var falseFunc = require("boolbase").falseFunc;

//https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js#L469
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;

function factory(adapter){
	/*
		attribute selectors
	*/
	var attributeRules = {
		__proto__: null,
		equals: function(next, data){
			var name  = data.name,
				value = data.value;

			if(data.ignoreCase){
				value = value.toLowerCase();

				return function equalsIC(elem){
					var attr = adapter.getAttributeValue(elem, name);
					return attr != null && attr.toLowerCase() === value && next(elem);
				};
			}

			return function equals(elem){
				return adapter.getAttributeValue(elem, name) === value && next(elem);
			};
		},
		hyphen: function(next, data){
			var name  = data.name,
				value = data.value,
				len = value.length;

			if(data.ignoreCase){
				value = value.toLowerCase();

				return function hyphenIC(elem){
					var attr = adapter.getAttributeValue(elem, name);
					return attr != null &&
							(attr.length === len || attr.charAt(len) === "-") &&
							attr.substr(0, len).toLowerCase() === value &&
							next(elem);
				};
			}

			return function hyphen(elem){
				var attr = adapter.getAttributeValue(elem, name);
				return attr != null &&
						attr.substr(0, len) === value &&
						(attr.length === len || attr.charAt(len) === "-") &&
						next(elem);
			};
		},
		element: function(next, data){
			var name = data.name,
				value = data.value;

			if(/\s/.test(value)){
				return falseFunc;
			}

			value = value.replace(reChars, "\\$&");

			var pattern = "(?:^|\\s)" + value + "(?:$|\\s)",
				flags = data.ignoreCase ? "i" : "",
				regex = new RegExp(pattern, flags);

			return function element(elem){
				var attr = adapter.getAttributeValue(elem, name);
				return attr != null && regex.test(attr) && next(elem);
			};
		},
		exists: function(next, data){
			var name = data.name;
			return function exists(elem){
				return adapter.hasAttrib(elem, name) && next(elem);
			};
		},
		start: function(next, data){
			var name  = data.name,
				value = data.value,
				len = value.length;

			if(len === 0){
				return falseFunc;
			}

			if(data.ignoreCase){
				value = value.toLowerCase();

				return function startIC(elem){
					var attr = adapter.getAttributeValue(elem, name);
					return attr != null && attr.substr(0, len).toLowerCase() === value && next(elem);
				};
			}

			return function start(elem){
				var attr = adapter.getAttributeValue(elem, name);
				return attr != null && attr.substr(0, len) === value && next(elem);
			};
		},
		end: function(next, data){
			var name  = data.name,
				value = data.value,
				len   = -value.length;

			if(len === 0){
				return falseFunc;
			}

			if(data.ignoreCase){
				value = value.toLowerCase();

				return function endIC(elem){
					var attr = adapter.getAttributeValue(elem, name);
					return attr != null && attr.substr(len).toLowerCase() === value && next(elem);
				};
			}

			return function end(elem){
				var attr = adapter.getAttributeValue(elem, name);
				return attr != null && attr.substr(len) === value && next(elem);
			};
		},
		any: function(next, data){
			var name  = data.name,
				value = data.value;

			if(value === ""){
				return falseFunc;
			}

			if(data.ignoreCase){
				var regex = new RegExp(value.replace(reChars, "\\$&"), "i");

				return function anyIC(elem){
					var attr = adapter.getAttributeValue(elem, name);
					return attr != null && regex.test(attr) && next(elem);
				};
			}

			return function any(elem){
				var attr = adapter.getAttributeValue(elem, name);
				return attr != null && attr.indexOf(value) >= 0 && next(elem);
			};
		},
		not: function(next, data){
			var name  = data.name,
				value = data.value;

			if(value === ""){
				return function notEmpty(elem){
					return !!adapter.getAttributeValue(elem, name) && next(elem);
				};
			} else if(data.ignoreCase){
				value = value.toLowerCase();

				return function notIC(elem){
					var attr = adapter.getAttributeValue(elem, name);
					return attr != null && attr.toLowerCase() !== value && next(elem);
				};
			}

			return function not(elem){
				return adapter.getAttributeValue(elem, name) !== value && next(elem);
			};
		}
	};

	return {
		compile: function(next, data, options){
			if(options && options.strict && (
				data.ignoreCase || data.action === "not"
			)) throw new Error("Unsupported attribute selector");
			return attributeRules[data.action](next, data);
		},
		rules: attributeRules
	};
}

module.exports = factory;

},{"boolbase":63}],75:[function(require,module,exports){
/*
	compiles a selector to an executable function
*/

module.exports = compileFactory;

var parse          = require("css-what"),
	BaseFuncs      = require("boolbase"),
	sortRules      = require("./sort.js"),
	procedure      = require("./procedure.json"),
	rulesFactory   = require("./general.js"),
	pseudosFactory = require("./pseudos.js"),
	trueFunc       = BaseFuncs.trueFunc,
	falseFunc      = BaseFuncs.falseFunc;

function compileFactory(adapter){
	var Pseudos     = pseudosFactory(adapter),
		filters     = Pseudos.filters,
		Rules 			= rulesFactory(adapter, Pseudos);

	function compile(selector, options, context){
		var next = compileUnsafe(selector, options, context);
		return wrap(next);
	}

	function wrap(next){
		return function base(elem){
			return adapter.isTag(elem) && next(elem);
		};
	}

	function compileUnsafe(selector, options, context){
		var token = parse(selector, options);
		return compileToken(token, options, context);
	}

	function includesScopePseudo(t){
		return t.type === "pseudo" && (
			t.name === "scope" || (
				Array.isArray(t.data) &&
				t.data.some(function(data){
					return data.some(includesScopePseudo);
				})
			)
		);
	}

	var DESCENDANT_TOKEN = {type: "descendant"},
		FLEXIBLE_DESCENDANT_TOKEN = {type: "_flexibleDescendant"},
		SCOPE_TOKEN = {type: "pseudo", name: "scope"},
		PLACEHOLDER_ELEMENT = {};

	//CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector
	//http://www.w3.org/TR/selectors4/#absolutizing
	function absolutize(token, context){
		//TODO better check if context is document
		var hasContext = !!context && !!context.length && context.every(function(e){
			return e === PLACEHOLDER_ELEMENT || !!adapter.getParent(e);
		});


		token.forEach(function(t){
			if(t.length > 0 && isTraversal(t[0]) && t[0].type !== "descendant"){
				//don't return in else branch
			} else if(hasContext && !includesScopePseudo(t)){
				t.unshift(DESCENDANT_TOKEN);
			} else {
				return;
			}

			t.unshift(SCOPE_TOKEN);
		});
	}

	function compileToken(token, options, context){
		token = token.filter(function(t){ return t.length > 0; });

		token.forEach(sortRules);

		var isArrayContext = Array.isArray(context);

		context = (options && options.context) || context;

		if(context && !isArrayContext) context = [context];

		absolutize(token, context);

		var shouldTestNextSiblings = false;

		var query = token
			.map(function(rules){
				if(rules[0] && rules[1] && rules[0].name === "scope"){
					var ruleType = rules[1].type;
					if(isArrayContext && ruleType === "descendant") rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
					else if(ruleType === "adjacent" || ruleType === "sibling") shouldTestNextSiblings = true;
				}
				return compileRules(rules, options, context);
			})
			.reduce(reduceRules, falseFunc);

		query.shouldTestNextSiblings = shouldTestNextSiblings;

		return query;
	}

	function isTraversal(t){
		return procedure[t.type] < 0;
	}

	function compileRules(rules, options, context){
		return rules.reduce(function(func, rule){
			if(func === falseFunc) return func;
			return Rules[rule.type](func, rule, options, context);
		}, options && options.rootFunc || trueFunc);
	}

	function reduceRules(a, b){
		if(b === falseFunc || a === trueFunc){
			return a;
		}
		if(a === falseFunc || b === trueFunc){
			return b;
		}

		return function combine(elem){
			return a(elem) || b(elem);
		};
	}

	function containsTraversal(t){
		return t.some(isTraversal);
	}

	//:not, :has and :matches have to compile selectors
	//doing this in lib/pseudos.js would lead to circular dependencies,
	//so we add them here
	filters.not = function(next, token, options, context){
		var opts = {
			xmlMode: !!(options && options.xmlMode),
			strict: !!(options && options.strict)
		};

		if(opts.strict){
			if(token.length > 1 || token.some(containsTraversal)){
				throw new Error("complex selectors in :not aren't allowed in strict mode");
			}
		}

		var func = compileToken(token, opts, context);

		if(func === falseFunc) return next;
		if(func === trueFunc)  return falseFunc;

		return function(elem){
			return !func(elem) && next(elem);
		};
	};

	filters.has = function(next, token, options){
		var opts = {
			xmlMode: !!(options && options.xmlMode),
			strict: !!(options && options.strict)
		};

		//FIXME: Uses an array as a pointer to the current element (side effects)
		var context = token.some(containsTraversal) ? [PLACEHOLDER_ELEMENT] : null;

		var func = compileToken(token, opts, context);

		if(func === falseFunc) return falseFunc;
		if(func === trueFunc){
			return function(elem){
				return adapter.getChildren(elem).some(adapter.isTag) && next(elem);
			};
		}

		func = wrap(func);

		if(context){
			return function has(elem){
				return next(elem) && (
					(context[0] = elem), adapter.existsOne(func, adapter.getChildren(elem))
				);
			};
		}

		return function has(elem){
			return next(elem) && adapter.existsOne(func, adapter.getChildren(elem));
		};
	};

	filters.matches = function(next, token, options, context){
		var opts = {
			xmlMode: !!(options && options.xmlMode),
			strict: !!(options && options.strict),
			rootFunc: next
		};

		return compileToken(token, opts, context);
	};

	compile.compileToken = compileToken;
	compile.compileUnsafe = compileUnsafe;
	compile.Pseudos = Pseudos;

	return compile;
}

},{"./general.js":76,"./procedure.json":77,"./pseudos.js":78,"./sort.js":79,"boolbase":63,"css-what":80}],76:[function(require,module,exports){
var attributeFactory = require("./attributes.js");

function generalFactory(adapter, Pseudos){
	/*
		all available rules
	*/
	return {
		__proto__: null,

		attribute: attributeFactory(adapter).compile,
		pseudo: Pseudos.compile,

		//tags
		tag: function(next, data){
			var name = data.name;
			return function tag(elem){
				return adapter.getName(elem) === name && next(elem);
			};
		},

		//traversal
		descendant: function(next){
			return function descendant(elem){

				var found = false;

				while(!found && (elem = adapter.getParent(elem))){
					found = next(elem);
				}

				return found;
			};
		},
		_flexibleDescendant: function(next){
			// Include element itself, only used while querying an array
			return function descendant(elem){

				var found = next(elem);

				while(!found && (elem = adapter.getParent(elem))){
					found = next(elem);
				}

				return found;
			};
		},
		parent: function(next, data, options){
			if(options && options.strict) throw new Error("Parent selector isn't part of CSS3");

			return function parent(elem){
				return adapter.getChildren(elem).some(test);
			};

			function test(elem){
				return adapter.isTag(elem) && next(elem);
			}
		},
		child: function(next){
			return function child(elem){
				var parent = adapter.getParent(elem);
				return !!parent && next(parent);
			};
		},
		sibling: function(next){
			return function sibling(elem){
				var siblings = adapter.getSiblings(elem);

				for(var i = 0; i < siblings.length; i++){
					if(adapter.isTag(siblings[i])){
						if(siblings[i] === elem) break;
						if(next(siblings[i])) return true;
					}
				}

				return false;
			};
		},
		adjacent: function(next){
			return function adjacent(elem){
				var siblings = adapter.getSiblings(elem),
					lastElement;

				for(var i = 0; i < siblings.length; i++){
					if(adapter.isTag(siblings[i])){
						if(siblings[i] === elem) break;
						lastElement = siblings[i];
					}
				}

				return !!lastElement && next(lastElement);
			};
		},
		universal: function(next){
			return next;
		}
	};
}

module.exports = generalFactory;

},{"./attributes.js":74}],77:[function(require,module,exports){
module.exports={
  "universal": 50,
  "tag": 30,
  "attribute": 1,
  "pseudo": 0,
  "descendant": -1,
  "child": -1,
  "parent": -1,
  "sibling": -1,
  "adjacent": -1
}

},{}],78:[function(require,module,exports){
/*
	pseudo selectors

	---

	they are available in two forms:
	* filters called when the selector
	  is compiled and return a function
	  that needs to return next()
	* pseudos get called on execution
	  they need to return a boolean
*/

var getNCheck         = require("nth-check"),
	BaseFuncs         = require("boolbase"),
	attributesFactory = require("./attributes.js"),
	trueFunc          = BaseFuncs.trueFunc,
	falseFunc         = BaseFuncs.falseFunc;

function filtersFactory(adapter){
	var attributes  = attributesFactory(adapter),
		checkAttrib = attributes.rules.equals;

	//helper methods
	function equals(a, b){
		if(typeof adapter.equals === "function") return adapter.equals(a, b);

		return a === b;
	}

	function getAttribFunc(name, value){
		var data = {name: name, value: value};
		return function attribFunc(next){
			return checkAttrib(next, data);
		};
	}

	function getChildFunc(next){
		return function(elem){
			return !!adapter.getParent(elem) && next(elem);
		};
	}

	var filters = {
		contains: function(next, text){
			return function contains(elem){
				return next(elem) && adapter.getText(elem).indexOf(text) >= 0;
			};
		},
		icontains: function(next, text){
			var itext = text.toLowerCase();
			return function icontains(elem){
				return next(elem) &&
					adapter.getText(elem).toLowerCase().indexOf(itext) >= 0;
			};
		},

		//location specific methods
		"nth-child": function(next, rule){
			var func = getNCheck(rule);

			if(func === falseFunc) return func;
			if(func === trueFunc)  return getChildFunc(next);

			return function nthChild(elem){
				var siblings = adapter.getSiblings(elem);

				for(var i = 0, pos = 0; i < siblings.length; i++){
					if(adapter.isTag(siblings[i])){
						if(siblings[i] === elem) break;
						else pos++;
					}
				}

				return func(pos) && next(elem);
			};
		},
		"nth-last-child": function(next, rule){
			var func = getNCheck(rule);

			if(func === falseFunc) return func;
			if(func === trueFunc)  return getChildFunc(next);

			return function nthLastChild(elem){
				var siblings = adapter.getSiblings(elem);

				for(var pos = 0, i = siblings.length - 1; i >= 0; i--){
					if(adapter.isTag(siblings[i])){
						if(siblings[i] === elem) break;
						else pos++;
					}
				}

				return func(pos) && next(elem);
			};
		},
		"nth-of-type": function(next, rule){
			var func = getNCheck(rule);

			if(func === falseFunc) return func;
			if(func === trueFunc)  return getChildFunc(next);

			return function nthOfType(elem){
				var siblings = adapter.getSiblings(elem);

				for(var pos = 0, i = 0; i < siblings.length; i++){
					if(adapter.isTag(siblings[i])){
						if(siblings[i] === elem) break;
						if(adapter.getName(siblings[i]) === adapter.getName(elem)) pos++;
					}
				}

				return func(pos) && next(elem);
			};
		},
		"nth-last-of-type": function(next, rule){
			var func = getNCheck(rule);

			if(func === falseFunc) return func;
			if(func === trueFunc)  return getChildFunc(next);

			return function nthLastOfType(elem){
				var siblings = adapter.getSiblings(elem);

				for(var pos = 0, i = siblings.length - 1; i >= 0; i--){
					if(adapter.isTag(siblings[i])){
						if(siblings[i] === elem) break;
						if(adapter.getName(siblings[i]) === adapter.getName(elem)) pos++;
					}
				}

				return func(pos) && next(elem);
			};
		},

		//TODO determine the actual root element
		root: function(next){
			return function(elem){
				return !adapter.getParent(elem) && next(elem);
			};
		},

		scope: function(next, rule, options, context){
			if(!context || context.length === 0){
				//equivalent to :root
				return filters.root(next);
			}

			if(context.length === 1){
				//NOTE: can't be unpacked, as :has uses this for side-effects
				return function(elem){
					return equals(context[0], elem) && next(elem);
				};
			}

			return function(elem){
				return context.indexOf(elem) >= 0 && next(elem);
			};
		},

		//jQuery extensions (others follow as pseudos)
		checkbox: getAttribFunc("type", "checkbox"),
		file: getAttribFunc("type", "file"),
		password: getAttribFunc("type", "password"),
		radio: getAttribFunc("type", "radio"),
		reset: getAttribFunc("type", "reset"),
		image: getAttribFunc("type", "image"),
		submit: getAttribFunc("type", "submit")
	};
	return filters;
}

function pseudosFactory(adapter){
	//helper methods
	function getFirstElement(elems){
		for(var i = 0; elems && i < elems.length; i++){
			if(adapter.isTag(elems[i])) return elems[i];
		}
	}

	//while filters are precompiled, pseudos get called when they are needed
	var pseudos = {
		empty: function(elem){
			return !adapter.getChildren(elem).some(function(elem){
				return adapter.isTag(elem) || elem.type === "text";
			});
		},

		"first-child": function(elem){
			return getFirstElement(adapter.getSiblings(elem)) === elem;
		},
		"last-child": function(elem){
			var siblings = adapter.getSiblings(elem);

			for(var i = siblings.length - 1; i >= 0; i--){
				if(siblings[i] === elem) return true;
				if(adapter.isTag(siblings[i])) break;
			}

			return false;
		},
		"first-of-type": function(elem){
			var siblings = adapter.getSiblings(elem);

			for(var i = 0; i < siblings.length; i++){
				if(adapter.isTag(siblings[i])){
					if(siblings[i] === elem) return true;
					if(adapter.getName(siblings[i]) === adapter.getName(elem)) break;
				}
			}

			return false;
		},
		"last-of-type": function(elem){
			var siblings = adapter.getSiblings(elem);

			for(var i = siblings.length - 1; i >= 0; i--){
				if(adapter.isTag(siblings[i])){
					if(siblings[i] === elem) return true;
					if(adapter.getName(siblings[i]) === adapter.getName(elem)) break;
				}
			}

			return false;
		},
		"only-of-type": function(elem){
			var siblings = adapter.getSiblings(elem);

			for(var i = 0, j = siblings.length; i < j; i++){
				if(adapter.isTag(siblings[i])){
					if(siblings[i] === elem) continue;
					if(adapter.getName(siblings[i]) === adapter.getName(elem)) return false;
				}
			}

			return true;
		},
		"only-child": function(elem){
			var siblings = adapter.getSiblings(elem);

			for(var i = 0; i < siblings.length; i++){
				if(adapter.isTag(siblings[i]) && siblings[i] !== elem) return false;
			}

			return true;
		},

		//:matches(a, area, link)[href]
		link: function(elem){
			return adapter.hasAttrib(elem, "href");
		},
		visited: falseFunc, //seems to be a valid implementation
		//TODO: :any-link once the name is finalized (as an alias of :link)

		//forms
		//to consider: :target

		//:matches([selected], select:not([multiple]):not(> option[selected]) > option:first-of-type)
		selected: function(elem){
			if(adapter.hasAttrib(elem, "selected")) return true;
			else if(adapter.getName(elem) !== "option") return false;

			//the first <option> in a <select> is also selected
			var parent = adapter.getParent(elem);

			if(
				!parent ||
				adapter.getName(parent) !== "select" ||
				adapter.hasAttrib(parent, "multiple")
			) return false;

			var siblings = adapter.getChildren(parent),
				sawElem  = false;

			for(var i = 0; i < siblings.length; i++){
				if(adapter.isTag(siblings[i])){
					if(siblings[i] === elem){
						sawElem = true;
					} else if(!sawElem){
						return false;
					} else if(adapter.hasAttrib(siblings[i], "selected")){
						return false;
					}
				}
			}

			return sawElem;
		},
		//https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
		//:matches(
		//  :matches(button, input, select, textarea, menuitem, optgroup, option)[disabled],
		//  optgroup[disabled] > option),
		// fieldset[disabled] * //TODO not child of first <legend>
		//)
		disabled: function(elem){
			return adapter.hasAttrib(elem, "disabled");
		},
		enabled: function(elem){
			return !adapter.hasAttrib(elem, "disabled");
		},
		//:matches(:matches(:radio, :checkbox)[checked], :selected) (TODO menuitem)
		checked: function(elem){
			return adapter.hasAttrib(elem, "checked") || pseudos.selected(elem);
		},
		//:matches(input, select, textarea)[required]
		required: function(elem){
			return adapter.hasAttrib(elem, "required");
		},
		//:matches(input, select, textarea):not([required])
		optional: function(elem){
			return !adapter.hasAttrib(elem, "required");
		},

		//jQuery extensions

		//:not(:empty)
		parent: function(elem){
			return !pseudos.empty(elem);
		},
		//:matches(h1, h2, h3, h4, h5, h6)
		header: function(elem){
			var name = adapter.getName(elem);
			return name === "h1" ||
					name === "h2" ||
					name === "h3" ||
					name === "h4" ||
					name === "h5" ||
					name === "h6";
		},

		//:matches(button, input[type=button])
		button: function(elem){
			var name = adapter.getName(elem);
			return name === "button" ||
					name === "input" &&
					adapter.getAttributeValue(elem, "type") === "button";
		},
		//:matches(input, textarea, select, button)
		input: function(elem){
			var name = adapter.getName(elem);
			return name === "input" ||
					name === "textarea" ||
					name === "select" ||
					name === "button";
		},
		//input:matches(:not([type!='']), [type='text' i])
		text: function(elem){
			var attr;
			return adapter.getName(elem) === "input" && (
				!(attr = adapter.getAttributeValue(elem, "type")) ||
				attr.toLowerCase() === "text"
			);
		}
	};

	return pseudos;
}

function verifyArgs(func, name, subselect){
	if(subselect === null){
		if(func.length > 1 && name !== "scope"){
			throw new Error("pseudo-selector :" + name + " requires an argument");
		}
	} else {
		if(func.length === 1){
			throw new Error("pseudo-selector :" + name + " doesn't have any arguments");
		}
	}
}

//FIXME this feels hacky
var re_CSS3 = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;

function factory(adapter){
	var pseudos = pseudosFactory(adapter);
	var filters = filtersFactory(adapter);

	return {
		compile: function(next, data, options, context){
			var name = data.name,
				subselect = data.data;

			if(options && options.strict && !re_CSS3.test(name)){
				throw new Error(":" + name + " isn't part of CSS3");
			}

			if(typeof filters[name] === "function"){
				verifyArgs(filters[name], name,  subselect);
				return filters[name](next, subselect, options, context);
			} else if(typeof pseudos[name] === "function"){
				var func = pseudos[name];
				verifyArgs(func, name, subselect);

				if(next === trueFunc) return func;

				return function pseudoArgs(elem){
					return func(elem, subselect) && next(elem);
				};
			} else {
				throw new Error("unmatched pseudo-class :" + name);
			}
		},
		filters: filters,
		pseudos: pseudos
	};
}

module.exports = factory;

},{"./attributes.js":74,"boolbase":63,"nth-check":176}],79:[function(require,module,exports){
module.exports = sortByProcedure;

/*
	sort the parts of the passed selector,
	as there is potential for optimization
	(some types of selectors are faster than others)
*/

var procedure = require("./procedure.json");

var attributes = {
	__proto__: null,
	exists: 10,
	equals: 8,
	not: 7,
	start: 6,
	end: 6,
	any: 5,
	hyphen: 4,
	element: 4
};

function sortByProcedure(arr){
	var procs = arr.map(getProcedure);
	for(var i = 1; i < arr.length; i++){
		var procNew = procs[i];

		if(procNew < 0) continue;

		for(var j = i - 1; j >= 0 && procNew < procs[j]; j--){
			var token = arr[j + 1];
			arr[j + 1] = arr[j];
			arr[j] = token;
			procs[j + 1] = procs[j];
			procs[j] = procNew;
		}
	}
}

function getProcedure(token){
	var proc = procedure[token.type];

	if(proc === procedure.attribute){
		proc = attributes[token.action];

		if(proc === attributes.equals && token.name === "id"){
			//prefer ID selectors (eg. #ID)
			proc = 9;
		}

		if(token.ignoreCase){
			//ignoreCase adds some overhead, prefer "normal" token
			//this is a binary operation, to ensure it's still an int
			proc >>= 1;
		}
	} else if(proc === procedure.pseudo){
		if(!token.data){
			proc = 3;
		} else if(token.name === "has" || token.name === "contains"){
			proc = 0; //expensive in any case
		} else if(token.name === "matches" || token.name === "not"){
			proc = 0;
			for(var i = 0; i < token.data.length; i++){
				//TODO better handling of complex selectors
				if(token.data[i].length !== 1) continue;
				var cur = getProcedure(token.data[i][0]);
				//avoid executing :has or :contains
				if(cur === 0){
					proc = 0;
					break;
				}
				if(cur > proc) proc = cur;
			}
			if(token.data.length > 1 && proc > 0) proc -= 1;
		} else {
			proc = 1;
		}
	}
	return proc;
}

},{"./procedure.json":77}],80:[function(require,module,exports){
"use strict";

module.exports = parse;

var re_name = /^(?:\\.|[\w\-\u00c0-\uFFFF])+/,
    re_escape = /\\([\da-f]{1,6}\s?|(\s)|.)/ig,
    //modified version of https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L87
    re_attr = /^\s*((?:\\.|[\w\u00c0-\uFFFF\-])+)\s*(?:(\S?)=\s*(?:(['"])(.*?)\3|(#?(?:\\.|[\w\u00c0-\uFFFF\-])*)|)|)\s*(i)?\]/;

var actionTypes = {
	__proto__: null,
	"undefined": "exists",
	"":  "equals",
	"~": "element",
	"^": "start",
	"$": "end",
	"*": "any",
	"!": "not",
	"|": "hyphen"
};

var simpleSelectors = {
	__proto__: null,
	">": "child",
	"<": "parent",
	"~": "sibling",
	"+": "adjacent"
};

var attribSelectors = {
	__proto__: null,
	"#": ["id", "equals"],
	".": ["class", "element"]
};

//pseudos, whose data-property is parsed as well
var unpackPseudos = {
	__proto__: null,
	"has": true,
	"not": true,
	"matches": true
};

var stripQuotesFromPseudos = {
	__proto__: null,
	"contains": true,
	"icontains": true
};

var quotes = {
	__proto__: null,
	"\"": true,
	"'": true
};

//unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L139
function funescape( _, escaped, escapedWhitespace ) {
	var high = "0x" + escaped - 0x10000;
	// NaN means non-codepoint
	// Support: Firefox
	// Workaround erroneous numeric interpretation of +"0x"
	return high !== high || escapedWhitespace ?
		escaped :
		// BMP codepoint
		high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			// Supplemental Plane codepoint (surrogate pair)
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
}

function unescapeCSS(str){
	return str.replace(re_escape, funescape);
}

function isWhitespace(c){
	return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}

function parse(selector, options){
	var subselects = [];

	selector = parseSelector(subselects, selector + "", options);

	if(selector !== ""){
		throw new SyntaxError("Unmatched selector: " + selector);
	}

	return subselects;
}

function parseSelector(subselects, selector, options){
	var tokens = [],
		sawWS = false,
		data, firstChar, name, quot;

	function getName(){
		var sub = selector.match(re_name)[0];
		selector = selector.substr(sub.length);
		return unescapeCSS(sub);
	}

	function stripWhitespace(start){
		while(isWhitespace(selector.charAt(start))) start++;
		selector = selector.substr(start);
	}

	stripWhitespace(0);

	while(selector !== ""){
		firstChar = selector.charAt(0);

		if(isWhitespace(firstChar)){
			sawWS = true;
			stripWhitespace(1);
		} else if(firstChar in simpleSelectors){
			tokens.push({type: simpleSelectors[firstChar]});
			sawWS = false;

			stripWhitespace(1);
		} else if(firstChar === ","){
			if(tokens.length === 0){
				throw new SyntaxError("empty sub-selector");
			}
			subselects.push(tokens);
			tokens = [];
			sawWS = false;
			stripWhitespace(1);
		} else {
			if(sawWS){
				if(tokens.length > 0){
					tokens.push({type: "descendant"});
				}
				sawWS = false;
			}

			if(firstChar === "*"){
				selector = selector.substr(1);
				tokens.push({type: "universal"});
			} else if(firstChar in attribSelectors){
				selector = selector.substr(1);
				tokens.push({
					type: "attribute",
					name: attribSelectors[firstChar][0],
					action: attribSelectors[firstChar][1],
					value: getName(),
					ignoreCase: false
				});
			} else if(firstChar === "["){
				selector = selector.substr(1);
				data = selector.match(re_attr);
				if(!data){
					throw new SyntaxError("Malformed attribute selector: " + selector);
				}
				selector = selector.substr(data[0].length);
				name = unescapeCSS(data[1]);

				if(
					!options || (
						"lowerCaseAttributeNames" in options ?
							options.lowerCaseAttributeNames :
							!options.xmlMode
					)
				){
					name = name.toLowerCase();
				}

				tokens.push({
					type: "attribute",
					name: name,
					action: actionTypes[data[2]],
					value: unescapeCSS(data[4] || data[5] || ""),
					ignoreCase: !!data[6]
				});

			} else if(firstChar === ":"){
				if(selector.charAt(1) === ":"){
					selector = selector.substr(2);
					tokens.push({type: "pseudo-element", name: getName().toLowerCase()});
					continue;
				}

				selector = selector.substr(1);

				name = getName().toLowerCase();
				data = null;

				if(selector.charAt(0) === "("){
					if(name in unpackPseudos){
						quot = selector.charAt(1);
						var quoted = quot in quotes;

						selector = selector.substr(quoted + 1);

						data = [];
						selector = parseSelector(data, selector, options);

						if(quoted){
							if(selector.charAt(0) !== quot){
								throw new SyntaxError("unmatched quotes in :" + name);
							} else {
								selector = selector.substr(1);
							}
						}

						if(selector.charAt(0) !== ")"){
							throw new SyntaxError("missing closing parenthesis in :" + name + " " + selector);
						}

						selector = selector.substr(1);
					} else {
						var pos = 1, counter = 1;

						for(; counter > 0 && pos < selector.length; pos++){
							if(selector.charAt(pos) === "(") counter++;
							else if(selector.charAt(pos) === ")") counter--;
						}

						if(counter){
							throw new SyntaxError("parenthesis not matched");
						}

						data = selector.substr(1, pos - 2);
						selector = selector.substr(pos);

						if(name in stripQuotesFromPseudos){
							quot = data.charAt(0);

							if(quot === data.slice(-1) && quot in quotes){
								data = data.slice(1, -1);
							}

							data = unescapeCSS(data);
						}
					}
				}

				tokens.push({type: "pseudo", name: name, data: data});
			} else if(re_name.test(selector)){
				name = getName();

				if(!options || ("lowerCaseTags" in options ? options.lowerCaseTags : !options.xmlMode)){
					name = name.toLowerCase();
				}

				tokens.push({type: "tag", name: name});
			} else {
				if(tokens.length && tokens[tokens.length - 1].type === "descendant"){
					tokens.pop();
				}
				addToken(subselects, tokens);
				return selector;
			}
		}
	}

	addToken(subselects, tokens);

	return selector;
}

function addToken(subselects, tokens){
	if(subselects.length > 0 && tokens.length === 0){
		throw new SyntaxError("empty sub-selector");
	}

	subselects.push(tokens);
}

},{}],81:[function(require,module,exports){
(function (global){

var NativeCustomEvent = global.CustomEvent;

function useNative () {
  try {
    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });
    return  'cat' === p.type && 'bar' === p.detail.foo;
  } catch (e) {
  }
  return false;
}

/**
 * Cross-browser `CustomEvent` constructor.
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
 *
 * @public
 */

module.exports = useNative() ? NativeCustomEvent :

// IE >= 9
'function' === typeof document.createEvent ? function CustomEvent (type, params) {
  var e = document.createEvent('CustomEvent');
  if (params) {
    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
  } else {
    e.initCustomEvent(type, false, false, void 0);
  }
  return e;
} :

// IE <= 8
function CustomEvent (type, params) {
  var e = document.createEventObject();
  e.type = type;
  if (params) {
    e.bubbles = Boolean(params.bubbles);
    e.cancelable = Boolean(params.cancelable);
    e.detail = params.detail;
  } else {
    e.bubbles = false;
    e.cancelable = false;
    e.detail = void 0;
  }
  return e;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],82:[function(require,module,exports){
/*
  Module dependencies
*/
var ElementType = require('domelementtype');
var entities = require('entities');

/*
  Boolean Attributes
*/
var booleanAttributes = {
  __proto__: null,
  allowfullscreen: true,
  async: true,
  autofocus: true,
  autoplay: true,
  checked: true,
  controls: true,
  default: true,
  defer: true,
  disabled: true,
  hidden: true,
  ismap: true,
  loop: true,
  multiple: true,
  muted: true,
  open: true,
  readonly: true,
  required: true,
  reversed: true,
  scoped: true,
  seamless: true,
  selected: true,
  typemustmatch: true
};

var unencodedElements = {
  __proto__: null,
  style: true,
  script: true,
  xmp: true,
  iframe: true,
  noembed: true,
  noframes: true,
  plaintext: true,
  noscript: true
};

/*
  Format attributes
*/
function formatAttrs(attributes, opts) {
  if (!attributes) return;

  var output = '',
      value;

  // Loop through the attributes
  for (var key in attributes) {
    value = attributes[key];
    if (output) {
      output += ' ';
    }

    if (!value && booleanAttributes[key]) {
      output += key;
    } else {
      output += key + '="' + (opts.decodeEntities ? entities.encodeXML(value) : value) + '"';
    }
  }

  return output;
}

/*
  Self-enclosing tags (stolen from node-htmlparser)
*/
var singleTag = {
  __proto__: null,
  area: true,
  base: true,
  basefont: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  isindex: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true,
};


var render = module.exports = function(dom, opts) {
  if (!Array.isArray(dom) && !dom.cheerio) dom = [dom];
  opts = opts || {};

  var output = '';

  for(var i = 0; i < dom.length; i++){
    var elem = dom[i];

    if (elem.type === 'root')
      output += render(elem.children, opts);
    else if (ElementType.isTag(elem))
      output += renderTag(elem, opts);
    else if (elem.type === ElementType.Directive)
      output += renderDirective(elem);
    else if (elem.type === ElementType.Comment)
      output += renderComment(elem);
    else if (elem.type === ElementType.CDATA)
      output += renderCdata(elem);
    else
      output += renderText(elem, opts);
  }

  return output;
};

function renderTag(elem, opts) {
  // Handle SVG
  if (elem.name === "svg") opts = {decodeEntities: opts.decodeEntities, xmlMode: true};

  var tag = '<' + elem.name,
      attribs = formatAttrs(elem.attribs, opts);

  if (attribs) {
    tag += ' ' + attribs;
  }

  if (
    opts.xmlMode
    && (!elem.children || elem.children.length === 0)
  ) {
    tag += '/>';
  } else {
    tag += '>';
    if (elem.children) {
      tag += render(elem.children, opts);
    }

    if (!singleTag[elem.name] || opts.xmlMode) {
      tag += '</' + elem.name + '>';
    }
  }

  return tag;
}

function renderDirective(elem) {
  return '<' + elem.data + '>';
}

function renderText(elem, opts) {
  var data = elem.data || '';

  // if entities weren't decoded, no need to encode them back
  if (opts.decodeEntities && !(elem.parent && elem.parent.name in unencodedElements)) {
    data = entities.encodeXML(data);
  }

  return data;
}

function renderCdata(elem) {
  return '<![CDATA[' + elem.children[0].data + ']]>';
}

function renderComment(elem) {
  return '<!--' + elem.data + '-->';
}

},{"domelementtype":83,"entities":97}],83:[function(require,module,exports){
//Types of elements found in the DOM
module.exports = {
	Text: "text", //Text
	Directive: "directive", //<? ... ?>
	Comment: "comment", //<!-- ... -->
	Script: "script", //<script> tags
	Style: "style", //<style> tags
	Tag: "tag", //Any tag
	CDATA: "cdata", //<![CDATA[ ... ]]>

	isTag: function(elem){
		return elem.type === "tag" || elem.type === "script" || elem.type === "style";
	}
};
},{}],84:[function(require,module,exports){
//Types of elements found in the DOM
module.exports = {
	Text: "text", //Text
	Directive: "directive", //<? ... ?>
	Comment: "comment", //<!-- ... -->
	Script: "script", //<script> tags
	Style: "style", //<style> tags
	Tag: "tag", //Any tag
	CDATA: "cdata", //<![CDATA[ ... ]]>
	Doctype: "doctype",

	isTag: function(elem){
		return elem.type === "tag" || elem.type === "script" || elem.type === "style";
	}
};

},{}],85:[function(require,module,exports){
var ElementType = require("domelementtype");

var re_whitespace = /\s+/g;
var NodePrototype = require("./lib/node");
var ElementPrototype = require("./lib/element");

function DomHandler(callback, options, elementCB){
	if(typeof callback === "object"){
		elementCB = options;
		options = callback;
		callback = null;
	} else if(typeof options === "function"){
		elementCB = options;
		options = defaultOpts;
	}
	this._callback = callback;
	this._options = options || defaultOpts;
	this._elementCB = elementCB;
	this.dom = [];
	this._done = false;
	this._tagStack = [];
	this._parser = this._parser || null;
}

//default options
var defaultOpts = {
	normalizeWhitespace: false, //Replace all whitespace with single spaces
	withStartIndices: false, //Add startIndex properties to nodes
};

DomHandler.prototype.onparserinit = function(parser){
	this._parser = parser;
};

//Resets the handler back to starting state
DomHandler.prototype.onreset = function(){
	DomHandler.call(this, this._callback, this._options, this._elementCB);
};

//Signals the handler that parsing is done
DomHandler.prototype.onend = function(){
	if(this._done) return;
	this._done = true;
	this._parser = null;
	this._handleCallback(null);
};

DomHandler.prototype._handleCallback =
DomHandler.prototype.onerror = function(error){
	if(typeof this._callback === "function"){
		this._callback(error, this.dom);
	} else {
		if(error) throw error;
	}
};

DomHandler.prototype.onclosetag = function(){
	//if(this._tagStack.pop().name !== name) this._handleCallback(Error("Tagname didn't match!"));
	var elem = this._tagStack.pop();
	if(this._elementCB) this._elementCB(elem);
};

DomHandler.prototype._addDomElement = function(element){
	var parent = this._tagStack[this._tagStack.length - 1];
	var siblings = parent ? parent.children : this.dom;
	var previousSibling = siblings[siblings.length - 1];

	element.next = null;

	if(this._options.withStartIndices){
		element.startIndex = this._parser.startIndex;
	}

	if (this._options.withDomLvl1) {
		element.__proto__ = element.type === "tag" ? ElementPrototype : NodePrototype;
	}

	if(previousSibling){
		element.prev = previousSibling;
		previousSibling.next = element;
	} else {
		element.prev = null;
	}

	siblings.push(element);
	element.parent = parent || null;
};

DomHandler.prototype.onopentag = function(name, attribs){
	var element = {
		type: name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag,
		name: name,
		attribs: attribs,
		children: []
	};

	this._addDomElement(element);

	this._tagStack.push(element);
};

DomHandler.prototype.ontext = function(data){
	//the ignoreWhitespace is officially dropped, but for now,
	//it's an alias for normalizeWhitespace
	var normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace;

	var lastTag;

	if(!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length-1]).type === ElementType.Text){
		if(normalize){
			lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
		} else {
			lastTag.data += data;
		}
	} else {
		if(
			this._tagStack.length &&
			(lastTag = this._tagStack[this._tagStack.length - 1]) &&
			(lastTag = lastTag.children[lastTag.children.length - 1]) &&
			lastTag.type === ElementType.Text
		){
			if(normalize){
				lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
			} else {
				lastTag.data += data;
			}
		} else {
			if(normalize){
				data = data.replace(re_whitespace, " ");
			}

			this._addDomElement({
				data: data,
				type: ElementType.Text
			});
		}
	}
};

DomHandler.prototype.oncomment = function(data){
	var lastTag = this._tagStack[this._tagStack.length - 1];

	if(lastTag && lastTag.type === ElementType.Comment){
		lastTag.data += data;
		return;
	}

	var element = {
		data: data,
		type: ElementType.Comment
	};

	this._addDomElement(element);
	this._tagStack.push(element);
};

DomHandler.prototype.oncdatastart = function(){
	var element = {
		children: [{
			data: "",
			type: ElementType.Text
		}],
		type: ElementType.CDATA
	};

	this._addDomElement(element);
	this._tagStack.push(element);
};

DomHandler.prototype.oncommentend = DomHandler.prototype.oncdataend = function(){
	this._tagStack.pop();
};

DomHandler.prototype.onprocessinginstruction = function(name, data){
	this._addDomElement({
		name: name,
		data: data,
		type: ElementType.Directive
	});
};

module.exports = DomHandler;

},{"./lib/element":86,"./lib/node":87,"domelementtype":84}],86:[function(require,module,exports){
// DOM-Level-1-compliant structure
var NodePrototype = require('./node');
var ElementPrototype = module.exports = Object.create(NodePrototype);

var domLvl1 = {
	tagName: "name"
};

Object.keys(domLvl1).forEach(function(key) {
	var shorthand = domLvl1[key];
	Object.defineProperty(ElementPrototype, key, {
		get: function() {
			return this[shorthand] || null;
		},
		set: function(val) {
			this[shorthand] = val;
			return val;
		}
	});
});

},{"./node":87}],87:[function(require,module,exports){
// This object will be used as the prototype for Nodes when creating a
// DOM-Level-1-compliant structure.
var NodePrototype = module.exports = {
	get firstChild() {
		var children = this.children;
		return children && children[0] || null;
	},
	get lastChild() {
		var children = this.children;
		return children && children[children.length - 1] || null;
	},
	get nodeType() {
		return nodeTypes[this.type] || nodeTypes.element;
	}
};

var domLvl1 = {
	tagName: "name",
	childNodes: "children",
	parentNode: "parent",
	previousSibling: "prev",
	nextSibling: "next",
	nodeValue: "data"
};

var nodeTypes = {
	element: 1,
	text: 3,
	cdata: 4,
	comment: 8
};

Object.keys(domLvl1).forEach(function(key) {
	var shorthand = domLvl1[key];
	Object.defineProperty(NodePrototype, key, {
		get: function() {
			return this[shorthand] || null;
		},
		set: function(val) {
			this[shorthand] = val;
			return val;
		}
	});
});

},{}],88:[function(require,module,exports){
var DomUtils = module.exports;

[
	require("./lib/stringify"),
	require("./lib/traversal"),
	require("./lib/manipulation"),
	require("./lib/querying"),
	require("./lib/legacy"),
	require("./lib/helpers")
].forEach(function(ext){
	Object.keys(ext).forEach(function(key){
		DomUtils[key] = ext[key].bind(DomUtils);
	});
});

},{"./lib/helpers":89,"./lib/legacy":90,"./lib/manipulation":91,"./lib/querying":92,"./lib/stringify":93,"./lib/traversal":94}],89:[function(require,module,exports){
// removeSubsets
// Given an array of nodes, remove any member that is contained by another.
exports.removeSubsets = function(nodes) {
	var idx = nodes.length, node, ancestor, replace;

	// Check if each node (or one of its ancestors) is already contained in the
	// array.
	while (--idx > -1) {
		node = ancestor = nodes[idx];

		// Temporarily remove the node under consideration
		nodes[idx] = null;
		replace = true;

		while (ancestor) {
			if (nodes.indexOf(ancestor) > -1) {
				replace = false;
				nodes.splice(idx, 1);
				break;
			}
			ancestor = ancestor.parent;
		}

		// If the node has been found to be unique, re-insert it.
		if (replace) {
			nodes[idx] = node;
		}
	}

	return nodes;
};

// Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition
var POSITION = {
	DISCONNECTED: 1,
	PRECEDING: 2,
	FOLLOWING: 4,
	CONTAINS: 8,
	CONTAINED_BY: 16
};

// Compare the position of one node against another node in any other document.
// The return value is a bitmask with the following values:
//
// document order:
// > There is an ordering, document order, defined on all the nodes in the
// > document corresponding to the order in which the first character of the
// > XML representation of each node occurs in the XML representation of the
// > document after expansion of general entities. Thus, the document element
// > node will be the first node. Element nodes occur before their children.
// > Thus, document order orders element nodes in order of the occurrence of
// > their start-tag in the XML (after expansion of entities). The attribute
// > nodes of an element occur after the element and before its children. The
// > relative order of attribute nodes is implementation-dependent./
// Source:
// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
//
// @argument {Node} nodaA The first node to use in the comparison
// @argument {Node} nodeB The second node to use in the comparison
//
// @return {Number} A bitmask describing the input nodes' relative position.
//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
//         a description of these values.
var comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {
	var aParents = [];
	var bParents = [];
	var current, sharedParent, siblings, aSibling, bSibling, idx;

	if (nodeA === nodeB) {
		return 0;
	}

	current = nodeA;
	while (current) {
		aParents.unshift(current);
		current = current.parent;
	}
	current = nodeB;
	while (current) {
		bParents.unshift(current);
		current = current.parent;
	}

	idx = 0;
	while (aParents[idx] === bParents[idx]) {
		idx++;
	}

	if (idx === 0) {
		return POSITION.DISCONNECTED;
	}

	sharedParent = aParents[idx - 1];
	siblings = sharedParent.children;
	aSibling = aParents[idx];
	bSibling = bParents[idx];

	if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
		if (sharedParent === nodeB) {
			return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
		}
		return POSITION.FOLLOWING;
	} else {
		if (sharedParent === nodeA) {
			return POSITION.PRECEDING | POSITION.CONTAINS;
		}
		return POSITION.PRECEDING;
	}
};

// Sort an array of nodes based on their relative position in the document and
// remove any duplicate nodes. If the array contains nodes that do not belong
// to the same document, sort order is unspecified.
//
// @argument {Array} nodes Array of DOM nodes
//
// @returns {Array} collection of unique nodes, sorted in document order
exports.uniqueSort = function(nodes) {
	var idx = nodes.length, node, position;

	nodes = nodes.slice();

	while (--idx > -1) {
		node = nodes[idx];
		position = nodes.indexOf(node);
		if (position > -1 && position < idx) {
			nodes.splice(idx, 1);
		}
	}
	nodes.sort(function(a, b) {
		var relative = comparePos(a, b);
		if (relative & POSITION.PRECEDING) {
			return -1;
		} else if (relative & POSITION.FOLLOWING) {
			return 1;
		}
		return 0;
	});

	return nodes;
};

},{}],90:[function(require,module,exports){
var ElementType = require("domelementtype");
var isTag = exports.isTag = ElementType.isTag;

exports.testElement = function(options, element){
	for(var key in options){
		if(!options.hasOwnProperty(key));
		else if(key === "tag_name"){
			if(!isTag(element) || !options.tag_name(element.name)){
				return false;
			}
		} else if(key === "tag_type"){
			if(!options.tag_type(element.type)) return false;
		} else if(key === "tag_contains"){
			if(isTag(element) || !options.tag_contains(element.data)){
				return false;
			}
		} else if(!element.attribs || !options[key](element.attribs[key])){
			return false;
		}
	}
	return true;
};

var Checks = {
	tag_name: function(name){
		if(typeof name === "function"){
			return function(elem){ return isTag(elem) && name(elem.name); };
		} else if(name === "*"){
			return isTag;
		} else {
			return function(elem){ return isTag(elem) && elem.name === name; };
		}
	},
	tag_type: function(type){
		if(typeof type === "function"){
			return function(elem){ return type(elem.type); };
		} else {
			return function(elem){ return elem.type === type; };
		}
	},
	tag_contains: function(data){
		if(typeof data === "function"){
			return function(elem){ return !isTag(elem) && data(elem.data); };
		} else {
			return function(elem){ return !isTag(elem) && elem.data === data; };
		}
	}
};

function getAttribCheck(attrib, value){
	if(typeof value === "function"){
		return function(elem){ return elem.attribs && value(elem.attribs[attrib]); };
	} else {
		return function(elem){ return elem.attribs && elem.attribs[attrib] === value; };
	}
}

function combineFuncs(a, b){
	return function(elem){
		return a(elem) || b(elem);
	};
}

exports.getElements = function(options, element, recurse, limit){
	var funcs = Object.keys(options).map(function(key){
		var value = options[key];
		return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
	});

	return funcs.length === 0 ? [] : this.filter(
		funcs.reduce(combineFuncs),
		element, recurse, limit
	);
};

exports.getElementById = function(id, element, recurse){
	if(!Array.isArray(element)) element = [element];
	return this.findOne(getAttribCheck("id", id), element, recurse !== false);
};

exports.getElementsByTagName = function(name, element, recurse, limit){
	return this.filter(Checks.tag_name(name), element, recurse, limit);
};

exports.getElementsByTagType = function(type, element, recurse, limit){
	return this.filter(Checks.tag_type(type), element, recurse, limit);
};

},{"domelementtype":84}],91:[function(require,module,exports){
exports.removeElement = function(elem){
	if(elem.prev) elem.prev.next = elem.next;
	if(elem.next) elem.next.prev = elem.prev;

	if(elem.parent){
		var childs = elem.parent.children;
		childs.splice(childs.lastIndexOf(elem), 1);
	}
};

exports.replaceElement = function(elem, replacement){
	var prev = replacement.prev = elem.prev;
	if(prev){
		prev.next = replacement;
	}

	var next = replacement.next = elem.next;
	if(next){
		next.prev = replacement;
	}

	var parent = replacement.parent = elem.parent;
	if(parent){
		var childs = parent.children;
		childs[childs.lastIndexOf(elem)] = replacement;
	}
};

exports.appendChild = function(elem, child){
	child.parent = elem;

	if(elem.children.push(child) !== 1){
		var sibling = elem.children[elem.children.length - 2];
		sibling.next = child;
		child.prev = sibling;
		child.next = null;
	}
};

exports.append = function(elem, next){
	var parent = elem.parent,
		currNext = elem.next;

	next.next = currNext;
	next.prev = elem;
	elem.next = next;
	next.parent = parent;

	if(currNext){
		currNext.prev = next;
		if(parent){
			var childs = parent.children;
			childs.splice(childs.lastIndexOf(currNext), 0, next);
		}
	} else if(parent){
		parent.children.push(next);
	}
};

exports.prepend = function(elem, prev){
	var parent = elem.parent;
	if(parent){
		var childs = parent.children;
		childs.splice(childs.lastIndexOf(elem), 0, prev);
	}

	if(elem.prev){
		elem.prev.next = prev;
	}
	
	prev.parent = parent;
	prev.prev = elem.prev;
	prev.next = elem;
	elem.prev = prev;
};



},{}],92:[function(require,module,exports){
var isTag = require("domelementtype").isTag;

module.exports = {
	filter: filter,
	find: find,
	findOneChild: findOneChild,
	findOne: findOne,
	existsOne: existsOne,
	findAll: findAll
};

function filter(test, element, recurse, limit){
	if(!Array.isArray(element)) element = [element];

	if(typeof limit !== "number" || !isFinite(limit)){
		limit = Infinity;
	}
	return find(test, element, recurse !== false, limit);
}

function find(test, elems, recurse, limit){
	var result = [], childs;

	for(var i = 0, j = elems.length; i < j; i++){
		if(test(elems[i])){
			result.push(elems[i]);
			if(--limit <= 0) break;
		}

		childs = elems[i].children;
		if(recurse && childs && childs.length > 0){
			childs = find(test, childs, recurse, limit);
			result = result.concat(childs);
			limit -= childs.length;
			if(limit <= 0) break;
		}
	}

	return result;
}

function findOneChild(test, elems){
	for(var i = 0, l = elems.length; i < l; i++){
		if(test(elems[i])) return elems[i];
	}

	return null;
}

function findOne(test, elems){
	var elem = null;

	for(var i = 0, l = elems.length; i < l && !elem; i++){
		if(!isTag(elems[i])){
			continue;
		} else if(test(elems[i])){
			elem = elems[i];
		} else if(elems[i].children.length > 0){
			elem = findOne(test, elems[i].children);
		}
	}

	return elem;
}

function existsOne(test, elems){
	for(var i = 0, l = elems.length; i < l; i++){
		if(
			isTag(elems[i]) && (
				test(elems[i]) || (
					elems[i].children.length > 0 &&
					existsOne(test, elems[i].children)
				)
			)
		){
			return true;
		}
	}

	return false;
}

function findAll(test, elems){
	var result = [];
	for(var i = 0, j = elems.length; i < j; i++){
		if(!isTag(elems[i])) continue;
		if(test(elems[i])) result.push(elems[i]);

		if(elems[i].children.length > 0){
			result = result.concat(findAll(test, elems[i].children));
		}
	}
	return result;
}

},{"domelementtype":84}],93:[function(require,module,exports){
var ElementType = require("domelementtype"),
    getOuterHTML = require("dom-serializer"),
    isTag = ElementType.isTag;

module.exports = {
	getInnerHTML: getInnerHTML,
	getOuterHTML: getOuterHTML,
	getText: getText
};

function getInnerHTML(elem, opts){
	return elem.children ? elem.children.map(function(elem){
		return getOuterHTML(elem, opts);
	}).join("") : "";
}

function getText(elem){
	if(Array.isArray(elem)) return elem.map(getText).join("");
	if(isTag(elem) || elem.type === ElementType.CDATA) return getText(elem.children);
	if(elem.type === ElementType.Text) return elem.data;
	return "";
}

},{"dom-serializer":82,"domelementtype":84}],94:[function(require,module,exports){
var getChildren = exports.getChildren = function(elem){
	return elem.children;
};

var getParent = exports.getParent = function(elem){
	return elem.parent;
};

exports.getSiblings = function(elem){
	var parent = getParent(elem);
	return parent ? getChildren(parent) : [elem];
};

exports.getAttributeValue = function(elem, name){
	return elem.attribs && elem.attribs[name];
};

exports.hasAttrib = function(elem, name){
	return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
};

exports.getName = function(elem){
	return elem.name;
};

},{}],95:[function(require,module,exports){
'use strict';

var cache = {};
var start = '(?:^|\\s)';
var end = '(?:\\s|$)';

function lookupClass (className) {
  var cached = cache[className];
  if (cached) {
    cached.lastIndex = 0;
  } else {
    cache[className] = cached = new RegExp(start + className + end, 'g');
  }
  return cached;
}

function addClass (el, className) {
  var current = el.className;
  if (!current.length) {
    el.className = className;
  } else if (!lookupClass(className).test(current)) {
    el.className += ' ' + className;
  }
}

function rmClass (el, className) {
  el.className = el.className.replace(lookupClass(className), ' ').trim();
}

module.exports = {
  add: addClass,
  rm: rmClass
};

},{}],96:[function(require,module,exports){
(function (global){
'use strict';

var emitter = require('contra/emitter');
var crossvent = require('crossvent');
var classes = require('./classes');
var doc = document;
var documentElement = doc.documentElement;

function dragula (initialContainers, options) {
  var len = arguments.length;
  if (len === 1 && Array.isArray(initialContainers) === false) {
    options = initialContainers;
    initialContainers = [];
  }
  var _mirror; // mirror image
  var _source; // source container
  var _item; // item being dragged
  var _offsetX; // reference x
  var _offsetY; // reference y
  var _moveX; // reference move x
  var _moveY; // reference move y
  var _initialSibling; // reference sibling when grabbed
  var _currentSibling; // reference sibling now
  var _copy; // item used for copying
  var _renderTimer; // timer for setTimeout renderMirrorImage
  var _lastDropTarget = null; // last container item was over
  var _grabbed; // holds mousedown context until first mousemove

  var o = options || {};
  if (o.moves === void 0) { o.moves = always; }
  if (o.accepts === void 0) { o.accepts = always; }
  if (o.invalid === void 0) { o.invalid = invalidTarget; }
  if (o.containers === void 0) { o.containers = initialContainers || []; }
  if (o.isContainer === void 0) { o.isContainer = never; }
  if (o.copy === void 0) { o.copy = false; }
  if (o.copySortSource === void 0) { o.copySortSource = false; }
  if (o.revertOnSpill === void 0) { o.revertOnSpill = false; }
  if (o.removeOnSpill === void 0) { o.removeOnSpill = false; }
  if (o.direction === void 0) { o.direction = 'vertical'; }
  if (o.ignoreInputTextSelection === void 0) { o.ignoreInputTextSelection = true; }
  if (o.mirrorContainer === void 0) { o.mirrorContainer = doc.body; }

  var drake = emitter({
    containers: o.containers,
    start: manualStart,
    end: end,
    cancel: cancel,
    remove: remove,
    destroy: destroy,
    canMove: canMove,
    dragging: false
  });

  if (o.removeOnSpill === true) {
    drake.on('over', spillOver).on('out', spillOut);
  }

  events();

  return drake;

  function isContainer (el) {
    return drake.containers.indexOf(el) !== -1 || o.isContainer(el);
  }

  function events (remove) {
    var op = remove ? 'remove' : 'add';
    touchy(documentElement, op, 'mousedown', grab);
    touchy(documentElement, op, 'mouseup', release);
  }

  function eventualMovements (remove) {
    var op = remove ? 'remove' : 'add';
    touchy(documentElement, op, 'mousemove', startBecauseMouseMoved);
  }

  function movements (remove) {
    var op = remove ? 'remove' : 'add';
    crossvent[op](documentElement, 'selectstart', preventGrabbed); // IE8
    crossvent[op](documentElement, 'click', preventGrabbed);
  }

  function destroy () {
    events(true);
    release({});
  }

  function preventGrabbed (e) {
    if (_grabbed) {
      e.preventDefault();
    }
  }

  function grab (e) {
    _moveX = e.clientX;
    _moveY = e.clientY;

    var ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;
    if (ignore) {
      return; // we only care about honest-to-god left clicks and touch events
    }
    var item = e.target;
    var context = canStart(item);
    if (!context) {
      return;
    }
    _grabbed = context;
    eventualMovements();
    if (e.type === 'mousedown') {
      if (isInput(item)) { // see also: https://github.com/bevacqua/dragula/issues/208
        item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176
      } else {
        e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155
      }
    }
  }

  function startBecauseMouseMoved (e) {
    if (!_grabbed) {
      return;
    }
    if (whichMouseButton(e) === 0) {
      release({});
      return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope
    }
    // truthy check fixes #239, equality fixes #207
    if (e.clientX !== void 0 && e.clientX === _moveX && e.clientY !== void 0 && e.clientY === _moveY) {
      return;
    }
    if (o.ignoreInputTextSelection) {
      var clientX = getCoord('clientX', e);
      var clientY = getCoord('clientY', e);
      var elementBehindCursor = doc.elementFromPoint(clientX, clientY);
      if (isInput(elementBehindCursor)) {
        return;
      }
    }

    var grabbed = _grabbed; // call to end() unsets _grabbed
    eventualMovements(true);
    movements();
    end();
    start(grabbed);

    var offset = getOffset(_item);
    _offsetX = getCoord('pageX', e) - offset.left;
    _offsetY = getCoord('pageY', e) - offset.top;

    classes.add(_copy || _item, 'gu-transit');
    renderMirrorImage();
    drag(e);
  }

  function canStart (item) {
    if (drake.dragging && _mirror) {
      return;
    }
    if (isContainer(item)) {
      return; // don't drag container itself
    }
    var handle = item;
    while (getParent(item) && isContainer(getParent(item)) === false) {
      if (o.invalid(item, handle)) {
        return;
      }
      item = getParent(item); // drag target should be a top element
      if (!item) {
        return;
      }
    }
    var source = getParent(item);
    if (!source) {
      return;
    }
    if (o.invalid(item, handle)) {
      return;
    }

    var movable = o.moves(item, source, handle, nextEl(item));
    if (!movable) {
      return;
    }

    return {
      item: item,
      source: source
    };
  }

  function canMove (item) {
    return !!canStart(item);
  }

  function manualStart (item) {
    var context = canStart(item);
    if (context) {
      start(context);
    }
  }

  function start (context) {
    if (isCopy(context.item, context.source)) {
      _copy = context.item.cloneNode(true);
      drake.emit('cloned', _copy, context.item, 'copy');
    }

    _source = context.source;
    _item = context.item;
    _initialSibling = _currentSibling = nextEl(context.item);

    drake.dragging = true;
    drake.emit('drag', _item, _source);
  }

  function invalidTarget () {
    return false;
  }

  function end () {
    if (!drake.dragging) {
      return;
    }
    var item = _copy || _item;
    drop(item, getParent(item));
  }

  function ungrab () {
    _grabbed = false;
    eventualMovements(true);
    movements(true);
  }

  function release (e) {
    ungrab();

    if (!drake.dragging) {
      return;
    }
    var item = _copy || _item;
    var clientX = getCoord('clientX', e);
    var clientY = getCoord('clientY', e);
    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);
    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);
    if (dropTarget && ((_copy && o.copySortSource) || (!_copy || dropTarget !== _source))) {
      drop(item, dropTarget);
    } else if (o.removeOnSpill) {
      remove();
    } else {
      cancel();
    }
  }

  function drop (item, target) {
    var parent = getParent(item);
    if (_copy && o.copySortSource && target === _source) {
      parent.removeChild(_item);
    }
    if (isInitialPlacement(target)) {
      drake.emit('cancel', item, _source, _source);
    } else {
      drake.emit('drop', item, target, _source, _currentSibling);
    }
    cleanup();
  }

  function remove () {
    if (!drake.dragging) {
      return;
    }
    var item = _copy || _item;
    var parent = getParent(item);
    if (parent) {
      parent.removeChild(item);
    }
    drake.emit(_copy ? 'cancel' : 'remove', item, parent, _source);
    cleanup();
  }

  function cancel (revert) {
    if (!drake.dragging) {
      return;
    }
    var reverts = arguments.length > 0 ? revert : o.revertOnSpill;
    var item = _copy || _item;
    var parent = getParent(item);
    var initial = isInitialPlacement(parent);
    if (initial === false && reverts) {
      if (_copy) {
        if (parent) {
          parent.removeChild(_copy);
        }
      } else {
        _source.insertBefore(item, _initialSibling);
      }
    }
    if (initial || reverts) {
      drake.emit('cancel', item, _source, _source);
    } else {
      drake.emit('drop', item, parent, _source, _currentSibling);
    }
    cleanup();
  }

  function cleanup () {
    var item = _copy || _item;
    ungrab();
    removeMirrorImage();
    if (item) {
      classes.rm(item, 'gu-transit');
    }
    if (_renderTimer) {
      clearTimeout(_renderTimer);
    }
    drake.dragging = false;
    if (_lastDropTarget) {
      drake.emit('out', item, _lastDropTarget, _source);
    }
    drake.emit('dragend', item);
    _source = _item = _copy = _initialSibling = _currentSibling = _renderTimer = _lastDropTarget = null;
  }

  function isInitialPlacement (target, s) {
    var sibling;
    if (s !== void 0) {
      sibling = s;
    } else if (_mirror) {
      sibling = _currentSibling;
    } else {
      sibling = nextEl(_copy || _item);
    }
    return target === _source && sibling === _initialSibling;
  }

  function findDropTarget (elementBehindCursor, clientX, clientY) {
    var target = elementBehindCursor;
    while (target && !accepted()) {
      target = getParent(target);
    }
    return target;

    function accepted () {
      var droppable = isContainer(target);
      if (droppable === false) {
        return false;
      }

      var immediate = getImmediateChild(target, elementBehindCursor);
      var reference = getReference(target, immediate, clientX, clientY);
      var initial = isInitialPlacement(target, reference);
      if (initial) {
        return true; // should always be able to drop it right back where it was
      }
      return o.accepts(_item, target, _source, reference);
    }
  }

  function drag (e) {
    if (!_mirror) {
      return;
    }
    e.preventDefault();

    var clientX = getCoord('clientX', e);
    var clientY = getCoord('clientY', e);
    var x = clientX - _offsetX;
    var y = clientY - _offsetY;

    _mirror.style.left = x + 'px';
    _mirror.style.top = y + 'px';

    var item = _copy || _item;
    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);
    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);
    var changed = dropTarget !== null && dropTarget !== _lastDropTarget;
    if (changed || dropTarget === null) {
      out();
      _lastDropTarget = dropTarget;
      over();
    }
    var parent = getParent(item);
    if (dropTarget === _source && _copy && !o.copySortSource) {
      if (parent) {
        parent.removeChild(item);
      }
      return;
    }
    var reference;
    var immediate = getImmediateChild(dropTarget, elementBehindCursor);
    if (immediate !== null) {
      reference = getReference(dropTarget, immediate, clientX, clientY);
    } else if (o.revertOnSpill === true && !_copy) {
      reference = _initialSibling;
      dropTarget = _source;
    } else {
      if (_copy && parent) {
        parent.removeChild(item);
      }
      return;
    }
    if (
      (reference === null && changed) ||
      reference !== item &&
      reference !== nextEl(item)
    ) {
      _currentSibling = reference;
      dropTarget.insertBefore(item, reference);
      drake.emit('shadow', item, dropTarget, _source);
    }
    function moved (type) { drake.emit(type, item, _lastDropTarget, _source); }
    function over () { if (changed) { moved('over'); } }
    function out () { if (_lastDropTarget) { moved('out'); } }
  }

  function spillOver (el) {
    classes.rm(el, 'gu-hide');
  }

  function spillOut (el) {
    if (drake.dragging) { classes.add(el, 'gu-hide'); }
  }

  function renderMirrorImage () {
    if (_mirror) {
      return;
    }
    var rect = _item.getBoundingClientRect();
    _mirror = _item.cloneNode(true);
    _mirror.style.width = getRectWidth(rect) + 'px';
    _mirror.style.height = getRectHeight(rect) + 'px';
    classes.rm(_mirror, 'gu-transit');
    classes.add(_mirror, 'gu-mirror');
    o.mirrorContainer.appendChild(_mirror);
    touchy(documentElement, 'add', 'mousemove', drag);
    classes.add(o.mirrorContainer, 'gu-unselectable');
    drake.emit('cloned', _mirror, _item, 'mirror');
  }

  function removeMirrorImage () {
    if (_mirror) {
      classes.rm(o.mirrorContainer, 'gu-unselectable');
      touchy(documentElement, 'remove', 'mousemove', drag);
      getParent(_mirror).removeChild(_mirror);
      _mirror = null;
    }
  }

  function getImmediateChild (dropTarget, target) {
    var immediate = target;
    while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {
      immediate = getParent(immediate);
    }
    if (immediate === documentElement) {
      return null;
    }
    return immediate;
  }

  function getReference (dropTarget, target, x, y) {
    var horizontal = o.direction === 'horizontal';
    var reference = target !== dropTarget ? inside() : outside();
    return reference;

    function outside () { // slower, but able to figure out any position
      var len = dropTarget.children.length;
      var i;
      var el;
      var rect;
      for (i = 0; i < len; i++) {
        el = dropTarget.children[i];
        rect = el.getBoundingClientRect();
        if (horizontal && (rect.left + rect.width / 2) > x) { return el; }
        if (!horizontal && (rect.top + rect.height / 2) > y) { return el; }
      }
      return null;
    }

    function inside () { // faster, but only available if dropped inside a child element
      var rect = target.getBoundingClientRect();
      if (horizontal) {
        return resolve(x > rect.left + getRectWidth(rect) / 2);
      }
      return resolve(y > rect.top + getRectHeight(rect) / 2);
    }

    function resolve (after) {
      return after ? nextEl(target) : target;
    }
  }

  function isCopy (item, container) {
    return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);
  }
}

function touchy (el, op, type, fn) {
  var touch = {
    mouseup: 'touchend',
    mousedown: 'touchstart',
    mousemove: 'touchmove'
  };
  var pointers = {
    mouseup: 'pointerup',
    mousedown: 'pointerdown',
    mousemove: 'pointermove'
  };
  var microsoft = {
    mouseup: 'MSPointerUp',
    mousedown: 'MSPointerDown',
    mousemove: 'MSPointerMove'
  };
  if (global.navigator.pointerEnabled) {
    crossvent[op](el, pointers[type], fn);
  } else if (global.navigator.msPointerEnabled) {
    crossvent[op](el, microsoft[type], fn);
  } else {
    crossvent[op](el, touch[type], fn);
    crossvent[op](el, type, fn);
  }
}

function whichMouseButton (e) {
  if (e.touches !== void 0) { return e.touches.length; }
  if (e.which !== void 0 && e.which !== 0) { return e.which; } // see https://github.com/bevacqua/dragula/issues/261
  if (e.buttons !== void 0) { return e.buttons; }
  var button = e.button;
  if (button !== void 0) { // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575
    return button & 1 ? 1 : button & 2 ? 3 : (button & 4 ? 2 : 0);
  }
}

function getOffset (el) {
  var rect = el.getBoundingClientRect();
  return {
    left: rect.left + getScroll('scrollLeft', 'pageXOffset'),
    top: rect.top + getScroll('scrollTop', 'pageYOffset')
  };
}

function getScroll (scrollProp, offsetProp) {
  if (typeof global[offsetProp] !== 'undefined') {
    return global[offsetProp];
  }
  if (documentElement.clientHeight) {
    return documentElement[scrollProp];
  }
  return doc.body[scrollProp];
}

function getElementBehindPoint (point, x, y) {
  var p = point || {};
  var state = p.className;
  var el;
  p.className += ' gu-hide';
  el = doc.elementFromPoint(x, y);
  p.className = state;
  return el;
}

function never () { return false; }
function always () { return true; }
function getRectWidth (rect) { return rect.width || (rect.right - rect.left); }
function getRectHeight (rect) { return rect.height || (rect.bottom - rect.top); }
function getParent (el) { return el.parentNode === doc ? null : el.parentNode; }
function isInput (el) { return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el); }
function isEditable (el) {
  if (!el) { return false; } // no parents were editable
  if (el.contentEditable === 'false') { return false; } // stop the lookup
  if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain
  return isEditable(getParent(el)); // contentEditable is set to 'inherit'
}

function nextEl (el) {
  return el.nextElementSibling || manually();
  function manually () {
    var sibling = el;
    do {
      sibling = sibling.nextSibling;
    } while (sibling && sibling.nodeType !== 1);
    return sibling;
  }
}

function getEventHost (e) {
  // on touchend event, we have to use `e.changedTouches`
  // see http://stackoverflow.com/questions/7192563/touchend-event-properties
  // see https://github.com/bevacqua/dragula/issues/34
  if (e.targetTouches && e.targetTouches.length) {
    return e.targetTouches[0];
  }
  if (e.changedTouches && e.changedTouches.length) {
    return e.changedTouches[0];
  }
  return e;
}

function getCoord (coord, e) {
  var host = getEventHost(e);
  var missMap = {
    pageX: 'clientX', // IE8
    pageY: 'clientY' // IE8
  };
  if (coord in missMap && !(coord in host) && missMap[coord] in host) {
    coord = missMap[coord];
  }
  return host[coord];
}

module.exports = dragula;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./classes":95,"contra/emitter":68,"crossvent":70}],97:[function(require,module,exports){
var encode = require("./lib/encode.js"),
    decode = require("./lib/decode.js");

exports.decode = function(data, level){
	return (!level || level <= 0 ? decode.XML : decode.HTML)(data);
};

exports.decodeStrict = function(data, level){
	return (!level || level <= 0 ? decode.XML : decode.HTMLStrict)(data);
};

exports.encode = function(data, level){
	return (!level || level <= 0 ? encode.XML : encode.HTML)(data);
};

exports.encodeXML = encode.XML;

exports.encodeHTML4 =
exports.encodeHTML5 =
exports.encodeHTML  = encode.HTML;

exports.decodeXML =
exports.decodeXMLStrict = decode.XML;

exports.decodeHTML4 =
exports.decodeHTML5 =
exports.decodeHTML = decode.HTML;

exports.decodeHTML4Strict =
exports.decodeHTML5Strict =
exports.decodeHTMLStrict = decode.HTMLStrict;

exports.escape = encode.escape;

},{"./lib/decode.js":98,"./lib/encode.js":100}],98:[function(require,module,exports){
var entityMap = require("../maps/entities.json"),
    legacyMap = require("../maps/legacy.json"),
    xmlMap    = require("../maps/xml.json"),
    decodeCodePoint = require("./decode_codepoint.js");

var decodeXMLStrict  = getStrictDecoder(xmlMap),
    decodeHTMLStrict = getStrictDecoder(entityMap);

function getStrictDecoder(map){
	var keys = Object.keys(map).join("|"),
	    replace = getReplacer(map);

	keys += "|#[xX][\\da-fA-F]+|#\\d+";

	var re = new RegExp("&(?:" + keys + ");", "g");

	return function(str){
		return String(str).replace(re, replace);
	};
}

var decodeHTML = (function(){
	var legacy = Object.keys(legacyMap)
		.sort(sorter);

	var keys = Object.keys(entityMap)
		.sort(sorter);

	for(var i = 0, j = 0; i < keys.length; i++){
		if(legacy[j] === keys[i]){
			keys[i] += ";?";
			j++;
		} else {
			keys[i] += ";";
		}
	}

	var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"),
	    replace = getReplacer(entityMap);

	function replacer(str){
		if(str.substr(-1) !== ";") str += ";";
		return replace(str);
	}

	//TODO consider creating a merged map
	return function(str){
		return String(str).replace(re, replacer);
	};
}());

function sorter(a, b){
	return a < b ? 1 : -1;
}

function getReplacer(map){
	return function replace(str){
		if(str.charAt(1) === "#"){
			if(str.charAt(2) === "X" || str.charAt(2) === "x"){
				return decodeCodePoint(parseInt(str.substr(3), 16));
			}
			return decodeCodePoint(parseInt(str.substr(2), 10));
		}
		return map[str.slice(1, -1)];
	};
}

module.exports = {
	XML: decodeXMLStrict,
	HTML: decodeHTML,
	HTMLStrict: decodeHTMLStrict
};
},{"../maps/entities.json":102,"../maps/legacy.json":103,"../maps/xml.json":104,"./decode_codepoint.js":99}],99:[function(require,module,exports){
var decodeMap = require("../maps/decode.json");

module.exports = decodeCodePoint;

// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint(codePoint){

	if((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF){
		return "\uFFFD";
	}

	if(codePoint in decodeMap){
		codePoint = decodeMap[codePoint];
	}

	var output = "";

	if(codePoint > 0xFFFF){
		codePoint -= 0x10000;
		output += String.fromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
		codePoint = 0xDC00 | codePoint & 0x3FF;
	}

	output += String.fromCharCode(codePoint);
	return output;
}

},{"../maps/decode.json":101}],100:[function(require,module,exports){
var inverseXML = getInverseObj(require("../maps/xml.json")),
    xmlReplacer = getInverseReplacer(inverseXML);

exports.XML = getInverse(inverseXML, xmlReplacer);

var inverseHTML = getInverseObj(require("../maps/entities.json")),
    htmlReplacer = getInverseReplacer(inverseHTML);

exports.HTML = getInverse(inverseHTML, htmlReplacer);

function getInverseObj(obj){
	return Object.keys(obj).sort().reduce(function(inverse, name){
		inverse[obj[name]] = "&" + name + ";";
		return inverse;
	}, {});
}

function getInverseReplacer(inverse){
	var single = [],
	    multiple = [];

	Object.keys(inverse).forEach(function(k){
		if(k.length === 1){
			single.push("\\" + k);
		} else {
			multiple.push(k);
		}
	});

	//TODO add ranges
	multiple.unshift("[" + single.join("") + "]");

	return new RegExp(multiple.join("|"), "g");
}

var re_nonASCII = /[^\0-\x7F]/g,
    re_astralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;

function singleCharReplacer(c){
	return "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";";
}

function astralReplacer(c){
	// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	var high = c.charCodeAt(0);
	var low  = c.charCodeAt(1);
	var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
	return "&#x" + codePoint.toString(16).toUpperCase() + ";";
}

function getInverse(inverse, re){
	function func(name){
		return inverse[name];
	}

	return function(data){
		return data
				.replace(re, func)
				.replace(re_astralSymbols, astralReplacer)
				.replace(re_nonASCII, singleCharReplacer);
	};
}

var re_xmlChars = getInverseReplacer(inverseXML);

function escapeXML(data){
	return data
			.replace(re_xmlChars, singleCharReplacer)
			.replace(re_astralSymbols, astralReplacer)
			.replace(re_nonASCII, singleCharReplacer);
}

exports.escape = escapeXML;

},{"../maps/entities.json":102,"../maps/xml.json":104}],101:[function(require,module,exports){
module.exports={"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}
},{}],102:[function(require,module,exports){
module.exports={"Aacute":"\u00C1","aacute":"\u00E1","Abreve":"\u0102","abreve":"\u0103","ac":"\u223E","acd":"\u223F","acE":"\u223E\u0333","Acirc":"\u00C2","acirc":"\u00E2","acute":"\u00B4","Acy":"\u0410","acy":"\u0430","AElig":"\u00C6","aelig":"\u00E6","af":"\u2061","Afr":"\uD835\uDD04","afr":"\uD835\uDD1E","Agrave":"\u00C0","agrave":"\u00E0","alefsym":"\u2135","aleph":"\u2135","Alpha":"\u0391","alpha":"\u03B1","Amacr":"\u0100","amacr":"\u0101","amalg":"\u2A3F","amp":"&","AMP":"&","andand":"\u2A55","And":"\u2A53","and":"\u2227","andd":"\u2A5C","andslope":"\u2A58","andv":"\u2A5A","ang":"\u2220","ange":"\u29A4","angle":"\u2220","angmsdaa":"\u29A8","angmsdab":"\u29A9","angmsdac":"\u29AA","angmsdad":"\u29AB","angmsdae":"\u29AC","angmsdaf":"\u29AD","angmsdag":"\u29AE","angmsdah":"\u29AF","angmsd":"\u2221","angrt":"\u221F","angrtvb":"\u22BE","angrtvbd":"\u299D","angsph":"\u2222","angst":"\u00C5","angzarr":"\u237C","Aogon":"\u0104","aogon":"\u0105","Aopf":"\uD835\uDD38","aopf":"\uD835\uDD52","apacir":"\u2A6F","ap":"\u2248","apE":"\u2A70","ape":"\u224A","apid":"\u224B","apos":"'","ApplyFunction":"\u2061","approx":"\u2248","approxeq":"\u224A","Aring":"\u00C5","aring":"\u00E5","Ascr":"\uD835\uDC9C","ascr":"\uD835\uDCB6","Assign":"\u2254","ast":"*","asymp":"\u2248","asympeq":"\u224D","Atilde":"\u00C3","atilde":"\u00E3","Auml":"\u00C4","auml":"\u00E4","awconint":"\u2233","awint":"\u2A11","backcong":"\u224C","backepsilon":"\u03F6","backprime":"\u2035","backsim":"\u223D","backsimeq":"\u22CD","Backslash":"\u2216","Barv":"\u2AE7","barvee":"\u22BD","barwed":"\u2305","Barwed":"\u2306","barwedge":"\u2305","bbrk":"\u23B5","bbrktbrk":"\u23B6","bcong":"\u224C","Bcy":"\u0411","bcy":"\u0431","bdquo":"\u201E","becaus":"\u2235","because":"\u2235","Because":"\u2235","bemptyv":"\u29B0","bepsi":"\u03F6","bernou":"\u212C","Bernoullis":"\u212C","Beta":"\u0392","beta":"\u03B2","beth":"\u2136","between":"\u226C","Bfr":"\uD835\uDD05","bfr":"\uD835\uDD1F","bigcap":"\u22C2","bigcirc":"\u25EF","bigcup":"\u22C3","bigodot":"\u2A00","bigoplus":"\u2A01","bigotimes":"\u2A02","bigsqcup":"\u2A06","bigstar":"\u2605","bigtriangledown":"\u25BD","bigtriangleup":"\u25B3","biguplus":"\u2A04","bigvee":"\u22C1","bigwedge":"\u22C0","bkarow":"\u290D","blacklozenge":"\u29EB","blacksquare":"\u25AA","blacktriangle":"\u25B4","blacktriangledown":"\u25BE","blacktriangleleft":"\u25C2","blacktriangleright":"\u25B8","blank":"\u2423","blk12":"\u2592","blk14":"\u2591","blk34":"\u2593","block":"\u2588","bne":"=\u20E5","bnequiv":"\u2261\u20E5","bNot":"\u2AED","bnot":"\u2310","Bopf":"\uD835\uDD39","bopf":"\uD835\uDD53","bot":"\u22A5","bottom":"\u22A5","bowtie":"\u22C8","boxbox":"\u29C9","boxdl":"\u2510","boxdL":"\u2555","boxDl":"\u2556","boxDL":"\u2557","boxdr":"\u250C","boxdR":"\u2552","boxDr":"\u2553","boxDR":"\u2554","boxh":"\u2500","boxH":"\u2550","boxhd":"\u252C","boxHd":"\u2564","boxhD":"\u2565","boxHD":"\u2566","boxhu":"\u2534","boxHu":"\u2567","boxhU":"\u2568","boxHU":"\u2569","boxminus":"\u229F","boxplus":"\u229E","boxtimes":"\u22A0","boxul":"\u2518","boxuL":"\u255B","boxUl":"\u255C","boxUL":"\u255D","boxur":"\u2514","boxuR":"\u2558","boxUr":"\u2559","boxUR":"\u255A","boxv":"\u2502","boxV":"\u2551","boxvh":"\u253C","boxvH":"\u256A","boxVh":"\u256B","boxVH":"\u256C","boxvl":"\u2524","boxvL":"\u2561","boxVl":"\u2562","boxVL":"\u2563","boxvr":"\u251C","boxvR":"\u255E","boxVr":"\u255F","boxVR":"\u2560","bprime":"\u2035","breve":"\u02D8","Breve":"\u02D8","brvbar":"\u00A6","bscr":"\uD835\uDCB7","Bscr":"\u212C","bsemi":"\u204F","bsim":"\u223D","bsime":"\u22CD","bsolb":"\u29C5","bsol":"\\","bsolhsub":"\u27C8","bull":"\u2022","bullet":"\u2022","bump":"\u224E","bumpE":"\u2AAE","bumpe":"\u224F","Bumpeq":"\u224E","bumpeq":"\u224F","Cacute":"\u0106","cacute":"\u0107","capand":"\u2A44","capbrcup":"\u2A49","capcap":"\u2A4B","cap":"\u2229","Cap":"\u22D2","capcup":"\u2A47","capdot":"\u2A40","CapitalDifferentialD":"\u2145","caps":"\u2229\uFE00","caret":"\u2041","caron":"\u02C7","Cayleys":"\u212D","ccaps":"\u2A4D","Ccaron":"\u010C","ccaron":"\u010D","Ccedil":"\u00C7","ccedil":"\u00E7","Ccirc":"\u0108","ccirc":"\u0109","Cconint":"\u2230","ccups":"\u2A4C","ccupssm":"\u2A50","Cdot":"\u010A","cdot":"\u010B","cedil":"\u00B8","Cedilla":"\u00B8","cemptyv":"\u29B2","cent":"\u00A2","centerdot":"\u00B7","CenterDot":"\u00B7","cfr":"\uD835\uDD20","Cfr":"\u212D","CHcy":"\u0427","chcy":"\u0447","check":"\u2713","checkmark":"\u2713","Chi":"\u03A7","chi":"\u03C7","circ":"\u02C6","circeq":"\u2257","circlearrowleft":"\u21BA","circlearrowright":"\u21BB","circledast":"\u229B","circledcirc":"\u229A","circleddash":"\u229D","CircleDot":"\u2299","circledR":"\u00AE","circledS":"\u24C8","CircleMinus":"\u2296","CirclePlus":"\u2295","CircleTimes":"\u2297","cir":"\u25CB","cirE":"\u29C3","cire":"\u2257","cirfnint":"\u2A10","cirmid":"\u2AEF","cirscir":"\u29C2","ClockwiseContourIntegral":"\u2232","CloseCurlyDoubleQuote":"\u201D","CloseCurlyQuote":"\u2019","clubs":"\u2663","clubsuit":"\u2663","colon":":","Colon":"\u2237","Colone":"\u2A74","colone":"\u2254","coloneq":"\u2254","comma":",","commat":"@","comp":"\u2201","compfn":"\u2218","complement":"\u2201","complexes":"\u2102","cong":"\u2245","congdot":"\u2A6D","Congruent":"\u2261","conint":"\u222E","Conint":"\u222F","ContourIntegral":"\u222E","copf":"\uD835\uDD54","Copf":"\u2102","coprod":"\u2210","Coproduct":"\u2210","copy":"\u00A9","COPY":"\u00A9","copysr":"\u2117","CounterClockwiseContourIntegral":"\u2233","crarr":"\u21B5","cross":"\u2717","Cross":"\u2A2F","Cscr":"\uD835\uDC9E","cscr":"\uD835\uDCB8","csub":"\u2ACF","csube":"\u2AD1","csup":"\u2AD0","csupe":"\u2AD2","ctdot":"\u22EF","cudarrl":"\u2938","cudarrr":"\u2935","cuepr":"\u22DE","cuesc":"\u22DF","cularr":"\u21B6","cularrp":"\u293D","cupbrcap":"\u2A48","cupcap":"\u2A46","CupCap":"\u224D","cup":"\u222A","Cup":"\u22D3","cupcup":"\u2A4A","cupdot":"\u228D","cupor":"\u2A45","cups":"\u222A\uFE00","curarr":"\u21B7","curarrm":"\u293C","curlyeqprec":"\u22DE","curlyeqsucc":"\u22DF","curlyvee":"\u22CE","curlywedge":"\u22CF","curren":"\u00A4","curvearrowleft":"\u21B6","curvearrowright":"\u21B7","cuvee":"\u22CE","cuwed":"\u22CF","cwconint":"\u2232","cwint":"\u2231","cylcty":"\u232D","dagger":"\u2020","Dagger":"\u2021","daleth":"\u2138","darr":"\u2193","Darr":"\u21A1","dArr":"\u21D3","dash":"\u2010","Dashv":"\u2AE4","dashv":"\u22A3","dbkarow":"\u290F","dblac":"\u02DD","Dcaron":"\u010E","dcaron":"\u010F","Dcy":"\u0414","dcy":"\u0434","ddagger":"\u2021","ddarr":"\u21CA","DD":"\u2145","dd":"\u2146","DDotrahd":"\u2911","ddotseq":"\u2A77","deg":"\u00B0","Del":"\u2207","Delta":"\u0394","delta":"\u03B4","demptyv":"\u29B1","dfisht":"\u297F","Dfr":"\uD835\uDD07","dfr":"\uD835\uDD21","dHar":"\u2965","dharl":"\u21C3","dharr":"\u21C2","DiacriticalAcute":"\u00B4","DiacriticalDot":"\u02D9","DiacriticalDoubleAcute":"\u02DD","DiacriticalGrave":"`","DiacriticalTilde":"\u02DC","diam":"\u22C4","diamond":"\u22C4","Diamond":"\u22C4","diamondsuit":"\u2666","diams":"\u2666","die":"\u00A8","DifferentialD":"\u2146","digamma":"\u03DD","disin":"\u22F2","div":"\u00F7","divide":"\u00F7","divideontimes":"\u22C7","divonx":"\u22C7","DJcy":"\u0402","djcy":"\u0452","dlcorn":"\u231E","dlcrop":"\u230D","dollar":"$","Dopf":"\uD835\uDD3B","dopf":"\uD835\uDD55","Dot":"\u00A8","dot":"\u02D9","DotDot":"\u20DC","doteq":"\u2250","doteqdot":"\u2251","DotEqual":"\u2250","dotminus":"\u2238","dotplus":"\u2214","dotsquare":"\u22A1","doublebarwedge":"\u2306","DoubleContourIntegral":"\u222F","DoubleDot":"\u00A8","DoubleDownArrow":"\u21D3","DoubleLeftArrow":"\u21D0","DoubleLeftRightArrow":"\u21D4","DoubleLeftTee":"\u2AE4","DoubleLongLeftArrow":"\u27F8","DoubleLongLeftRightArrow":"\u27FA","DoubleLongRightArrow":"\u27F9","DoubleRightArrow":"\u21D2","DoubleRightTee":"\u22A8","DoubleUpArrow":"\u21D1","DoubleUpDownArrow":"\u21D5","DoubleVerticalBar":"\u2225","DownArrowBar":"\u2913","downarrow":"\u2193","DownArrow":"\u2193","Downarrow":"\u21D3","DownArrowUpArrow":"\u21F5","DownBreve":"\u0311","downdownarrows":"\u21CA","downharpoonleft":"\u21C3","downharpoonright":"\u21C2","DownLeftRightVector":"\u2950","DownLeftTeeVector":"\u295E","DownLeftVectorBar":"\u2956","DownLeftVector":"\u21BD","DownRightTeeVector":"\u295F","DownRightVectorBar":"\u2957","DownRightVector":"\u21C1","DownTeeArrow":"\u21A7","DownTee":"\u22A4","drbkarow":"\u2910","drcorn":"\u231F","drcrop":"\u230C","Dscr":"\uD835\uDC9F","dscr":"\uD835\uDCB9","DScy":"\u0405","dscy":"\u0455","dsol":"\u29F6","Dstrok":"\u0110","dstrok":"\u0111","dtdot":"\u22F1","dtri":"\u25BF","dtrif":"\u25BE","duarr":"\u21F5","duhar":"\u296F","dwangle":"\u29A6","DZcy":"\u040F","dzcy":"\u045F","dzigrarr":"\u27FF","Eacute":"\u00C9","eacute":"\u00E9","easter":"\u2A6E","Ecaron":"\u011A","ecaron":"\u011B","Ecirc":"\u00CA","ecirc":"\u00EA","ecir":"\u2256","ecolon":"\u2255","Ecy":"\u042D","ecy":"\u044D","eDDot":"\u2A77","Edot":"\u0116","edot":"\u0117","eDot":"\u2251","ee":"\u2147","efDot":"\u2252","Efr":"\uD835\uDD08","efr":"\uD835\uDD22","eg":"\u2A9A","Egrave":"\u00C8","egrave":"\u00E8","egs":"\u2A96","egsdot":"\u2A98","el":"\u2A99","Element":"\u2208","elinters":"\u23E7","ell":"\u2113","els":"\u2A95","elsdot":"\u2A97","Emacr":"\u0112","emacr":"\u0113","empty":"\u2205","emptyset":"\u2205","EmptySmallSquare":"\u25FB","emptyv":"\u2205","EmptyVerySmallSquare":"\u25AB","emsp13":"\u2004","emsp14":"\u2005","emsp":"\u2003","ENG":"\u014A","eng":"\u014B","ensp":"\u2002","Eogon":"\u0118","eogon":"\u0119","Eopf":"\uD835\uDD3C","eopf":"\uD835\uDD56","epar":"\u22D5","eparsl":"\u29E3","eplus":"\u2A71","epsi":"\u03B5","Epsilon":"\u0395","epsilon":"\u03B5","epsiv":"\u03F5","eqcirc":"\u2256","eqcolon":"\u2255","eqsim":"\u2242","eqslantgtr":"\u2A96","eqslantless":"\u2A95","Equal":"\u2A75","equals":"=","EqualTilde":"\u2242","equest":"\u225F","Equilibrium":"\u21CC","equiv":"\u2261","equivDD":"\u2A78","eqvparsl":"\u29E5","erarr":"\u2971","erDot":"\u2253","escr":"\u212F","Escr":"\u2130","esdot":"\u2250","Esim":"\u2A73","esim":"\u2242","Eta":"\u0397","eta":"\u03B7","ETH":"\u00D0","eth":"\u00F0","Euml":"\u00CB","euml":"\u00EB","euro":"\u20AC","excl":"!","exist":"\u2203","Exists":"\u2203","expectation":"\u2130","exponentiale":"\u2147","ExponentialE":"\u2147","fallingdotseq":"\u2252","Fcy":"\u0424","fcy":"\u0444","female":"\u2640","ffilig":"\uFB03","fflig":"\uFB00","ffllig":"\uFB04","Ffr":"\uD835\uDD09","ffr":"\uD835\uDD23","filig":"\uFB01","FilledSmallSquare":"\u25FC","FilledVerySmallSquare":"\u25AA","fjlig":"fj","flat":"\u266D","fllig":"\uFB02","fltns":"\u25B1","fnof":"\u0192","Fopf":"\uD835\uDD3D","fopf":"\uD835\uDD57","forall":"\u2200","ForAll":"\u2200","fork":"\u22D4","forkv":"\u2AD9","Fouriertrf":"\u2131","fpartint":"\u2A0D","frac12":"\u00BD","frac13":"\u2153","frac14":"\u00BC","frac15":"\u2155","frac16":"\u2159","frac18":"\u215B","frac23":"\u2154","frac25":"\u2156","frac34":"\u00BE","frac35":"\u2157","frac38":"\u215C","frac45":"\u2158","frac56":"\u215A","frac58":"\u215D","frac78":"\u215E","frasl":"\u2044","frown":"\u2322","fscr":"\uD835\uDCBB","Fscr":"\u2131","gacute":"\u01F5","Gamma":"\u0393","gamma":"\u03B3","Gammad":"\u03DC","gammad":"\u03DD","gap":"\u2A86","Gbreve":"\u011E","gbreve":"\u011F","Gcedil":"\u0122","Gcirc":"\u011C","gcirc":"\u011D","Gcy":"\u0413","gcy":"\u0433","Gdot":"\u0120","gdot":"\u0121","ge":"\u2265","gE":"\u2267","gEl":"\u2A8C","gel":"\u22DB","geq":"\u2265","geqq":"\u2267","geqslant":"\u2A7E","gescc":"\u2AA9","ges":"\u2A7E","gesdot":"\u2A80","gesdoto":"\u2A82","gesdotol":"\u2A84","gesl":"\u22DB\uFE00","gesles":"\u2A94","Gfr":"\uD835\uDD0A","gfr":"\uD835\uDD24","gg":"\u226B","Gg":"\u22D9","ggg":"\u22D9","gimel":"\u2137","GJcy":"\u0403","gjcy":"\u0453","gla":"\u2AA5","gl":"\u2277","glE":"\u2A92","glj":"\u2AA4","gnap":"\u2A8A","gnapprox":"\u2A8A","gne":"\u2A88","gnE":"\u2269","gneq":"\u2A88","gneqq":"\u2269","gnsim":"\u22E7","Gopf":"\uD835\uDD3E","gopf":"\uD835\uDD58","grave":"`","GreaterEqual":"\u2265","GreaterEqualLess":"\u22DB","GreaterFullEqual":"\u2267","GreaterGreater":"\u2AA2","GreaterLess":"\u2277","GreaterSlantEqual":"\u2A7E","GreaterTilde":"\u2273","Gscr":"\uD835\uDCA2","gscr":"\u210A","gsim":"\u2273","gsime":"\u2A8E","gsiml":"\u2A90","gtcc":"\u2AA7","gtcir":"\u2A7A","gt":">","GT":">","Gt":"\u226B","gtdot":"\u22D7","gtlPar":"\u2995","gtquest":"\u2A7C","gtrapprox":"\u2A86","gtrarr":"\u2978","gtrdot":"\u22D7","gtreqless":"\u22DB","gtreqqless":"\u2A8C","gtrless":"\u2277","gtrsim":"\u2273","gvertneqq":"\u2269\uFE00","gvnE":"\u2269\uFE00","Hacek":"\u02C7","hairsp":"\u200A","half":"\u00BD","hamilt":"\u210B","HARDcy":"\u042A","hardcy":"\u044A","harrcir":"\u2948","harr":"\u2194","hArr":"\u21D4","harrw":"\u21AD","Hat":"^","hbar":"\u210F","Hcirc":"\u0124","hcirc":"\u0125","hearts":"\u2665","heartsuit":"\u2665","hellip":"\u2026","hercon":"\u22B9","hfr":"\uD835\uDD25","Hfr":"\u210C","HilbertSpace":"\u210B","hksearow":"\u2925","hkswarow":"\u2926","hoarr":"\u21FF","homtht":"\u223B","hookleftarrow":"\u21A9","hookrightarrow":"\u21AA","hopf":"\uD835\uDD59","Hopf":"\u210D","horbar":"\u2015","HorizontalLine":"\u2500","hscr":"\uD835\uDCBD","Hscr":"\u210B","hslash":"\u210F","Hstrok":"\u0126","hstrok":"\u0127","HumpDownHump":"\u224E","HumpEqual":"\u224F","hybull":"\u2043","hyphen":"\u2010","Iacute":"\u00CD","iacute":"\u00ED","ic":"\u2063","Icirc":"\u00CE","icirc":"\u00EE","Icy":"\u0418","icy":"\u0438","Idot":"\u0130","IEcy":"\u0415","iecy":"\u0435","iexcl":"\u00A1","iff":"\u21D4","ifr":"\uD835\uDD26","Ifr":"\u2111","Igrave":"\u00CC","igrave":"\u00EC","ii":"\u2148","iiiint":"\u2A0C","iiint":"\u222D","iinfin":"\u29DC","iiota":"\u2129","IJlig":"\u0132","ijlig":"\u0133","Imacr":"\u012A","imacr":"\u012B","image":"\u2111","ImaginaryI":"\u2148","imagline":"\u2110","imagpart":"\u2111","imath":"\u0131","Im":"\u2111","imof":"\u22B7","imped":"\u01B5","Implies":"\u21D2","incare":"\u2105","in":"\u2208","infin":"\u221E","infintie":"\u29DD","inodot":"\u0131","intcal":"\u22BA","int":"\u222B","Int":"\u222C","integers":"\u2124","Integral":"\u222B","intercal":"\u22BA","Intersection":"\u22C2","intlarhk":"\u2A17","intprod":"\u2A3C","InvisibleComma":"\u2063","InvisibleTimes":"\u2062","IOcy":"\u0401","iocy":"\u0451","Iogon":"\u012E","iogon":"\u012F","Iopf":"\uD835\uDD40","iopf":"\uD835\uDD5A","Iota":"\u0399","iota":"\u03B9","iprod":"\u2A3C","iquest":"\u00BF","iscr":"\uD835\uDCBE","Iscr":"\u2110","isin":"\u2208","isindot":"\u22F5","isinE":"\u22F9","isins":"\u22F4","isinsv":"\u22F3","isinv":"\u2208","it":"\u2062","Itilde":"\u0128","itilde":"\u0129","Iukcy":"\u0406","iukcy":"\u0456","Iuml":"\u00CF","iuml":"\u00EF","Jcirc":"\u0134","jcirc":"\u0135","Jcy":"\u0419","jcy":"\u0439","Jfr":"\uD835\uDD0D","jfr":"\uD835\uDD27","jmath":"\u0237","Jopf":"\uD835\uDD41","jopf":"\uD835\uDD5B","Jscr":"\uD835\uDCA5","jscr":"\uD835\uDCBF","Jsercy":"\u0408","jsercy":"\u0458","Jukcy":"\u0404","jukcy":"\u0454","Kappa":"\u039A","kappa":"\u03BA","kappav":"\u03F0","Kcedil":"\u0136","kcedil":"\u0137","Kcy":"\u041A","kcy":"\u043A","Kfr":"\uD835\uDD0E","kfr":"\uD835\uDD28","kgreen":"\u0138","KHcy":"\u0425","khcy":"\u0445","KJcy":"\u040C","kjcy":"\u045C","Kopf":"\uD835\uDD42","kopf":"\uD835\uDD5C","Kscr":"\uD835\uDCA6","kscr":"\uD835\uDCC0","lAarr":"\u21DA","Lacute":"\u0139","lacute":"\u013A","laemptyv":"\u29B4","lagran":"\u2112","Lambda":"\u039B","lambda":"\u03BB","lang":"\u27E8","Lang":"\u27EA","langd":"\u2991","langle":"\u27E8","lap":"\u2A85","Laplacetrf":"\u2112","laquo":"\u00AB","larrb":"\u21E4","larrbfs":"\u291F","larr":"\u2190","Larr":"\u219E","lArr":"\u21D0","larrfs":"\u291D","larrhk":"\u21A9","larrlp":"\u21AB","larrpl":"\u2939","larrsim":"\u2973","larrtl":"\u21A2","latail":"\u2919","lAtail":"\u291B","lat":"\u2AAB","late":"\u2AAD","lates":"\u2AAD\uFE00","lbarr":"\u290C","lBarr":"\u290E","lbbrk":"\u2772","lbrace":"{","lbrack":"[","lbrke":"\u298B","lbrksld":"\u298F","lbrkslu":"\u298D","Lcaron":"\u013D","lcaron":"\u013E","Lcedil":"\u013B","lcedil":"\u013C","lceil":"\u2308","lcub":"{","Lcy":"\u041B","lcy":"\u043B","ldca":"\u2936","ldquo":"\u201C","ldquor":"\u201E","ldrdhar":"\u2967","ldrushar":"\u294B","ldsh":"\u21B2","le":"\u2264","lE":"\u2266","LeftAngleBracket":"\u27E8","LeftArrowBar":"\u21E4","leftarrow":"\u2190","LeftArrow":"\u2190","Leftarrow":"\u21D0","LeftArrowRightArrow":"\u21C6","leftarrowtail":"\u21A2","LeftCeiling":"\u2308","LeftDoubleBracket":"\u27E6","LeftDownTeeVector":"\u2961","LeftDownVectorBar":"\u2959","LeftDownVector":"\u21C3","LeftFloor":"\u230A","leftharpoondown":"\u21BD","leftharpoonup":"\u21BC","leftleftarrows":"\u21C7","leftrightarrow":"\u2194","LeftRightArrow":"\u2194","Leftrightarrow":"\u21D4","leftrightarrows":"\u21C6","leftrightharpoons":"\u21CB","leftrightsquigarrow":"\u21AD","LeftRightVector":"\u294E","LeftTeeArrow":"\u21A4","LeftTee":"\u22A3","LeftTeeVector":"\u295A","leftthreetimes":"\u22CB","LeftTriangleBar":"\u29CF","LeftTriangle":"\u22B2","LeftTriangleEqual":"\u22B4","LeftUpDownVector":"\u2951","LeftUpTeeVector":"\u2960","LeftUpVectorBar":"\u2958","LeftUpVector":"\u21BF","LeftVectorBar":"\u2952","LeftVector":"\u21BC","lEg":"\u2A8B","leg":"\u22DA","leq":"\u2264","leqq":"\u2266","leqslant":"\u2A7D","lescc":"\u2AA8","les":"\u2A7D","lesdot":"\u2A7F","lesdoto":"\u2A81","lesdotor":"\u2A83","lesg":"\u22DA\uFE00","lesges":"\u2A93","lessapprox":"\u2A85","lessdot":"\u22D6","lesseqgtr":"\u22DA","lesseqqgtr":"\u2A8B","LessEqualGreater":"\u22DA","LessFullEqual":"\u2266","LessGreater":"\u2276","lessgtr":"\u2276","LessLess":"\u2AA1","lesssim":"\u2272","LessSlantEqual":"\u2A7D","LessTilde":"\u2272","lfisht":"\u297C","lfloor":"\u230A","Lfr":"\uD835\uDD0F","lfr":"\uD835\uDD29","lg":"\u2276","lgE":"\u2A91","lHar":"\u2962","lhard":"\u21BD","lharu":"\u21BC","lharul":"\u296A","lhblk":"\u2584","LJcy":"\u0409","ljcy":"\u0459","llarr":"\u21C7","ll":"\u226A","Ll":"\u22D8","llcorner":"\u231E","Lleftarrow":"\u21DA","llhard":"\u296B","lltri":"\u25FA","Lmidot":"\u013F","lmidot":"\u0140","lmoustache":"\u23B0","lmoust":"\u23B0","lnap":"\u2A89","lnapprox":"\u2A89","lne":"\u2A87","lnE":"\u2268","lneq":"\u2A87","lneqq":"\u2268","lnsim":"\u22E6","loang":"\u27EC","loarr":"\u21FD","lobrk":"\u27E6","longleftarrow":"\u27F5","LongLeftArrow":"\u27F5","Longleftarrow":"\u27F8","longleftrightarrow":"\u27F7","LongLeftRightArrow":"\u27F7","Longleftrightarrow":"\u27FA","longmapsto":"\u27FC","longrightarrow":"\u27F6","LongRightArrow":"\u27F6","Longrightarrow":"\u27F9","looparrowleft":"\u21AB","looparrowright":"\u21AC","lopar":"\u2985","Lopf":"\uD835\uDD43","lopf":"\uD835\uDD5D","loplus":"\u2A2D","lotimes":"\u2A34","lowast":"\u2217","lowbar":"_","LowerLeftArrow":"\u2199","LowerRightArrow":"\u2198","loz":"\u25CA","lozenge":"\u25CA","lozf":"\u29EB","lpar":"(","lparlt":"\u2993","lrarr":"\u21C6","lrcorner":"\u231F","lrhar":"\u21CB","lrhard":"\u296D","lrm":"\u200E","lrtri":"\u22BF","lsaquo":"\u2039","lscr":"\uD835\uDCC1","Lscr":"\u2112","lsh":"\u21B0","Lsh":"\u21B0","lsim":"\u2272","lsime":"\u2A8D","lsimg":"\u2A8F","lsqb":"[","lsquo":"\u2018","lsquor":"\u201A","Lstrok":"\u0141","lstrok":"\u0142","ltcc":"\u2AA6","ltcir":"\u2A79","lt":"<","LT":"<","Lt":"\u226A","ltdot":"\u22D6","lthree":"\u22CB","ltimes":"\u22C9","ltlarr":"\u2976","ltquest":"\u2A7B","ltri":"\u25C3","ltrie":"\u22B4","ltrif":"\u25C2","ltrPar":"\u2996","lurdshar":"\u294A","luruhar":"\u2966","lvertneqq":"\u2268\uFE00","lvnE":"\u2268\uFE00","macr":"\u00AF","male":"\u2642","malt":"\u2720","maltese":"\u2720","Map":"\u2905","map":"\u21A6","mapsto":"\u21A6","mapstodown":"\u21A7","mapstoleft":"\u21A4","mapstoup":"\u21A5","marker":"\u25AE","mcomma":"\u2A29","Mcy":"\u041C","mcy":"\u043C","mdash":"\u2014","mDDot":"\u223A","measuredangle":"\u2221","MediumSpace":"\u205F","Mellintrf":"\u2133","Mfr":"\uD835\uDD10","mfr":"\uD835\uDD2A","mho":"\u2127","micro":"\u00B5","midast":"*","midcir":"\u2AF0","mid":"\u2223","middot":"\u00B7","minusb":"\u229F","minus":"\u2212","minusd":"\u2238","minusdu":"\u2A2A","MinusPlus":"\u2213","mlcp":"\u2ADB","mldr":"\u2026","mnplus":"\u2213","models":"\u22A7","Mopf":"\uD835\uDD44","mopf":"\uD835\uDD5E","mp":"\u2213","mscr":"\uD835\uDCC2","Mscr":"\u2133","mstpos":"\u223E","Mu":"\u039C","mu":"\u03BC","multimap":"\u22B8","mumap":"\u22B8","nabla":"\u2207","Nacute":"\u0143","nacute":"\u0144","nang":"\u2220\u20D2","nap":"\u2249","napE":"\u2A70\u0338","napid":"\u224B\u0338","napos":"\u0149","napprox":"\u2249","natural":"\u266E","naturals":"\u2115","natur":"\u266E","nbsp":"\u00A0","nbump":"\u224E\u0338","nbumpe":"\u224F\u0338","ncap":"\u2A43","Ncaron":"\u0147","ncaron":"\u0148","Ncedil":"\u0145","ncedil":"\u0146","ncong":"\u2247","ncongdot":"\u2A6D\u0338","ncup":"\u2A42","Ncy":"\u041D","ncy":"\u043D","ndash":"\u2013","nearhk":"\u2924","nearr":"\u2197","neArr":"\u21D7","nearrow":"\u2197","ne":"\u2260","nedot":"\u2250\u0338","NegativeMediumSpace":"\u200B","NegativeThickSpace":"\u200B","NegativeThinSpace":"\u200B","NegativeVeryThinSpace":"\u200B","nequiv":"\u2262","nesear":"\u2928","nesim":"\u2242\u0338","NestedGreaterGreater":"\u226B","NestedLessLess":"\u226A","NewLine":"\n","nexist":"\u2204","nexists":"\u2204","Nfr":"\uD835\uDD11","nfr":"\uD835\uDD2B","ngE":"\u2267\u0338","nge":"\u2271","ngeq":"\u2271","ngeqq":"\u2267\u0338","ngeqslant":"\u2A7E\u0338","nges":"\u2A7E\u0338","nGg":"\u22D9\u0338","ngsim":"\u2275","nGt":"\u226B\u20D2","ngt":"\u226F","ngtr":"\u226F","nGtv":"\u226B\u0338","nharr":"\u21AE","nhArr":"\u21CE","nhpar":"\u2AF2","ni":"\u220B","nis":"\u22FC","nisd":"\u22FA","niv":"\u220B","NJcy":"\u040A","njcy":"\u045A","nlarr":"\u219A","nlArr":"\u21CD","nldr":"\u2025","nlE":"\u2266\u0338","nle":"\u2270","nleftarrow":"\u219A","nLeftarrow":"\u21CD","nleftrightarrow":"\u21AE","nLeftrightarrow":"\u21CE","nleq":"\u2270","nleqq":"\u2266\u0338","nleqslant":"\u2A7D\u0338","nles":"\u2A7D\u0338","nless":"\u226E","nLl":"\u22D8\u0338","nlsim":"\u2274","nLt":"\u226A\u20D2","nlt":"\u226E","nltri":"\u22EA","nltrie":"\u22EC","nLtv":"\u226A\u0338","nmid":"\u2224","NoBreak":"\u2060","NonBreakingSpace":"\u00A0","nopf":"\uD835\uDD5F","Nopf":"\u2115","Not":"\u2AEC","not":"\u00AC","NotCongruent":"\u2262","NotCupCap":"\u226D","NotDoubleVerticalBar":"\u2226","NotElement":"\u2209","NotEqual":"\u2260","NotEqualTilde":"\u2242\u0338","NotExists":"\u2204","NotGreater":"\u226F","NotGreaterEqual":"\u2271","NotGreaterFullEqual":"\u2267\u0338","NotGreaterGreater":"\u226B\u0338","NotGreaterLess":"\u2279","NotGreaterSlantEqual":"\u2A7E\u0338","NotGreaterTilde":"\u2275","NotHumpDownHump":"\u224E\u0338","NotHumpEqual":"\u224F\u0338","notin":"\u2209","notindot":"\u22F5\u0338","notinE":"\u22F9\u0338","notinva":"\u2209","notinvb":"\u22F7","notinvc":"\u22F6","NotLeftTriangleBar":"\u29CF\u0338","NotLeftTriangle":"\u22EA","NotLeftTriangleEqual":"\u22EC","NotLess":"\u226E","NotLessEqual":"\u2270","NotLessGreater":"\u2278","NotLessLess":"\u226A\u0338","NotLessSlantEqual":"\u2A7D\u0338","NotLessTilde":"\u2274","NotNestedGreaterGreater":"\u2AA2\u0338","NotNestedLessLess":"\u2AA1\u0338","notni":"\u220C","notniva":"\u220C","notnivb":"\u22FE","notnivc":"\u22FD","NotPrecedes":"\u2280","NotPrecedesEqual":"\u2AAF\u0338","NotPrecedesSlantEqual":"\u22E0","NotReverseElement":"\u220C","NotRightTriangleBar":"\u29D0\u0338","NotRightTriangle":"\u22EB","NotRightTriangleEqual":"\u22ED","NotSquareSubset":"\u228F\u0338","NotSquareSubsetEqual":"\u22E2","NotSquareSuperset":"\u2290\u0338","NotSquareSupersetEqual":"\u22E3","NotSubset":"\u2282\u20D2","NotSubsetEqual":"\u2288","NotSucceeds":"\u2281","NotSucceedsEqual":"\u2AB0\u0338","NotSucceedsSlantEqual":"\u22E1","NotSucceedsTilde":"\u227F\u0338","NotSuperset":"\u2283\u20D2","NotSupersetEqual":"\u2289","NotTilde":"\u2241","NotTildeEqual":"\u2244","NotTildeFullEqual":"\u2247","NotTildeTilde":"\u2249","NotVerticalBar":"\u2224","nparallel":"\u2226","npar":"\u2226","nparsl":"\u2AFD\u20E5","npart":"\u2202\u0338","npolint":"\u2A14","npr":"\u2280","nprcue":"\u22E0","nprec":"\u2280","npreceq":"\u2AAF\u0338","npre":"\u2AAF\u0338","nrarrc":"\u2933\u0338","nrarr":"\u219B","nrArr":"\u21CF","nrarrw":"\u219D\u0338","nrightarrow":"\u219B","nRightarrow":"\u21CF","nrtri":"\u22EB","nrtrie":"\u22ED","nsc":"\u2281","nsccue":"\u22E1","nsce":"\u2AB0\u0338","Nscr":"\uD835\uDCA9","nscr":"\uD835\uDCC3","nshortmid":"\u2224","nshortparallel":"\u2226","nsim":"\u2241","nsime":"\u2244","nsimeq":"\u2244","nsmid":"\u2224","nspar":"\u2226","nsqsube":"\u22E2","nsqsupe":"\u22E3","nsub":"\u2284","nsubE":"\u2AC5\u0338","nsube":"\u2288","nsubset":"\u2282\u20D2","nsubseteq":"\u2288","nsubseteqq":"\u2AC5\u0338","nsucc":"\u2281","nsucceq":"\u2AB0\u0338","nsup":"\u2285","nsupE":"\u2AC6\u0338","nsupe":"\u2289","nsupset":"\u2283\u20D2","nsupseteq":"\u2289","nsupseteqq":"\u2AC6\u0338","ntgl":"\u2279","Ntilde":"\u00D1","ntilde":"\u00F1","ntlg":"\u2278","ntriangleleft":"\u22EA","ntrianglelefteq":"\u22EC","ntriangleright":"\u22EB","ntrianglerighteq":"\u22ED","Nu":"\u039D","nu":"\u03BD","num":"#","numero":"\u2116","numsp":"\u2007","nvap":"\u224D\u20D2","nvdash":"\u22AC","nvDash":"\u22AD","nVdash":"\u22AE","nVDash":"\u22AF","nvge":"\u2265\u20D2","nvgt":">\u20D2","nvHarr":"\u2904","nvinfin":"\u29DE","nvlArr":"\u2902","nvle":"\u2264\u20D2","nvlt":"<\u20D2","nvltrie":"\u22B4\u20D2","nvrArr":"\u2903","nvrtrie":"\u22B5\u20D2","nvsim":"\u223C\u20D2","nwarhk":"\u2923","nwarr":"\u2196","nwArr":"\u21D6","nwarrow":"\u2196","nwnear":"\u2927","Oacute":"\u00D3","oacute":"\u00F3","oast":"\u229B","Ocirc":"\u00D4","ocirc":"\u00F4","ocir":"\u229A","Ocy":"\u041E","ocy":"\u043E","odash":"\u229D","Odblac":"\u0150","odblac":"\u0151","odiv":"\u2A38","odot":"\u2299","odsold":"\u29BC","OElig":"\u0152","oelig":"\u0153","ofcir":"\u29BF","Ofr":"\uD835\uDD12","ofr":"\uD835\uDD2C","ogon":"\u02DB","Ograve":"\u00D2","ograve":"\u00F2","ogt":"\u29C1","ohbar":"\u29B5","ohm":"\u03A9","oint":"\u222E","olarr":"\u21BA","olcir":"\u29BE","olcross":"\u29BB","oline":"\u203E","olt":"\u29C0","Omacr":"\u014C","omacr":"\u014D","Omega":"\u03A9","omega":"\u03C9","Omicron":"\u039F","omicron":"\u03BF","omid":"\u29B6","ominus":"\u2296","Oopf":"\uD835\uDD46","oopf":"\uD835\uDD60","opar":"\u29B7","OpenCurlyDoubleQuote":"\u201C","OpenCurlyQuote":"\u2018","operp":"\u29B9","oplus":"\u2295","orarr":"\u21BB","Or":"\u2A54","or":"\u2228","ord":"\u2A5D","order":"\u2134","orderof":"\u2134","ordf":"\u00AA","ordm":"\u00BA","origof":"\u22B6","oror":"\u2A56","orslope":"\u2A57","orv":"\u2A5B","oS":"\u24C8","Oscr":"\uD835\uDCAA","oscr":"\u2134","Oslash":"\u00D8","oslash":"\u00F8","osol":"\u2298","Otilde":"\u00D5","otilde":"\u00F5","otimesas":"\u2A36","Otimes":"\u2A37","otimes":"\u2297","Ouml":"\u00D6","ouml":"\u00F6","ovbar":"\u233D","OverBar":"\u203E","OverBrace":"\u23DE","OverBracket":"\u23B4","OverParenthesis":"\u23DC","para":"\u00B6","parallel":"\u2225","par":"\u2225","parsim":"\u2AF3","parsl":"\u2AFD","part":"\u2202","PartialD":"\u2202","Pcy":"\u041F","pcy":"\u043F","percnt":"%","period":".","permil":"\u2030","perp":"\u22A5","pertenk":"\u2031","Pfr":"\uD835\uDD13","pfr":"\uD835\uDD2D","Phi":"\u03A6","phi":"\u03C6","phiv":"\u03D5","phmmat":"\u2133","phone":"\u260E","Pi":"\u03A0","pi":"\u03C0","pitchfork":"\u22D4","piv":"\u03D6","planck":"\u210F","planckh":"\u210E","plankv":"\u210F","plusacir":"\u2A23","plusb":"\u229E","pluscir":"\u2A22","plus":"+","plusdo":"\u2214","plusdu":"\u2A25","pluse":"\u2A72","PlusMinus":"\u00B1","plusmn":"\u00B1","plussim":"\u2A26","plustwo":"\u2A27","pm":"\u00B1","Poincareplane":"\u210C","pointint":"\u2A15","popf":"\uD835\uDD61","Popf":"\u2119","pound":"\u00A3","prap":"\u2AB7","Pr":"\u2ABB","pr":"\u227A","prcue":"\u227C","precapprox":"\u2AB7","prec":"\u227A","preccurlyeq":"\u227C","Precedes":"\u227A","PrecedesEqual":"\u2AAF","PrecedesSlantEqual":"\u227C","PrecedesTilde":"\u227E","preceq":"\u2AAF","precnapprox":"\u2AB9","precneqq":"\u2AB5","precnsim":"\u22E8","pre":"\u2AAF","prE":"\u2AB3","precsim":"\u227E","prime":"\u2032","Prime":"\u2033","primes":"\u2119","prnap":"\u2AB9","prnE":"\u2AB5","prnsim":"\u22E8","prod":"\u220F","Product":"\u220F","profalar":"\u232E","profline":"\u2312","profsurf":"\u2313","prop":"\u221D","Proportional":"\u221D","Proportion":"\u2237","propto":"\u221D","prsim":"\u227E","prurel":"\u22B0","Pscr":"\uD835\uDCAB","pscr":"\uD835\uDCC5","Psi":"\u03A8","psi":"\u03C8","puncsp":"\u2008","Qfr":"\uD835\uDD14","qfr":"\uD835\uDD2E","qint":"\u2A0C","qopf":"\uD835\uDD62","Qopf":"\u211A","qprime":"\u2057","Qscr":"\uD835\uDCAC","qscr":"\uD835\uDCC6","quaternions":"\u210D","quatint":"\u2A16","quest":"?","questeq":"\u225F","quot":"\"","QUOT":"\"","rAarr":"\u21DB","race":"\u223D\u0331","Racute":"\u0154","racute":"\u0155","radic":"\u221A","raemptyv":"\u29B3","rang":"\u27E9","Rang":"\u27EB","rangd":"\u2992","range":"\u29A5","rangle":"\u27E9","raquo":"\u00BB","rarrap":"\u2975","rarrb":"\u21E5","rarrbfs":"\u2920","rarrc":"\u2933","rarr":"\u2192","Rarr":"\u21A0","rArr":"\u21D2","rarrfs":"\u291E","rarrhk":"\u21AA","rarrlp":"\u21AC","rarrpl":"\u2945","rarrsim":"\u2974","Rarrtl":"\u2916","rarrtl":"\u21A3","rarrw":"\u219D","ratail":"\u291A","rAtail":"\u291C","ratio":"\u2236","rationals":"\u211A","rbarr":"\u290D","rBarr":"\u290F","RBarr":"\u2910","rbbrk":"\u2773","rbrace":"}","rbrack":"]","rbrke":"\u298C","rbrksld":"\u298E","rbrkslu":"\u2990","Rcaron":"\u0158","rcaron":"\u0159","Rcedil":"\u0156","rcedil":"\u0157","rceil":"\u2309","rcub":"}","Rcy":"\u0420","rcy":"\u0440","rdca":"\u2937","rdldhar":"\u2969","rdquo":"\u201D","rdquor":"\u201D","rdsh":"\u21B3","real":"\u211C","realine":"\u211B","realpart":"\u211C","reals":"\u211D","Re":"\u211C","rect":"\u25AD","reg":"\u00AE","REG":"\u00AE","ReverseElement":"\u220B","ReverseEquilibrium":"\u21CB","ReverseUpEquilibrium":"\u296F","rfisht":"\u297D","rfloor":"\u230B","rfr":"\uD835\uDD2F","Rfr":"\u211C","rHar":"\u2964","rhard":"\u21C1","rharu":"\u21C0","rharul":"\u296C","Rho":"\u03A1","rho":"\u03C1","rhov":"\u03F1","RightAngleBracket":"\u27E9","RightArrowBar":"\u21E5","rightarrow":"\u2192","RightArrow":"\u2192","Rightarrow":"\u21D2","RightArrowLeftArrow":"\u21C4","rightarrowtail":"\u21A3","RightCeiling":"\u2309","RightDoubleBracket":"\u27E7","RightDownTeeVector":"\u295D","RightDownVectorBar":"\u2955","RightDownVector":"\u21C2","RightFloor":"\u230B","rightharpoondown":"\u21C1","rightharpoonup":"\u21C0","rightleftarrows":"\u21C4","rightleftharpoons":"\u21CC","rightrightarrows":"\u21C9","rightsquigarrow":"\u219D","RightTeeArrow":"\u21A6","RightTee":"\u22A2","RightTeeVector":"\u295B","rightthreetimes":"\u22CC","RightTriangleBar":"\u29D0","RightTriangle":"\u22B3","RightTriangleEqual":"\u22B5","RightUpDownVector":"\u294F","RightUpTeeVector":"\u295C","RightUpVectorBar":"\u2954","RightUpVector":"\u21BE","RightVectorBar":"\u2953","RightVector":"\u21C0","ring":"\u02DA","risingdotseq":"\u2253","rlarr":"\u21C4","rlhar":"\u21CC","rlm":"\u200F","rmoustache":"\u23B1","rmoust":"\u23B1","rnmid":"\u2AEE","roang":"\u27ED","roarr":"\u21FE","robrk":"\u27E7","ropar":"\u2986","ropf":"\uD835\uDD63","Ropf":"\u211D","roplus":"\u2A2E","rotimes":"\u2A35","RoundImplies":"\u2970","rpar":")","rpargt":"\u2994","rppolint":"\u2A12","rrarr":"\u21C9","Rrightarrow":"\u21DB","rsaquo":"\u203A","rscr":"\uD835\uDCC7","Rscr":"\u211B","rsh":"\u21B1","Rsh":"\u21B1","rsqb":"]","rsquo":"\u2019","rsquor":"\u2019","rthree":"\u22CC","rtimes":"\u22CA","rtri":"\u25B9","rtrie":"\u22B5","rtrif":"\u25B8","rtriltri":"\u29CE","RuleDelayed":"\u29F4","ruluhar":"\u2968","rx":"\u211E","Sacute":"\u015A","sacute":"\u015B","sbquo":"\u201A","scap":"\u2AB8","Scaron":"\u0160","scaron":"\u0161","Sc":"\u2ABC","sc":"\u227B","sccue":"\u227D","sce":"\u2AB0","scE":"\u2AB4","Scedil":"\u015E","scedil":"\u015F","Scirc":"\u015C","scirc":"\u015D","scnap":"\u2ABA","scnE":"\u2AB6","scnsim":"\u22E9","scpolint":"\u2A13","scsim":"\u227F","Scy":"\u0421","scy":"\u0441","sdotb":"\u22A1","sdot":"\u22C5","sdote":"\u2A66","searhk":"\u2925","searr":"\u2198","seArr":"\u21D8","searrow":"\u2198","sect":"\u00A7","semi":";","seswar":"\u2929","setminus":"\u2216","setmn":"\u2216","sext":"\u2736","Sfr":"\uD835\uDD16","sfr":"\uD835\uDD30","sfrown":"\u2322","sharp":"\u266F","SHCHcy":"\u0429","shchcy":"\u0449","SHcy":"\u0428","shcy":"\u0448","ShortDownArrow":"\u2193","ShortLeftArrow":"\u2190","shortmid":"\u2223","shortparallel":"\u2225","ShortRightArrow":"\u2192","ShortUpArrow":"\u2191","shy":"\u00AD","Sigma":"\u03A3","sigma":"\u03C3","sigmaf":"\u03C2","sigmav":"\u03C2","sim":"\u223C","simdot":"\u2A6A","sime":"\u2243","simeq":"\u2243","simg":"\u2A9E","simgE":"\u2AA0","siml":"\u2A9D","simlE":"\u2A9F","simne":"\u2246","simplus":"\u2A24","simrarr":"\u2972","slarr":"\u2190","SmallCircle":"\u2218","smallsetminus":"\u2216","smashp":"\u2A33","smeparsl":"\u29E4","smid":"\u2223","smile":"\u2323","smt":"\u2AAA","smte":"\u2AAC","smtes":"\u2AAC\uFE00","SOFTcy":"\u042C","softcy":"\u044C","solbar":"\u233F","solb":"\u29C4","sol":"/","Sopf":"\uD835\uDD4A","sopf":"\uD835\uDD64","spades":"\u2660","spadesuit":"\u2660","spar":"\u2225","sqcap":"\u2293","sqcaps":"\u2293\uFE00","sqcup":"\u2294","sqcups":"\u2294\uFE00","Sqrt":"\u221A","sqsub":"\u228F","sqsube":"\u2291","sqsubset":"\u228F","sqsubseteq":"\u2291","sqsup":"\u2290","sqsupe":"\u2292","sqsupset":"\u2290","sqsupseteq":"\u2292","square":"\u25A1","Square":"\u25A1","SquareIntersection":"\u2293","SquareSubset":"\u228F","SquareSubsetEqual":"\u2291","SquareSuperset":"\u2290","SquareSupersetEqual":"\u2292","SquareUnion":"\u2294","squarf":"\u25AA","squ":"\u25A1","squf":"\u25AA","srarr":"\u2192","Sscr":"\uD835\uDCAE","sscr":"\uD835\uDCC8","ssetmn":"\u2216","ssmile":"\u2323","sstarf":"\u22C6","Star":"\u22C6","star":"\u2606","starf":"\u2605","straightepsilon":"\u03F5","straightphi":"\u03D5","strns":"\u00AF","sub":"\u2282","Sub":"\u22D0","subdot":"\u2ABD","subE":"\u2AC5","sube":"\u2286","subedot":"\u2AC3","submult":"\u2AC1","subnE":"\u2ACB","subne":"\u228A","subplus":"\u2ABF","subrarr":"\u2979","subset":"\u2282","Subset":"\u22D0","subseteq":"\u2286","subseteqq":"\u2AC5","SubsetEqual":"\u2286","subsetneq":"\u228A","subsetneqq":"\u2ACB","subsim":"\u2AC7","subsub":"\u2AD5","subsup":"\u2AD3","succapprox":"\u2AB8","succ":"\u227B","succcurlyeq":"\u227D","Succeeds":"\u227B","SucceedsEqual":"\u2AB0","SucceedsSlantEqual":"\u227D","SucceedsTilde":"\u227F","succeq":"\u2AB0","succnapprox":"\u2ABA","succneqq":"\u2AB6","succnsim":"\u22E9","succsim":"\u227F","SuchThat":"\u220B","sum":"\u2211","Sum":"\u2211","sung":"\u266A","sup1":"\u00B9","sup2":"\u00B2","sup3":"\u00B3","sup":"\u2283","Sup":"\u22D1","supdot":"\u2ABE","supdsub":"\u2AD8","supE":"\u2AC6","supe":"\u2287","supedot":"\u2AC4","Superset":"\u2283","SupersetEqual":"\u2287","suphsol":"\u27C9","suphsub":"\u2AD7","suplarr":"\u297B","supmult":"\u2AC2","supnE":"\u2ACC","supne":"\u228B","supplus":"\u2AC0","supset":"\u2283","Supset":"\u22D1","supseteq":"\u2287","supseteqq":"\u2AC6","supsetneq":"\u228B","supsetneqq":"\u2ACC","supsim":"\u2AC8","supsub":"\u2AD4","supsup":"\u2AD6","swarhk":"\u2926","swarr":"\u2199","swArr":"\u21D9","swarrow":"\u2199","swnwar":"\u292A","szlig":"\u00DF","Tab":"\t","target":"\u2316","Tau":"\u03A4","tau":"\u03C4","tbrk":"\u23B4","Tcaron":"\u0164","tcaron":"\u0165","Tcedil":"\u0162","tcedil":"\u0163","Tcy":"\u0422","tcy":"\u0442","tdot":"\u20DB","telrec":"\u2315","Tfr":"\uD835\uDD17","tfr":"\uD835\uDD31","there4":"\u2234","therefore":"\u2234","Therefore":"\u2234","Theta":"\u0398","theta":"\u03B8","thetasym":"\u03D1","thetav":"\u03D1","thickapprox":"\u2248","thicksim":"\u223C","ThickSpace":"\u205F\u200A","ThinSpace":"\u2009","thinsp":"\u2009","thkap":"\u2248","thksim":"\u223C","THORN":"\u00DE","thorn":"\u00FE","tilde":"\u02DC","Tilde":"\u223C","TildeEqual":"\u2243","TildeFullEqual":"\u2245","TildeTilde":"\u2248","timesbar":"\u2A31","timesb":"\u22A0","times":"\u00D7","timesd":"\u2A30","tint":"\u222D","toea":"\u2928","topbot":"\u2336","topcir":"\u2AF1","top":"\u22A4","Topf":"\uD835\uDD4B","topf":"\uD835\uDD65","topfork":"\u2ADA","tosa":"\u2929","tprime":"\u2034","trade":"\u2122","TRADE":"\u2122","triangle":"\u25B5","triangledown":"\u25BF","triangleleft":"\u25C3","trianglelefteq":"\u22B4","triangleq":"\u225C","triangleright":"\u25B9","trianglerighteq":"\u22B5","tridot":"\u25EC","trie":"\u225C","triminus":"\u2A3A","TripleDot":"\u20DB","triplus":"\u2A39","trisb":"\u29CD","tritime":"\u2A3B","trpezium":"\u23E2","Tscr":"\uD835\uDCAF","tscr":"\uD835\uDCC9","TScy":"\u0426","tscy":"\u0446","TSHcy":"\u040B","tshcy":"\u045B","Tstrok":"\u0166","tstrok":"\u0167","twixt":"\u226C","twoheadleftarrow":"\u219E","twoheadrightarrow":"\u21A0","Uacute":"\u00DA","uacute":"\u00FA","uarr":"\u2191","Uarr":"\u219F","uArr":"\u21D1","Uarrocir":"\u2949","Ubrcy":"\u040E","ubrcy":"\u045E","Ubreve":"\u016C","ubreve":"\u016D","Ucirc":"\u00DB","ucirc":"\u00FB","Ucy":"\u0423","ucy":"\u0443","udarr":"\u21C5","Udblac":"\u0170","udblac":"\u0171","udhar":"\u296E","ufisht":"\u297E","Ufr":"\uD835\uDD18","ufr":"\uD835\uDD32","Ugrave":"\u00D9","ugrave":"\u00F9","uHar":"\u2963","uharl":"\u21BF","uharr":"\u21BE","uhblk":"\u2580","ulcorn":"\u231C","ulcorner":"\u231C","ulcrop":"\u230F","ultri":"\u25F8","Umacr":"\u016A","umacr":"\u016B","uml":"\u00A8","UnderBar":"_","UnderBrace":"\u23DF","UnderBracket":"\u23B5","UnderParenthesis":"\u23DD","Union":"\u22C3","UnionPlus":"\u228E","Uogon":"\u0172","uogon":"\u0173","Uopf":"\uD835\uDD4C","uopf":"\uD835\uDD66","UpArrowBar":"\u2912","uparrow":"\u2191","UpArrow":"\u2191","Uparrow":"\u21D1","UpArrowDownArrow":"\u21C5","updownarrow":"\u2195","UpDownArrow":"\u2195","Updownarrow":"\u21D5","UpEquilibrium":"\u296E","upharpoonleft":"\u21BF","upharpoonright":"\u21BE","uplus":"\u228E","UpperLeftArrow":"\u2196","UpperRightArrow":"\u2197","upsi":"\u03C5","Upsi":"\u03D2","upsih":"\u03D2","Upsilon":"\u03A5","upsilon":"\u03C5","UpTeeArrow":"\u21A5","UpTee":"\u22A5","upuparrows":"\u21C8","urcorn":"\u231D","urcorner":"\u231D","urcrop":"\u230E","Uring":"\u016E","uring":"\u016F","urtri":"\u25F9","Uscr":"\uD835\uDCB0","uscr":"\uD835\uDCCA","utdot":"\u22F0","Utilde":"\u0168","utilde":"\u0169","utri":"\u25B5","utrif":"\u25B4","uuarr":"\u21C8","Uuml":"\u00DC","uuml":"\u00FC","uwangle":"\u29A7","vangrt":"\u299C","varepsilon":"\u03F5","varkappa":"\u03F0","varnothing":"\u2205","varphi":"\u03D5","varpi":"\u03D6","varpropto":"\u221D","varr":"\u2195","vArr":"\u21D5","varrho":"\u03F1","varsigma":"\u03C2","varsubsetneq":"\u228A\uFE00","varsubsetneqq":"\u2ACB\uFE00","varsupsetneq":"\u228B\uFE00","varsupsetneqq":"\u2ACC\uFE00","vartheta":"\u03D1","vartriangleleft":"\u22B2","vartriangleright":"\u22B3","vBar":"\u2AE8","Vbar":"\u2AEB","vBarv":"\u2AE9","Vcy":"\u0412","vcy":"\u0432","vdash":"\u22A2","vDash":"\u22A8","Vdash":"\u22A9","VDash":"\u22AB","Vdashl":"\u2AE6","veebar":"\u22BB","vee":"\u2228","Vee":"\u22C1","veeeq":"\u225A","vellip":"\u22EE","verbar":"|","Verbar":"\u2016","vert":"|","Vert":"\u2016","VerticalBar":"\u2223","VerticalLine":"|","VerticalSeparator":"\u2758","VerticalTilde":"\u2240","VeryThinSpace":"\u200A","Vfr":"\uD835\uDD19","vfr":"\uD835\uDD33","vltri":"\u22B2","vnsub":"\u2282\u20D2","vnsup":"\u2283\u20D2","Vopf":"\uD835\uDD4D","vopf":"\uD835\uDD67","vprop":"\u221D","vrtri":"\u22B3","Vscr":"\uD835\uDCB1","vscr":"\uD835\uDCCB","vsubnE":"\u2ACB\uFE00","vsubne":"\u228A\uFE00","vsupnE":"\u2ACC\uFE00","vsupne":"\u228B\uFE00","Vvdash":"\u22AA","vzigzag":"\u299A","Wcirc":"\u0174","wcirc":"\u0175","wedbar":"\u2A5F","wedge":"\u2227","Wedge":"\u22C0","wedgeq":"\u2259","weierp":"\u2118","Wfr":"\uD835\uDD1A","wfr":"\uD835\uDD34","Wopf":"\uD835\uDD4E","wopf":"\uD835\uDD68","wp":"\u2118","wr":"\u2240","wreath":"\u2240","Wscr":"\uD835\uDCB2","wscr":"\uD835\uDCCC","xcap":"\u22C2","xcirc":"\u25EF","xcup":"\u22C3","xdtri":"\u25BD","Xfr":"\uD835\uDD1B","xfr":"\uD835\uDD35","xharr":"\u27F7","xhArr":"\u27FA","Xi":"\u039E","xi":"\u03BE","xlarr":"\u27F5","xlArr":"\u27F8","xmap":"\u27FC","xnis":"\u22FB","xodot":"\u2A00","Xopf":"\uD835\uDD4F","xopf":"\uD835\uDD69","xoplus":"\u2A01","xotime":"\u2A02","xrarr":"\u27F6","xrArr":"\u27F9","Xscr":"\uD835\uDCB3","xscr":"\uD835\uDCCD","xsqcup":"\u2A06","xuplus":"\u2A04","xutri":"\u25B3","xvee":"\u22C1","xwedge":"\u22C0","Yacute":"\u00DD","yacute":"\u00FD","YAcy":"\u042F","yacy":"\u044F","Ycirc":"\u0176","ycirc":"\u0177","Ycy":"\u042B","ycy":"\u044B","yen":"\u00A5","Yfr":"\uD835\uDD1C","yfr":"\uD835\uDD36","YIcy":"\u0407","yicy":"\u0457","Yopf":"\uD835\uDD50","yopf":"\uD835\uDD6A","Yscr":"\uD835\uDCB4","yscr":"\uD835\uDCCE","YUcy":"\u042E","yucy":"\u044E","yuml":"\u00FF","Yuml":"\u0178","Zacute":"\u0179","zacute":"\u017A","Zcaron":"\u017D","zcaron":"\u017E","Zcy":"\u0417","zcy":"\u0437","Zdot":"\u017B","zdot":"\u017C","zeetrf":"\u2128","ZeroWidthSpace":"\u200B","Zeta":"\u0396","zeta":"\u03B6","zfr":"\uD835\uDD37","Zfr":"\u2128","ZHcy":"\u0416","zhcy":"\u0436","zigrarr":"\u21DD","zopf":"\uD835\uDD6B","Zopf":"\u2124","Zscr":"\uD835\uDCB5","zscr":"\uD835\uDCCF","zwj":"\u200D","zwnj":"\u200C"}
},{}],103:[function(require,module,exports){
module.exports={"Aacute":"\u00C1","aacute":"\u00E1","Acirc":"\u00C2","acirc":"\u00E2","acute":"\u00B4","AElig":"\u00C6","aelig":"\u00E6","Agrave":"\u00C0","agrave":"\u00E0","amp":"&","AMP":"&","Aring":"\u00C5","aring":"\u00E5","Atilde":"\u00C3","atilde":"\u00E3","Auml":"\u00C4","auml":"\u00E4","brvbar":"\u00A6","Ccedil":"\u00C7","ccedil":"\u00E7","cedil":"\u00B8","cent":"\u00A2","copy":"\u00A9","COPY":"\u00A9","curren":"\u00A4","deg":"\u00B0","divide":"\u00F7","Eacute":"\u00C9","eacute":"\u00E9","Ecirc":"\u00CA","ecirc":"\u00EA","Egrave":"\u00C8","egrave":"\u00E8","ETH":"\u00D0","eth":"\u00F0","Euml":"\u00CB","euml":"\u00EB","frac12":"\u00BD","frac14":"\u00BC","frac34":"\u00BE","gt":">","GT":">","Iacute":"\u00CD","iacute":"\u00ED","Icirc":"\u00CE","icirc":"\u00EE","iexcl":"\u00A1","Igrave":"\u00CC","igrave":"\u00EC","iquest":"\u00BF","Iuml":"\u00CF","iuml":"\u00EF","laquo":"\u00AB","lt":"<","LT":"<","macr":"\u00AF","micro":"\u00B5","middot":"\u00B7","nbsp":"\u00A0","not":"\u00AC","Ntilde":"\u00D1","ntilde":"\u00F1","Oacute":"\u00D3","oacute":"\u00F3","Ocirc":"\u00D4","ocirc":"\u00F4","Ograve":"\u00D2","ograve":"\u00F2","ordf":"\u00AA","ordm":"\u00BA","Oslash":"\u00D8","oslash":"\u00F8","Otilde":"\u00D5","otilde":"\u00F5","Ouml":"\u00D6","ouml":"\u00F6","para":"\u00B6","plusmn":"\u00B1","pound":"\u00A3","quot":"\"","QUOT":"\"","raquo":"\u00BB","reg":"\u00AE","REG":"\u00AE","sect":"\u00A7","shy":"\u00AD","sup1":"\u00B9","sup2":"\u00B2","sup3":"\u00B3","szlig":"\u00DF","THORN":"\u00DE","thorn":"\u00FE","times":"\u00D7","Uacute":"\u00DA","uacute":"\u00FA","Ucirc":"\u00DB","ucirc":"\u00FB","Ugrave":"\u00D9","ugrave":"\u00F9","uml":"\u00A8","Uuml":"\u00DC","uuml":"\u00FC","Yacute":"\u00DD","yacute":"\u00FD","yen":"\u00A5","yuml":"\u00FF"}
},{}],104:[function(require,module,exports){
module.exports={"amp":"&","apos":"'","gt":">","lt":"<","quot":"\""}

},{}],105:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],106:[function(require,module,exports){
module.exports={
  "html": {
    "content": [ "<head>", "<body>" ],
    "singular": true
  },
  "head": {
    "content": [ "metadata content" ],
    "parent": [ "<html>" ],
    "singular": true
  },
  "body": {
    "categories": [ "sectioning root" ],
    "content": [ "flow content" ],
    "parent": [ "<html>" ],
    "singular": true
  },

  "title": {
    "categories": [ "metadata content" ],
    "content": [ "text" ],
    "parent": [ "<head>" ],
    "singular": true
  },
  "base": {
    "categories": [ "metadata content" ],
    "parent": [ "<head>" ],
    "singular": true
  },
  "link": {
    "categories": [ "metadata content" ],
    "parent": [ "<head>" ]
  },
  "meta": {
    "categories": [ "metadata content" ],
    "parent": [ "<head>" ]
  },
  "style": {
    "categories": [ "metadata content" ],
    "content": [ "text" ],
    "parent": [ "<head>" ]
  },

  "address": {
    "categories": [ "flow content", "palpable content" ],
    "content": [ "flow content" ],
    "disallow": [ "<address>", "heading content", "sectioning content", "<header>", "<footer>" ]
  },
  "article": {
    "categories": [ "flow content", "sectioning content", "palpable content" ],
    "content": [ "flow content" ],
    "disallow": [ "<main>" ],
    "nospec": [ "4.01" ]
  },
  "aside": {
    "categories": [ "flow content", "sectioning content", "palpable content" ],
    "content": [ "flow content" ],
    "disallow": [ "<main>" ],
    "nospec": [ "4.01" ]
  },
  "footer": {
    "categories": [ "flow content", "palpable content" ],
    "content": [ "flow content" ],
    "disallow": [ "<footer>", "<header>", "<main>" ],
    "nospec": [ "4.01" ]
  },
  "header": {
    "categories": [ "flow content", "palpable content" ],
    "content": [ "flow content" ],
    "disallow": [ "<footer>", "<header>", "<main>" ],
    "nospec": [ "4.01" ]
  },
  "h1": {
    "categories": [ "flow content", "heading content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "h2": {
    "categories": [ "flow content", "heading content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "h3": {
    "categories": [ "flow content", "heading content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "h4": {
    "categories": [ "flow content", "heading content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "h5": {
    "categories": [ "flow content", "heading content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "h6": {
    "categories": [ "flow content", "heading content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "nav": {
    "categories": [ "flow content", "sectioning content", "palpable content" ],
    "content": [ "flow content" ],
    "disallow": [ "<main>" ],
    "nospec": [ "4.01" ]
  },

  "blockquote": {
    "categories": [ "flow content", "sectioning root", "palpable content" ],
    "content": [ "flow content" ]
  },
  "dd": {
    "content": [ "flow content" ],
    "parent": [ "<dl>" ],
    "previous": [ "<dt>", "<dd>" ]
  },
  "div": {
    "categories": [ "flow content", "palpable content" ],
    "content": [ "flow content" ]
  },
  "dl": {
    "categories": [ "flow content" ],
    "content": [ "<dt>", "<dd>" ]
  },
  "dt": {
    "content": [ "flow content" ],
    "parent": [ "<dl>" ],
    "disallow": [ "<footer>", "<header>", "sectioning content", "heading content" ],
    "next": [ "<dt>", "<dd>" ]
  },
  "figcaption": {
    "content": [ "flow content" ],
    "parent": [ "<figure>" ],
    "position": [ "first", "last" ],
    "nospec": [ "4.01" ]
  },
  "figure": {
    "categories": [ "flow content", "sectioning root", "palpable content" ],
    "content": [ "flow content", "<figcaption>" ],
    "nospec": [ "4.01" ]
  },
  "hr": {
    "categories": [ "flow content" ]
  },
  "li": {
    "content": [ "flow content" ],
    "parent": [ "<ul>", "<ol>", "<menu>" ]
  },
  "main": {
    "categories": [ "flow content", "palpable content" ],
    "content": [ "flow content" ],
    "nospec": [ "4.01" ]
  },
  "ol": {
    "categories": [ "flow content" ],
    "content": [ "<li>" ],
    "states": {
      ":not(:empty)": {
        "categories": [ "palpable content" ]
      }
    }
  },
  "p": {
    "categories": [ "flow content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "pre": {
    "categories": [ "flow content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "section": {
    "categories": [ "flow content", "sectioning content", "palpable content" ],
    "content": [ "flow content" ],
    "nospec": [ "4.01" ]
  },
  "ul": {
    "categories": [ "flow content" ],
    "content": [ "<li>" ],
    "states": {
      ":not(:empty)": {
        "categories": [ "palpable content" ]
      }
    }
  },

  "a": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "flow content", "phrasing content" ],
    "disallow": [ "interactive content" ],
    "states": {
      "[href]" : {
        "categories": [ "interactive content" ]
      }
    }
  },
  "abbr": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "b": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "bdi": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ],
    "nospec": [ "4.01" ]
  },
  "bdo": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ],
    "nospec": [ "4.01" ]
  },
  "br": {
    "categories": [ "flow content", "phrasing content" ]
  },
  "cite": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "code": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "data": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ],
    "nospec": [ "4.01" ]
  },
  "dfn": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ],
    "disallow": [ "<dfn>" ]
  },
  "em": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "i": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "kbd": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "mark": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ],
    "nospec": [ "4.01" ]
  },
  "q": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "rp": {
    "content": [ "phrasing content" ],
    "parent": [ "<ruby>" ],
    "nospec": [ "4.01" ]
  },
  "rt": {
    "content": [ "phrasing content" ],
    "parent": [ "<ruby>", "<rtc>" ],
    "nospec": [ "4.01" ]
  },
  "rtc": {
    "content": [ "phrasing content", "<rt>" ],
    "parent": [ "<ruby>" ],
    "nospec": [ "4.01" ]
  },
  "ruby": {
    "categories": [ "flow content", "phrasing content" ],
    "content": [ "phrasing content", "<rp>", "<rt>", "<rtc>" ],
    "nospec": [ "4.01" ]
  },
  "s": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "samp": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "small": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "span": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "strong": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "sub": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "sup": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "time": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ],
    "nospec": [ "4.01" ]
  },
  "u": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "var": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "wbr": {
    "categories": [ "flow content", "phrasing content" ],
    "nospec": [ "4.01" ]
  },

  "area": {
    "categories": [ "flow content", "phrasing content" ],
    "ancestor": [ "<map>" ]
  },
  "audio": {
    "categories": [ "flow content", "phrasing content", "embedded content" ],
    "content": [ "transparent", "<track>" ],
    "disallow": [ "<audio>", "<video>" ],
    "states": {
      "[controls]": {
        "categories": [ "interactive content", "palpable content" ]
      },
      ":not([src])": {
        "content": [ "<source>" ]
      }
    },
    "nospec": [ "4.01" ]
  },
  "map": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "transparent", "<area>" ]
  },
  "track": {
    "parent": [ "<audio>", "<video>" ],
    "nospec": [ "4.01" ]
  },
  "video": {
    "categories": [ "flow content", "phrasing content", "embedded content" ],
    "content": [ "transparent", "<track>" ],
    "disallow": [ "<audio>", "<video>" ],
    "states": {
      "[controls]": {
        "categories": [ "interactive content", "palpable content" ]
      },
      ":not([src])": {
        "content": [ "<source>" ]
      }
    },
    "nospec": [ "4.01" ]
  },

  "embed": {
    "categories": [ "flow content", "phrasing content", "embedded content", "interactive content", "palpable content" ],
    "nospec": [ "4.01" ]
  },
  "iframe": {
    "categories": [ "flow content", "phrasing content", "embedded content", "interactive content", "palpable content" ],
    "content": [ "phrasing content" ],
    "disallow": [ "<script>" ]
  },
  "img": {
    "categories": [ "flow content", "phrasing content", "embedded content", "palpable content" ],
    "states": {
      "[usemap]": {
        "categories": [ "interactive content" ]
      }
    }
  },
  "object": {
    "categories": [ "flow content", "phrasing content", "embedded content", "palpable content", "form-associated content", "listed", "submittable" ],
    "content": [ "transparent", "<param>" ],
    "states": {
      "[usemap]": {
        "categories": [ "interactive content" ]
      }
    }
  },
  "param": {
    "parent": [ "<object>" ]
  },
  "source": {
    "parent": [ "<picture>", "<audio>", "<video>" ],
    "position": [ "first" ],
    "nospec": [ "4.01" ]
  },

  "canvas": {
    "categories": [ "flow content", "phrasing content", "embedded content", "palpable content" ],
    "content": [ "transparent" ],
    "nospec": [ "4.01" ]
  },
  "noscript": {
    "categories": [ "flow content", "phrasing content", "metadata content" ],
    "disallow": [ "<noscript>" ],
    "states": {
      "head > noscript": {
        "content": [ "<link>", "<style>", "<meta>" ]
      },
      ":not( head > noscript )": {
        "content": [ "transparent" ]
      }
    }
  },
  "script": {
    "categories": [ "flow content", "phrasing content", "metadata content" ],
    "content": [ "text" ]
  },
  "template": {
    "categories": [ "metadata content", "flow content", "phrasing content" ],
    "content": [ "metadata content", "flow content" ],
    "parent": [ "body", "head", "colgroup" ],
    "nospec": [ "4.01" ]
  },

  "del": {
    "categories": [ "flow content", "phrasing content" ],
    "content": [ "transparent" ]
  },
  "ins": {
    "categories": [ "flow content", "phrasing content" ],
    "content": [ "transparent" ]
  },

  "caption": {
    "content": [ "flow content" ],
    "parent": [ "<table>" ],
    "position": [ "first" ]
  },
  "col": {
    "parent": [ "<colgroup>" ]
  },
  "colgroup": {
    "parent": [ "<table>" ],
    "states": {
      ":not([span])": {
        "content": [ "<col>" ]
      }
    }
  },
  "table": {
    "categories": [ "flow content" ],
    "content": [ "<caption>", "<colgroup>", "<thead>", "<tbody>", "<tfoot>", "<tr>" ]
  },
  "tbody": {
    "content": [ "<tr>" ],
    "parent": [ "<table>" ]
  },
  "td": {
    "content": [ "flow content", "phrasing content" ],
    "parent": [ "<tr>" ]
  },
  "tfoot": {
    "content": [ "<tr>" ],
    "parent": [ "<table>" ]
  },
  "th": {
    "content": [ "phrasing content" ],
    "parent": [ "<tr>" ]
  },
  "thead": {
    "content": [ "<tr>" ],
    "parent": [ "<table>" ]
  },
  "tr": {
    "content": [ "<th>", "<td>" ],
    "parent": [ "<table>", "<thead>", "<tbody>", "<tfoot>" ]
  },

  "button": {
    "categories": [ "flow content", "phrasing content", "interactive content", "form-associated content", "listed", "labelable", "submittable", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "datalist": {
    "categories": [ "flow content", "phrasing content" ],
    "content": [ "phrasing content", "<option>" ],
    "nospec": [ "4.01" ]
  },
  "fieldset": {
    "categories": [ "flow content", "sectioning root", "form-associated content", "listed", "palpable content" ],
    "content": [ "<legend>", "flow content" ]
  },
  "form": {
    "categories": [ "flow content", "palpable content" ],
    "content": [ "flow content" ],
    "disallow": [ "<form>" ]
  },
  "input": {
    "categories": [ "flow content", "phrasing content", "form-associated content", "listed", "submittable", "resettable" ],
    "states": {
      ":not([type=hidden])": {
        "categories": [ "labelable", "palpable content" ]
      }
    }
  },
  "label": {
    "categories": [ "flow content", "phrasing content", "interactive content", "form-associated content", "palpable content" ],
    "content": [ "phrasing content" ],
    "disallow": [ "<label>" ]
  },
  "legend": {
    "content": [ "phrasing content" ],
    "parent": [ "<fieldset>" ],
    "position": [ "first" ]
  },
  "meter": {
    "categories": [ "flow content", "phrasing content", "form-associated content", "labelable", "palpable content" ],
    "content": [ "phrasing content" ],
    "disallow": [ "<meter>" ],
    "nospec": [ "4.01" ]
  },
  "optgroup": {
    "content": [ "<option>" ],
    "parent": [ "<select>" ]
  },
  "option": {
    "content": [ "text" ],
    "parent": [ "<select>", "<optgroup>", "<datalist>" ]
  },
  "output": {
    "categories": [ "flow content", "phrasing content", "form-associated content", "listed", "labelable", "resettable", "palpable content" ],
    "content": [ "phrasing content" ],
    "nospec": [ "4.01" ]
  },
  "progress": {
    "categories": [ "flow content", "phrasing content", "form-associated content", "labelable", "palpable content" ],
    "content": [ "phrasing content" ],
    "disallow": [ "<progress>" ],
    "nospec": [ "4.01" ]
  },
  "select": {
    "categories": [ "flow content", "phrasing content", "interactive content", "form-associated content", "listed", "labelable", "submittable", "resettable" ],
    "content": [ "<optgroup>", "<option>" ]
  },
  "textarea": {
    "categories": [ "flow content", "phrasing content", "interactive content", "form-associated content", "listed", "labelable", "submittable", "resettable" ],
    "content": [ "text" ]
  },

  "details": {
    "categories": [ "flow content", "sectioning root", "interactive content", "palpable content" ],
    "content": [ "<summary>", "flow content" ],
    "nospec": [ "4.01", "5" ],
    "experimental": true
  },
  "dialog": {
    "categories": [ "flow content", "sectioning root" ],
    "content": [ "flow content" ],
    "nospec": [ "4.01", "5" ],
    "experimental": true
  },
   "hgroup": {
    "categories": [ "flow content", "heading content", "palpable content" ],
    "content": [ "<h1>", "<h2>", "<h3>", "<h4>", "<h5>", "<h6>" ],
    "nospec": [ "4.01", "5" ],
    "experimental": true
  },
  "menu": {
    "categories": [ "flow content" ],
    "states": {
      "[type=list], :not([type])": {
        "categories": [ "palpable content" ],
        "content": [ "flow content", "<li>", "<script>", "<template>" ]
      },
      "[type=menu]": {
        "content": [ "<script>", "<template>", "<menu>", "<menuitem>", "<hr>" ]
      }
    },
    "nospec": [ "4.01", "5" ],
    "experimental": true
  },
  "menuitem": {
    "parent": [ "<menu>" ],
    "nospec": [ "4.01", "5" ],
    "experimental": true
  },
  "picture": {
    "categories": [ "flow content", "phrasing content", "embedded content" ],
    "content": [ "<source>", "<img>" ],
    "nospec": [ "4.01", "5", "5.1" ],
    "experimental": true
  },
  "shadow": {
    "content": [ "flow content" ],
    "nospec": [ "4.01", "5", "5.1", "LS" ],
    "experimental": true
  },
  "summary": {
    "content": [ "phrasing content", "heading content" ],
    "parent": [ "<details>" ],
    "nospec": [ "4.01", "5" ],
    "experimental": true
  }
}

},{}],107:[function(require,module,exports){
'use strict';

var elementData = require('../data/elements.json');
var schema = require('../schema/hinfo.schema.json');

// ensure a fresh copy, in case the consumer modifies it
var hinfo = function hinfo() {
  return JSON.parse(JSON.stringify(elementData));
};

hinfo.schema = function () {
  return JSON.parse(JSON.stringify(schema));
};

module.exports = hinfo;
},{"../data/elements.json":106,"../schema/hinfo.schema.json":109}],108:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":107,"dup":3}],109:[function(require,module,exports){
module.exports={
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "html element meta data",
    "description": "schema for html element meta data",
    "type": "object",
    "patternProperties": {
        "^[a-z][a-z\\d]*$": {
            "$ref": "#/definitions/elementDef"
        }
    },
    "additionalProperties": false,
    "definitions": {
        "elementDef": {
            "type": "object",
            "properties": {
                "categories": {
                    "$ref": "#/definitions/categoryArrayDef"
                },
                "content": {
                    "$ref": "#/definitions/stringArrayDef"
                },
                "parent": {
                    "$ref": "#/definitions/stringArrayDef"
                },
                "disallow": {
                    "$ref": "#/definitions/stringArrayDef"
                },
                "ancestor": {
                    "$ref": "#/definitions/stringArrayDef"
                },
                "position": {
                    "$ref": "#/definitions/positionArrayDef"
                },
                "previous": {
                    "$ref": "#/definitions/tagArrayDef"
                },
                "next": {
                    "$ref": "#/definitions/tagArrayDef"
                },
                "states": {
                    "$ref": "#/definitions/stateDef"
                },
                "nospec": {
                    "$ref": "#/definitions/nospecDef"
                },
                "singular": {
                    "type": "boolean"
                },
                "experimental": {
                    "type": "boolean"
                }
            },
            "additionalProperties": false
        },
        "stringArrayDef": {
            "type": "array",
            "items": {
                "type": "string"
            },
            "uniqueItems": true
        },
        "tagArrayDef": {
            "type": "array",
            "items": {
                "type": "string",
                "pattern": "^<[a-z][a-z0-9]*>$"
            },
            "uniqueItems": true
        },
        "categoryArrayDef": {
            "type": "array",
            "items": {
                "enum": [
                    "embedded content",
                    "flow content",
                    "form-associated content",
                    "heading content",
                    "interactive content",
                    "labelable",
                    "listed",
                    "metadata content",
                    "palpable content",
                    "phrasing content",
                    "resettable",
                    "sectioning content",
                    "sectioning root",
                    "submittable"
                ]
            },
            "uniqueItems": true
        },
        "positionArrayDef": {
            "type": "array",
            "items": {
                "enum": [
                    "first",
                    "last"
                ]
            },
            "uniqueItems": true
        },
        "stateDef": {
            "type": "object",
            "patternProperties": {
                "^[\\w\\d :=,<>\\(\\)\\[\\]]+$": {
                    "type": "object",
                    "properties": {
                        "categories": {
                            "$ref": "#/definitions/stringArrayDef"
                        },
                        "content": {
                            "$ref": "#/definitions/stringArrayDef"
                        }
                    },
                    "additionalProperties": false
                }
            },
            "additionalProperties": false
        },
        "nospecDef": {
            "type": "array",
            "minItems": 1,
            "items": {
                "enum": [
                    "4.01",
                    "5",
                    "5.1",
                    "LS"
                ]
            },
            "uniqueItems": true
        }
    }
}
},{}],110:[function(require,module,exports){
'use strict';

var hinfo = require('hinfo');

var nodeDefs = {
  '#document': {
    'content': ['#documentType', '<html>']
  },
  '#documentType': {
    'parent': ['#document']
  },
  '#text': {
    'categories': ['flow content', 'phrasing content', 'palpable content']
  },
  '#comment': {
    'categories': ['flow content']
  },
  '#documentFragment': {
    'content': ['flow content']
  }
};

var ensureArray = function ensureArray(obj, name) {
  if (!Array.isArray(obj[name])) obj[name] = [];
};

var ensureProperties = function ensureProperties(def) {
  ensureArray(def, 'categories');
  ensureArray(def, 'content');
  ensureArray(def, 'parent');
};

var defaultDefs = Object.assign(hinfo(), nodeDefs);

var Html = function Html() {
  var defs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultDefs;

  defs = JSON.parse(JSON.stringify(defs));

  var _tagNames = Object.keys(defs);

  var hasCategory = function hasCategory(tagName, categoryName) {
    return defs[tagName].categories.includes(categoryName);
  };

  var predicates = {
    empty: function empty(tagName) {
      return defs[tagName].content.length === 0;
    },
    metadata: function metadata(tagName) {
      return hasCategory(tagName, 'metadata content');
    },
    inline: function inline(tagName) {
      return hasCategory(tagName, 'phrasing content');
    },
    embedded: function embedded(tagName) {
      return hasCategory(tagName, 'embedded content');
    },
    block: function block(tagName) {
      return hasCategory(tagName, 'flow content') && !predicates.inline(tagName);
    },
    container: function container(tagName) {
      return !predicates.empty(tagName);
    }
  };

  var doesAccept = function doesAccept(tagName, childTagName) {
    if (predicates.empty(tagName)) return false;

    var def = defs[tagName];
    var childDef = defs[childTagName];

    if (childDef.parent.includes('<' + tagName + '>')) return true;

    if (def.content.includes('<' + childTagName + '>') || def.content.includes('#' + childTagName)) return true;

    return childDef.categories.some(function (category) {
      return def.content.includes(category);
    });
  };

  var predicateNames = Object.keys(predicates);

  var maps = {
    accepts: {}
  };

  predicateNames.forEach(function (name) {
    return maps[name] = {};
  });

  var allCategories = [];

  _tagNames.forEach(function (tagName) {
    var def = defs[tagName];

    ensureProperties(def);

    allCategories = allCategories.concat(def.categories);

    predicateNames.forEach(function (predicateName) {
      return maps[predicateName][tagName] = predicates[predicateName](tagName);
    });

    maps.accepts[tagName] = {};

    _tagNames.forEach(function (childTagName) {
      ensureProperties(defs[childTagName]);

      maps.accepts[tagName][childTagName] = doesAccept(tagName, childTagName);
    });
  });

  var _categoryNames = Array.from(new Set(allCategories)).sort();

  var api = {
    tagNames: function tagNames() {
      return _tagNames;
    },
    categoryNames: function categoryNames() {
      return _categoryNames;
    },
    isEmpty: function isEmpty(tagName) {
      return maps.empty[tagName];
    },
    isMetadata: function isMetadata(tagName) {
      return maps.metadata[tagName];
    },
    isInline: function isInline(tagName) {
      return maps.inline[tagName];
    },
    isEmbedded: function isEmbedded(tagName) {
      return maps.embedded[tagName];
    },
    isBlock: function isBlock(tagName) {
      return maps.block[tagName];
    },
    isContainer: function isContainer(tagName) {
      return maps.container[tagName];
    },
    accepts: function accepts(tagName, childTagName) {
      return maps.accepts[tagName][childTagName];
    },
    def: function def(tagName) {
      if (defs[tagName]) return JSON.parse(JSON.stringify(defs[tagName]));
    }
  };

  return api;
};

module.exports = Html;
},{"hinfo":108}],111:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":110,"dup":3}],112:[function(require,module,exports){
module.exports = CollectingHandler;

function CollectingHandler(cbs){
	this._cbs = cbs || {};
	this.events = [];
}

var EVENTS = require("./").EVENTS;
Object.keys(EVENTS).forEach(function(name){
	if(EVENTS[name] === 0){
		name = "on" + name;
		CollectingHandler.prototype[name] = function(){
			this.events.push([name]);
			if(this._cbs[name]) this._cbs[name]();
		};
	} else if(EVENTS[name] === 1){
		name = "on" + name;
		CollectingHandler.prototype[name] = function(a){
			this.events.push([name, a]);
			if(this._cbs[name]) this._cbs[name](a);
		};
	} else if(EVENTS[name] === 2){
		name = "on" + name;
		CollectingHandler.prototype[name] = function(a, b){
			this.events.push([name, a, b]);
			if(this._cbs[name]) this._cbs[name](a, b);
		};
	} else {
		throw Error("wrong number of arguments");
	}
});

CollectingHandler.prototype.onreset = function(){
	this.events = [];
	if(this._cbs.onreset) this._cbs.onreset();
};

CollectingHandler.prototype.restart = function(){
	if(this._cbs.onreset) this._cbs.onreset();

	for(var i = 0, len = this.events.length; i < len; i++){
		if(this._cbs[this.events[i][0]]){

			var num = this.events[i].length;

			if(num === 1){
				this._cbs[this.events[i][0]]();
			} else if(num === 2){
				this._cbs[this.events[i][0]](this.events[i][1]);
			} else {
				this._cbs[this.events[i][0]](this.events[i][1], this.events[i][2]);
			}
		}
	}
};

},{"./":119}],113:[function(require,module,exports){
var index = require("./index.js"),
    DomHandler = index.DomHandler,
    DomUtils = index.DomUtils;

//TODO: make this a streamable handler
function FeedHandler(callback, options){
	this.init(callback, options);
}

require("inherits")(FeedHandler, DomHandler);

FeedHandler.prototype.init = DomHandler;

function getElements(what, where){
	return DomUtils.getElementsByTagName(what, where, true);
}
function getOneElement(what, where){
	return DomUtils.getElementsByTagName(what, where, true, 1)[0];
}
function fetch(what, where, recurse){
	return DomUtils.getText(
		DomUtils.getElementsByTagName(what, where, recurse, 1)
	).trim();
}

function addConditionally(obj, prop, what, where, recurse){
	var tmp = fetch(what, where, recurse);
	if(tmp) obj[prop] = tmp;
}

var isValidFeed = function(value){
	return value === "rss" || value === "feed" || value === "rdf:RDF";
};

FeedHandler.prototype.onend = function(){
	var feed = {},
	    feedRoot = getOneElement(isValidFeed, this.dom),
	    tmp, childs;

	if(feedRoot){
		if(feedRoot.name === "feed"){
			childs = feedRoot.children;

			feed.type = "atom";
			addConditionally(feed, "id", "id", childs);
			addConditionally(feed, "title", "title", childs);
			if((tmp = getOneElement("link", childs)) && (tmp = tmp.attribs) && (tmp = tmp.href)) feed.link = tmp;
			addConditionally(feed, "description", "subtitle", childs);
			if((tmp = fetch("updated", childs))) feed.updated = new Date(tmp);
			addConditionally(feed, "author", "email", childs, true);

			feed.items = getElements("entry", childs).map(function(item){
				var entry = {}, tmp;

				item = item.children;

				addConditionally(entry, "id", "id", item);
				addConditionally(entry, "title", "title", item);
				if((tmp = getOneElement("link", item)) && (tmp = tmp.attribs) && (tmp = tmp.href)) entry.link = tmp;
				if((tmp = fetch("summary", item) || fetch("content", item))) entry.description = tmp;
				if((tmp = fetch("updated", item))) entry.pubDate = new Date(tmp);
				return entry;
			});
		} else {
			childs = getOneElement("channel", feedRoot.children).children;

			feed.type = feedRoot.name.substr(0, 3);
			feed.id = "";
			addConditionally(feed, "title", "title", childs);
			addConditionally(feed, "link", "link", childs);
			addConditionally(feed, "description", "description", childs);
			if((tmp = fetch("lastBuildDate", childs))) feed.updated = new Date(tmp);
			addConditionally(feed, "author", "managingEditor", childs, true);

			feed.items = getElements("item", feedRoot.children).map(function(item){
				var entry = {}, tmp;

				item = item.children;

				addConditionally(entry, "id", "guid", item);
				addConditionally(entry, "title", "title", item);
				addConditionally(entry, "link", "link", item);
				addConditionally(entry, "description", "description", item);
				if((tmp = fetch("pubDate", item))) entry.pubDate = new Date(tmp);
				return entry;
			});
		}
	}
	this.dom = feed;
	DomHandler.prototype._handleCallback.call(
		this, feedRoot ? null : Error("couldn't find root of feed")
	);
};

module.exports = FeedHandler;

},{"./index.js":119,"inherits":121}],114:[function(require,module,exports){
var Tokenizer = require("./Tokenizer.js");

/*
	Options:

	xmlMode: Disables the special behavior for script/style tags (false by default)
	lowerCaseAttributeNames: call .toLowerCase for each attribute name (true if xmlMode is `false`)
	lowerCaseTags: call .toLowerCase for each tag name (true if xmlMode is `false`)
*/

/*
	Callbacks:

	oncdataend,
	oncdatastart,
	onclosetag,
	oncomment,
	oncommentend,
	onerror,
	onopentag,
	onprocessinginstruction,
	onreset,
	ontext
*/

var formTags = {
	input: true,
	option: true,
	optgroup: true,
	select: true,
	button: true,
	datalist: true,
	textarea: true
};

var openImpliesClose = {
	tr      : { tr:true, th:true, td:true },
	th      : { th:true },
	td      : { thead:true, th:true, td:true },
	body    : { head:true, link:true, script:true },
	li      : { li:true },
	p       : { p:true },
	h1      : { p:true },
	h2      : { p:true },
	h3      : { p:true },
	h4      : { p:true },
	h5      : { p:true },
	h6      : { p:true },
	select  : formTags,
	input   : formTags,
	output  : formTags,
	button  : formTags,
	datalist: formTags,
	textarea: formTags,
	option  : { option:true },
	optgroup: { optgroup:true }
};

var voidElements = {
	__proto__: null,
	area: true,
	base: true,
	basefont: true,
	br: true,
	col: true,
	command: true,
	embed: true,
	frame: true,
	hr: true,
	img: true,
	input: true,
	isindex: true,
	keygen: true,
	link: true,
	meta: true,
	param: true,
	source: true,
	track: true,
	wbr: true,

	//common self closing svg elements
	path: true,
	circle: true,
	ellipse: true,
	line: true,
	rect: true,
	use: true,
	stop: true,
	polyline: true,
	polygon: true
};

var re_nameEnd = /\s|\//;

function Parser(cbs, options){
	this._options = options || {};
	this._cbs = cbs || {};

	this._tagname = "";
	this._attribname = "";
	this._attribvalue = "";
	this._attribs = null;
	this._stack = [];

	this.startIndex = 0;
	this.endIndex = null;

	this._lowerCaseTagNames = "lowerCaseTags" in this._options ?
									!!this._options.lowerCaseTags :
									!this._options.xmlMode;
	this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ?
									!!this._options.lowerCaseAttributeNames :
									!this._options.xmlMode;

	if(this._options.Tokenizer) {
		Tokenizer = this._options.Tokenizer;
	}
	this._tokenizer = new Tokenizer(this._options, this);

	if(this._cbs.onparserinit) this._cbs.onparserinit(this);
}

require("inherits")(Parser, require("events").EventEmitter);

Parser.prototype._updatePosition = function(initialOffset){
	if(this.endIndex === null){
		if(this._tokenizer._sectionStart <= initialOffset){
			this.startIndex = 0;
		} else {
			this.startIndex = this._tokenizer._sectionStart - initialOffset;
		}
	}
	else this.startIndex = this.endIndex + 1;
	this.endIndex = this._tokenizer.getAbsoluteIndex();
};

//Tokenizer event handlers
Parser.prototype.ontext = function(data){
	this._updatePosition(1);
	this.endIndex--;

	if(this._cbs.ontext) this._cbs.ontext(data);
};

Parser.prototype.onopentagname = function(name){
	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	this._tagname = name;

	if(!this._options.xmlMode && name in openImpliesClose) {
		for(
			var el;
			(el = this._stack[this._stack.length - 1]) in openImpliesClose[name];
			this.onclosetag(el)
		);
	}

	if(this._options.xmlMode || !(name in voidElements)){
		this._stack.push(name);
	}

	if(this._cbs.onopentagname) this._cbs.onopentagname(name);
	if(this._cbs.onopentag) this._attribs = {};
};

Parser.prototype.onopentagend = function(){
	this._updatePosition(1);

	if(this._attribs){
		if(this._cbs.onopentag) this._cbs.onopentag(this._tagname, this._attribs);
		this._attribs = null;
	}

	if(!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements){
		this._cbs.onclosetag(this._tagname);
	}

	this._tagname = "";
};

Parser.prototype.onclosetag = function(name){
	this._updatePosition(1);

	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	if(this._stack.length && (!(name in voidElements) || this._options.xmlMode)){
		var pos = this._stack.lastIndexOf(name);
		if(pos !== -1){
			if(this._cbs.onclosetag){
				pos = this._stack.length - pos;
				while(pos--) this._cbs.onclosetag(this._stack.pop());
			}
			else this._stack.length = pos;
		} else if(name === "p" && !this._options.xmlMode){
			this.onopentagname(name);
			this._closeCurrentTag();
		}
	} else if(!this._options.xmlMode && (name === "br" || name === "p")){
		this.onopentagname(name);
		this._closeCurrentTag();
	}
};

Parser.prototype.onselfclosingtag = function(){
	if(this._options.xmlMode || this._options.recognizeSelfClosing){
		this._closeCurrentTag();
	} else {
		this.onopentagend();
	}
};

Parser.prototype._closeCurrentTag = function(){
	var name = this._tagname;

	this.onopentagend();

	//self-closing tags will be on the top of the stack
	//(cheaper check than in onclosetag)
	if(this._stack[this._stack.length - 1] === name){
		if(this._cbs.onclosetag){
			this._cbs.onclosetag(name);
		}
		this._stack.pop();
	}
};

Parser.prototype.onattribname = function(name){
	if(this._lowerCaseAttributeNames){
		name = name.toLowerCase();
	}
	this._attribname = name;
};

Parser.prototype.onattribdata = function(value){
	this._attribvalue += value;
};

Parser.prototype.onattribend = function(){
	if(this._cbs.onattribute) this._cbs.onattribute(this._attribname, this._attribvalue);
	if(
		this._attribs &&
		!Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)
	){
		this._attribs[this._attribname] = this._attribvalue;
	}
	this._attribname = "";
	this._attribvalue = "";
};

Parser.prototype._getInstructionName = function(value){
	var idx = value.search(re_nameEnd),
	    name = idx < 0 ? value : value.substr(0, idx);

	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	return name;
};

Parser.prototype.ondeclaration = function(value){
	if(this._cbs.onprocessinginstruction){
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("!" + name, "!" + value);
	}
};

Parser.prototype.onprocessinginstruction = function(value){
	if(this._cbs.onprocessinginstruction){
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("?" + name, "?" + value);
	}
};

Parser.prototype.oncomment = function(value){
	this._updatePosition(4);

	if(this._cbs.oncomment) this._cbs.oncomment(value);
	if(this._cbs.oncommentend) this._cbs.oncommentend();
};

Parser.prototype.oncdata = function(value){
	this._updatePosition(1);

	if(this._options.xmlMode || this._options.recognizeCDATA){
		if(this._cbs.oncdatastart) this._cbs.oncdatastart();
		if(this._cbs.ontext) this._cbs.ontext(value);
		if(this._cbs.oncdataend) this._cbs.oncdataend();
	} else {
		this.oncomment("[CDATA[" + value + "]]");
	}
};

Parser.prototype.onerror = function(err){
	if(this._cbs.onerror) this._cbs.onerror(err);
};

Parser.prototype.onend = function(){
	if(this._cbs.onclosetag){
		for(
			var i = this._stack.length;
			i > 0;
			this._cbs.onclosetag(this._stack[--i])
		);
	}
	if(this._cbs.onend) this._cbs.onend();
};


//Resets the parser to a blank state, ready to parse a new HTML document
Parser.prototype.reset = function(){
	if(this._cbs.onreset) this._cbs.onreset();
	this._tokenizer.reset();

	this._tagname = "";
	this._attribname = "";
	this._attribs = null;
	this._stack = [];

	if(this._cbs.onparserinit) this._cbs.onparserinit(this);
};

//Parses a complete HTML document and pushes it to the handler
Parser.prototype.parseComplete = function(data){
	this.reset();
	this.end(data);
};

Parser.prototype.write = function(chunk){
	this._tokenizer.write(chunk);
};

Parser.prototype.end = function(chunk){
	this._tokenizer.end(chunk);
};

Parser.prototype.pause = function(){
	this._tokenizer.pause();
};

Parser.prototype.resume = function(){
	this._tokenizer.resume();
};

//alias for backwards compat
Parser.prototype.parseChunk = Parser.prototype.write;
Parser.prototype.done = Parser.prototype.end;

module.exports = Parser;

},{"./Tokenizer.js":117,"events":105,"inherits":121}],115:[function(require,module,exports){
module.exports = ProxyHandler;

function ProxyHandler(cbs){
	this._cbs = cbs || {};
}

var EVENTS = require("./").EVENTS;
Object.keys(EVENTS).forEach(function(name){
	if(EVENTS[name] === 0){
		name = "on" + name;
		ProxyHandler.prototype[name] = function(){
			if(this._cbs[name]) this._cbs[name]();
		};
	} else if(EVENTS[name] === 1){
		name = "on" + name;
		ProxyHandler.prototype[name] = function(a){
			if(this._cbs[name]) this._cbs[name](a);
		};
	} else if(EVENTS[name] === 2){
		name = "on" + name;
		ProxyHandler.prototype[name] = function(a, b){
			if(this._cbs[name]) this._cbs[name](a, b);
		};
	} else {
		throw Error("wrong number of arguments");
	}
});
},{"./":119}],116:[function(require,module,exports){
module.exports = Stream;

var Parser = require("./WritableStream.js");

function Stream(options){
	Parser.call(this, new Cbs(this), options);
}

require("inherits")(Stream, Parser);

Stream.prototype.readable = true;

function Cbs(scope){
	this.scope = scope;
}

var EVENTS = require("../").EVENTS;

Object.keys(EVENTS).forEach(function(name){
	if(EVENTS[name] === 0){
		Cbs.prototype["on" + name] = function(){
			this.scope.emit(name);
		};
	} else if(EVENTS[name] === 1){
		Cbs.prototype["on" + name] = function(a){
			this.scope.emit(name, a);
		};
	} else if(EVENTS[name] === 2){
		Cbs.prototype["on" + name] = function(a, b){
			this.scope.emit(name, a, b);
		};
	} else {
		throw Error("wrong number of arguments!");
	}
});
},{"../":119,"./WritableStream.js":118,"inherits":121}],117:[function(require,module,exports){
module.exports = Tokenizer;

var decodeCodePoint = require("entities/lib/decode_codepoint.js"),
    entityMap = require("entities/maps/entities.json"),
    legacyMap = require("entities/maps/legacy.json"),
    xmlMap    = require("entities/maps/xml.json"),

    i = 0,

    TEXT                      = i++,
    BEFORE_TAG_NAME           = i++, //after <
    IN_TAG_NAME               = i++,
    IN_SELF_CLOSING_TAG       = i++,
    BEFORE_CLOSING_TAG_NAME   = i++,
    IN_CLOSING_TAG_NAME       = i++,
    AFTER_CLOSING_TAG_NAME    = i++,

    //attributes
    BEFORE_ATTRIBUTE_NAME     = i++,
    IN_ATTRIBUTE_NAME         = i++,
    AFTER_ATTRIBUTE_NAME      = i++,
    BEFORE_ATTRIBUTE_VALUE    = i++,
    IN_ATTRIBUTE_VALUE_DQ     = i++, // "
    IN_ATTRIBUTE_VALUE_SQ     = i++, // '
    IN_ATTRIBUTE_VALUE_NQ     = i++,

    //declarations
    BEFORE_DECLARATION        = i++, // !
    IN_DECLARATION            = i++,

    //processing instructions
    IN_PROCESSING_INSTRUCTION = i++, // ?

    //comments
    BEFORE_COMMENT            = i++,
    IN_COMMENT                = i++,
    AFTER_COMMENT_1           = i++,
    AFTER_COMMENT_2           = i++,

    //cdata
    BEFORE_CDATA_1            = i++, // [
    BEFORE_CDATA_2            = i++, // C
    BEFORE_CDATA_3            = i++, // D
    BEFORE_CDATA_4            = i++, // A
    BEFORE_CDATA_5            = i++, // T
    BEFORE_CDATA_6            = i++, // A
    IN_CDATA                  = i++, // [
    AFTER_CDATA_1             = i++, // ]
    AFTER_CDATA_2             = i++, // ]

    //special tags
    BEFORE_SPECIAL            = i++, //S
    BEFORE_SPECIAL_END        = i++,   //S

    BEFORE_SCRIPT_1           = i++, //C
    BEFORE_SCRIPT_2           = i++, //R
    BEFORE_SCRIPT_3           = i++, //I
    BEFORE_SCRIPT_4           = i++, //P
    BEFORE_SCRIPT_5           = i++, //T
    AFTER_SCRIPT_1            = i++, //C
    AFTER_SCRIPT_2            = i++, //R
    AFTER_SCRIPT_3            = i++, //I
    AFTER_SCRIPT_4            = i++, //P
    AFTER_SCRIPT_5            = i++, //T

    BEFORE_STYLE_1            = i++, //T
    BEFORE_STYLE_2            = i++, //Y
    BEFORE_STYLE_3            = i++, //L
    BEFORE_STYLE_4            = i++, //E
    AFTER_STYLE_1             = i++, //T
    AFTER_STYLE_2             = i++, //Y
    AFTER_STYLE_3             = i++, //L
    AFTER_STYLE_4             = i++, //E

    BEFORE_ENTITY             = i++, //&
    BEFORE_NUMERIC_ENTITY     = i++, //#
    IN_NAMED_ENTITY           = i++,
    IN_NUMERIC_ENTITY         = i++,
    IN_HEX_ENTITY             = i++, //X

    j = 0,

    SPECIAL_NONE              = j++,
    SPECIAL_SCRIPT            = j++,
    SPECIAL_STYLE             = j++;

function whitespace(c){
	return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}

function characterState(char, SUCCESS){
	return function(c){
		if(c === char) this._state = SUCCESS;
	};
}

function ifElseState(upper, SUCCESS, FAILURE){
	var lower = upper.toLowerCase();

	if(upper === lower){
		return function(c){
			if(c === lower){
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	} else {
		return function(c){
			if(c === lower || c === upper){
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	}
}

function consumeSpecialNameChar(upper, NEXT_STATE){
	var lower = upper.toLowerCase();

	return function(c){
		if(c === lower || c === upper){
			this._state = NEXT_STATE;
		} else {
			this._state = IN_TAG_NAME;
			this._index--; //consume the token again
		}
	};
}

function Tokenizer(options, cbs){
	this._state = TEXT;
	this._buffer = "";
	this._sectionStart = 0;
	this._index = 0;
	this._bufferOffset = 0; //chars removed from _buffer
	this._baseState = TEXT;
	this._special = SPECIAL_NONE;
	this._cbs = cbs;
	this._running = true;
	this._ended = false;
	this._xmlMode = !!(options && options.xmlMode);
	this._decodeEntities = !!(options && options.decodeEntities);
}

Tokenizer.prototype._stateText = function(c){
	if(c === "<"){
		if(this._index > this._sectionStart){
			this._cbs.ontext(this._getSection());
		}
		this._state = BEFORE_TAG_NAME;
		this._sectionStart = this._index;
	} else if(this._decodeEntities && this._special === SPECIAL_NONE && c === "&"){
		if(this._index > this._sectionStart){
			this._cbs.ontext(this._getSection());
		}
		this._baseState = TEXT;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateBeforeTagName = function(c){
	if(c === "/"){
		this._state = BEFORE_CLOSING_TAG_NAME;
	} else if(c === "<"){
		this._cbs.ontext(this._getSection());
		this._sectionStart = this._index;
	} else if(c === ">" || this._special !== SPECIAL_NONE || whitespace(c)) {
		this._state = TEXT;
	} else if(c === "!"){
		this._state = BEFORE_DECLARATION;
		this._sectionStart = this._index + 1;
	} else if(c === "?"){
		this._state = IN_PROCESSING_INSTRUCTION;
		this._sectionStart = this._index + 1;
	} else {
		this._state = (!this._xmlMode && (c === "s" || c === "S")) ?
						BEFORE_SPECIAL : IN_TAG_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInTagName = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._emitToken("onopentagname");
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateBeforeCloseingTagName = function(c){
	if(whitespace(c));
	else if(c === ">"){
		this._state = TEXT;
	} else if(this._special !== SPECIAL_NONE){
		if(c === "s" || c === "S"){
			this._state = BEFORE_SPECIAL_END;
		} else {
			this._state = TEXT;
			this._index--;
		}
	} else {
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInCloseingTagName = function(c){
	if(c === ">" || whitespace(c)){
		this._emitToken("onclosetag");
		this._state = AFTER_CLOSING_TAG_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateAfterCloseingTagName = function(c){
	//skip everything until ">"
	if(c === ">"){
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer.prototype._stateBeforeAttributeName = function(c){
	if(c === ">"){
		this._cbs.onopentagend();
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c === "/"){
		this._state = IN_SELF_CLOSING_TAG;
	} else if(!whitespace(c)){
		this._state = IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInSelfClosingTag = function(c){
	if(c === ">"){
		this._cbs.onselfclosingtag();
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(!whitespace(c)){
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateInAttributeName = function(c){
	if(c === "=" || c === "/" || c === ">" || whitespace(c)){
		this._cbs.onattribname(this._getSection());
		this._sectionStart = -1;
		this._state = AFTER_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateAfterAttributeName = function(c){
	if(c === "="){
		this._state = BEFORE_ATTRIBUTE_VALUE;
	} else if(c === "/" || c === ">"){
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if(!whitespace(c)){
		this._cbs.onattribend();
		this._state = IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateBeforeAttributeValue = function(c){
	if(c === "\""){
		this._state = IN_ATTRIBUTE_VALUE_DQ;
		this._sectionStart = this._index + 1;
	} else if(c === "'"){
		this._state = IN_ATTRIBUTE_VALUE_SQ;
		this._sectionStart = this._index + 1;
	} else if(!whitespace(c)){
		this._state = IN_ATTRIBUTE_VALUE_NQ;
		this._sectionStart = this._index;
		this._index--; //reconsume token
	}
};

Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function(c){
	if(c === "\""){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInAttributeValueSingleQuotes = function(c){
	if(c === "'"){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInAttributeValueNoQuotes = function(c){
	if(whitespace(c) || c === ">"){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateBeforeDeclaration = function(c){
	this._state = c === "[" ? BEFORE_CDATA_1 :
					c === "-" ? BEFORE_COMMENT :
						IN_DECLARATION;
};

Tokenizer.prototype._stateInDeclaration = function(c){
	if(c === ">"){
		this._cbs.ondeclaration(this._getSection());
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer.prototype._stateInProcessingInstruction = function(c){
	if(c === ">"){
		this._cbs.onprocessinginstruction(this._getSection());
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer.prototype._stateBeforeComment = function(c){
	if(c === "-"){
		this._state = IN_COMMENT;
		this._sectionStart = this._index + 1;
	} else {
		this._state = IN_DECLARATION;
	}
};

Tokenizer.prototype._stateInComment = function(c){
	if(c === "-") this._state = AFTER_COMMENT_1;
};

Tokenizer.prototype._stateAfterComment1 = function(c){
	if(c === "-"){
		this._state = AFTER_COMMENT_2;
	} else {
		this._state = IN_COMMENT;
	}
};

Tokenizer.prototype._stateAfterComment2 = function(c){
	if(c === ">"){
		//remove 2 trailing chars
		this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c !== "-"){
		this._state = IN_COMMENT;
	}
	// else: stay in AFTER_COMMENT_2 (`--->`)
};

Tokenizer.prototype._stateBeforeCdata1 = ifElseState("C", BEFORE_CDATA_2, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata2 = ifElseState("D", BEFORE_CDATA_3, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata3 = ifElseState("A", BEFORE_CDATA_4, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata4 = ifElseState("T", BEFORE_CDATA_5, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata5 = ifElseState("A", BEFORE_CDATA_6, IN_DECLARATION);

Tokenizer.prototype._stateBeforeCdata6 = function(c){
	if(c === "["){
		this._state = IN_CDATA;
		this._sectionStart = this._index + 1;
	} else {
		this._state = IN_DECLARATION;
		this._index--;
	}
};

Tokenizer.prototype._stateInCdata = function(c){
	if(c === "]") this._state = AFTER_CDATA_1;
};

Tokenizer.prototype._stateAfterCdata1 = characterState("]", AFTER_CDATA_2);

Tokenizer.prototype._stateAfterCdata2 = function(c){
	if(c === ">"){
		//remove 2 trailing chars
		this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c !== "]") {
		this._state = IN_CDATA;
	}
	//else: stay in AFTER_CDATA_2 (`]]]>`)
};

Tokenizer.prototype._stateBeforeSpecial = function(c){
	if(c === "c" || c === "C"){
		this._state = BEFORE_SCRIPT_1;
	} else if(c === "t" || c === "T"){
		this._state = BEFORE_STYLE_1;
	} else {
		this._state = IN_TAG_NAME;
		this._index--; //consume the token again
	}
};

Tokenizer.prototype._stateBeforeSpecialEnd = function(c){
	if(this._special === SPECIAL_SCRIPT && (c === "c" || c === "C")){
		this._state = AFTER_SCRIPT_1;
	} else if(this._special === SPECIAL_STYLE && (c === "t" || c === "T")){
		this._state = AFTER_STYLE_1;
	}
	else this._state = TEXT;
};

Tokenizer.prototype._stateBeforeScript1 = consumeSpecialNameChar("R", BEFORE_SCRIPT_2);
Tokenizer.prototype._stateBeforeScript2 = consumeSpecialNameChar("I", BEFORE_SCRIPT_3);
Tokenizer.prototype._stateBeforeScript3 = consumeSpecialNameChar("P", BEFORE_SCRIPT_4);
Tokenizer.prototype._stateBeforeScript4 = consumeSpecialNameChar("T", BEFORE_SCRIPT_5);

Tokenizer.prototype._stateBeforeScript5 = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._special = SPECIAL_SCRIPT;
	}
	this._state = IN_TAG_NAME;
	this._index--; //consume the token again
};

Tokenizer.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT);
Tokenizer.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT);
Tokenizer.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT);
Tokenizer.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT);

Tokenizer.prototype._stateAfterScript5 = function(c){
	if(c === ">" || whitespace(c)){
		this._special = SPECIAL_NONE;
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 6;
		this._index--; //reconsume the token
	}
	else this._state = TEXT;
};

Tokenizer.prototype._stateBeforeStyle1 = consumeSpecialNameChar("Y", BEFORE_STYLE_2);
Tokenizer.prototype._stateBeforeStyle2 = consumeSpecialNameChar("L", BEFORE_STYLE_3);
Tokenizer.prototype._stateBeforeStyle3 = consumeSpecialNameChar("E", BEFORE_STYLE_4);

Tokenizer.prototype._stateBeforeStyle4 = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._special = SPECIAL_STYLE;
	}
	this._state = IN_TAG_NAME;
	this._index--; //consume the token again
};

Tokenizer.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT);
Tokenizer.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT);
Tokenizer.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT);

Tokenizer.prototype._stateAfterStyle4 = function(c){
	if(c === ">" || whitespace(c)){
		this._special = SPECIAL_NONE;
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 5;
		this._index--; //reconsume the token
	}
	else this._state = TEXT;
};

Tokenizer.prototype._stateBeforeEntity = ifElseState("#", BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY);
Tokenizer.prototype._stateBeforeNumericEntity = ifElseState("X", IN_HEX_ENTITY, IN_NUMERIC_ENTITY);

//for entities terminated with a semicolon
Tokenizer.prototype._parseNamedEntityStrict = function(){
	//offset = 1
	if(this._sectionStart + 1 < this._index){
		var entity = this._buffer.substring(this._sectionStart + 1, this._index),
		    map = this._xmlMode ? xmlMap : entityMap;

		if(map.hasOwnProperty(entity)){
			this._emitPartial(map[entity]);
			this._sectionStart = this._index + 1;
		}
	}
};


//parses legacy entities (without trailing semicolon)
Tokenizer.prototype._parseLegacyEntity = function(){
	var start = this._sectionStart + 1,
	    limit = this._index - start;

	if(limit > 6) limit = 6; //the max length of legacy entities is 6

	while(limit >= 2){ //the min length of legacy entities is 2
		var entity = this._buffer.substr(start, limit);

		if(legacyMap.hasOwnProperty(entity)){
			this._emitPartial(legacyMap[entity]);
			this._sectionStart += limit + 1;
			return;
		} else {
			limit--;
		}
	}
};

Tokenizer.prototype._stateInNamedEntity = function(c){
	if(c === ";"){
		this._parseNamedEntityStrict();
		if(this._sectionStart + 1 < this._index && !this._xmlMode){
			this._parseLegacyEntity();
		}
		this._state = this._baseState;
	} else if((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")){
		if(this._xmlMode);
		else if(this._sectionStart + 1 === this._index);
		else if(this._baseState !== TEXT){
			if(c !== "="){
				this._parseNamedEntityStrict();
			}
		} else {
			this._parseLegacyEntity();
		}

		this._state = this._baseState;
		this._index--;
	}
};

Tokenizer.prototype._decodeNumericEntity = function(offset, base){
	var sectionStart = this._sectionStart + offset;

	if(sectionStart !== this._index){
		//parse entity
		var entity = this._buffer.substring(sectionStart, this._index);
		var parsed = parseInt(entity, base);

		this._emitPartial(decodeCodePoint(parsed));
		this._sectionStart = this._index;
	} else {
		this._sectionStart--;
	}

	this._state = this._baseState;
};

Tokenizer.prototype._stateInNumericEntity = function(c){
	if(c === ";"){
		this._decodeNumericEntity(2, 10);
		this._sectionStart++;
	} else if(c < "0" || c > "9"){
		if(!this._xmlMode){
			this._decodeNumericEntity(2, 10);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

Tokenizer.prototype._stateInHexEntity = function(c){
	if(c === ";"){
		this._decodeNumericEntity(3, 16);
		this._sectionStart++;
	} else if((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")){
		if(!this._xmlMode){
			this._decodeNumericEntity(3, 16);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

Tokenizer.prototype._cleanup = function (){
	if(this._sectionStart < 0){
		this._buffer = "";
		this._bufferOffset += this._index;
		this._index = 0;
	} else if(this._running){
		if(this._state === TEXT){
			if(this._sectionStart !== this._index){
				this._cbs.ontext(this._buffer.substr(this._sectionStart));
			}
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else if(this._sectionStart === this._index){
			//the section just started
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else {
			//remove everything unnecessary
			this._buffer = this._buffer.substr(this._sectionStart);
			this._index -= this._sectionStart;
			this._bufferOffset += this._sectionStart;
		}

		this._sectionStart = 0;
	}
};

//TODO make events conditional
Tokenizer.prototype.write = function(chunk){
	if(this._ended) this._cbs.onerror(Error(".write() after done!"));

	this._buffer += chunk;
	this._parse();
};

Tokenizer.prototype._parse = function(){
	while(this._index < this._buffer.length && this._running){
		var c = this._buffer.charAt(this._index);
		if(this._state === TEXT) {
			this._stateText(c);
		} else if(this._state === BEFORE_TAG_NAME){
			this._stateBeforeTagName(c);
		} else if(this._state === IN_TAG_NAME) {
			this._stateInTagName(c);
		} else if(this._state === BEFORE_CLOSING_TAG_NAME){
			this._stateBeforeCloseingTagName(c);
		} else if(this._state === IN_CLOSING_TAG_NAME){
			this._stateInCloseingTagName(c);
		} else if(this._state === AFTER_CLOSING_TAG_NAME){
			this._stateAfterCloseingTagName(c);
		} else if(this._state === IN_SELF_CLOSING_TAG){
			this._stateInSelfClosingTag(c);
		}

		/*
		*	attributes
		*/
		else if(this._state === BEFORE_ATTRIBUTE_NAME){
			this._stateBeforeAttributeName(c);
		} else if(this._state === IN_ATTRIBUTE_NAME){
			this._stateInAttributeName(c);
		} else if(this._state === AFTER_ATTRIBUTE_NAME){
			this._stateAfterAttributeName(c);
		} else if(this._state === BEFORE_ATTRIBUTE_VALUE){
			this._stateBeforeAttributeValue(c);
		} else if(this._state === IN_ATTRIBUTE_VALUE_DQ){
			this._stateInAttributeValueDoubleQuotes(c);
		} else if(this._state === IN_ATTRIBUTE_VALUE_SQ){
			this._stateInAttributeValueSingleQuotes(c);
		} else if(this._state === IN_ATTRIBUTE_VALUE_NQ){
			this._stateInAttributeValueNoQuotes(c);
		}

		/*
		*	declarations
		*/
		else if(this._state === BEFORE_DECLARATION){
			this._stateBeforeDeclaration(c);
		} else if(this._state === IN_DECLARATION){
			this._stateInDeclaration(c);
		}

		/*
		*	processing instructions
		*/
		else if(this._state === IN_PROCESSING_INSTRUCTION){
			this._stateInProcessingInstruction(c);
		}

		/*
		*	comments
		*/
		else if(this._state === BEFORE_COMMENT){
			this._stateBeforeComment(c);
		} else if(this._state === IN_COMMENT){
			this._stateInComment(c);
		} else if(this._state === AFTER_COMMENT_1){
			this._stateAfterComment1(c);
		} else if(this._state === AFTER_COMMENT_2){
			this._stateAfterComment2(c);
		}

		/*
		*	cdata
		*/
		else if(this._state === BEFORE_CDATA_1){
			this._stateBeforeCdata1(c);
		} else if(this._state === BEFORE_CDATA_2){
			this._stateBeforeCdata2(c);
		} else if(this._state === BEFORE_CDATA_3){
			this._stateBeforeCdata3(c);
		} else if(this._state === BEFORE_CDATA_4){
			this._stateBeforeCdata4(c);
		} else if(this._state === BEFORE_CDATA_5){
			this._stateBeforeCdata5(c);
		} else if(this._state === BEFORE_CDATA_6){
			this._stateBeforeCdata6(c);
		} else if(this._state === IN_CDATA){
			this._stateInCdata(c);
		} else if(this._state === AFTER_CDATA_1){
			this._stateAfterCdata1(c);
		} else if(this._state === AFTER_CDATA_2){
			this._stateAfterCdata2(c);
		}

		/*
		* special tags
		*/
		else if(this._state === BEFORE_SPECIAL){
			this._stateBeforeSpecial(c);
		} else if(this._state === BEFORE_SPECIAL_END){
			this._stateBeforeSpecialEnd(c);
		}

		/*
		* script
		*/
		else if(this._state === BEFORE_SCRIPT_1){
			this._stateBeforeScript1(c);
		} else if(this._state === BEFORE_SCRIPT_2){
			this._stateBeforeScript2(c);
		} else if(this._state === BEFORE_SCRIPT_3){
			this._stateBeforeScript3(c);
		} else if(this._state === BEFORE_SCRIPT_4){
			this._stateBeforeScript4(c);
		} else if(this._state === BEFORE_SCRIPT_5){
			this._stateBeforeScript5(c);
		}

		else if(this._state === AFTER_SCRIPT_1){
			this._stateAfterScript1(c);
		} else if(this._state === AFTER_SCRIPT_2){
			this._stateAfterScript2(c);
		} else if(this._state === AFTER_SCRIPT_3){
			this._stateAfterScript3(c);
		} else if(this._state === AFTER_SCRIPT_4){
			this._stateAfterScript4(c);
		} else if(this._state === AFTER_SCRIPT_5){
			this._stateAfterScript5(c);
		}

		/*
		* style
		*/
		else if(this._state === BEFORE_STYLE_1){
			this._stateBeforeStyle1(c);
		} else if(this._state === BEFORE_STYLE_2){
			this._stateBeforeStyle2(c);
		} else if(this._state === BEFORE_STYLE_3){
			this._stateBeforeStyle3(c);
		} else if(this._state === BEFORE_STYLE_4){
			this._stateBeforeStyle4(c);
		}

		else if(this._state === AFTER_STYLE_1){
			this._stateAfterStyle1(c);
		} else if(this._state === AFTER_STYLE_2){
			this._stateAfterStyle2(c);
		} else if(this._state === AFTER_STYLE_3){
			this._stateAfterStyle3(c);
		} else if(this._state === AFTER_STYLE_4){
			this._stateAfterStyle4(c);
		}

		/*
		* entities
		*/
		else if(this._state === BEFORE_ENTITY){
			this._stateBeforeEntity(c);
		} else if(this._state === BEFORE_NUMERIC_ENTITY){
			this._stateBeforeNumericEntity(c);
		} else if(this._state === IN_NAMED_ENTITY){
			this._stateInNamedEntity(c);
		} else if(this._state === IN_NUMERIC_ENTITY){
			this._stateInNumericEntity(c);
		} else if(this._state === IN_HEX_ENTITY){
			this._stateInHexEntity(c);
		}

		else {
			this._cbs.onerror(Error("unknown _state"), this._state);
		}

		this._index++;
	}

	this._cleanup();
};

Tokenizer.prototype.pause = function(){
	this._running = false;
};
Tokenizer.prototype.resume = function(){
	this._running = true;

	if(this._index < this._buffer.length){
		this._parse();
	}
	if(this._ended){
		this._finish();
	}
};

Tokenizer.prototype.end = function(chunk){
	if(this._ended) this._cbs.onerror(Error(".end() after done!"));
	if(chunk) this.write(chunk);

	this._ended = true;

	if(this._running) this._finish();
};

Tokenizer.prototype._finish = function(){
	//if there is remaining data, emit it in a reasonable way
	if(this._sectionStart < this._index){
		this._handleTrailingData();
	}

	this._cbs.onend();
};

Tokenizer.prototype._handleTrailingData = function(){
	var data = this._buffer.substr(this._sectionStart);

	if(this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2){
		this._cbs.oncdata(data);
	} else if(this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2){
		this._cbs.oncomment(data);
	} else if(this._state === IN_NAMED_ENTITY && !this._xmlMode){
		this._parseLegacyEntity();
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(this._state === IN_NUMERIC_ENTITY && !this._xmlMode){
		this._decodeNumericEntity(2, 10);
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(this._state === IN_HEX_ENTITY && !this._xmlMode){
		this._decodeNumericEntity(3, 16);
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(
		this._state !== IN_TAG_NAME &&
		this._state !== BEFORE_ATTRIBUTE_NAME &&
		this._state !== BEFORE_ATTRIBUTE_VALUE &&
		this._state !== AFTER_ATTRIBUTE_NAME &&
		this._state !== IN_ATTRIBUTE_NAME &&
		this._state !== IN_ATTRIBUTE_VALUE_SQ &&
		this._state !== IN_ATTRIBUTE_VALUE_DQ &&
		this._state !== IN_ATTRIBUTE_VALUE_NQ &&
		this._state !== IN_CLOSING_TAG_NAME
	){
		this._cbs.ontext(data);
	}
	//else, ignore remaining data
	//TODO add a way to remove current tag
};

Tokenizer.prototype.reset = function(){
	Tokenizer.call(this, {xmlMode: this._xmlMode, decodeEntities: this._decodeEntities}, this._cbs);
};

Tokenizer.prototype.getAbsoluteIndex = function(){
	return this._bufferOffset + this._index;
};

Tokenizer.prototype._getSection = function(){
	return this._buffer.substring(this._sectionStart, this._index);
};

Tokenizer.prototype._emitToken = function(name){
	this._cbs[name](this._getSection());
	this._sectionStart = -1;
};

Tokenizer.prototype._emitPartial = function(value){
	if(this._baseState !== TEXT){
		this._cbs.onattribdata(value); //TODO implement the new event
	} else {
		this._cbs.ontext(value);
	}
};

},{"entities/lib/decode_codepoint.js":99,"entities/maps/entities.json":102,"entities/maps/legacy.json":103,"entities/maps/xml.json":104}],118:[function(require,module,exports){
module.exports = Stream;

var Parser = require("./Parser.js"),
    WritableStream = require("stream").Writable || require("readable-stream").Writable,
    StringDecoder = require("string_decoder").StringDecoder,
    Buffer = require("buffer").Buffer;

function Stream(cbs, options){
	var parser = this._parser = new Parser(cbs, options);
	var decoder = this._decoder = new StringDecoder();

	WritableStream.call(this, {decodeStrings: false});

	this.once("finish", function(){
		parser.end(decoder.end());
	});
}

require("inherits")(Stream, WritableStream);

WritableStream.prototype._write = function(chunk, encoding, cb){
	if(chunk instanceof Buffer) chunk = this._decoder.write(chunk);
	this._parser.write(chunk);
	cb();
};
},{"./Parser.js":114,"buffer":66,"inherits":121,"readable-stream":64,"stream":191,"string_decoder":192}],119:[function(require,module,exports){
var Parser = require("./Parser.js"),
    DomHandler = require("domhandler");

function defineProp(name, value){
	delete module.exports[name];
	module.exports[name] = value;
	return value;
}

module.exports = {
	Parser: Parser,
	Tokenizer: require("./Tokenizer.js"),
	ElementType: require("domelementtype"),
	DomHandler: DomHandler,
	get FeedHandler(){
		return defineProp("FeedHandler", require("./FeedHandler.js"));
	},
	get Stream(){
		return defineProp("Stream", require("./Stream.js"));
	},
	get WritableStream(){
		return defineProp("WritableStream", require("./WritableStream.js"));
	},
	get ProxyHandler(){
		return defineProp("ProxyHandler", require("./ProxyHandler.js"));
	},
	get DomUtils(){
		return defineProp("DomUtils", require("domutils"));
	},
	get CollectingHandler(){
		return defineProp("CollectingHandler", require("./CollectingHandler.js"));
	},
	// For legacy support
	DefaultHandler: DomHandler,
	get RssHandler(){
		return defineProp("RssHandler", this.FeedHandler);
	},
	//helper methods
	parseDOM: function(data, options){
		var handler = new DomHandler(options);
		new Parser(handler, options).end(data);
		return handler.dom;
	},
	parseFeed: function(feed, options){
		var handler = new module.exports.FeedHandler(options);
		new Parser(handler, options).end(feed);
		return handler.dom;
	},
	createDomStream: function(cb, options, elementCb){
		var handler = new DomHandler(cb, options, elementCb);
		return new Parser(handler, options);
	},
	// List of all events that the parser emits
	EVENTS: { /* Format: eventname: number of arguments */
		attribute: 2,
		cdatastart: 0,
		cdataend: 0,
		text: 1,
		processinginstruction: 2,
		comment: 1,
		commentend: 0,
		closetag: 1,
		opentag: 2,
		opentagname: 1,
		error: 1,
		end: 0
	}
};

},{"./CollectingHandler.js":112,"./FeedHandler.js":113,"./Parser.js":114,"./ProxyHandler.js":115,"./Stream.js":116,"./Tokenizer.js":117,"./WritableStream.js":118,"domelementtype":84,"domhandler":85,"domutils":88}],120:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],121:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],122:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],123:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],124:[function(require,module,exports){
'use strict';

var Mtree = require('1tree-factory');

var createTree = require('./plugins/createTree');
var insertBefore = require('./plugins/insertBefore');
var dom = require('./plugins/dom');
var parse = require('./plugins/parse');
var select = require('./plugins/select');
var stringify = require('./plugins/stringify');
var types = require('./plugins/types');
var vdom = require('./plugins/vdom');

var Htree = Mtree(dom, parse, select, stringify, types, vdom);

// add afterwards because the original createTree doesn't exist until now
Htree.plugin(createTree);
// add afterwards so that it wraps parentMap and not the other way round
Htree.plugin(insertBefore);

module.exports = Htree;
},{"./plugins/createTree":127,"./plugins/dom":130,"./plugins/insertBefore":132,"./plugins/parse":133,"./plugins/select":135,"./plugins/stringify":136,"./plugins/types":137,"./plugins/vdom":138,"1tree-factory":3}],125:[function(require,module,exports){
'use strict';

var EntityNode = require('mtype-node');

var DomHandler = function DomHandler(options) {
  var state = State(options);

  var handler = { state: state };

  var api = Api(handler);

  return api;
};

//default options
var defaultOpts = {
  normalizeWhitespace: false
};

var whitespace = /\s+/g;

var State = function State(options) {
  options = options || defaultOpts;

  var dom = EntityNode('documentFragment');
  var done = false;
  var tagStack = [];
  var parser = null;

  var state = {
    options: options, dom: dom, done: done, tagStack: tagStack, parser: parser
  };

  return state;
};

var Api = function Api(handler) {
  var oninit = function oninit(parser) {
    return handler.state.parser = parser;
  };

  var onreset = function onreset() {
    var options = handler.state.options;


    handler.state = State(options);
  };

  var onend = function onend() {
    if (handler.state.done) return;

    handler.state.done = true;
    handler.state.parser = null;
    onerror(null);
  };

  var onerror = function onerror(err) {
    if (err) throw err;
  };

  var onclosetag = function onclosetag() {
    var tagStack = handler.state.tagStack;


    tagStack.pop();
  };

  var onopentag = function onopentag(name, attribs) {
    var tagStack = handler.state.tagStack;


    var element = EntityNode('element', {
      tagName: name,
      attributes: attribs
    });

    addDomElement(handler, element);
    tagStack.push(element);
  };

  var ontext = function ontext(data) {
    var options = handler.state.options;


    var normalize = options.normalizeWhitespace || options.ignoreWhitespace ? function (str) {
      return str.replace(whitespace, ' ');
    } : function (str) {
      return str;
    };

    var previousText = findPreviousText(handler);

    if (previousText) {
      previousText.value.nodeValue = normalize(previousText.nodeValue + data);
    } else {
      data = normalize(data);

      var text = EntityNode('text', { nodeValue: data });

      addDomElement(handler, text);
    }
  };

  var oncomment = function oncomment(data) {
    var tagStack = handler.state.tagStack;


    var lastTag = tagStack[tagStack.length - 1];

    if (lastTag && lastTag.value.nodeType === 'comment') {
      lastTag.value.nodeValue += data;

      return;
    }

    var comment = EntityNode('comment', { nodeValue: data });

    addDomElement(handler, comment);
    tagStack.push(comment);
  };

  var onprocessinginstruction = function onprocessinginstruction(name, data) {
    oncomment(data);
    oncommentend();
  };

  var oncommentend = function oncommentend() {
    return handler.state.tagStack.pop();
  };

  var getDom = function getDom() {
    return handler.state.dom;
  };

  var api = {
    oninit: oninit, onreset: onreset, onend: onend, onerror: onerror, onclosetag: onclosetag, onopentag: onopentag, ontext: ontext, oncomment: oncomment,
    oncommentend: oncommentend, onprocessinginstruction: onprocessinginstruction, getDom: getDom
  };

  return api;
};

var findPreviousText = function findPreviousText(handler) {
  var _handler$state = handler.state,
      tagStack = _handler$state.tagStack,
      dom = _handler$state.dom;


  if (tagStack.length) {
    var lastTag = tagStack[tagStack.length - 1];
    var _children = lastTag.children;

    if (_children.length) {
      var _lastChild = _children[_children.length - 1];

      if (_lastChild.value.nodeType === 'text') return _lastChild;
    }
  }

  var children = dom.children;

  if (!children || !children.length) return;

  var lastChild = children[children.length - 1];

  if (lastChild.value.nodeType === 'text') return lastChild;
};

var addDomElement = function addDomElement(handler, element) {
  var _handler$state2 = handler.state,
      tagStack = _handler$state2.tagStack,
      dom = _handler$state2.dom;


  var parent = tagStack[tagStack.length - 1];
  var target = parent ? parent.children : dom.children;

  target.push(element);
};

module.exports = DomHandler;
},{"mtype-node":165}],126:[function(require,module,exports){
'use strict';

var htmlparser2 = require('htmlparser2');
var DomHandler = require('./domhandler-adapter');

var parse = function parse(str) {
  var handler = DomHandler();
  new htmlparser2.Parser(handler).end(str);

  return handler.getDom();
};

module.exports = parse;
},{"./domhandler-adapter":125,"htmlparser2":119}],127:[function(require,module,exports){
'use strict';

/*
  Extend createTree to allow creating a tree from an HTML string
*/

var parseStr = require('../../parse');

// should be added after the default plugins so that createTree exists!
var createTreeFromStr = function createTreeFromStr(fn) {
  // override createTree to allow passing a string
  var originalCreateTree = fn.createTree;

  var createTree = function createTree(rootValue) {
    if (typeof rootValue === 'string') rootValue = parseStr(rootValue);

    return originalCreateTree(rootValue);
  };

  createTree.def = originalCreateTree.def;

  return Object.assign(fn, { createTree: createTree });
};

module.exports = createTreeFromStr;
},{"../../parse":126}],128:[function(require,module,exports){
'use strict';

var EntityNode = require('mtype-node');
var utils = require('mojule-utils');

var capitalizeFirstLetter = utils.capitalizeFirstLetter;


var nodeMap = {
  element: function element() {
    return {
      tagName: 'div',
      attributes: {}
    };
  },
  comment: function comment() {
    return {
      nodeValue: '',
      isEmpty: true
    };
  },
  text: function text() {
    return {
      nodeValue: '',
      isEmpty: true
    };
  },
  documentType: function documentType() {
    return {
      name: 'html',
      publicId: '',
      systemId: '',
      isEmpty: true
    };
  }
};

var createDomNode = function createDomNode(fn, nodeType, value) {
  var defaultValue = nodeType in nodeMap ? nodeMap[nodeType]() : {};

  value = Object.assign({ nodeType: nodeType }, defaultValue, value || {});

  var entityNode = EntityNode(nodeType, value);

  var node = fn.createNode(entityNode.value);

  var capNodeType = capitalizeFirstLetter(nodeType);
  var assertName = 'assert' + capNodeType;

  fn[assertName](node);

  return node;
};

var createDomNodeDef = function createDomNodeDef(nodeType, argTypes) {
  return {
    argTypes: argTypes,
    returnType: 'node',
    requires: ['createNode', 'assert' + capitalizeFirstLetter(nodeType)],
    categories: ['create', 'plugin']
  };
};

var create = function create(fn) {
  var createElement = function createElement(tagName, attributes) {
    attributes = attributes || {};

    return createDomNode(fn, 'element', { tagName: tagName, attributes: attributes });
  };

  createElement.def = createDomNodeDef('element', ['string', 'object']);

  var createComment = function createComment(nodeValue) {
    return createDomNode(fn, 'element', { nodeValue: nodeValue });
  };

  createComment.def = createDomNodeDef('comment', ['string']);

  var createDocument = function createDocument() {
    return createDomNode(fn, 'document');
  };

  createDocument.def = createDomNodeDef('document', []);

  var createDocumentFragment = function createDocumentFragment() {
    return createDomNode(fn, 'documentFragment');
  };

  createDocumentFragment.def = createDomNodeDef('documentFragment', []);

  var createText = function createText(nodeValue) {
    return createDomNode(fn, 'text', {
      nodeValue: String(nodeValue)
    });
  };

  createText.def = createDomNodeDef('text', ['string']);

  var createDocumentType = function createDocumentType(name, publicId, systemId) {
    return createDomNode(fn, 'documentType', { name: name, publicId: publicId, systemId: systemId });
  };

  createDocumentType.def = createDomNodeDef('documentType', ['string', 'string', 'string']);

  var plugins = {
    createText: createText, createElement: createElement, createComment: createComment, createDocument: createDocument,
    createDocumentFragment: createDocumentFragment, createDocumentType: createDocumentType
  };

  return Object.assign(fn, plugins);
};

module.exports = create;
},{"mojule-utils":161,"mtype-node":165}],129:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var utils = require('mojule-utils');

var clone = utils.clone;


var element = function element(fn) {
  var attributes = function attributes(node, attributeMap) {
    fn.assertElement(node);

    var nodeValue = fn.value(node);

    if ((typeof attributeMap === 'undefined' ? 'undefined' : _typeof(attributeMap)) === 'object') {
      Object.keys(attributeMap).forEach(function (attributeName) {
        var attributeValue = attributeMap[attributeName];

        fn.attr(node, attributeName, attributeValue);
      });
    }

    if (nodeValue.attributes === undefined) return {};

    return clone(nodeValue.attributes);
  };

  attributes.def = {
    argTypes: ['node', 'object?'],
    returnType: 'object',
    requires: ['value', 'assertElement', 'attr'],
    categories: ['dom', 'attributes', 'plugins']
  };

  var tagName = function tagName(node, value) {
    fn.assertElement(node);

    var nodeValue = fn.value(node);

    if (value !== undefined) {
      nodeValue.tagName = value;

      fn.value(node, nodeValue);
    }

    return nodeValue.tagName;
  };

  tagName.def = {
    argTypes: ['node', 'string'],
    returnType: 'string',
    requires: ['value', 'assertElement'],
    categories: ['dom', 'tagName', 'plugins']
  };

  var attr = function attr(node, name, value) {
    fn.assertElement(node);

    var nodeValue = fn.value(node);

    if (value !== undefined) {
      if (nodeValue.attributes === undefined) nodeValue.attributes = {};

      nodeValue.attributes[name] = value.toString();

      fn.value(node, nodeValue);
    }

    if (_typeof(nodeValue.attributes) === 'object') return nodeValue.attributes[name];
  };

  attr.def = {
    argTypes: ['node', 'string', 'string'],
    returnType: 'string',
    requires: ['value', 'assertElement'],
    categories: ['dom', 'attr', 'plugins']
  };

  var hasAttr = function hasAttr(node, name) {
    fn.assertElement(node);

    return fn.attr(node, name) !== undefined;
  };

  hasAttr.def = {
    argTypes: ['node', 'string'],
    returnType: 'boolean',
    requires: ['value', 'assertElement'],
    categories: ['dom', 'hasAttr', 'plugins']
  };

  var removeAttr = function removeAttr(node, name) {
    fn.assertElement(node);

    var nodeValue = fn.value(node);

    if (_typeof(nodeValue.attributes) === 'object') delete nodeValue.attributes[name];

    fn.value(node, nodeValue);
  };

  removeAttr.def = {
    argTypes: ['node', 'string'],
    requires: ['value', 'assertElement'],
    categories: ['dom', 'removeAttr', 'plugins']
  };

  var clearAttrs = function clearAttrs(node) {
    fn.assertElement(node);

    var nodeValue = fn.value(node);

    nodeValue.attributes = {};

    fn.value(node, nodeValue);
  };

  clearAttrs.def = {
    argTypes: ['node'],
    requires: ['value', 'assertElement'],
    categories: ['dom', 'clearAttrs', 'plugins']
  };

  var clearClasses = function clearClasses(node) {
    fn.assertElement(node);

    fn.attr(node, 'class', '');
  };

  clearClasses.def = {
    argTypes: ['node'],
    requires: ['value', 'assertElement'],
    categories: ['dom', 'clearClasses', 'plugins']
  };

  var classNames = function classNames(node) {
    fn.assertElement(node);

    var classNames = fn.attr(node, 'class');

    if (typeof classNames === 'string') return classNames.split(' ');

    return [];
  };

  classNames.def = {
    argTypes: ['node'],
    returnType: '[string]',
    requires: ['attr', 'assertElement'],
    categories: ['dom', 'classNames', 'plugins']
  };

  var hasClass = function hasClass(node, className) {
    fn.assertElement(node);

    return fn.classNames(node).some(function (name) {
      return name === className;
    });
  };

  hasClass.def = {
    argTypes: ['node', 'string'],
    returnType: 'boolean',
    requires: ['classNames', 'assertElement'],
    categories: ['dom', 'hasClass', 'plugins']
  };

  var addClass = function addClass(node, className) {
    fn.assertElement(node);

    className = className.trim();

    var existing = fn.classNames(node);

    existing.push(className);

    fn.attr(node, 'class', existing.join(' '));

    return node;
  };

  addClass.def = {
    argTypes: ['node', 'string'],
    returnType: 'node',
    requires: ['classNames', 'attr', 'assertElement'],
    categories: ['dom', 'addClass', 'plugins']
  };

  var removeClass = function removeClass(node, className) {
    fn.assertElement(node);

    className = className.trim();

    var existing = fn.classNames(node).filter(function (name) {
      return name !== className;
    });

    fn.attr(node, 'class', existing.join(' '));

    return node;
  };

  removeClass.def = {
    argTypes: ['node', 'string'],
    returnType: 'node',
    requires: ['classNames', 'attr', 'assertElement'],
    categories: ['dom', 'removeClass', 'plugins']
  };

  var toggleClass = function toggleClass(node, className, shouldHave) {
    fn.assertElement(node);

    var alreadyHas = fn.hasClass(node, className);

    if (typeof shouldHave !== 'boolean') return fn.toggleClass(node, className, !alreadyHas);

    if (alreadyHas) {
      if (shouldHave) return node;

      return fn.removeClass(node, className);
    }

    if (shouldHave) return fn.addClass(node, className);

    return node;
  };

  toggleClass.def = {
    argTypes: ['node', 'string', 'boolean'],
    returnType: 'node',
    requires: ['hasClass', 'removeClass', 'addClass', 'assertElement'],
    categories: ['dom', 'toggleClass', 'plugins']
  };

  var plugins = {
    attributes: attributes, attr: attr, hasAttr: hasAttr, removeAttr: removeAttr, classNames: classNames, hasClass: hasClass, addClass: addClass,
    removeClass: removeClass, toggleClass: toggleClass, tagName: tagName, clearAttrs: clearAttrs, clearClasses: clearClasses
  };

  return Object.assign(fn, plugins);
};

module.exports = element;
},{"mojule-utils":161}],130:[function(require,module,exports){
'use strict';

var element = require('./element');
var create = require('./create');
var node = require('./node');

var dom = function dom(fn) {
  element(fn);
  create(fn);
  node(fn);
};

module.exports = dom;
},{"./create":128,"./element":129,"./node":131}],131:[function(require,module,exports){
'use strict';

var Html = require('html-node');

var html = Html();

var emptyNodeTypes = ['text', 'comment', 'documentType'];

var nodeNameMap = {
  element: function element(fn, node) {
    return fn.tagName(node);
  },
  documentType: function documentType(fn, node) {
    var value = fn.value(node);

    return value.name;
  }
};

var nodePlugins = function nodePlugins(fn) {
  var nodeType = function nodeType(fn, node) {
    var value = fn.value(node);

    return value.nodeType;
  };

  nodeType.def = {
    argTypes: ['fn', 'node'],
    returnType: 'string',
    requires: ['value'],
    categories: ['node', 'plugin']
  };

  var nodeName = function nodeName(fn, node) {
    var nodeType = fn.nodeType(fn, node);

    if (nodeType in nodeNameMap) return nodeNameMap[nodeType](fn, node);

    return '#' + nodeType;
  };

  nodeName.def = {
    argTypes: ['fn', 'node'],
    returnType: 'string',
    requires: ['nodeType'],
    categories: ['node', 'plugin']
  };

  var isEmpty = function isEmpty(fn, node) {
    var nodeType = fn.nodeType(fn, node);

    if (emptyNodeTypes.includes(nodeType)) return true;

    if (nodeType === 'element') {
      var tagName = fn.tagName(node);

      return html.isEmpty(tagName);
    }

    // assumes remaining node types should be able to have children, is this true?
    return false;
  };

  isEmpty.def = {
    argType: ['fn', 'node'],
    returnType: 'boolean',
    require: ['nodeType', 'tagName'],
    categories: ['node', 'plugin']
  };

  var accepts = function accepts(fn, node, childNode) {
    var isEmpty = fn.isEmpty(fn, node);

    if (isEmpty) return false;

    var nodeType = fn.nodeType(fn, node);
    var childNodeType = fn.nodeType(fn, childNode);

    if (childNodeType === 'documentType') return nodeType === 'document';

    if (nodeType === 'element') {
      if (childNodeType === 'text' || childNodeType === 'comment') return true;

      var _nodeName = fn.nodeName(fn, node);
      var childName = fn.nodeName(fn, childNode);

      return html.accepts(_nodeName, childName);
    }

    // assumes non-elements that can have child nodes can have any child node,
    // is this true?
    return true;
  };

  accepts.def = {
    argType: ['fn', 'node', 'node'],
    returnType: 'boolean',
    require: ['isEmpty', 'nodeType', 'nodeName'],
    categories: ['node', 'plugin']
  };

  return Object.assign(fn, { nodeType: nodeType, nodeName: nodeName, isEmpty: isEmpty, accepts: accepts });
};

module.exports = nodePlugins;
},{"html-node":111}],132:[function(require,module,exports){
'use strict';

var insertBeforeWrapper = function insertBeforeWrapper(fn) {
  var originalInsertBefore = fn.insertBefore;

  var insertBefore = function insertBefore(fn, root, parentNode, childNode, referenceNode) {
    // TODO
    // handle document fragments
    // handle combining text elements
    return originalInsertBefore(fn, root, parentNode, childNode, referenceNode);
  };

  insertBefore.def = originalInsertBefore.def;

  return Object.assign(fn, { insertBefore: insertBefore });
};

module.exports = insertBeforeWrapper;
},{}],133:[function(require,module,exports){
'use strict';

var parseStr = require('../../parse');

var parser = function parser(fn) {
  var parse = function parse(str) {
    return fn.deserialize(parseStr(str));
  };

  parse.def = {
    argTypes: ['string'],
    returnType: 'node',
    requires: ['deserialize'],
    categories: ['parser', 'plugin']
  };

  return Object.assign(fn, { parse: parse });
};

module.exports = parser;
},{"../../parse":126}],134:[function(require,module,exports){
'use strict';

var baseAdapter = require('css-select-base-adapter');

var Adapter = function Adapter(fn, root) {
  var isTag = function isTag(node) {
    var value = fn.value(node);

    return value && value.nodeType === 'element';
  };

  var getAttributeValue = function getAttributeValue(node, name) {
    var value = fn.value(node);

    if (value && value.attributes) return value.attributes[name];
  };

  var getChildren = function getChildren(node) {
    return fn.getChildren(node);
  };

  var getName = function getName(node) {
    var value = fn.value(node);

    if (value) return value.tagName;
  };

  var getParent = function getParent(node) {
    return fn.getParent(fn, root, node);
  };

  var getText = function getText(node) {
    if (Array.isArray(node)) return node.map(getText).join('');

    if (isTag(node)) return getText(getChildren(node));

    var value = fn.value(node);

    if (value && value.nodeType === 'text') return value.nodeValue;

    return '';
  };

  var adapter = {
    isTag: isTag, getAttributeValue: getAttributeValue, getChildren: getChildren, getName: getName, getParent: getParent, getText: getText
  };

  return baseAdapter(adapter);
};

module.exports = Adapter;
},{"css-select-base-adapter":72}],135:[function(require,module,exports){
'use strict';

var Adapter = require('./htmlparser2-adapter');
var Select = require('../../select');

var Selecter = function Selecter(fn, root) {
  return Select(Adapter(fn, root));
};

var querySelector = function querySelector(fn) {
  var select = function select(fn, root, node, query) {
    return Selecter(fn, root).select(node, query);
  };

  select.def = {
    argTypes: ['fn', 'rootNode', 'node', 'string'],
    returnType: 'node',
    requires: ['value', 'getChildren', 'getParent'],
    categories: ['query', 'select', 'plugins']
  };

  var selectAll = function selectAll(fn, root, node, query) {
    return Selecter(fn, root).selectAll(node, query);
  };

  selectAll.def = {
    argTypes: ['fn', 'rootNode', 'node', 'string'],
    returnType: '[node]',
    requires: ['value', 'getChildren', 'getParent'],
    categories: ['query', 'select', 'plugins']
  };

  var matches = function matches(fn, root, node, query) {
    return Selecter(fn, root).matches(node, query);
  };

  matches.def = {
    argTypes: ['fn', 'rootNode', 'node', 'string'],
    returnType: 'boolean',
    requires: ['value', 'getChildren', 'getParent'],
    categories: ['query', 'select', 'plugins']
  };

  var plugin = { select: select, selectAll: selectAll, matches: matches };

  return Object.assign(fn, plugin);
};

module.exports = querySelector;
},{"../../select":140,"./htmlparser2-adapter":134}],136:[function(require,module,exports){
'use strict';

var stringifyNode = require('../../stringify');

var stringifier = function stringifier(fn) {
  var stringify = function stringify(node) {
    return stringifyNode(node);
  };

  stringify.def = {
    argTypes: ['node'],
    returnType: 'string',
    requires: [],
    categories: ['stringify', 'plugin']
  };

  return Object.assign(fn, { stringify: stringify });
};

module.exports = stringifier;
},{"../../stringify":141}],137:[function(require,module,exports){
'use strict';

var Validator = require('mtype-tv4');
var schema = require('../../schema');
var utils = require('mojule-utils');

var capitalizeFirstLetter = utils.capitalizeFirstLetter;

// could get this from the names, but better to be explicit

var nodeTypes = ['text', 'element', 'comment', 'document', 'documentType', 'documentFragment'];

var validator = Validator(schema);
var t = Validator.mtype(validator);

var isType = function isType(node, typename) {
  return t.is(node, typename);
};

isType.def = {
  argTypes: ['node', 'string'],
  returnType: 'boolean',
  requires: [],
  categories: ['type', 'plugin']
};

var types = function types(fn) {
  var assertType = function assertType(node, typename) {
    if (!fn.isType(node, typename)) {
      var result = validator.validateMultiple(node, schema[typename]);
      var errors = JSON.stringify(result.errors);

      throw new TypeError('Expected node to be ' + typename + '; ' + errors);
    }
  };

  assertType.def = {
    argTypes: ['node', 'string'],
    requires: ['isType'],
    categories: ['type', 'plugin']
  };

  var plugins = { isType: isType, assertType: assertType };

  // add isDocument, isText etc
  nodeTypes.forEach(function (typename) {
    var capTypename = capitalizeFirstLetter(typename);
    var isName = 'is' + capTypename;
    var assertName = 'assert' + capTypename;

    plugins[isName] = function (node) {
      return fn.isType(node, typename);
    };
    plugins[isName].def = isType.def;

    plugins[assertName] = function (node) {
      return fn.assertType(node, typename);
    };
    plugins[assertName].def = assertType.def;
  });

  return Object.assign(fn, plugins);
};

module.exports = types;
},{"../../schema":139,"mojule-utils":161,"mtype-tv4":171}],138:[function(require,module,exports){
'use strict';

var morphdom = require('morphdom');
var Vnode = require('../../vdom');

var morphdomPlugin = function morphdomPlugin(fn) {
  var patchDom = function patchDom(node, targetEl, options) {
    //Vnode expects wrapped node!
    var wrapped = fn.createTree(node);
    var vdom = Vnode(wrapped);

    morphdom(targetEl, vdom, options);
  };

  patchDom.def = {
    argTypes: ['node', 'object', 'object'],
    requires: ['createTree'],
    categories: ['patch', 'plugin']
  };

  return Object.assign(fn, { morphdom: patchDom });
};

module.exports = morphdomPlugin;
},{"../../vdom":142,"morphdom":162}],139:[function(require,module,exports){
'use strict';

var entityNode = require('mtype-node/schema/entityNode.schema.json');
var entityNodeValue = require('mtype-node/schema/entityNodeValue.schema.json');
var emptyNode = require('mtype-node/schema/emptyNode.schema.json');
var parentNode = require('mtype-node/schema/parentNode.schema.json');

var comment = require('../../schema/comment.schema.json');
var commentValue = require('../../schema/commentValue.schema.json');
var documentFragment = require('../../schema/documentFragment.schema.json');
var documentFragmentValue = require('../../schema/documentFragmentValue.schema.json');
var document = require('../../schema/document.schema.json');
var documentValue = require('../../schema/documentValue.schema.json');
var documentType = require('../../schema/documentType.json');
var documentTypeValue = require('../../schema/documentTypeValue.schema.json');
var element = require('../../schema/element.schema.json');
var elementValue = require('../../schema/elementValue.schema.json');
var text = require('../../schema/text.schema.json');
var textValue = require('../../schema/textValue.schema.json');

var schema = {
  comment: comment, commentValue: commentValue, documentFragment: documentFragment,
  documentFragmentValue: documentFragmentValue, document: document, documentValue: documentValue, documentType: documentType,
  documentTypeValue: documentTypeValue, element: element, elementValue: elementValue, text: text, textValue: textValue,

  entityNode: entityNode, entityNodeValue: entityNodeValue, emptyNode: emptyNode, parentNode: parentNode
};

module.exports = schema;
},{"../../schema/comment.schema.json":144,"../../schema/commentValue.schema.json":145,"../../schema/document.schema.json":146,"../../schema/documentFragment.schema.json":147,"../../schema/documentFragmentValue.schema.json":148,"../../schema/documentType.json":149,"../../schema/documentTypeValue.schema.json":150,"../../schema/documentValue.schema.json":151,"../../schema/element.schema.json":152,"../../schema/elementValue.schema.json":153,"../../schema/text.schema.json":154,"../../schema/textValue.schema.json":155,"mtype-node/schema/emptyNode.schema.json":166,"mtype-node/schema/entityNode.schema.json":167,"mtype-node/schema/entityNodeValue.schema.json":168,"mtype-node/schema/parentNode.schema.json":169}],140:[function(require,module,exports){
'use strict';

var CSSselect = require('css-select');

var Select = function Select(adapter) {
  var options = { adapter: adapter };

  var select = function select(node, selector) {
    return CSSselect.selectOne(selector, node, options);
  };

  var selectAll = function selectAll(node, selector) {
    return CSSselect(selector, node, options);
  };

  var matches = function matches(node, selector) {
    return CSSselect.is(node, selector, options);
  };

  var api = {
    select: select, selectAll: selectAll, matches: matches
  };

  return api;
};

module.exports = Select;
},{"css-select":73}],141:[function(require,module,exports){
'use strict';

var Html = require('html-node');
var utils = require('mojule-utils');

var escapeHtml = utils.escapeHtml;


var info = Html();

var stringify = function stringify(node) {
  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  var html = '';

  var nodeType = node.value.nodeType;


  if (nodeType === 'text') html += escapeHtml(node.value.nodeValue);

  if (nodeType === 'comment') html += '<!--' + node.value.nodeValue + '-->';

  if (nodeType === 'element') {
    (function () {
      var _node$value = node.value,
          tagName = _node$value.tagName,
          attributes = _node$value.attributes;


      html += '<' + tagName;

      if (attributes) Object.keys(attributes).forEach(function (name) {
        var value = attributes[name];

        html += ' ' + name;

        if (value) html += '="' + value + '"';
      });

      html += info.isEmpty(tagName) ? ' />' : '>';

      depth++;
    })();
  }

  if (nodeType === 'documentType') {
    var _node$value2 = node.value,
        name = _node$value2.name,
        publicId = _node$value2.publicId,
        systemId = _node$value2.systemId;


    html += '<!doctype ' + name;

    if (publicId) {
      html += ' public "' + publicId + '"';
    }

    if (systemId) {
      html += ' "' + systemId + '"';
    }

    html += '>';
  }

  if (Array.isArray(node.children)) node.children.forEach(function (child) {
    return html += stringify(child, depth);
  });

  if (nodeType === 'element' && !info.isEmpty(node.value.tagName)) {
    html += '</' + node.value.tagName + '>';
  }

  return html;
};

module.exports = stringify;
},{"html-node":111,"mojule-utils":161}],142:[function(require,module,exports){
'use strict';

var Vnode = function Vnode(node) {
  if (node === null || node === undefined) {
    return node;
  }

  var vnode = {
    get firstChild() {
      return Vnode(node.firstChild());
    },

    get nextSibling() {
      return Vnode(node.nextSibling());
    },

    get nodeType() {
      return node.nodeType();
    },

    get nodeName() {
      return node.nodeName();
    },

    // should be something for svg or math etc.!
    get namespaceURI() {
      return 'http://www.w3.org/1999/xhtml';
    },

    get nodeValue() {
      var value = node.value();

      return value.nodeValue || '';
    },

    get value() {
      var value = node.value();

      return value.value;
    },

    get selected() {
      var value = node.value();

      return !!value.selected;
    },

    get disabled() {
      var value = node.value();

      return !!value.disabled;
    },

    // should be something for svg or math etc.!
    // hasAttributeNS: ( namespaceURI, name ) => {
    hasAttributeNS: function hasAttributeNS(namespaceURI) {
      return namespaceURI === vnode.namespaceURI;
    },

    assignAttributes: function assignAttributes(targetNode) {
      var attributes = node.attributes();

      Object.keys(attributes).forEach(function (name) {
        return targetNode.setAttribute(name, attributes[name]);
      });
    },

    actualize: function actualize(document) {
      return _actualize[vnode.nodeType](document, vnode);
    }
  };

  return vnode;
};

var addChildren = function addChildren(document, el, vnode) {
  var child = vnode.firstChild;

  while (child) {
    el.appendChild(child.actualize(document));
    child = child.nextSibling;
  }
};

var _actualize = {
  text: function text(document, vnode) {
    return document.createTextNode(vnode.nodeValue);
  },
  comment: function comment(document, vnode) {
    return document.createComment(vnode.nodeValue);
  },
  element: function element(document, vnode) {
    var el = document.createElement(vnode.nodeName);

    vnode.assignAttributes(el);

    addChildren(document, el, vnode);

    return el;
  },
  documentFragment: function documentFragment(document, vnode) {
    var el = document.createDocumentFragment();

    addChildren(document, el, vnode);

    return el;
  }
};

module.exports = Vnode;
},{}],143:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":124,"dup":3}],144:[function(require,module,exports){
module.exports={
  "id": "comment",
  "allOf": [
    { "$ref": "emptyNode" },
    {
      "properties": {
        "value": { "$ref": "commentValue" }
      }
    }
  ]
}

},{}],145:[function(require,module,exports){
module.exports={
  "id": "commentValue",
  "allOf":  [
    { "$ref": "entityNodeValue" },
    {
      "properties": {
        "nodeType": {
          "type": "string",
          "enum": [ "comment" ]
        },
        "nodeValue": { "type": "string" }
      },
      "required": [ "nodeType", "nodeValue" ]
    }
  ]
}
},{}],146:[function(require,module,exports){
module.exports={
  "id": "document",
  "allOf": [
    { "$ref": "parentNode" },
    {
      "properties": {
        "value": { "$ref": "documentValue" }
      }      
    }    
  ]
}

},{}],147:[function(require,module,exports){
module.exports={
  "id": "documentFragment",
  "allOf": [
    { "$ref": "parentNode" },
    {
      "properties": {
        "value": { "$ref": "documentFragmentValue" }
      }      
    }    
  ]
}

},{}],148:[function(require,module,exports){
module.exports={
  "id": "documentFragmentValue",
  "allOf":  [
    { "$ref": "entityNodeValue" },
    {
      "properties": {
        "nodeType": {
          "type": "string",
          "enum": [ "documentFragment" ]
        }
      },
      "required": [ "nodeType" ]
    }
  ]
}

},{}],149:[function(require,module,exports){
module.exports={
  "id": "documentType",
  "allOf": [
    { "$ref": "emptyNode" },
    {
      "properties": {
        "value": { "$ref": "documentTypeValue" }
      }
    }
  ]
}

},{}],150:[function(require,module,exports){
module.exports={
  "id": "documentTypeValue",
  "allOf":  [
    { "$ref": "entityNodeValue" },
    {
      "properties": {
        "nodeType": {
          "type": "string",
          "enum": [ "documentType" ]
        },
        "name": { "type": "string" },
        "publicId": { "type": "string" },
        "systemId": { "type": "string" }
      },
      "required": [ "nodeType", "name", "publicId", "systemId" ]
    }
  ]
}
},{}],151:[function(require,module,exports){
module.exports={
  "id": "documentValue",
  "allOf":  [
    { "$ref": "entityNodeValue" },
    {
      "properties": {
        "nodeType": {
          "type": "string",
          "enum": [ "document" ]
        }
      },
      "required": [ "nodeType" ]
    }
  ]
}

},{}],152:[function(require,module,exports){
module.exports={
  "id": "element",
  "allOf": [
    { "$ref": "parentNode" },
    {
      "properties": {
        "value": { "$ref": "elementValue" }
      }      
    }    
  ]
}

},{}],153:[function(require,module,exports){
module.exports={
  "id": "elementValue",
  "allOf":  [
    { "$ref": "entityNodeValue" },
    {
      "properties": {
        "nodeType": {
          "type": "string",
          "enum": [ "element" ]
        },
        "attributes": {
          "type": "object",
          "additionalProperties": { "type": "string" }
        }
      },
      "required": [ "nodeType", "attributes" ]
    }
  ]
}

},{}],154:[function(require,module,exports){
module.exports={
  "id": "text",
  "allOf": [
    { "$ref": "emptyNode" },
    {
      "properties": {
        "value": { "$ref": "textValue" }
      }
    }
  ]
}

},{}],155:[function(require,module,exports){
module.exports={
  "id": "textValue",
  "allOf":  [
    { "$ref": "entityNodeValue" },
    {
      "properties": {
        "nodeType": {
          "type": "string",
          "enum": [ "text" ]
        },
        "nodeValue": { "type": "string" }
      },
      "required": [ "nodeType", "nodeValue" ]
    }
  ]
}

},{}],156:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var Htree = require('mojule-dom');
var utils = require('mojule-utils');

var clone = utils.clone;


var tokens = ['tag', 'text', 'html', 'if', 'not', 'each', 'empty', 'context', 'include'];

var tokenSelector = function tokenSelector(token) {
  return '[data-' + token + ']';
};
var selectors = tokens.map(tokenSelector);

var resolve = function resolve(scope, propertyName) {
  if (_typeof(scope.current) === 'object' && propertyName in scope.current) return scope.current[propertyName];

  if (propertyName === '.') return scope.current;

  if (scope.parent) return resolve(scope.parent, propertyName);
};

var actionWhitelist = ['tagName', 'attr', 'removeAttr', 'addClass', 'removeClass', 'toggleClass', 'clearAttrs', 'clearClasses', 'attributes'];

var handleAction = function handleAction(el, action) {
  return Object.keys(action).filter(function (fname) {
    return actionWhitelist.includes(fname);
  }).forEach(function (fname) {
    var args = action[fname];

    if (!Array.isArray(args)) args = [args];

    el[fname].apply(el, _toConsumableArray(args));
  });
};

var Templating = function Templating(templates) {
  var getTemplateFragment = function getTemplateFragment(name) {
    return Htree(clone(templates[name]));
  };

  var populateEl = {
    tag: function tag(el, scope, value) {
      if (value === undefined) return;

      if (!Array.isArray(value)) value = [value];

      value.forEach(function (action) {
        return handleAction(el, action);
      });
    },
    text: function text(el, scope, value) {
      el.empty();

      if (value === undefined) return;

      var textNode = el.createText(value);

      el.append(textNode);
    },
    html: function html(el, scope, value) {
      if (value === undefined) {
        el.empty();
        return;
      }

      var children = el.parse(value);

      el.append(children);
    },
    if: function _if(el, scope, value) {
      if (!value) el.empty();
    },
    not: function not(el, scope, value) {
      if (value) el.empty();
    },
    each: function each(el, scope, value) {
      if (value === undefined) {
        el.empty();

        return;
      }

      if (!Array.isArray(value)) {
        populateEl.context(el, scope, value);

        return;
      }

      var children = el.empty();

      value.forEach(function (item) {
        var childScope = {
          parent: scope,
          current: item
        };

        children.forEach(function (child) {
          el.append(child.clone());
        });

        populateNext(el, childScope);
      });
    },
    empty: function empty(el, scope, value) {
      if (value === undefined) {
        el.empty();
        return;
      }

      if (!Array.isArray(value) || value.length > 0) el.empty();
    },
    context: function context(el, scope, value) {
      if (value === undefined) return;

      var newScope = {
        parent: null,
        current: value
      };

      populateNext(el, newScope);
    },
    include: function include(el, scope, value) {
      el.empty();

      if (value === undefined) return;

      el.append(getTemplateFragment(value));
    }
  };

  var populateNext = function populateNext(template, scope) {
    var next = template.select(selectors.join(', '));

    if (!next) return template;

    var currentToken = tokens.find(function (token) {
      return next.matches(tokenSelector(token));
    });

    var attrName = 'data-' + currentToken;
    var name = next.attr(attrName);

    if (currentToken === 'include') {
      populateEl[currentToken](next, scope, name);
    } else {
      var value = resolve(scope, name);

      populateEl[currentToken](next, scope, value);

      if (value !== undefined) {
        scope = {
          parent: scope,
          current: value
        };
      }
    }

    next.removeAttr(attrName);

    return populateNext(template, scope);
  };

  var unwrapFragmentChildren = function unwrapFragmentChildren(fragment) {
    var notFragment = fragment.find(function (n) {
      return !n.matches('fragment');
    });

    if (!notFragment) return fragment;

    var fragmentParent = fragment.getParent();

    fragmentParent.insertBefore(notFragment, fragment);

    return unwrapFragmentChildren(fragment);
  };

  var unwrapNextFragment = function unwrapNextFragment(template) {
    var fragment = template.select('fragment');

    if (!fragment) return template;

    unwrapFragmentChildren(fragment);

    fragment.remove();

    return unwrapNextFragment(template);
  };

  var populate = function populate(name, model) {
    var template = getTemplateFragment(name);

    var scope = {
      parent: null,
      current: model
    };

    populateNext(template, scope);
    unwrapNextFragment(template);

    return template;
  };

  return populate;
};

Templating.getTemplates = function (htree) {
  if (typeof htree === 'string') htree = Htree(htree);

  var templateEls = htree.clone().selectAll('template[id]:not([id=""])');

  return templateEls.reduce(function (templates, el) {
    var id = el.attr('id');

    var fragment = htree.createDocumentFragment();

    el.getChildren().forEach(function (child) {
      return fragment.append(child);
    });

    templates[id] = fragment.serialize();

    return templates;
  }, {});
};

module.exports = Templating;
},{"mojule-dom":143,"mojule-utils":161}],157:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":156,"dup":3}],158:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _require = require('mojule-utils'),
    clone = _require.clone;

var _require2 = require('1tree-json'),
    toTree = _require2.toTree,
    toJson = _require2.toJson;

var transforms = {
  values: function values(data) {
    var model = data.model,
        transform = data.transform;


    var transformTree = toTree(transform);

    var valuePropertyNodes = transformTree.findAll(function (n) {
      return n.value().propertyName === '$value';
    });

    if (valuePropertyNodes.length === 0) return data;

    valuePropertyNodes.forEach(function (propertyNode) {
      var objectNode = propertyNode.getParent();
      var objectNodeParent = objectNode.getParent();

      var value = propertyNode.value();
      var sourcePropertyName = value.nodeValue;

      var newValueNode = sourcePropertyName in model ? toTree(model[sourcePropertyName]) : toTree('$delete');

      var propertyName = objectNode.value().propertyName;

      if (propertyName) {
        var newValue = newValueNode.value();
        newValue.propertyName = propertyName;
        newValueNode.value(newValue);
      }

      objectNodeParent.replaceChild(newValueNode, objectNode);
    });

    transform = toJson(transformTree);

    return { model: model, transform: transform };
  },
  ifs: function ifs(data) {
    var model = data.model,
        transform = data.transform;


    var transformTree = toTree(transform);

    var ifPropertyNodes = transformTree.findAll(function (n) {
      return n.value().propertyName === '$if';
    });

    ifPropertyNodes.forEach(function (propertyNode) {
      var objectNode = propertyNode.getParent();
      var objectNodeParent = objectNode.getParent();

      var ifArgNodes = propertyNode.getChildren();

      var isValue = ifArgNodes[0].value().nodeValue;

      if (isValue && isValue !== '$delete') {
        var ifValueNode = ifArgNodes[1];

        var propertyName = objectNode.value().propertyName;

        if (propertyName) {
          var newValue = ifValueNode.value();
          newValue.propertyName = propertyName;
          ifValueNode.value(newValue);
        }

        objectNodeParent.insertBefore(ifValueNode, objectNode);
      }

      objectNode.remove();
    });

    transform = toJson(transformTree);

    return { model: model, transform: transform };
  },
  deletes: function deletes(data) {
    var model = data.model,
        transform = data.transform;


    var transformKeys = Object.keys(transform);

    transformKeys.forEach(function (propertyName) {
      if (transform[propertyName] === '$delete') {
        delete model[propertyName];
        delete transform[propertyName];
      }
    });

    return { model: model, transform: transform };
  },
  substitutes: function substitutes(data) {
    var model = data.model,
        transform = data.transform;


    var transformKeys = Object.keys(transform);

    transformKeys.forEach(function (propertyName) {
      model[propertyName] = transform[propertyName];
    });

    return { model: model, transform: transform };
  }
};

var transformMapper = function transformMapper(model, transform) {
  if (Array.isArray(model)) {
    return model.map(function (el) {
      return transformMapper(el, transform);
    });
  } else if ((typeof model === 'undefined' ? 'undefined' : _typeof(model)) !== 'object') {
    return model;
  }

  var data = clone({ model: model, transform: transform });

  Object.keys(transforms).forEach(function (transformName) {
    var fn = transforms[transformName];

    data = fn(data);
  });

  return data.model;
};

module.exports = transformMapper;
},{"1tree-json":6,"mojule-utils":161}],159:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":158,"dup":3}],160:[function(require,module,exports){
'use strict';

var clone = function clone() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return JSON.parse(JSON.stringify(obj));
};

var matches = function matches() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Object.keys(source).every(function (key) {
    return obj[key] === source[key];
  });
};

var id = function id() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;

  if (prefix) prefix = identifier(prefix) + '-';

  var str = prefix;

  for (var i = 0; i < length; i++) {
    str += Math.floor(Math.random() * 16).toString(16);
  }

  return str;
};

var identifier = function identifier() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var caseSensitive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var id = value.replace(/[^a-z0-9]/gi, '-').replace(/-{2,}/g, '-');

  if (!caseSensitive) id = id.toLowerCase();

  return id;
};

var escapeHtml = function escapeHtml() {
  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  var result = str.replace(/</g, '&lt;');
  return result;
};

var capitalizeFirstLetter = function capitalizeFirstLetter() {
  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return str.charAt(0).toUpperCase() + str.slice(1);
};

var utils = {
  id: id, identifier: identifier, matches: matches, clone: clone, escapeHtml: escapeHtml, capitalizeFirstLetter: capitalizeFirstLetter
};

module.exports = utils;
},{}],161:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":160,"dup":3}],162:[function(require,module,exports){
'use strict';

var range; // Create a range object for efficently rendering strings to elements.
var NS_XHTML = 'http://www.w3.org/1999/xhtml';

var doc = typeof document === 'undefined' ? undefined : document;

var testEl = doc ?
    doc.body || doc.createElement('div') :
    {};

// Fixes <https://github.com/patrick-steele-idem/morphdom/issues/32>
// (IE7+ support) <=IE7 does not support el.hasAttribute(name)
var actualHasAttributeNS;

if (testEl.hasAttributeNS) {
    actualHasAttributeNS = function(el, namespaceURI, name) {
        return el.hasAttributeNS(namespaceURI, name);
    };
} else if (testEl.hasAttribute) {
    actualHasAttributeNS = function(el, namespaceURI, name) {
        return el.hasAttribute(name);
    };
} else {
    actualHasAttributeNS = function(el, namespaceURI, name) {
        return el.getAttributeNode(namespaceURI, name) != null;
    };
}

var hasAttributeNS = actualHasAttributeNS;


function toElement(str) {
    if (!range && doc.createRange) {
        range = doc.createRange();
        range.selectNode(doc.body);
    }

    var fragment;
    if (range && range.createContextualFragment) {
        fragment = range.createContextualFragment(str);
    } else {
        fragment = doc.createElement('body');
        fragment.innerHTML = str;
    }
    return fragment.childNodes[0];
}

/**
 * Returns true if two node's names are the same.
 *
 * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same
 *       nodeName and different namespace URIs.
 *
 * @param {Element} a
 * @param {Element} b The target element
 * @return {boolean}
 */
function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;

    if (fromNodeName === toNodeName) {
        return true;
    }

    if (toEl.actualize &&
        fromNodeName.charCodeAt(0) < 91 && /* from tag name is upper case */
        toNodeName.charCodeAt(0) > 90 /* target tag name is lower case */) {
        // If the target element is a virtual DOM node then we may need to normalize the tag name
        // before comparing. Normal HTML elements that are in the "http://www.w3.org/1999/xhtml"
        // are converted to upper case
        return fromNodeName === toNodeName.toUpperCase();
    } else {
        return false;
    }
}

/**
 * Create an element, optionally with a known namespace URI.
 *
 * @param {string} name the element name, e.g. 'div' or 'svg'
 * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of
 * its `xmlns` attribute or its inferred namespace.
 *
 * @return {Element}
 */
function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ?
        doc.createElement(name) :
        doc.createElementNS(namespaceURI, name);
}

/**
 * Copies the children of one DOM element to another DOM element
 */
function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
        var nextChild = curChild.nextSibling;
        toEl.appendChild(curChild);
        curChild = nextChild;
    }
    return toEl;
}

function morphAttrs(fromNode, toNode) {
    var attrs = toNode.attributes;
    var i;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;

    for (i = attrs.length - 1; i >= 0; --i) {
        attr = attrs[i];
        attrName = attr.name;
        attrNamespaceURI = attr.namespaceURI;
        attrValue = attr.value;

        if (attrNamespaceURI) {
            attrName = attr.localName || attrName;
            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);

            if (fromValue !== attrValue) {
                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
            }
        } else {
            fromValue = fromNode.getAttribute(attrName);

            if (fromValue !== attrValue) {
                fromNode.setAttribute(attrName, attrValue);
            }
        }
    }

    // Remove any extra attributes found on the original DOM element that
    // weren't found on the target element.
    attrs = fromNode.attributes;

    for (i = attrs.length - 1; i >= 0; --i) {
        attr = attrs[i];
        if (attr.specified !== false) {
            attrName = attr.name;
            attrNamespaceURI = attr.namespaceURI;

            if (attrNamespaceURI) {
                attrName = attr.localName || attrName;

                if (!hasAttributeNS(toNode, attrNamespaceURI, attrName)) {
                    fromNode.removeAttributeNS(attrNamespaceURI, attrName);
                }
            } else {
                if (!hasAttributeNS(toNode, null, attrName)) {
                    fromNode.removeAttribute(attrName);
                }
            }
        }
    }
}

function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
        fromEl[name] = toEl[name];
        if (fromEl[name]) {
            fromEl.setAttribute(name, '');
        } else {
            fromEl.removeAttribute(name, '');
        }
    }
}

var specialElHandlers = {
    /**
     * Needed for IE. Apparently IE doesn't think that "selected" is an
     * attribute when reading over the attributes using selectEl.attributes
     */
    OPTION: function(fromEl, toEl) {
        syncBooleanAttrProp(fromEl, toEl, 'selected');
    },
    /**
     * The "value" attribute is special for the <input> element since it sets
     * the initial value. Changing the "value" attribute without changing the
     * "value" property will have no effect since it is only used to the set the
     * initial value.  Similar for the "checked" attribute, and "disabled".
     */
    INPUT: function(fromEl, toEl) {
        syncBooleanAttrProp(fromEl, toEl, 'checked');
        syncBooleanAttrProp(fromEl, toEl, 'disabled');

        if (fromEl.value !== toEl.value) {
            fromEl.value = toEl.value;
        }

        if (!hasAttributeNS(toEl, null, 'value')) {
            fromEl.removeAttribute('value');
        }
    },

    TEXTAREA: function(fromEl, toEl) {
        var newValue = toEl.value;
        if (fromEl.value !== newValue) {
            fromEl.value = newValue;
        }

        if (fromEl.firstChild) {
            // Needed for IE. Apparently IE sets the placeholder as the
            // node value and vise versa. This ignores an empty update.
            if (newValue === '' && fromEl.firstChild.nodeValue === fromEl.placeholder) {
                return;
            }

            fromEl.firstChild.nodeValue = newValue;
        }
    },
    SELECT: function(fromEl, toEl) {
        if (!hasAttributeNS(toEl, null, 'multiple')) {
            var selectedIndex = -1;
            var i = 0;
            var curChild = toEl.firstChild;
            while(curChild) {
                var nodeName = curChild.nodeName;
                if (nodeName && nodeName.toUpperCase() === 'OPTION') {
                    if (hasAttributeNS(curChild, null, 'selected')) {
                        selectedIndex = i;
                        break;
                    }
                    i++;
                }
                curChild = curChild.nextSibling;
            }

            fromEl.selectedIndex = i;
        }
    }
};

var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;

function noop() {}

function defaultGetNodeKey(node) {
    return node.id;
}

function morphdomFactory(morphAttrs) {

    return function morphdom(fromNode, toNode, options) {
        if (!options) {
            options = {};
        }

        if (typeof toNode === 'string') {
            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML') {
                var toNodeHtml = toNode;
                toNode = doc.createElement('html');
                toNode.innerHTML = toNodeHtml;
            } else {
                toNode = toElement(toNode);
            }
        }

        var getNodeKey = options.getNodeKey || defaultGetNodeKey;
        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
        var onNodeAdded = options.onNodeAdded || noop;
        var onBeforeElUpdated = options.onBeforeElUpdated || noop;
        var onElUpdated = options.onElUpdated || noop;
        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
        var onNodeDiscarded = options.onNodeDiscarded || noop;
        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
        var childrenOnly = options.childrenOnly === true;

        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.
        var fromNodesLookup = {};
        var keyedRemovalList;

        function addKeyedRemoval(key) {
            if (keyedRemovalList) {
                keyedRemovalList.push(key);
            } else {
                keyedRemovalList = [key];
            }
        }

        function walkDiscardedChildNodes(node, skipKeyedNodes) {
            if (node.nodeType === ELEMENT_NODE) {
                var curChild = node.firstChild;
                while (curChild) {

                    var key = undefined;

                    if (skipKeyedNodes && (key = getNodeKey(curChild))) {
                        // If we are skipping keyed nodes then we add the key
                        // to a list so that it can be handled at the very end.
                        addKeyedRemoval(key);
                    } else {
                        // Only report the node as discarded if it is not keyed. We do this because
                        // at the end we loop through all keyed elements that were unmatched
                        // and then discard them in one final pass.
                        onNodeDiscarded(curChild);
                        if (curChild.firstChild) {
                            walkDiscardedChildNodes(curChild, skipKeyedNodes);
                        }
                    }

                    curChild = curChild.nextSibling;
                }
            }
        }

        /**
         * Removes a DOM node out of the original DOM
         *
         * @param  {Node} node The node to remove
         * @param  {Node} parentNode The nodes parent
         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.
         * @return {undefined}
         */
        function removeNode(node, parentNode, skipKeyedNodes) {
            if (onBeforeNodeDiscarded(node) === false) {
                return;
            }

            if (parentNode) {
                parentNode.removeChild(node);
            }

            onNodeDiscarded(node);
            walkDiscardedChildNodes(node, skipKeyedNodes);
        }

        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future
        // function indexTree(root) {
        //     var treeWalker = document.createTreeWalker(
        //         root,
        //         NodeFilter.SHOW_ELEMENT);
        //
        //     var el;
        //     while((el = treeWalker.nextNode())) {
        //         var key = getNodeKey(el);
        //         if (key) {
        //             fromNodesLookup[key] = el;
        //         }
        //     }
        // }

        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future
        //
        // function indexTree(node) {
        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);
        //     var el;
        //     while((el = nodeIterator.nextNode())) {
        //         var key = getNodeKey(el);
        //         if (key) {
        //             fromNodesLookup[key] = el;
        //         }
        //     }
        // }

        function indexTree(node) {
            if (node.nodeType === ELEMENT_NODE) {
                var curChild = node.firstChild;
                while (curChild) {
                    var key = getNodeKey(curChild);
                    if (key) {
                        fromNodesLookup[key] = curChild;
                    }

                    // Walk recursively
                    indexTree(curChild);

                    curChild = curChild.nextSibling;
                }
            }
        }

        indexTree(fromNode);

        function handleNodeAdded(el) {
            onNodeAdded(el);

            var curChild = el.firstChild;
            while (curChild) {
                var nextSibling = curChild.nextSibling;

                var key = getNodeKey(curChild);
                if (key) {
                    var unmatchedFromEl = fromNodesLookup[key];
                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
                        morphEl(unmatchedFromEl, curChild);
                    }
                }

                handleNodeAdded(curChild);
                curChild = nextSibling;
            }
        }

        function morphEl(fromEl, toEl, childrenOnly) {
            var toElKey = getNodeKey(toEl);
            var curFromNodeKey;

            if (toElKey) {
                // If an element with an ID is being morphed then it is will be in the final
                // DOM so clear it out of the saved elements collection
                delete fromNodesLookup[toElKey];
            }

            if (toNode.isSameNode && toNode.isSameNode(fromNode)) {
                return;
            }

            if (!childrenOnly) {
                if (onBeforeElUpdated(fromEl, toEl) === false) {
                    return;
                }

                morphAttrs(fromEl, toEl);
                onElUpdated(fromEl);

                if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
                    return;
                }
            }

            if (fromEl.nodeName !== 'TEXTAREA') {
                var curToNodeChild = toEl.firstChild;
                var curFromNodeChild = fromEl.firstChild;
                var curToNodeKey;

                var fromNextSibling;
                var toNextSibling;
                var matchingFromEl;

                outer: while (curToNodeChild) {
                    toNextSibling = curToNodeChild.nextSibling;
                    curToNodeKey = getNodeKey(curToNodeChild);

                    while (curFromNodeChild) {
                        fromNextSibling = curFromNodeChild.nextSibling;

                        if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                            curToNodeChild = toNextSibling;
                            curFromNodeChild = fromNextSibling;
                            continue outer;
                        }

                        curFromNodeKey = getNodeKey(curFromNodeChild);

                        var curFromNodeType = curFromNodeChild.nodeType;

                        var isCompatible = undefined;

                        if (curFromNodeType === curToNodeChild.nodeType) {
                            if (curFromNodeType === ELEMENT_NODE) {
                                // Both nodes being compared are Element nodes

                                if (curToNodeKey) {
                                    // The target node has a key so we want to match it up with the correct element
                                    // in the original DOM tree
                                    if (curToNodeKey !== curFromNodeKey) {
                                        // The current element in the original DOM tree does not have a matching key so
                                        // let's check our lookup to see if there is a matching element in the original
                                        // DOM tree
                                        if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {
                                            if (curFromNodeChild.nextSibling === matchingFromEl) {
                                                // Special case for single element removals. To avoid removing the original
                                                // DOM node out of the tree (since that can break CSS transitions, etc.),
                                                // we will instead discard the current node and wait until the next
                                                // iteration to properly match up the keyed target element with its matching
                                                // element in the original tree
                                                isCompatible = false;
                                            } else {
                                                // We found a matching keyed element somewhere in the original DOM tree.
                                                // Let's moving the original DOM node into the current position and morph
                                                // it.

                                                // NOTE: We use insertBefore instead of replaceChild because we want to go through
                                                // the `removeNode()` function for the node that is being discarded so that
                                                // all lifecycle hooks are correctly invoked
                                                fromEl.insertBefore(matchingFromEl, curFromNodeChild);

                                                fromNextSibling = curFromNodeChild.nextSibling;

                                                if (curFromNodeKey) {
                                                    // Since the node is keyed it might be matched up later so we defer
                                                    // the actual removal to later
                                                    addKeyedRemoval(curFromNodeKey);
                                                } else {
                                                    // NOTE: we skip nested keyed nodes from being removed since there is
                                                    //       still a chance they will be matched up later
                                                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);
                                                }

                                                curFromNodeChild = matchingFromEl;
                                            }
                                        } else {
                                            // The nodes are not compatible since the "to" node has a key and there
                                            // is no matching keyed node in the source tree
                                            isCompatible = false;
                                        }
                                    }
                                } else if (curFromNodeKey) {
                                    // The original has a key
                                    isCompatible = false;
                                }

                                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                                if (isCompatible) {
                                    // We found compatible DOM elements so transform
                                    // the current "from" node to match the current
                                    // target DOM node.
                                    morphEl(curFromNodeChild, curToNodeChild);
                                }

                            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                                // Both nodes being compared are Text or Comment nodes
                                isCompatible = true;
                                // Simply update nodeValue on the original node to
                                // change the text value
                                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                            }
                        }

                        if (isCompatible) {
                            // Advance both the "to" child and the "from" child since we found a match
                            curToNodeChild = toNextSibling;
                            curFromNodeChild = fromNextSibling;
                            continue outer;
                        }

                        // No compatible match so remove the old node from the DOM and continue trying to find a
                        // match in the original DOM. However, we only do this if the from node is not keyed
                        // since it is possible that a keyed node might match up with a node somewhere else in the
                        // target tree and we don't want to discard it just yet since it still might find a
                        // home in the final DOM tree. After everything is done we will remove any keyed nodes
                        // that didn't find a home
                        if (curFromNodeKey) {
                            // Since the node is keyed it might be matched up later so we defer
                            // the actual removal to later
                            addKeyedRemoval(curFromNodeKey);
                        } else {
                            // NOTE: we skip nested keyed nodes from being removed since there is
                            //       still a chance they will be matched up later
                            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);
                        }

                        curFromNodeChild = fromNextSibling;
                    }

                    // If we got this far then we did not find a candidate match for
                    // our "to node" and we exhausted all of the children "from"
                    // nodes. Therefore, we will just append the current "to" node
                    // to the end
                    if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
                        fromEl.appendChild(matchingFromEl);
                        morphEl(matchingFromEl, curToNodeChild);
                    } else {
                        var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
                        if (onBeforeNodeAddedResult !== false) {
                            if (onBeforeNodeAddedResult) {
                                curToNodeChild = onBeforeNodeAddedResult;
                            }

                            if (curToNodeChild.actualize) {
                                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                            }
                            fromEl.appendChild(curToNodeChild);
                            handleNodeAdded(curToNodeChild);
                        }
                    }

                    curToNodeChild = toNextSibling;
                    curFromNodeChild = fromNextSibling;
                }

                // We have processed all of the "to nodes". If curFromNodeChild is
                // non-null then we still have some from nodes left over that need
                // to be removed
                while (curFromNodeChild) {
                    fromNextSibling = curFromNodeChild.nextSibling;
                    if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {
                        // Since the node is keyed it might be matched up later so we defer
                        // the actual removal to later
                        addKeyedRemoval(curFromNodeKey);
                    } else {
                        // NOTE: we skip nested keyed nodes from being removed since there is
                        //       still a chance they will be matched up later
                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);
                    }
                    curFromNodeChild = fromNextSibling;
                }
            }

            var specialElHandler = specialElHandlers[fromEl.nodeName];
            if (specialElHandler) {
                specialElHandler(fromEl, toEl);
            }
        } // END: morphEl(...)

        var morphedNode = fromNode;
        var morphedNodeType = morphedNode.nodeType;
        var toNodeType = toNode.nodeType;

        if (!childrenOnly) {
            // Handle the case where we are given two DOM nodes that are not
            // compatible (e.g. <div> --> <span> or <div> --> TEXT)
            if (morphedNodeType === ELEMENT_NODE) {
                if (toNodeType === ELEMENT_NODE) {
                    if (!compareNodeNames(fromNode, toNode)) {
                        onNodeDiscarded(fromNode);
                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
                    }
                } else {
                    // Going from an element node to a text node
                    morphedNode = toNode;
                }
            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node
                if (toNodeType === morphedNodeType) {
                    morphedNode.nodeValue = toNode.nodeValue;
                    return morphedNode;
                } else {
                    // Text node to something else
                    morphedNode = toNode;
                }
            }
        }

        if (morphedNode === toNode) {
            // The "to node" was not compatible with the "from node" so we had to
            // toss out the "from node" and use the "to node"
            onNodeDiscarded(fromNode);
        } else {
            morphEl(morphedNode, toNode, childrenOnly);

            // We now need to loop over any keyed nodes that might need to be
            // removed. We only do the removal if we know that the keyed node
            // never found a match. When a keyed node is matched up we remove
            // it out of fromNodesLookup and we use fromNodesLookup to determine
            // if a keyed node has been matched up or not
            if (keyedRemovalList) {
                for (var i=0, len=keyedRemovalList.length; i<len; i++) {
                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];
                    if (elToRemove) {
                        removeNode(elToRemove, elToRemove.parentNode, false);
                    }
                }
            }
        }

        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
            if (morphedNode.actualize) {
                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
            }
            // If we had to swap out the from node with a new node because the old
            // node was not compatible with the target node then we need to
            // replace the old DOM node in the original DOM tree. This is only
            // possible if the original DOM node was part of a DOM tree which
            // we know is the case if it has a parent node.
            fromNode.parentNode.replaceChild(morphedNode, fromNode);
        }

        return morphedNode;
    };
}

var morphdom = morphdomFactory(morphAttrs);

module.exports = morphdom;

},{}],163:[function(require,module,exports){
'use strict';

var Validator = require('mtype-tv4');
var utils = require('mojule-utils');
var schema = require('./schema');

var id = utils.id;


var validator = Validator(schema);
var t = Validator.mtype(validator);

var EntityNodeValue = function EntityNodeValue() {
  var nodeType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'entityNode';
  var additionalValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var value = Object.assign({ nodeType: nodeType }, additionalValues);

  if (typeof value._id !== 'string') value._id = id(value.nodeType);

  if (!t.is(value, 'entityNodeValue')) throw new TypeError('Cannot create an entityNodeValue with those arguments');

  return value;
};

var EntityNode = function EntityNode() {
  var nodeType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'entityNode';
  var additionalValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var value = EntityNodeValue(nodeType, additionalValues);
  var children = [];

  return { value: value, children: children };
};

EntityNode.Value = EntityNodeValue;
EntityNode.mtype = t;

module.exports = EntityNode;
},{"./schema":164,"mojule-utils":161,"mtype-tv4":171}],164:[function(require,module,exports){
'use strict';

var entityNode = require('../schema/entityNode.schema.json');
var entityNodeValue = require('../schema/entityNodeValue.schema.json');
var emptyNode = require('../schema/emptyNode.schema.json');
var parentNode = require('../schema/parentNode.schema.json');

var schema = {
  entityNode: entityNode, entityNodeValue: entityNodeValue, emptyNode: emptyNode, parentNode: parentNode
};

module.exports = schema;
},{"../schema/emptyNode.schema.json":166,"../schema/entityNode.schema.json":167,"../schema/entityNodeValue.schema.json":168,"../schema/parentNode.schema.json":169}],165:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":163,"dup":3}],166:[function(require,module,exports){
module.exports={
  "id": "emptyNode",
  "allOf": [
    { "$ref": "entityNode" },
    {
      "properties": {
        "value": { "$ref": "entityNodeValue" },
        "children": {
          "type": "array",
          "maxLength": 0
        }
      }
    }
  ]
}

},{}],167:[function(require,module,exports){
module.exports={
  "id": "entityNode",
  "type": "object",
  "properties": {
    "value": { "$ref": "entityNodeValue" }
  },
  "required": [ "value" ]
}

},{}],168:[function(require,module,exports){
module.exports={
  "id": "entityNodeValue",
  "type": "object",
  "properties": {
    "_id": {
      "type": "string",
      "minLength": 1
    },
    "nodeType": {
      "type": "string",
      "minLength": 1
    }
  },
  "required": [ "_id", "nodeType" ]
}

},{}],169:[function(require,module,exports){
module.exports={
  "id": "parentNode",
  "allOf": [
    { "$ref": "entityNode" },
    {
      "properties": {
        "children": {
          "type": "array",
          "items": { "$ref": "entityNode" }
        }
      },
      "required": [ "children" ]
    }
  ]
}

},{}],170:[function(require,module,exports){
'use strict';

var tv4 = require('tv4');
var T = require('mtype');

var Validator = function Validator() {
  var schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var validator = tv4.freshApi();

  var schemas = Object.keys(schema).map(function (name) {
    return schema[name];
  });

  schemas.forEach(function (schema) {
    return validator.addSchema(schema);
  });

  return validator;
};

Validator.mtype = function () {
  var validator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Validator();

  var schemaNames = validator.getSchemaUris();

  var is = schemaNames.reduce(function (map, name) {
    map[name] = function (obj) {
      return validator.validate(obj, name);
    };

    return map;
  }, {});

  return T(is);
};

module.exports = Validator;
},{"mtype":174,"tv4":194}],171:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":170,"dup":3}],172:[function(require,module,exports){
'use strict';

var jsonPredicates = require('./json-predicates');

var mtype = function mtype(typePredicates) {
  typePredicates = typePredicates || jsonPredicates;

  var keys = Object.keys(typePredicates);

  var is = function is(subject, typename) {
    return typePredicates[typename] && typePredicates[typename](subject);
  };

  var isOnly = function isOnly(subject, typename) {
    return is(subject, typename) && allOf(subject).length === 1;
  };

  var some = function some(subject) {
    for (var _len = arguments.length, typenames = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      typenames[_key - 1] = arguments[_key];
    }

    return typenames.some(function (typename) {
      return is(subject, typename);
    });
  };

  var every = function every(subject) {
    for (var _len2 = arguments.length, typenames = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      typenames[_key2 - 1] = arguments[_key2];
    }

    return typenames.every(function (typename) {
      return is(subject, typename);
    });
  };

  var of = function of(subject) {
    return keys.find(function (key) {
      return is(subject, key);
    });
  };

  var allOf = function allOf(subject) {
    return keys.filter(function (key) {
      return is(subject, key);
    });
  };

  var types = function types() {
    return keys.slice();
  };

  return { is: is, isOnly: isOnly, some: some, every: every, of: of, allOf: allOf, types: types };
};

module.exports = mtype;
},{"./json-predicates":173}],173:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var jsonPredicates = {
  number: function number(subject) {
    return typeof subject === 'number' && isFinite(subject);
  },
  string: function string(subject) {
    return typeof subject === 'string';
  },
  boolean: function boolean(subject) {
    return typeof subject === 'boolean';
  },
  array: function array(subject) {
    return Array.isArray(subject);
  },
  null: function _null(subject) {
    return subject === null;
  },
  object: function object(subject) {
    return (typeof subject === 'undefined' ? 'undefined' : _typeof(subject)) === 'object' && !jsonPredicates.null(subject) && !jsonPredicates.array(subject);
  }
};

module.exports = jsonPredicates;
},{}],174:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":172,"dup":3}],175:[function(require,module,exports){
module.exports = compile;

var BaseFuncs = require("boolbase"),
    trueFunc  = BaseFuncs.trueFunc,
    falseFunc = BaseFuncs.falseFunc;

/*
	returns a function that checks if an elements index matches the given rule
	highly optimized to return the fastest solution
*/
function compile(parsed){
	var a = parsed[0],
	    b = parsed[1] - 1;

	//when b <= 0, a*n won't be possible for any matches when a < 0
	//besides, the specification says that no element is matched when a and b are 0
	if(b < 0 && a <= 0) return falseFunc;

	//when a is in the range -1..1, it matches any element (so only b is checked)
	if(a ===-1) return function(pos){ return pos <= b; };
	if(a === 0) return function(pos){ return pos === b; };
	//when b <= 0 and a === 1, they match any element
	if(a === 1) return b < 0 ? trueFunc : function(pos){ return pos >= b; };

	//when a > 0, modulo can be used to check if there is a match
	var bMod = b % a;
	if(bMod < 0) bMod += a;

	if(a > 1){
		return function(pos){
			return pos >= b && pos % a === bMod;
		};
	}

	a *= -1; //make `a` positive

	return function(pos){
		return pos <= b && pos % a === bMod;
	};
}
},{"boolbase":63}],176:[function(require,module,exports){
var parse = require("./parse.js"),
    compile = require("./compile.js");

module.exports = function nthCheck(formula){
	return compile(parse(formula));
};

module.exports.parse = parse;
module.exports.compile = compile;
},{"./compile.js":175,"./parse.js":177}],177:[function(require,module,exports){
module.exports = parse;

//following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo

//[ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
var re_nthElement = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;

/*
	parses a nth-check formula, returns an array of two numbers
*/
function parse(formula){
	formula = formula.trim().toLowerCase();

	if(formula === "even"){
		return [2, 0];
	} else if(formula === "odd"){
		return [2, 1];
	} else {
		var parsed = formula.match(re_nthElement);

		if(!parsed){
			throw new SyntaxError("n-th rule couldn't be parsed ('" + formula + "')");
		}

		var a;

		if(parsed[1]){
			a = parseInt(parsed[1], 10);
			if(isNaN(a)){
				if(parsed[1].charAt(0) === "-") a = -1;
				else a = 1;
			}
		} else a = 0;

		return [
			a,
			parsed[3] ? parseInt((parsed[2] || "") + parsed[3], 10) : 0
		];
	}
}

},{}],178:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,require('_process'))

},{"_process":179}],179:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],180:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":181}],181:[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":183,"./_stream_writable":185,"core-util-is":69,"inherits":121,"process-nextick-args":178}],182:[function(require,module,exports){
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":184,"core-util-is":69,"inherits":121}],183:[function(require,module,exports){
(function (process){
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var StringDecoder;

util.inherits(Readable, Stream);

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = bufferShim.from(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');
      stream.emit('error', _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = bufferShim.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'))

},{"./_stream_duplex":181,"./internal/streams/BufferList":186,"_process":179,"buffer":66,"buffer-shims":65,"core-util-is":69,"events":105,"inherits":121,"isarray":123,"process-nextick-args":178,"string_decoder/":192,"util":64}],184:[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":181,"core-util-is":69,"inherits":121}],185:[function(require,module,exports){
(function (process){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  // Always throw error if a null is written
  // if we are not in object mode then throw
  // if it is not a buffer, string, or undefined.
  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = bufferShim.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) processNextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
        afterWrite(stream, state, finished, cb);
      }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
}).call(this,require('_process'))

},{"./_stream_duplex":181,"_process":179,"buffer":66,"buffer-shims":65,"core-util-is":69,"events":105,"inherits":121,"process-nextick-args":178,"util-deprecate":195}],186:[function(require,module,exports){
'use strict';

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

module.exports = BufferList;

function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}

BufferList.prototype.push = function (v) {
  var entry = { data: v, next: null };
  if (this.length > 0) this.tail.next = entry;else this.head = entry;
  this.tail = entry;
  ++this.length;
};

BufferList.prototype.unshift = function (v) {
  var entry = { data: v, next: this.head };
  if (this.length === 0) this.tail = entry;
  this.head = entry;
  ++this.length;
};

BufferList.prototype.shift = function () {
  if (this.length === 0) return;
  var ret = this.head.data;
  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
  --this.length;
  return ret;
};

BufferList.prototype.clear = function () {
  this.head = this.tail = null;
  this.length = 0;
};

BufferList.prototype.join = function (s) {
  if (this.length === 0) return '';
  var p = this.head;
  var ret = '' + p.data;
  while (p = p.next) {
    ret += s + p.data;
  }return ret;
};

BufferList.prototype.concat = function (n) {
  if (this.length === 0) return bufferShim.alloc(0);
  if (this.length === 1) return this.head.data;
  var ret = bufferShim.allocUnsafe(n >>> 0);
  var p = this.head;
  var i = 0;
  while (p) {
    p.data.copy(ret, i);
    i += p.data.length;
    p = p.next;
  }
  return ret;
};
},{"buffer":66,"buffer-shims":65}],187:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":182}],188:[function(require,module,exports){
(function (process){
var Stream = (function (){
  try {
    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify
  } catch(_){}
}());
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream || exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
}

}).call(this,require('_process'))

},{"./lib/_stream_duplex.js":181,"./lib/_stream_passthrough.js":182,"./lib/_stream_readable.js":183,"./lib/_stream_transform.js":184,"./lib/_stream_writable.js":185,"_process":179}],189:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":184}],190:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":185}],191:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":105,"inherits":121,"readable-stream/duplex.js":180,"readable-stream/passthrough.js":187,"readable-stream/readable.js":188,"readable-stream/transform.js":189,"readable-stream/writable.js":190}],192:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":66}],193:[function(require,module,exports){
var si = typeof setImmediate === 'function', tick;
if (si) {
  tick = function (fn) { setImmediate(fn); };
} else {
  tick = function (fn) { setTimeout(fn, 0); };
}

module.exports = tick;
},{}],194:[function(require,module,exports){
/*
Author: Geraint Luff and others
Year: 2013

This code is released into the "public domain" by its author(s).  Anybody may use, alter and distribute the code without restriction.  The author makes no guarantees, and takes no liability of any kind for use of this code.

If you find a bug or make an improvement, it would be courteous to let the author know, but it is not compulsory.
*/
(function (global, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if (typeof module !== 'undefined' && module.exports){
    // CommonJS. Define export.
    module.exports = factory();
  } else {
    // Browser globals
    global.tv4 = factory();
  }
}(this, function () {

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FObject%2Fkeys
if (!Object.keys) {
	Object.keys = (function () {
		var hasOwnProperty = Object.prototype.hasOwnProperty,
			hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
			dontEnums = [
				'toString',
				'toLocaleString',
				'valueOf',
				'hasOwnProperty',
				'isPrototypeOf',
				'propertyIsEnumerable',
				'constructor'
			],
			dontEnumsLength = dontEnums.length;

		return function (obj) {
			if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) {
				throw new TypeError('Object.keys called on non-object');
			}

			var result = [];

			for (var prop in obj) {
				if (hasOwnProperty.call(obj, prop)) {
					result.push(prop);
				}
			}

			if (hasDontEnumBug) {
				for (var i=0; i < dontEnumsLength; i++) {
					if (hasOwnProperty.call(obj, dontEnums[i])) {
						result.push(dontEnums[i]);
					}
				}
			}
			return result;
		};
	})();
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
if (!Object.create) {
	Object.create = (function(){
		function F(){}

		return function(o){
			if (arguments.length !== 1) {
				throw new Error('Object.create implementation only accepts one parameter.');
			}
			F.prototype = o;
			return new F();
		};
	})();
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FisArray
if(!Array.isArray) {
	Array.isArray = function (vArg) {
		return Object.prototype.toString.call(vArg) === "[object Array]";
	};
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FindexOf
if (!Array.prototype.indexOf) {
	Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
		if (this === null) {
			throw new TypeError();
		}
		var t = Object(this);
		var len = t.length >>> 0;

		if (len === 0) {
			return -1;
		}
		var n = 0;
		if (arguments.length > 1) {
			n = Number(arguments[1]);
			if (n !== n) { // shortcut for verifying if it's NaN
				n = 0;
			} else if (n !== 0 && n !== Infinity && n !== -Infinity) {
				n = (n > 0 || -1) * Math.floor(Math.abs(n));
			}
		}
		if (n >= len) {
			return -1;
		}
		var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
		for (; k < len; k++) {
			if (k in t && t[k] === searchElement) {
				return k;
			}
		}
		return -1;
	};
}

// Grungey Object.isFrozen hack
if (!Object.isFrozen) {
	Object.isFrozen = function (obj) {
		var key = "tv4_test_frozen_key";
		while (obj.hasOwnProperty(key)) {
			key += Math.random();
		}
		try {
			obj[key] = true;
			delete obj[key];
			return false;
		} catch (e) {
			return true;
		}
	};
}
// Based on: https://github.com/geraintluff/uri-templates, but with all the de-substitution stuff removed

var uriTemplateGlobalModifiers = {
	"+": true,
	"#": true,
	".": true,
	"/": true,
	";": true,
	"?": true,
	"&": true
};
var uriTemplateSuffices = {
	"*": true
};

function notReallyPercentEncode(string) {
	return encodeURI(string).replace(/%25[0-9][0-9]/g, function (doubleEncoded) {
		return "%" + doubleEncoded.substring(3);
	});
}

function uriTemplateSubstitution(spec) {
	var modifier = "";
	if (uriTemplateGlobalModifiers[spec.charAt(0)]) {
		modifier = spec.charAt(0);
		spec = spec.substring(1);
	}
	var separator = "";
	var prefix = "";
	var shouldEscape = true;
	var showVariables = false;
	var trimEmptyString = false;
	if (modifier === '+') {
		shouldEscape = false;
	} else if (modifier === ".") {
		prefix = ".";
		separator = ".";
	} else if (modifier === "/") {
		prefix = "/";
		separator = "/";
	} else if (modifier === '#') {
		prefix = "#";
		shouldEscape = false;
	} else if (modifier === ';') {
		prefix = ";";
		separator = ";";
		showVariables = true;
		trimEmptyString = true;
	} else if (modifier === '?') {
		prefix = "?";
		separator = "&";
		showVariables = true;
	} else if (modifier === '&') {
		prefix = "&";
		separator = "&";
		showVariables = true;
	}

	var varNames = [];
	var varList = spec.split(",");
	var varSpecs = [];
	var varSpecMap = {};
	for (var i = 0; i < varList.length; i++) {
		var varName = varList[i];
		var truncate = null;
		if (varName.indexOf(":") !== -1) {
			var parts = varName.split(":");
			varName = parts[0];
			truncate = parseInt(parts[1], 10);
		}
		var suffices = {};
		while (uriTemplateSuffices[varName.charAt(varName.length - 1)]) {
			suffices[varName.charAt(varName.length - 1)] = true;
			varName = varName.substring(0, varName.length - 1);
		}
		var varSpec = {
			truncate: truncate,
			name: varName,
			suffices: suffices
		};
		varSpecs.push(varSpec);
		varSpecMap[varName] = varSpec;
		varNames.push(varName);
	}
	var subFunction = function (valueFunction) {
		var result = "";
		var startIndex = 0;
		for (var i = 0; i < varSpecs.length; i++) {
			var varSpec = varSpecs[i];
			var value = valueFunction(varSpec.name);
			if (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || (typeof value === 'object' && Object.keys(value).length === 0)) {
				startIndex++;
				continue;
			}
			if (i === startIndex) {
				result += prefix;
			} else {
				result += (separator || ",");
			}
			if (Array.isArray(value)) {
				if (showVariables) {
					result += varSpec.name + "=";
				}
				for (var j = 0; j < value.length; j++) {
					if (j > 0) {
						result += varSpec.suffices['*'] ? (separator || ",") : ",";
						if (varSpec.suffices['*'] && showVariables) {
							result += varSpec.name + "=";
						}
					}
					result += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, "%21") : notReallyPercentEncode(value[j]);
				}
			} else if (typeof value === "object") {
				if (showVariables && !varSpec.suffices['*']) {
					result += varSpec.name + "=";
				}
				var first = true;
				for (var key in value) {
					if (!first) {
						result += varSpec.suffices['*'] ? (separator || ",") : ",";
					}
					first = false;
					result += shouldEscape ? encodeURIComponent(key).replace(/!/g, "%21") : notReallyPercentEncode(key);
					result += varSpec.suffices['*'] ? '=' : ",";
					result += shouldEscape ? encodeURIComponent(value[key]).replace(/!/g, "%21") : notReallyPercentEncode(value[key]);
				}
			} else {
				if (showVariables) {
					result += varSpec.name;
					if (!trimEmptyString || value !== "") {
						result += "=";
					}
				}
				if (varSpec.truncate != null) {
					value = value.substring(0, varSpec.truncate);
				}
				result += shouldEscape ? encodeURIComponent(value).replace(/!/g, "%21"): notReallyPercentEncode(value);
			}
		}
		return result;
	};
	subFunction.varNames = varNames;
	return {
		prefix: prefix,
		substitution: subFunction
	};
}

function UriTemplate(template) {
	if (!(this instanceof UriTemplate)) {
		return new UriTemplate(template);
	}
	var parts = template.split("{");
	var textParts = [parts.shift()];
	var prefixes = [];
	var substitutions = [];
	var varNames = [];
	while (parts.length > 0) {
		var part = parts.shift();
		var spec = part.split("}")[0];
		var remainder = part.substring(spec.length + 1);
		var funcs = uriTemplateSubstitution(spec);
		substitutions.push(funcs.substitution);
		prefixes.push(funcs.prefix);
		textParts.push(remainder);
		varNames = varNames.concat(funcs.substitution.varNames);
	}
	this.fill = function (valueFunction) {
		var result = textParts[0];
		for (var i = 0; i < substitutions.length; i++) {
			var substitution = substitutions[i];
			result += substitution(valueFunction);
			result += textParts[i + 1];
		}
		return result;
	};
	this.varNames = varNames;
	this.template = template;
}
UriTemplate.prototype = {
	toString: function () {
		return this.template;
	},
	fillFromObject: function (obj) {
		return this.fill(function (varName) {
			return obj[varName];
		});
	}
};
var ValidatorContext = function ValidatorContext(parent, collectMultiple, errorReporter, checkRecursive, trackUnknownProperties) {
	this.missing = [];
	this.missingMap = {};
	this.formatValidators = parent ? Object.create(parent.formatValidators) : {};
	this.schemas = parent ? Object.create(parent.schemas) : {};
	this.collectMultiple = collectMultiple;
	this.errors = [];
	this.handleError = collectMultiple ? this.collectError : this.returnError;
	if (checkRecursive) {
		this.checkRecursive = true;
		this.scanned = [];
		this.scannedFrozen = [];
		this.scannedFrozenSchemas = [];
		this.scannedFrozenValidationErrors = [];
		this.validatedSchemasKey = 'tv4_validation_id';
		this.validationErrorsKey = 'tv4_validation_errors_id';
	}
	if (trackUnknownProperties) {
		this.trackUnknownProperties = true;
		this.knownPropertyPaths = {};
		this.unknownPropertyPaths = {};
	}
	this.errorReporter = errorReporter || defaultErrorReporter('en');
	if (typeof this.errorReporter === 'string') {
		throw new Error('debug');
	}
	this.definedKeywords = {};
	if (parent) {
		for (var key in parent.definedKeywords) {
			this.definedKeywords[key] = parent.definedKeywords[key].slice(0);
		}
	}
};
ValidatorContext.prototype.defineKeyword = function (keyword, keywordFunction) {
	this.definedKeywords[keyword] = this.definedKeywords[keyword] || [];
	this.definedKeywords[keyword].push(keywordFunction);
};
ValidatorContext.prototype.createError = function (code, messageParams, dataPath, schemaPath, subErrors, data, schema) {
	var error = new ValidationError(code, messageParams, dataPath, schemaPath, subErrors);
	error.message = this.errorReporter(error, data, schema);
	return error;
};
ValidatorContext.prototype.returnError = function (error) {
	return error;
};
ValidatorContext.prototype.collectError = function (error) {
	if (error) {
		this.errors.push(error);
	}
	return null;
};
ValidatorContext.prototype.prefixErrors = function (startIndex, dataPath, schemaPath) {
	for (var i = startIndex; i < this.errors.length; i++) {
		this.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);
	}
	return this;
};
ValidatorContext.prototype.banUnknownProperties = function (data, schema) {
	for (var unknownPath in this.unknownPropertyPaths) {
		var error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, {path: unknownPath}, unknownPath, "", null, data, schema);
		var result = this.handleError(error);
		if (result) {
			return result;
		}
	}
	return null;
};

ValidatorContext.prototype.addFormat = function (format, validator) {
	if (typeof format === 'object') {
		for (var key in format) {
			this.addFormat(key, format[key]);
		}
		return this;
	}
	this.formatValidators[format] = validator;
};
ValidatorContext.prototype.resolveRefs = function (schema, urlHistory) {
	if (schema['$ref'] !== undefined) {
		urlHistory = urlHistory || {};
		if (urlHistory[schema['$ref']]) {
			return this.createError(ErrorCodes.CIRCULAR_REFERENCE, {urls: Object.keys(urlHistory).join(', ')}, '', '', null, undefined, schema);
		}
		urlHistory[schema['$ref']] = true;
		schema = this.getSchema(schema['$ref'], urlHistory);
	}
	return schema;
};
ValidatorContext.prototype.getSchema = function (url, urlHistory) {
	var schema;
	if (this.schemas[url] !== undefined) {
		schema = this.schemas[url];
		return this.resolveRefs(schema, urlHistory);
	}
	var baseUrl = url;
	var fragment = "";
	if (url.indexOf('#') !== -1) {
		fragment = url.substring(url.indexOf("#") + 1);
		baseUrl = url.substring(0, url.indexOf("#"));
	}
	if (typeof this.schemas[baseUrl] === 'object') {
		schema = this.schemas[baseUrl];
		var pointerPath = decodeURIComponent(fragment);
		if (pointerPath === "") {
			return this.resolveRefs(schema, urlHistory);
		} else if (pointerPath.charAt(0) !== "/") {
			return undefined;
		}
		var parts = pointerPath.split("/").slice(1);
		for (var i = 0; i < parts.length; i++) {
			var component = parts[i].replace(/~1/g, "/").replace(/~0/g, "~");
			if (schema[component] === undefined) {
				schema = undefined;
				break;
			}
			schema = schema[component];
		}
		if (schema !== undefined) {
			return this.resolveRefs(schema, urlHistory);
		}
	}
	if (this.missing[baseUrl] === undefined) {
		this.missing.push(baseUrl);
		this.missing[baseUrl] = baseUrl;
		this.missingMap[baseUrl] = baseUrl;
	}
};
ValidatorContext.prototype.searchSchemas = function (schema, url) {
	if (Array.isArray(schema)) {
		for (var i = 0; i < schema.length; i++) {
			this.searchSchemas(schema[i], url);
		}
	} else if (schema && typeof schema === "object") {
		if (typeof schema.id === "string") {
			if (isTrustedUrl(url, schema.id)) {
				if (this.schemas[schema.id] === undefined) {
					this.schemas[schema.id] = schema;
				}
			}
		}
		for (var key in schema) {
			if (key !== "enum") {
				if (typeof schema[key] === "object") {
					this.searchSchemas(schema[key], url);
				} else if (key === "$ref") {
					var uri = getDocumentUri(schema[key]);
					if (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {
						this.missingMap[uri] = uri;
					}
				}
			}
		}
	}
};
ValidatorContext.prototype.addSchema = function (url, schema) {
	//overload
	if (typeof url !== 'string' || typeof schema === 'undefined') {
		if (typeof url === 'object' && typeof url.id === 'string') {
			schema = url;
			url = schema.id;
		}
		else {
			return;
		}
	}
	if (url === getDocumentUri(url) + "#") {
		// Remove empty fragment
		url = getDocumentUri(url);
	}
	this.schemas[url] = schema;
	delete this.missingMap[url];
	normSchema(schema, url);
	this.searchSchemas(schema, url);
};

ValidatorContext.prototype.getSchemaMap = function () {
	var map = {};
	for (var key in this.schemas) {
		map[key] = this.schemas[key];
	}
	return map;
};

ValidatorContext.prototype.getSchemaUris = function (filterRegExp) {
	var list = [];
	for (var key in this.schemas) {
		if (!filterRegExp || filterRegExp.test(key)) {
			list.push(key);
		}
	}
	return list;
};

ValidatorContext.prototype.getMissingUris = function (filterRegExp) {
	var list = [];
	for (var key in this.missingMap) {
		if (!filterRegExp || filterRegExp.test(key)) {
			list.push(key);
		}
	}
	return list;
};

ValidatorContext.prototype.dropSchemas = function () {
	this.schemas = {};
	this.reset();
};
ValidatorContext.prototype.reset = function () {
	this.missing = [];
	this.missingMap = {};
	this.errors = [];
};

ValidatorContext.prototype.validateAll = function (data, schema, dataPathParts, schemaPathParts, dataPointerPath) {
	var topLevel;
	schema = this.resolveRefs(schema);
	if (!schema) {
		return null;
	} else if (schema instanceof ValidationError) {
		this.errors.push(schema);
		return schema;
	}

	var startErrorCount = this.errors.length;
	var frozenIndex, scannedFrozenSchemaIndex = null, scannedSchemasIndex = null;
	if (this.checkRecursive && data && typeof data === 'object') {
		topLevel = !this.scanned.length;
		if (data[this.validatedSchemasKey]) {
			var schemaIndex = data[this.validatedSchemasKey].indexOf(schema);
			if (schemaIndex !== -1) {
				this.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);
				return null;
			}
		}
		if (Object.isFrozen(data)) {
			frozenIndex = this.scannedFrozen.indexOf(data);
			if (frozenIndex !== -1) {
				var frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);
				if (frozenSchemaIndex !== -1) {
					this.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);
					return null;
				}
			}
		}
		this.scanned.push(data);
		if (Object.isFrozen(data)) {
			if (frozenIndex === -1) {
				frozenIndex = this.scannedFrozen.length;
				this.scannedFrozen.push(data);
				this.scannedFrozenSchemas.push([]);
			}
			scannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;
			this.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;
			this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];
		} else {
			if (!data[this.validatedSchemasKey]) {
				try {
					Object.defineProperty(data, this.validatedSchemasKey, {
						value: [],
						configurable: true
					});
					Object.defineProperty(data, this.validationErrorsKey, {
						value: [],
						configurable: true
					});
				} catch (e) {
					//IE 7/8 workaround
					data[this.validatedSchemasKey] = [];
					data[this.validationErrorsKey] = [];
				}
			}
			scannedSchemasIndex = data[this.validatedSchemasKey].length;
			data[this.validatedSchemasKey][scannedSchemasIndex] = schema;
			data[this.validationErrorsKey][scannedSchemasIndex] = [];
		}
	}

	var errorCount = this.errors.length;
	var error = this.validateBasic(data, schema, dataPointerPath)
		|| this.validateNumeric(data, schema, dataPointerPath)
		|| this.validateString(data, schema, dataPointerPath)
		|| this.validateArray(data, schema, dataPointerPath)
		|| this.validateObject(data, schema, dataPointerPath)
		|| this.validateCombinations(data, schema, dataPointerPath)
		|| this.validateHypermedia(data, schema, dataPointerPath)
		|| this.validateFormat(data, schema, dataPointerPath)
		|| this.validateDefinedKeywords(data, schema, dataPointerPath)
		|| null;

	if (topLevel) {
		while (this.scanned.length) {
			var item = this.scanned.pop();
			delete item[this.validatedSchemasKey];
		}
		this.scannedFrozen = [];
		this.scannedFrozenSchemas = [];
	}

	if (error || errorCount !== this.errors.length) {
		while ((dataPathParts && dataPathParts.length) || (schemaPathParts && schemaPathParts.length)) {
			var dataPart = (dataPathParts && dataPathParts.length) ? "" + dataPathParts.pop() : null;
			var schemaPart = (schemaPathParts && schemaPathParts.length) ? "" + schemaPathParts.pop() : null;
			if (error) {
				error = error.prefixWith(dataPart, schemaPart);
			}
			this.prefixErrors(errorCount, dataPart, schemaPart);
		}
	}

	if (scannedFrozenSchemaIndex !== null) {
		this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);
	} else if (scannedSchemasIndex !== null) {
		data[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);
	}

	return this.handleError(error);
};
ValidatorContext.prototype.validateFormat = function (data, schema) {
	if (typeof schema.format !== 'string' || !this.formatValidators[schema.format]) {
		return null;
	}
	var errorMessage = this.formatValidators[schema.format].call(null, data, schema);
	if (typeof errorMessage === 'string' || typeof errorMessage === 'number') {
		return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage}, '', '/format', null, data, schema);
	} else if (errorMessage && typeof errorMessage === 'object') {
		return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage.message || "?"}, errorMessage.dataPath || '', errorMessage.schemaPath || "/format", null, data, schema);
	}
	return null;
};
ValidatorContext.prototype.validateDefinedKeywords = function (data, schema, dataPointerPath) {
	for (var key in this.definedKeywords) {
		if (typeof schema[key] === 'undefined') {
			continue;
		}
		var validationFunctions = this.definedKeywords[key];
		for (var i = 0; i < validationFunctions.length; i++) {
			var func = validationFunctions[i];
			var result = func(data, schema[key], schema, dataPointerPath);
			if (typeof result === 'string' || typeof result === 'number') {
				return this.createError(ErrorCodes.KEYWORD_CUSTOM, {key: key, message: result}, '', '', null, data, schema).prefixWith(null, key);
			} else if (result && typeof result === 'object') {
				var code = result.code;
				if (typeof code === 'string') {
					if (!ErrorCodes[code]) {
						throw new Error('Undefined error code (use defineError): ' + code);
					}
					code = ErrorCodes[code];
				} else if (typeof code !== 'number') {
					code = ErrorCodes.KEYWORD_CUSTOM;
				}
				var messageParams = (typeof result.message === 'object') ? result.message : {key: key, message: result.message || "?"};
				var schemaPath = result.schemaPath || ("/" + key.replace(/~/g, '~0').replace(/\//g, '~1'));
				return this.createError(code, messageParams, result.dataPath || null, schemaPath, null, data, schema);
			}
		}
	}
	return null;
};

function recursiveCompare(A, B) {
	if (A === B) {
		return true;
	}
	if (A && B && typeof A === "object" && typeof B === "object") {
		if (Array.isArray(A) !== Array.isArray(B)) {
			return false;
		} else if (Array.isArray(A)) {
			if (A.length !== B.length) {
				return false;
			}
			for (var i = 0; i < A.length; i++) {
				if (!recursiveCompare(A[i], B[i])) {
					return false;
				}
			}
		} else {
			var key;
			for (key in A) {
				if (B[key] === undefined && A[key] !== undefined) {
					return false;
				}
			}
			for (key in B) {
				if (A[key] === undefined && B[key] !== undefined) {
					return false;
				}
			}
			for (key in A) {
				if (!recursiveCompare(A[key], B[key])) {
					return false;
				}
			}
		}
		return true;
	}
	return false;
}

ValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {
	var error;
	if (error = this.validateType(data, schema, dataPointerPath)) {
		return error.prefixWith(null, "type");
	}
	if (error = this.validateEnum(data, schema, dataPointerPath)) {
		return error.prefixWith(null, "type");
	}
	return null;
};

ValidatorContext.prototype.validateType = function validateType(data, schema) {
	if (schema.type === undefined) {
		return null;
	}
	var dataType = typeof data;
	if (data === null) {
		dataType = "null";
	} else if (Array.isArray(data)) {
		dataType = "array";
	}
	var allowedTypes = schema.type;
	if (!Array.isArray(allowedTypes)) {
		allowedTypes = [allowedTypes];
	}

	for (var i = 0; i < allowedTypes.length; i++) {
		var type = allowedTypes[i];
		if (type === dataType || (type === "integer" && dataType === "number" && (data % 1 === 0))) {
			return null;
		}
	}
	return this.createError(ErrorCodes.INVALID_TYPE, {type: dataType, expected: allowedTypes.join("/")}, '', '', null, data, schema);
};

ValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {
	if (schema["enum"] === undefined) {
		return null;
	}
	for (var i = 0; i < schema["enum"].length; i++) {
		var enumVal = schema["enum"][i];
		if (recursiveCompare(data, enumVal)) {
			return null;
		}
	}
	return this.createError(ErrorCodes.ENUM_MISMATCH, {value: (typeof JSON !== 'undefined') ? JSON.stringify(data) : data}, '', '', null, data, schema);
};

ValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {
	return this.validateMultipleOf(data, schema, dataPointerPath)
		|| this.validateMinMax(data, schema, dataPointerPath)
		|| this.validateNaN(data, schema, dataPointerPath)
		|| null;
};

var CLOSE_ENOUGH_LOW = Math.pow(2, -51);
var CLOSE_ENOUGH_HIGH = 1 - CLOSE_ENOUGH_LOW;
ValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {
	var multipleOf = schema.multipleOf || schema.divisibleBy;
	if (multipleOf === undefined) {
		return null;
	}
	if (typeof data === "number") {
		var remainder = (data/multipleOf)%1;
		if (remainder >= CLOSE_ENOUGH_LOW && remainder < CLOSE_ENOUGH_HIGH) {
			return this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, {value: data, multipleOf: multipleOf}, '', '', null, data, schema);
		}
	}
	return null;
};

ValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {
	if (typeof data !== "number") {
		return null;
	}
	if (schema.minimum !== undefined) {
		if (data < schema.minimum) {
			return this.createError(ErrorCodes.NUMBER_MINIMUM, {value: data, minimum: schema.minimum}, '', '/minimum', null, data, schema);
		}
		if (schema.exclusiveMinimum && data === schema.minimum) {
			return this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, {value: data, minimum: schema.minimum}, '', '/exclusiveMinimum', null, data, schema);
		}
	}
	if (schema.maximum !== undefined) {
		if (data > schema.maximum) {
			return this.createError(ErrorCodes.NUMBER_MAXIMUM, {value: data, maximum: schema.maximum}, '', '/maximum', null, data, schema);
		}
		if (schema.exclusiveMaximum && data === schema.maximum) {
			return this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, {value: data, maximum: schema.maximum}, '', '/exclusiveMaximum', null, data, schema);
		}
	}
	return null;
};

ValidatorContext.prototype.validateNaN = function validateNaN(data, schema) {
	if (typeof data !== "number") {
		return null;
	}
	if (isNaN(data) === true || data === Infinity || data === -Infinity) {
		return this.createError(ErrorCodes.NUMBER_NOT_A_NUMBER, {value: data}, '', '/type', null, data, schema);
	}
	return null;
};

ValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {
	return this.validateStringLength(data, schema, dataPointerPath)
		|| this.validateStringPattern(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {
	if (typeof data !== "string") {
		return null;
	}
	if (schema.minLength !== undefined) {
		if (data.length < schema.minLength) {
			return this.createError(ErrorCodes.STRING_LENGTH_SHORT, {length: data.length, minimum: schema.minLength}, '', '/minLength', null, data, schema);
		}
	}
	if (schema.maxLength !== undefined) {
		if (data.length > schema.maxLength) {
			return this.createError(ErrorCodes.STRING_LENGTH_LONG, {length: data.length, maximum: schema.maxLength}, '', '/maxLength', null, data, schema);
		}
	}
	return null;
};

ValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {
	if (typeof data !== "string" || (typeof schema.pattern !== "string" && !(schema.pattern instanceof RegExp))) {
		return null;
	}
	var regexp;
	if (schema.pattern instanceof RegExp) {
	  regexp = schema.pattern;
	}
	else {
	  var body, flags = '';
	  // Check for regular expression literals
	  // @see http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.5
	  var literal = schema.pattern.match(/^\/(.+)\/([img]*)$/);
	  if (literal) {
	    body = literal[1];
	    flags = literal[2];
	  }
	  else {
	    body = schema.pattern;
	  }
	  regexp = new RegExp(body, flags);
	}
	if (!regexp.test(data)) {
		return this.createError(ErrorCodes.STRING_PATTERN, {pattern: schema.pattern}, '', '/pattern', null, data, schema);
	}
	return null;
};

ValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {
	if (!Array.isArray(data)) {
		return null;
	}
	return this.validateArrayLength(data, schema, dataPointerPath)
		|| this.validateArrayUniqueItems(data, schema, dataPointerPath)
		|| this.validateArrayItems(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {
	var error;
	if (schema.minItems !== undefined) {
		if (data.length < schema.minItems) {
			error = this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, {length: data.length, minimum: schema.minItems}, '', '/minItems', null, data, schema);
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	if (schema.maxItems !== undefined) {
		if (data.length > schema.maxItems) {
			error = this.createError(ErrorCodes.ARRAY_LENGTH_LONG, {length: data.length, maximum: schema.maxItems}, '', '/maxItems', null, data, schema);
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {
	if (schema.uniqueItems) {
		for (var i = 0; i < data.length; i++) {
			for (var j = i + 1; j < data.length; j++) {
				if (recursiveCompare(data[i], data[j])) {
					var error = this.createError(ErrorCodes.ARRAY_UNIQUE, {match1: i, match2: j}, '', '/uniqueItems', null, data, schema);
					if (this.handleError(error)) {
						return error;
					}
				}
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {
	if (schema.items === undefined) {
		return null;
	}
	var error, i;
	if (Array.isArray(schema.items)) {
		for (i = 0; i < data.length; i++) {
			if (i < schema.items.length) {
				if (error = this.validateAll(data[i], schema.items[i], [i], ["items", i], dataPointerPath + "/" + i)) {
					return error;
				}
			} else if (schema.additionalItems !== undefined) {
				if (typeof schema.additionalItems === "boolean") {
					if (!schema.additionalItems) {
						error = (this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {}, '/' + i, '/additionalItems', null, data, schema));
						if (this.handleError(error)) {
							return error;
						}
					}
				} else if (error = this.validateAll(data[i], schema.additionalItems, [i], ["additionalItems"], dataPointerPath + "/" + i)) {
					return error;
				}
			}
		}
	} else {
		for (i = 0; i < data.length; i++) {
			if (error = this.validateAll(data[i], schema.items, [i], ["items"], dataPointerPath + "/" + i)) {
				return error;
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {
	if (typeof data !== "object" || data === null || Array.isArray(data)) {
		return null;
	}
	return this.validateObjectMinMaxProperties(data, schema, dataPointerPath)
		|| this.validateObjectRequiredProperties(data, schema, dataPointerPath)
		|| this.validateObjectProperties(data, schema, dataPointerPath)
		|| this.validateObjectDependencies(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {
	var keys = Object.keys(data);
	var error;
	if (schema.minProperties !== undefined) {
		if (keys.length < schema.minProperties) {
			error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, {propertyCount: keys.length, minimum: schema.minProperties}, '', '/minProperties', null, data, schema);
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	if (schema.maxProperties !== undefined) {
		if (keys.length > schema.maxProperties) {
			error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, {propertyCount: keys.length, maximum: schema.maxProperties}, '', '/maxProperties', null, data, schema);
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {
	if (schema.required !== undefined) {
		for (var i = 0; i < schema.required.length; i++) {
			var key = schema.required[i];
			if (data[key] === undefined) {
				var error = this.createError(ErrorCodes.OBJECT_REQUIRED, {key: key}, '', '/required/' + i, null, data, schema);
				if (this.handleError(error)) {
					return error;
				}
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {
	var error;
	for (var key in data) {
		var keyPointerPath = dataPointerPath + "/" + key.replace(/~/g, '~0').replace(/\//g, '~1');
		var foundMatch = false;
		if (schema.properties !== undefined && schema.properties[key] !== undefined) {
			foundMatch = true;
			if (error = this.validateAll(data[key], schema.properties[key], [key], ["properties", key], keyPointerPath)) {
				return error;
			}
		}
		if (schema.patternProperties !== undefined) {
			for (var patternKey in schema.patternProperties) {
				var regexp = new RegExp(patternKey);
				if (regexp.test(key)) {
					foundMatch = true;
					if (error = this.validateAll(data[key], schema.patternProperties[patternKey], [key], ["patternProperties", patternKey], keyPointerPath)) {
						return error;
					}
				}
			}
		}
		if (!foundMatch) {
			if (schema.additionalProperties !== undefined) {
				if (this.trackUnknownProperties) {
					this.knownPropertyPaths[keyPointerPath] = true;
					delete this.unknownPropertyPaths[keyPointerPath];
				}
				if (typeof schema.additionalProperties === "boolean") {
					if (!schema.additionalProperties) {
						error = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, {key: key}, '', '/additionalProperties', null, data, schema).prefixWith(key, null);
						if (this.handleError(error)) {
							return error;
						}
					}
				} else {
					if (error = this.validateAll(data[key], schema.additionalProperties, [key], ["additionalProperties"], keyPointerPath)) {
						return error;
					}
				}
			} else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {
				this.unknownPropertyPaths[keyPointerPath] = true;
			}
		} else if (this.trackUnknownProperties) {
			this.knownPropertyPaths[keyPointerPath] = true;
			delete this.unknownPropertyPaths[keyPointerPath];
		}
	}
	return null;
};

ValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {
	var error;
	if (schema.dependencies !== undefined) {
		for (var depKey in schema.dependencies) {
			if (data[depKey] !== undefined) {
				var dep = schema.dependencies[depKey];
				if (typeof dep === "string") {
					if (data[dep] === undefined) {
						error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: dep}, '', '', null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");
						if (this.handleError(error)) {
							return error;
						}
					}
				} else if (Array.isArray(dep)) {
					for (var i = 0; i < dep.length; i++) {
						var requiredKey = dep[i];
						if (data[requiredKey] === undefined) {
							error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: requiredKey}, '', '/' + i, null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");
							if (this.handleError(error)) {
								return error;
							}
						}
					}
				} else {
					if (error = this.validateAll(data, dep, [], ["dependencies", depKey], dataPointerPath)) {
						return error;
					}
				}
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {
	return this.validateAllOf(data, schema, dataPointerPath)
		|| this.validateAnyOf(data, schema, dataPointerPath)
		|| this.validateOneOf(data, schema, dataPointerPath)
		|| this.validateNot(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {
	if (schema.allOf === undefined) {
		return null;
	}
	var error;
	for (var i = 0; i < schema.allOf.length; i++) {
		var subSchema = schema.allOf[i];
		if (error = this.validateAll(data, subSchema, [], ["allOf", i], dataPointerPath)) {
			return error;
		}
	}
	return null;
};

ValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {
	if (schema.anyOf === undefined) {
		return null;
	}
	var errors = [];
	var startErrorCount = this.errors.length;
	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
	}
	var errorAtEnd = true;
	for (var i = 0; i < schema.anyOf.length; i++) {
		if (this.trackUnknownProperties) {
			this.unknownPropertyPaths = {};
			this.knownPropertyPaths = {};
		}
		var subSchema = schema.anyOf[i];

		var errorCount = this.errors.length;
		var error = this.validateAll(data, subSchema, [], ["anyOf", i], dataPointerPath);

		if (error === null && errorCount === this.errors.length) {
			this.errors = this.errors.slice(0, startErrorCount);

			if (this.trackUnknownProperties) {
				for (var knownKey in this.knownPropertyPaths) {
					oldKnownPropertyPaths[knownKey] = true;
					delete oldUnknownPropertyPaths[knownKey];
				}
				for (var unknownKey in this.unknownPropertyPaths) {
					if (!oldKnownPropertyPaths[unknownKey]) {
						oldUnknownPropertyPaths[unknownKey] = true;
					}
				}
				// We need to continue looping so we catch all the property definitions, but we don't want to return an error
				errorAtEnd = false;
				continue;
			}

			return null;
		}
		if (error) {
			errors.push(error.prefixWith(null, "" + i).prefixWith(null, "anyOf"));
		}
	}
	if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	}
	if (errorAtEnd) {
		errors = errors.concat(this.errors.slice(startErrorCount));
		this.errors = this.errors.slice(0, startErrorCount);
		return this.createError(ErrorCodes.ANY_OF_MISSING, {}, "", "/anyOf", errors, data, schema);
	}
};

ValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {
	if (schema.oneOf === undefined) {
		return null;
	}
	var validIndex = null;
	var errors = [];
	var startErrorCount = this.errors.length;
	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
	}
	for (var i = 0; i < schema.oneOf.length; i++) {
		if (this.trackUnknownProperties) {
			this.unknownPropertyPaths = {};
			this.knownPropertyPaths = {};
		}
		var subSchema = schema.oneOf[i];

		var errorCount = this.errors.length;
		var error = this.validateAll(data, subSchema, [], ["oneOf", i], dataPointerPath);

		if (error === null && errorCount === this.errors.length) {
			if (validIndex === null) {
				validIndex = i;
			} else {
				this.errors = this.errors.slice(0, startErrorCount);
				return this.createError(ErrorCodes.ONE_OF_MULTIPLE, {index1: validIndex, index2: i}, "", "/oneOf", null, data, schema);
			}
			if (this.trackUnknownProperties) {
				for (var knownKey in this.knownPropertyPaths) {
					oldKnownPropertyPaths[knownKey] = true;
					delete oldUnknownPropertyPaths[knownKey];
				}
				for (var unknownKey in this.unknownPropertyPaths) {
					if (!oldKnownPropertyPaths[unknownKey]) {
						oldUnknownPropertyPaths[unknownKey] = true;
					}
				}
			}
		} else if (error) {
			errors.push(error);
		}
	}
	if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	}
	if (validIndex === null) {
		errors = errors.concat(this.errors.slice(startErrorCount));
		this.errors = this.errors.slice(0, startErrorCount);
		return this.createError(ErrorCodes.ONE_OF_MISSING, {}, "", "/oneOf", errors, data, schema);
	} else {
		this.errors = this.errors.slice(0, startErrorCount);
	}
	return null;
};

ValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {
	if (schema.not === undefined) {
		return null;
	}
	var oldErrorCount = this.errors.length;
	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
		this.unknownPropertyPaths = {};
		this.knownPropertyPaths = {};
	}
	var error = this.validateAll(data, schema.not, null, null, dataPointerPath);
	var notErrors = this.errors.slice(oldErrorCount);
	this.errors = this.errors.slice(0, oldErrorCount);
	if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	}
	if (error === null && notErrors.length === 0) {
		return this.createError(ErrorCodes.NOT_PASSED, {}, "", "/not", null, data, schema);
	}
	return null;
};

ValidatorContext.prototype.validateHypermedia = function validateCombinations(data, schema, dataPointerPath) {
	if (!schema.links) {
		return null;
	}
	var error;
	for (var i = 0; i < schema.links.length; i++) {
		var ldo = schema.links[i];
		if (ldo.rel === "describedby") {
			var template = new UriTemplate(ldo.href);
			var allPresent = true;
			for (var j = 0; j < template.varNames.length; j++) {
				if (!(template.varNames[j] in data)) {
					allPresent = false;
					break;
				}
			}
			if (allPresent) {
				var schemaUrl = template.fillFromObject(data);
				var subSchema = {"$ref": schemaUrl};
				if (error = this.validateAll(data, subSchema, [], ["links", i], dataPointerPath)) {
					return error;
				}
			}
		}
	}
};

// parseURI() and resolveUrl() are from https://gist.github.com/1088850
//   -  released as public domain by author ("Yaffle") - see comments on gist

function parseURI(url) {
	var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
	// authority = '//' + user + ':' + pass '@' + hostname + ':' port
	return (m ? {
		href     : m[0] || '',
		protocol : m[1] || '',
		authority: m[2] || '',
		host     : m[3] || '',
		hostname : m[4] || '',
		port     : m[5] || '',
		pathname : m[6] || '',
		search   : m[7] || '',
		hash     : m[8] || ''
	} : null);
}

function resolveUrl(base, href) {// RFC 3986

	function removeDotSegments(input) {
		var output = [];
		input.replace(/^(\.\.?(\/|$))+/, '')
			.replace(/\/(\.(\/|$))+/g, '/')
			.replace(/\/\.\.$/, '/../')
			.replace(/\/?[^\/]*/g, function (p) {
				if (p === '/..') {
					output.pop();
				} else {
					output.push(p);
				}
		});
		return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
	}

	href = parseURI(href || '');
	base = parseURI(base || '');

	return !href || !base ? null : (href.protocol || base.protocol) +
		(href.protocol || href.authority ? href.authority : base.authority) +
		removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +
		(href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +
		href.hash;
}

function getDocumentUri(uri) {
	return uri.split('#')[0];
}
function normSchema(schema, baseUri) {
	if (schema && typeof schema === "object") {
		if (baseUri === undefined) {
			baseUri = schema.id;
		} else if (typeof schema.id === "string") {
			baseUri = resolveUrl(baseUri, schema.id);
			schema.id = baseUri;
		}
		if (Array.isArray(schema)) {
			for (var i = 0; i < schema.length; i++) {
				normSchema(schema[i], baseUri);
			}
		} else {
			if (typeof schema['$ref'] === "string") {
				schema['$ref'] = resolveUrl(baseUri, schema['$ref']);
			}
			for (var key in schema) {
				if (key !== "enum") {
					normSchema(schema[key], baseUri);
				}
			}
		}
	}
}

function defaultErrorReporter(language) {
	language = language || 'en';

	var errorMessages = languages[language];

	return function (error) {
		var messageTemplate = errorMessages[error.code] || ErrorMessagesDefault[error.code];
		if (typeof messageTemplate !== 'string') {
			return "Unknown error code " + error.code + ": " + JSON.stringify(error.messageParams);
		}
		var messageParams = error.params;
		// Adapted from Crockford's supplant()
		return messageTemplate.replace(/\{([^{}]*)\}/g, function (whole, varName) {
			var subValue = messageParams[varName];
			return typeof subValue === 'string' || typeof subValue === 'number' ? subValue : whole;
		});
	};
}

var ErrorCodes = {
	INVALID_TYPE: 0,
	ENUM_MISMATCH: 1,
	ANY_OF_MISSING: 10,
	ONE_OF_MISSING: 11,
	ONE_OF_MULTIPLE: 12,
	NOT_PASSED: 13,
	// Numeric errors
	NUMBER_MULTIPLE_OF: 100,
	NUMBER_MINIMUM: 101,
	NUMBER_MINIMUM_EXCLUSIVE: 102,
	NUMBER_MAXIMUM: 103,
	NUMBER_MAXIMUM_EXCLUSIVE: 104,
	NUMBER_NOT_A_NUMBER: 105,
	// String errors
	STRING_LENGTH_SHORT: 200,
	STRING_LENGTH_LONG: 201,
	STRING_PATTERN: 202,
	// Object errors
	OBJECT_PROPERTIES_MINIMUM: 300,
	OBJECT_PROPERTIES_MAXIMUM: 301,
	OBJECT_REQUIRED: 302,
	OBJECT_ADDITIONAL_PROPERTIES: 303,
	OBJECT_DEPENDENCY_KEY: 304,
	// Array errors
	ARRAY_LENGTH_SHORT: 400,
	ARRAY_LENGTH_LONG: 401,
	ARRAY_UNIQUE: 402,
	ARRAY_ADDITIONAL_ITEMS: 403,
	// Custom/user-defined errors
	FORMAT_CUSTOM: 500,
	KEYWORD_CUSTOM: 501,
	// Schema structure
	CIRCULAR_REFERENCE: 600,
	// Non-standard validation options
	UNKNOWN_PROPERTY: 1000
};
var ErrorCodeLookup = {};
for (var key in ErrorCodes) {
	ErrorCodeLookup[ErrorCodes[key]] = key;
}
var ErrorMessagesDefault = {
	INVALID_TYPE: "Invalid type: {type} (expected {expected})",
	ENUM_MISMATCH: "No enum match for: {value}",
	ANY_OF_MISSING: "Data does not match any schemas from \"anyOf\"",
	ONE_OF_MISSING: "Data does not match any schemas from \"oneOf\"",
	ONE_OF_MULTIPLE: "Data is valid against more than one schema from \"oneOf\": indices {index1} and {index2}",
	NOT_PASSED: "Data matches schema from \"not\"",
	// Numeric errors
	NUMBER_MULTIPLE_OF: "Value {value} is not a multiple of {multipleOf}",
	NUMBER_MINIMUM: "Value {value} is less than minimum {minimum}",
	NUMBER_MINIMUM_EXCLUSIVE: "Value {value} is equal to exclusive minimum {minimum}",
	NUMBER_MAXIMUM: "Value {value} is greater than maximum {maximum}",
	NUMBER_MAXIMUM_EXCLUSIVE: "Value {value} is equal to exclusive maximum {maximum}",
	NUMBER_NOT_A_NUMBER: "Value {value} is not a valid number",
	// String errors
	STRING_LENGTH_SHORT: "String is too short ({length} chars), minimum {minimum}",
	STRING_LENGTH_LONG: "String is too long ({length} chars), maximum {maximum}",
	STRING_PATTERN: "String does not match pattern: {pattern}",
	// Object errors
	OBJECT_PROPERTIES_MINIMUM: "Too few properties defined ({propertyCount}), minimum {minimum}",
	OBJECT_PROPERTIES_MAXIMUM: "Too many properties defined ({propertyCount}), maximum {maximum}",
	OBJECT_REQUIRED: "Missing required property: {key}",
	OBJECT_ADDITIONAL_PROPERTIES: "Additional properties not allowed",
	OBJECT_DEPENDENCY_KEY: "Dependency failed - key must exist: {missing} (due to key: {key})",
	// Array errors
	ARRAY_LENGTH_SHORT: "Array is too short ({length}), minimum {minimum}",
	ARRAY_LENGTH_LONG: "Array is too long ({length}), maximum {maximum}",
	ARRAY_UNIQUE: "Array items are not unique (indices {match1} and {match2})",
	ARRAY_ADDITIONAL_ITEMS: "Additional items not allowed",
	// Format errors
	FORMAT_CUSTOM: "Format validation failed ({message})",
	KEYWORD_CUSTOM: "Keyword failed: {key} ({message})",
	// Schema structure
	CIRCULAR_REFERENCE: "Circular $refs: {urls}",
	// Non-standard validation options
	UNKNOWN_PROPERTY: "Unknown property (not in schema)"
};

function ValidationError(code, params, dataPath, schemaPath, subErrors) {
	Error.call(this);
	if (code === undefined) {
		throw new Error ("No error code supplied: " + schemaPath);
	}
	this.message = '';
	this.params = params;
	this.code = code;
	this.dataPath = dataPath || "";
	this.schemaPath = schemaPath || "";
	this.subErrors = subErrors || null;

	var err = new Error(this.message);
	this.stack = err.stack || err.stacktrace;
	if (!this.stack) {
		try {
			throw err;
		}
		catch(err) {
			this.stack = err.stack || err.stacktrace;
		}
	}
}
ValidationError.prototype = Object.create(Error.prototype);
ValidationError.prototype.constructor = ValidationError;
ValidationError.prototype.name = 'ValidationError';

ValidationError.prototype.prefixWith = function (dataPrefix, schemaPrefix) {
	if (dataPrefix !== null) {
		dataPrefix = dataPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
		this.dataPath = "/" + dataPrefix + this.dataPath;
	}
	if (schemaPrefix !== null) {
		schemaPrefix = schemaPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
		this.schemaPath = "/" + schemaPrefix + this.schemaPath;
	}
	if (this.subErrors !== null) {
		for (var i = 0; i < this.subErrors.length; i++) {
			this.subErrors[i].prefixWith(dataPrefix, schemaPrefix);
		}
	}
	return this;
};

function isTrustedUrl(baseUrl, testUrl) {
	if(testUrl.substring(0, baseUrl.length) === baseUrl){
		var remainder = testUrl.substring(baseUrl.length);
		if ((testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === "/")
			|| remainder.charAt(0) === "#"
			|| remainder.charAt(0) === "?") {
			return true;
		}
	}
	return false;
}

var languages = {};
function createApi(language) {
	var globalContext = new ValidatorContext();
	var currentLanguage;
	var customErrorReporter;
	var api = {
		setErrorReporter: function (reporter) {
			if (typeof reporter === 'string') {
				return this.language(reporter);
			}
			customErrorReporter = reporter;
			return true;
		},
		addFormat: function () {
			globalContext.addFormat.apply(globalContext, arguments);
		},
		language: function (code) {
			if (!code) {
				return currentLanguage;
			}
			if (!languages[code]) {
				code = code.split('-')[0]; // fall back to base language
			}
			if (languages[code]) {
				currentLanguage = code;
				return code; // so you can tell if fall-back has happened
			}
			return false;
		},
		addLanguage: function (code, messageMap) {
			var key;
			for (key in ErrorCodes) {
				if (messageMap[key] && !messageMap[ErrorCodes[key]]) {
					messageMap[ErrorCodes[key]] = messageMap[key];
				}
			}
			var rootCode = code.split('-')[0];
			if (!languages[rootCode]) { // use for base language if not yet defined
				languages[code] = messageMap;
				languages[rootCode] = messageMap;
			} else {
				languages[code] = Object.create(languages[rootCode]);
				for (key in messageMap) {
					if (typeof languages[rootCode][key] === 'undefined') {
						languages[rootCode][key] = messageMap[key];
					}
					languages[code][key] = messageMap[key];
				}
			}
			return this;
		},
		freshApi: function (language) {
			var result = createApi();
			if (language) {
				result.language(language);
			}
			return result;
		},
		validate: function (data, schema, checkRecursive, banUnknownProperties) {
			var def = defaultErrorReporter(currentLanguage);
			var errorReporter = customErrorReporter ? function (error, data, schema) {
				return customErrorReporter(error, data, schema) || def(error, data, schema);
			} : def;
			var context = new ValidatorContext(globalContext, false, errorReporter, checkRecursive, banUnknownProperties);
			if (typeof schema === "string") {
				schema = {"$ref": schema};
			}
			context.addSchema("", schema);
			var error = context.validateAll(data, schema, null, null, "");
			if (!error && banUnknownProperties) {
				error = context.banUnknownProperties(data, schema);
			}
			this.error = error;
			this.missing = context.missing;
			this.valid = (error === null);
			return this.valid;
		},
		validateResult: function () {
			var result = {};
			this.validate.apply(result, arguments);
			return result;
		},
		validateMultiple: function (data, schema, checkRecursive, banUnknownProperties) {
			var def = defaultErrorReporter(currentLanguage);
			var errorReporter = customErrorReporter ? function (error, data, schema) {
				return customErrorReporter(error, data, schema) || def(error, data, schema);
			} : def;
			var context = new ValidatorContext(globalContext, true, errorReporter, checkRecursive, banUnknownProperties);
			if (typeof schema === "string") {
				schema = {"$ref": schema};
			}
			context.addSchema("", schema);
			context.validateAll(data, schema, null, null, "");
			if (banUnknownProperties) {
				context.banUnknownProperties(data, schema);
			}
			var result = {};
			result.errors = context.errors;
			result.missing = context.missing;
			result.valid = (result.errors.length === 0);
			return result;
		},
		addSchema: function () {
			return globalContext.addSchema.apply(globalContext, arguments);
		},
		getSchema: function () {
			return globalContext.getSchema.apply(globalContext, arguments);
		},
		getSchemaMap: function () {
			return globalContext.getSchemaMap.apply(globalContext, arguments);
		},
		getSchemaUris: function () {
			return globalContext.getSchemaUris.apply(globalContext, arguments);
		},
		getMissingUris: function () {
			return globalContext.getMissingUris.apply(globalContext, arguments);
		},
		dropSchemas: function () {
			globalContext.dropSchemas.apply(globalContext, arguments);
		},
		defineKeyword: function () {
			globalContext.defineKeyword.apply(globalContext, arguments);
		},
		defineError: function (codeName, codeNumber, defaultMessage) {
			if (typeof codeName !== 'string' || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) {
				throw new Error('Code name must be a string in UPPER_CASE_WITH_UNDERSCORES');
			}
			if (typeof codeNumber !== 'number' || codeNumber%1 !== 0 || codeNumber < 10000) {
				throw new Error('Code number must be an integer > 10000');
			}
			if (typeof ErrorCodes[codeName] !== 'undefined') {
				throw new Error('Error already defined: ' + codeName + ' as ' + ErrorCodes[codeName]);
			}
			if (typeof ErrorCodeLookup[codeNumber] !== 'undefined') {
				throw new Error('Error code already used: ' + ErrorCodeLookup[codeNumber] + ' as ' + codeNumber);
			}
			ErrorCodes[codeName] = codeNumber;
			ErrorCodeLookup[codeNumber] = codeName;
			ErrorMessagesDefault[codeName] = ErrorMessagesDefault[codeNumber] = defaultMessage;
			for (var langCode in languages) {
				var language = languages[langCode];
				if (language[codeName]) {
					language[codeNumber] = language[codeNumber] || language[codeName];
				}
			}
		},
		reset: function () {
			globalContext.reset();
			this.error = null;
			this.missing = [];
			this.valid = true;
		},
		missing: [],
		error: null,
		valid: true,
		normSchema: normSchema,
		resolveUrl: resolveUrl,
		getDocumentUri: getDocumentUri,
		errorCodes: ErrorCodes
	};
	api.language(language || 'en');
	return api;
}

var tv4 = createApi();
tv4.addLanguage('en-gb', ErrorMessagesDefault);

//legacy property
tv4.tv4 = tv4;

return tv4; // used by _header.js to globalise.

}));
},{}],195:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],196:[function(require,module,exports){
'use strict';

// setup the drake (dragula instance) for our composer drag drop requirements

var Drake = function Drake(deps) {
  var cloneSelector = '.composer-node__toolbar [data-dragsource="composer"]';
  var containerSelector = '[data-dragsource="composer"]';
  var updateNode = deps.updateNode,
      dragula = deps.dragula,
      find = deps.find,
      ondrop = deps.ondrop;


  var isContainer = function isContainer(el) {
    return el.matches(containerSelector);
  };

  var accepts = function accepts(el, containerEl) {
    var accepts = containerEl.matches(containerSelector);

    if (accepts) {
      accepts = !containerEl.matches(cloneSelector);
    }

    if (accepts) {
      var node = find.elNode(el);
      var parentNode = find.containerElNode(containerEl);

      if (node === parentNode) return false;

      accepts = parentNode.accepts(node);
    }

    return accepts;
  };

  var options = { isContainer: isContainer, accepts: accepts };

  var drake = dragula(options);

  drake.on('drop', function (el, containerEl, sourceContainerEl, nextEl) {
    var node = find.elNode(el);
    var parentNode = find.containerElNode(containerEl);

    if (nextEl) {
      var referenceNode = find.elNode(nextEl);
      parentNode.insertBefore(node, referenceNode);
    } else {
      parentNode.append(node);
    }

    updateNode(node);

    ondrop(node, parentNode, el, containerEl, sourceContainerEl, nextEl);
  });

  return drake;
};

module.exports = Drake;

},{}],197:[function(require,module,exports){
'use strict';

// functions for finding different tree node types in the composer DOM

var Find = function Find(idMap) {
  var nodeEl = function nodeEl(el) {
    return el.querySelector('.composer-node');
  };
  var containerEl = function containerEl(el) {
    return el.closest('.composer-node');
  };
  var elNode = function elNode(el) {
    return idMap.findById(nodeEl(el).id);
  };
  var containerElNode = function containerElNode(el) {
    return idMap.findById(containerEl(el).id);
  };

  return { nodeEl: nodeEl, containerEl: containerEl, elNode: elNode, containerElNode: containerElNode };
};

module.exports = Find;

},{}],198:[function(require,module,exports){
'use strict';

/*
  cache that maps between tree nodes and their DOM representations using the id
  attribute
*/

var IdMap = function IdMap(tree) {
  var idMap = new Map();

  var findById = function findById(id) {
    if (idMap.has(id)) return idMap.get(id);

    var node = tree.find(function (n) {
      return n.id() === id;
    });

    idMap.set(id, node);

    return node;
  };

  var refresh = function refresh(node) {
    node.walk(function (n) {
      return idMap.set(n.id(), n);
    });
  };

  refresh(tree);

  return Object.assign(idMap, { findById: findById, refresh: refresh });
};

module.exports = IdMap;

},{}],199:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var dragula = require('dragula');
var morphdom = require('morphdom');
var IdMap = require('./idmap');
var Drake = require('./drake');
var Find = require('./find');

var defaultOptions = {
  document: typeof window === 'undefined' ? null : window.document,
  dragula: dragula,
  morphdom: morphdom,
  selector: '.composer'
};

var validateObj = function validateObj(obj, name, typeName) {
  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== typeName) throw new Error('A ' + name + ' ' + typeName + ' is required');
};

/*
  TODO

  * the expand/collapse children actions should be disabled if that action is
    not possible or necessary
  * the tree or options or something should be able to override the actions
    eg not all nodes may have all actions

*/
var Composer = function Composer(_tree, renderNode, options) {
  options = Object.assign({}, defaultOptions, options);

  var _options = options,
      document = _options.document,
      dragula = _options.dragula,
      morphdom = _options.morphdom,
      selector = _options.selector;


  validateObj(document, 'document', 'object');
  validateObj(renderNode, 'renderNode', 'function');
  validateObj(selector, 'selector', 'string');

  var _idMap = IdMap(_tree);
  var find = Find(_idMap);

  var composerView = document.querySelector(selector);

  var initialDom = renderNode(_tree);

  morphdom(composerView, initialDom.stringify());

  /*
   TODO the functions should take the actual el node, not the clicked node, any
   logic inside the various fns below for finding the el node should be moved
   here
  */
  var clickHandler = {
    '.composer-node__title, .composer-node__action > i': function composerNode__titleComposerNode__actionI(el) {
      return el.parentNode;
    },

    '.composer-node__toolbar': function composerNode__toolbar(el) {
      toggleEl(el);
    },

    '.composer-node__delete': function composerNode__delete(el) {
      var shouldDelete = window.confirm('Are you sure?');

      if (shouldDelete) removeEl(el);
    },

    '.composer-node__collapse-children': function composerNode__collapseChildren(el) {
      collapseElChildren(el);
    },

    '.composer-node__expand-children': function composerNode__expandChildren(el) {
      expandElChildren(el);
    }
  };

  var clickSelectors = Object.keys(clickHandler);

  var handleClick = function handleClick(el) {
    var selector = clickSelectors.find(function (sel) {
      return el.matches(sel);
    });

    if (selector) {
      el = clickHandler[selector](el);
    }

    if (el) handleClick(el);
  };

  composerView.addEventListener('click', function (e) {
    handleClick(e.target);
  });

  var toggleEl = function toggleEl(el) {
    var isNode = el.parentNode.matches('.composer-node');
    var key = isNode ? 'isCollapsed' : 'isChildrenCollapsed';
    var collapsedClass = isNode ? 'composer-node--collapsed' : 'composer-node__children--collapsed';

    el.parentNode.classList.toggle(collapsedClass);

    var node = isNode ? _idMap.findById(el.parentNode.id) : find.containerElNode(el.parentNode);

    var isCollapsed = el.parentNode.matches('.composer-node--collapsed, .composer-node__children--collapsed');

    toggle(node, key, isCollapsed);
    updateNode(node);
  };

  var collapseElChildren = function collapseElChildren(el) {
    var containerElNode = find.containerElNode(el);
    var children = containerElNode.getChildren();

    children.forEach(function (node) {
      toggle(node, 'isCollapsed', true);
    });

    updateNode(containerElNode);
  };

  var expandElChildren = function expandElChildren(el) {
    var containerElNode = find.containerElNode(el);
    var children = containerElNode.getChildren();

    children.forEach(function (node) {
      toggle(node, 'isCollapsed', false);
    });

    updateNode(containerElNode);
  };

  var removeEl = function removeEl(el) {
    var nodeEl = el.closest('.composer-node');
    var id = nodeEl.id;
    var node = _idMap.findById(id);
    var parentNode = node.getParent();

    node.remove();
    /*
      It may seem as though by just removing the node, the parentNode will be
      regenerated correctly, however this is not the case sometimes, like when
      the node is the first child of the element. Not sure if problem with
      morphdom or if I've made some mistaken assumption somewhere, but in any
      case also removing the node's element representation from the DOM ensures
      that this works correctly. Not removing the DOM node and calling
      updateNode twice also works - go figure :/
    */
    nodeEl.remove();

    updateNode(parentNode);
  };

  var toggle = function toggle(node, key, isCollapsed) {
    node.meta(key, isCollapsed);
  };

  var updateNode = function updateNode(node) {
    var nodeEl = document.getElementById(node.id());
    var parentNode = node.getParent();

    var depth = 0;
    var parentEl = void 0;

    if (parentNode) {
      parentEl = document.getElementById(parentNode.id());
      depth = parentEl.dataset.depth * 1 + 1;
    }

    var newElDom = renderNode(node, { depth: depth });
    var newElHtml = newElDom.stringify();

    morphdom(nodeEl, newElHtml);
  };

  var _dropHandler = void 0;

  var ondrop = function ondrop() {
    if (_dropHandler) _dropHandler.apply(undefined, arguments);
  };

  var drakeDeps = { dragula: dragula, updateNode: updateNode, find: find, ondrop: ondrop };

  var drake = Drake(drakeDeps);

  var api = {
    remove: function remove() {
      return composerView.innerHTML = '';
    },
    tree: function tree() {
      return _tree;
    },
    idMap: function idMap() {
      return _idMap;
    },
    dropHandler: function dropHandler(handler) {
      if (typeof handler === 'function') _dropHandler = handler;

      return _dropHandler;
    }
  };

  return api;
};

module.exports = Composer;

},{"./drake":196,"./find":197,"./idmap":198,"dragula":96,"morphdom":162}],200:[function(require,module,exports){
'use strict';

var Composer = require('./composer');

require('./polyfills');

window.mojule = { Composer: Composer };

/*
TODO this is test code to get the composer up and running, needs to be init'ed
properly as and where needed
*/

//const Tree = require( '1tree' )
var TreeFactory = require('1tree-factory');

//in reality this would be implemented by the specific tree type, this is just a
//hack for testing
var isEmptyPlugin = function isEmptyPlugin(fn) {
  var isEmpty = function isEmpty(fn, node) {
    var value = fn.value(node);

    return value.nodeType === 'file' || value.nodeType === 'text';
  };

  isEmpty.def = fn.isEmpty.def;

  return Object.assign(fn, { isEmpty: isEmpty });
};

var Tree = TreeFactory(isEmptyPlugin);

var componentDependencies = require('../../dist/dependencies.json');
var RenderNode = require('../composer-tree/renderNode');
var renderNode = RenderNode(componentDependencies);

var treeRaw = componentDependencies.datas['data-small'];
var tree = Tree(treeRaw);

var composerApi = Composer(tree, renderNode);

},{"../../dist/dependencies.json":1,"../composer-tree/renderNode":207,"./composer":199,"./polyfills":201,"1tree-factory":3}],201:[function(require,module,exports){
'use strict';

(function (ElementProto) {
	if (typeof ElementProto.matches !== 'function') {
		ElementProto.matches = ElementProto.msMatchesSelector || ElementProto.mozMatchesSelector || ElementProto.webkitMatchesSelector || function matches(selector) {
			var element = this;
			var elements = (element.document || element.ownerDocument).querySelectorAll(selector);
			var index = 0;

			while (elements[index] && elements[index] !== element) {
				++index;
			}

			return Boolean(elements[index]);
		};
	}

	if (typeof ElementProto.closest !== 'function') {
		ElementProto.closest = function closest(selector) {
			var element = this;

			while (element && element.nodeType === 1) {
				if (element.matches(selector)) {
					return element;
				}

				element = element.parentNode;
			}

			return null;
		};
	}
})(window.Element.prototype);

},{}],202:[function(require,module,exports){
'use strict';

var RenderCss = function RenderCss(dependencies) {
  var styles = dependencies.styles;


  var renderCss = function renderCss(root) {
    var css = '';

    var alreadyAdded = new Set();

    root.walk(function (node) {
      var value = node.value();
      var componentName = value.name;

      if (alreadyAdded.has(componentName)) return;

      alreadyAdded.add(componentName);

      var style = styles[componentName];

      if (typeof style === 'string') {
        css += style;
        css += ' ';
      }
    });

    return css;
  };

  return renderCss;
};

module.exports = RenderCss;

},{}],203:[function(require,module,exports){
'use strict';

var Templates = require('../../templates');
var RenderCss = require('./renderCss');

var RenderNode = function RenderNode(dependencies) {
  var renderCss = RenderCss(dependencies);
  var configs = dependencies.configs;

  var _Templates = Templates(dependencies),
      renderComponent = _Templates.renderComponent;

  var defaultConfig = {
    containerSelector: "[data-container]"
  };

  var addCssToDocumentHead = function addCssToDocumentHead(node) {
    var value = node.value();
    var componentName = value.name;
    var componentModel = value.model;

    var css = renderCss(node);

    if (!Array.isArray(componentModel.headStyles)) componentModel.headStyles = [];

    componentModel.headStyles.push({
      text: css
    });

    node.value(value);
  };

  var renderNode = function renderNode(node) {
    var value = node.value();
    var componentName = value.name;
    var componentModel = value.model;

    if (componentName === 'document') {
      addCssToDocumentHead(node);
    }

    var dom = renderComponent(componentName, componentModel);
    var config = Object.assign({}, defaultConfig, configs[componentName]);
    var childContainer = dom.select(config.containerSelector);
    var children = node.getChildren();

    if (childContainer && children.length) {
      children.forEach(function (childNode) {
        var childDom = renderNode(childNode);

        if (childContainer.nodeName() === 'ul' || childContainer.nodeName() === 'ol') {
          /*
            dom.parse always returns a fragment, because the html string could
            contain multiple elements
              perhaps if we see it only has one element, we should return that
            rather than a documentFragment with a single child, but continue to
            use current behaviour if the fragment has multiple children?
          */
          var liNode = dom.parse('<li></li>').select('li');

          liNode.append(childDom);
          childContainer.append(liNode);

          return;
        }

        childContainer.append(childDom);
      });
    }

    return dom;
  };

  return renderNode;
};

module.exports = RenderNode;

},{"../../templates":208,"./renderCss":202}],204:[function(require,module,exports){
'use strict';

var treeSchema = require('1tree-schema');
var treeJson = require('1tree-json');
var transformMapper = require('mojule-transform');
var utils = require('mojule-utils');

var clone = utils.clone;


var mapComponents = function mapComponents(dependencies, componentName, model) {
  model = clone(model);

  var modelTree = treeJson.toTree(model);

  var componentNames = dependencies.componentNames,
      schemas = dependencies.schemas,
      transforms = dependencies.transforms;


  var schemaNames = Object.keys(schemas);

  var findRefComponents = function findRefComponents(schemaNode) {
    return schemaNode.findAll(function (n) {
      return componentNames.includes(n.value().$ref);
    });
  };

  var transform = transforms[componentName];
  var componentSchema = schemas[componentName];

  if (transform && !componentSchema) {
    return transformMapper(model, transform);
  }

  if (!transform && !componentSchema) {
    return model;
  }

  var componentSchemaTree = treeSchema.toTree(componentSchema);
  var refComponents = findRefComponents(componentSchemaTree);

  refComponents.forEach(function (refComponentNode) {
    var value = refComponentNode.value();
    var componentName = value.$ref;
    var componentTransform = transforms[componentName];

    if (!componentTransform) return;

    var refNodePath = treeSchema.pathFromNode(refComponentNode);
    var modelNode = treeJson.nodeFromPath(modelTree, refNodePath);

    if (!modelNode) return;

    var modelNodeValue = modelNode.value();

    if (value.arrayItem) {
      var modelArray = treeJson.toJson(modelNode);

      var transformed = modelArray.map(function (item) {
        return mapComponents(dependencies, componentName, item);
      });

      var transformedNode = treeJson.toTree(transformed);
      var modelNodeParent = modelNode.getParent();

      if (modelNodeValue.propertyName) {
        var transformedNodeValue = transformedNode.value();
        transformedNodeValue.propertyName = modelNodeValue.propertyName;
        transformedNode.value(transformedNodeValue);
      }

      modelNodeParent.replaceChild(transformedNode, modelNode);
    } else {
      throw new Error('Non arrayitem not implemented yet');
    }
  });

  model = treeJson.toJson(modelTree);

  if (transform) model = transformMapper(model, transform);

  return model;
};

module.exports = mapComponents;

},{"1tree-json":6,"1tree-schema":11,"mojule-transform":159,"mojule-utils":161}],205:[function(require,module,exports){
'use strict';

var Tree = require('1tree');
var nodeToModel = require('./defaultNodeToModel');

var defaultOptions = {
  depth: 0,
  createNode: Tree.createRoot,
  alwaysRenderChildren: false,
  nodeToModel: nodeToModel
};

var nodeToComposerNode = function nodeToComposerNode(node, options) {
  options = Object.assign({}, defaultOptions, options);

  var _options = options,
      depth = _options.depth,
      createNode = _options.createNode,
      nodeToModel = _options.nodeToModel,
      alwaysRenderChildren = _options.alwaysRenderChildren;


  var model = nodeToModel(node, { depth: depth });

  var value = {
    name: 'composer-node',
    model: model
  };

  var componentNode = createNode(value);

  var shouldRenderChildren = alwaysRenderChildren || !model.isChildrenCollapsed;

  if (shouldRenderChildren) {
    var children = node.getChildren();

    children.forEach(function (childNode) {
      var childOptions = Object.assign({}, options, {
        depth: depth + 1
      });

      var componentChildNode = nodeToComposerNode(childNode, childOptions);

      componentNode.append(componentChildNode);
    });
  }

  return componentNode;
};

module.exports = nodeToComposerNode;

},{"./defaultNodeToModel":206,"1tree":60}],206:[function(require,module,exports){
'use strict';

var _require = require('mojule-utils'),
    escapeHtml = _require.escapeHtml;

var defaultOptions = {
  depth: 0
};

var nodeToModel = function nodeToModel(node, options) {
  options = Object.assign({}, defaultOptions, options);

  var _options = options,
      depth = _options.depth;


  var value = node.value();
  var children = node.getChildren();

  var id = node.id();
  var name = value.name || '';
  var treeType = '1tree';
  var nodeType = node.nodeType();
  var title = depth + ': ' + name + ' ' + nodeType + ' [ ' + children.length + ' ]';
  var isEmpty = node.isEmpty();

  var isCollapsed = node.meta('isCollapsed');

  isCollapsed = typeof isCollapsed === 'boolean' ? isCollapsed : depth > 0;

  var isChildrenCollapsed = isCollapsed || !!node.meta('isChildrenCollapsed');

  var preview = escapeHtml(JSON.stringify(value));
  var childrenTitle = depth + ': children';

  var model = {
    id: id, title: title, treeType: treeType, nodeType: nodeType, depth: depth, isEmpty: isEmpty, isCollapsed: isCollapsed,
    isChildrenCollapsed: isChildrenCollapsed, preview: preview, childrenTitle: childrenTitle
  };

  return model;
};

module.exports = nodeToModel;

},{"mojule-utils":161}],207:[function(require,module,exports){
'use strict';

var Tree = require('1tree');
var nodeToModel = require('./defaultNodeToModel');
var nodeToComposerNode = require('./defaultNodeToComposerNode');
var ComponentRenderNode = require('../components/component-tree/renderNode');

var defaultOptions = {
  depth: 0,
  createNode: Tree.createRoot,
  nodeToModel: nodeToModel,
  nodeToComposerNode: nodeToComposerNode
};

var RenderNode = function RenderNode(dependencies) {
  var componentRenderNode = ComponentRenderNode(dependencies);

  var renderNode = function renderNode(node, options) {
    options = Object.assign({}, defaultOptions, options);

    var _options = options,
        nodeToModel = _options.nodeToModel,
        nodeToComposerNode = _options.nodeToComposerNode,
        depth = _options.depth,
        createNode = _options.createNode;


    var toComposerNodeOptions = { depth: depth, createNode: createNode, nodeToModel: nodeToModel };
    var composerNode = nodeToComposerNode(node, toComposerNodeOptions);
    var componentNode = componentRenderNode(composerNode);

    return componentNode;
  };

  return renderNode;
};

module.exports = RenderNode;

},{"../components/component-tree/renderNode":203,"./defaultNodeToComposerNode":205,"./defaultNodeToModel":206,"1tree":60}],208:[function(require,module,exports){
'use strict';

var Templating = require('mojule-templating');
var Validator = require('mtype-tv4');
var componentTransformMapper = require('../components/componentTransformMapper');

var ensureModel = function ensureModel(validator, model, name) {
  var schemaNames = validator.getSchemaUris();

  if (!schemaNames.includes(name)) return;

  var result = validator.validateMultiple(model, name);

  if (result.valid) return;

  var message = 'Template model validation failed for ' + name + ': ' + JSON.stringify(result.errors);
  throw new Error(message);
};

var Templates = function Templates(dependencies) {
  var components = dependencies.components,
      templates = dependencies.templates,
      defaultModels = dependencies.defaultModels,
      schemas = dependencies.schemas;


  var templating = Templating(templates);
  var validator = Validator(schemas);

  var renderComponent = function renderComponent(name, model) {
    var templateModel = Object.assign({}, defaultModels[name] || {}, model);

    ensureModel(validator, templateModel, name);

    var viewModel = componentTransformMapper(dependencies, name, templateModel);

    return templating(name, viewModel);
  };

  //TODO I believe that this doesn't need to use callbacks anymore
  var renderTemplate = function renderTemplate(name, model, callback) {
    try {
      var documentModel = Object.assign({}, defaultModels.document, model);

      if (name !== 'document') {
        var body = renderComponent(name, model).stringify();

        Object.assign(documentModel, { body: body });
      }

      ensureModel(validator, documentModel, 'document');

      var viewModel = componentTransformMapper(dependencies, 'document', documentModel);

      var dom = templating('document', viewModel);

      callback(null, dom);
    } catch (e) {
      callback(e);
    }
  };

  return { renderTemplate: renderTemplate, renderComponent: renderComponent };
};

module.exports = Templates;

},{"../components/componentTransformMapper":204,"mojule-templating":157,"mtype-tv4":171}]},{},[200])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2RlcGVuZGVuY2llcy5qc29uIiwibm9kZV9tb2R1bGVzLzF0cmVlLWZhY3RvcnkvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS1mYWN0b3J5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlLWpzb24vZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS1qc29uL2Rpc3QvcGF0aHMuanMiLCJub2RlX21vZHVsZXMvMXRyZWUtc2NoZW1hL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvMXRyZWUtc2NoZW1hL2Rpc3QvcGF0aHMuanMiLCJub2RlX21vZHVsZXMvMXRyZWUtc2NoZW1hL2Rpc3QvdG9Kc29uLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlLXNjaGVtYS9kaXN0L3RvVHJlZS5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS1zY2hlbWEvaW5kZXguanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9hZGFwdGVyL2RlZmF1bHQvY3JlYXRlTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2FkYXB0ZXIvZGVmYXVsdC9nZXRDaGlsZHJlbi5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2FkYXB0ZXIvZGVmYXVsdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2FkYXB0ZXIvZGVmYXVsdC9pbnNlcnRCZWZvcmUuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9hZGFwdGVyL2RlZmF1bHQvcmVtb3ZlLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvYWRhcHRlci9kZWZhdWx0L3ZhbHVlLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy9hZGFwdGVyL2NyZWF0ZU5vZGUuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL2FkYXB0ZXIvZ2V0Q2hpbGRyZW4uanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL2FkYXB0ZXIvaW5zZXJ0QmVmb3JlLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy9hZGFwdGVyL3JlbW92ZS5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2RlZnMvYWRhcHRlci92YWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2RlZnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL21hbmlwdWxhdGlvbi9hcHBlbmQuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL21hbmlwdWxhdGlvbi9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2RlZnMvbWFuaXB1bGF0aW9uL2luc2VydEFmdGVyLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy9tYW5pcHVsYXRpb24vaW5zZXJ0QXQuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL21hbmlwdWxhdGlvbi9wcmVwZW5kLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy9tYW5pcHVsYXRpb24vcmVtb3ZlQXQuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL21hbmlwdWxhdGlvbi9yZXBsYWNlQ2hpbGQuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL21hbmlwdWxhdGlvbi91bndyYXAuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL21hbmlwdWxhdGlvbi93cmFwLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy90cmF2ZXJzYWwvYW5jZXN0b3JzLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy90cmF2ZXJzYWwvY2hpbGRBdC5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2RlZnMvdHJhdmVyc2FsL2Nsb3Nlc3QuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL3RyYXZlcnNhbC9jb250YWlucy5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2RlZnMvdHJhdmVyc2FsL2Rlc2NlbmRlbnRzLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy90cmF2ZXJzYWwvZmluZC5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2RlZnMvdHJhdmVyc2FsL2ZpbmRBbGwuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL3RyYXZlcnNhbC9maXJzdENoaWxkLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy90cmF2ZXJzYWwvZ2V0UGFyZW50LmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy90cmF2ZXJzYWwvaGFzQ2hpbGRyZW4uanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL3RyYXZlcnNhbC9pc0VtcHR5LmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy90cmF2ZXJzYWwvbGFzdENoaWxkLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy90cmF2ZXJzYWwvbmV4dFNpYmxpbmcuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL3RyYXZlcnNhbC9wcmV2aW91c1NpYmxpbmcuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL3RyYXZlcnNhbC9zaWJsaW5ncy5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2RlZnMvdHJhdmVyc2FsL3dhbGsuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL3RyYXZlcnNhbC93YWxrVXAuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9mbi1mYWN0b3J5LmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9wbHVnaW5zL2FjY2VwdHMuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9wbHVnaW5zL2lkLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvcGx1Z2lucy9tZXRhLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvcGx1Z2lucy9ub2RlVHlwZS5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L3BsdWdpbnMvcGFyZW50LW1hcC5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L3BsdWdpbnMvc2VyaWFsaXplci5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L3BsdWdpbnMvd3JhcC1ub2Rlcy5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L3BvbHlmaWxscy5qcyIsIm5vZGVfbW9kdWxlcy9hdG9hL2F0b2EuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jvb2xiYXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXItc2hpbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbnRyYS9kZWJvdW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jb250cmEvZW1pdHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvY3Jvc3N2ZW50L3NyYy9jcm9zc3ZlbnQuanMiLCJub2RlX21vZHVsZXMvY3Jvc3N2ZW50L3NyYy9ldmVudG1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jc3Mtc2VsZWN0LWJhc2UtYWRhcHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jc3Mtc2VsZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Nzcy1zZWxlY3QvbGliL2F0dHJpYnV0ZXMuanMiLCJub2RlX21vZHVsZXMvY3NzLXNlbGVjdC9saWIvY29tcGlsZS5qcyIsIm5vZGVfbW9kdWxlcy9jc3Mtc2VsZWN0L2xpYi9nZW5lcmFsLmpzIiwibm9kZV9tb2R1bGVzL2Nzcy1zZWxlY3QvbGliL3Byb2NlZHVyZS5qc29uIiwibm9kZV9tb2R1bGVzL2Nzcy1zZWxlY3QvbGliL3BzZXVkb3MuanMiLCJub2RlX21vZHVsZXMvY3NzLXNlbGVjdC9saWIvc29ydC5qcyIsIm5vZGVfbW9kdWxlcy9jc3Mtd2hhdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jdXN0b20tZXZlbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZG9tLXNlcmlhbGl6ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZG9tLXNlcmlhbGl6ZXIvbm9kZV9tb2R1bGVzL2RvbWVsZW1lbnR0eXBlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RvbWVsZW1lbnR0eXBlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RvbWhhbmRsZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZG9taGFuZGxlci9saWIvZWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9kb21oYW5kbGVyL2xpYi9ub2RlLmpzIiwibm9kZV9tb2R1bGVzL2RvbXV0aWxzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi9sZWdhY3kuanMiLCJub2RlX21vZHVsZXMvZG9tdXRpbHMvbGliL21hbmlwdWxhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9kb211dGlscy9saWIvcXVlcnlpbmcuanMiLCJub2RlX21vZHVsZXMvZG9tdXRpbHMvbGliL3N0cmluZ2lmeS5qcyIsIm5vZGVfbW9kdWxlcy9kb211dGlscy9saWIvdHJhdmVyc2FsLmpzIiwibm9kZV9tb2R1bGVzL2RyYWd1bGEvY2xhc3Nlcy5qcyIsIm5vZGVfbW9kdWxlcy9kcmFndWxhL2RyYWd1bGEuanMiLCJub2RlX21vZHVsZXMvZW50aXRpZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZW50aXRpZXMvbGliL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZGVjb2RlX2NvZGVwb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL2VudGl0aWVzL21hcHMvZGVjb2RlLmpzb24iLCJub2RlX21vZHVsZXMvZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uIiwibm9kZV9tb2R1bGVzL2VudGl0aWVzL21hcHMvbGVnYWN5Lmpzb24iLCJub2RlX21vZHVsZXMvZW50aXRpZXMvbWFwcy94bWwuanNvbiIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2hpbmZvL2RhdGEvZWxlbWVudHMuanNvbiIsIm5vZGVfbW9kdWxlcy9oaW5mby9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hpbmZvL3NjaGVtYS9oaW5mby5zY2hlbWEuanNvbiIsIm5vZGVfbW9kdWxlcy9odG1sLW5vZGUvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9odG1scGFyc2VyMi9saWIvQ29sbGVjdGluZ0hhbmRsZXIuanMiLCJub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbGliL0ZlZWRIYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL2xpYi9QYXJzZXIuanMiLCJub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbGliL1Byb3h5SGFuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9odG1scGFyc2VyMi9saWIvU3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL2xpYi9Ub2tlbml6ZXIuanMiLCJub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbGliL1dyaXRhYmxlU3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vZGlzdC9wYXJzZS9kb21oYW5kbGVyLWFkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9kaXN0L3BhcnNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vZGlzdC9wbHVnaW5zL2NyZWF0ZVRyZWUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9kaXN0L3BsdWdpbnMvZG9tL2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL2Rpc3QvcGx1Z2lucy9kb20vZWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL2Rpc3QvcGx1Z2lucy9kb20vaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9kaXN0L3BsdWdpbnMvZG9tL25vZGUuanMiLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9kaXN0L3BsdWdpbnMvaW5zZXJ0QmVmb3JlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vZGlzdC9wbHVnaW5zL3BhcnNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vZGlzdC9wbHVnaW5zL3NlbGVjdC9odG1scGFyc2VyMi1hZGFwdGVyLmpzIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vZGlzdC9wbHVnaW5zL3NlbGVjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL2Rpc3QvcGx1Z2lucy9zdHJpbmdpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9kaXN0L3BsdWdpbnMvdHlwZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9kaXN0L3BsdWdpbnMvdmRvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL2Rpc3Qvc2NoZW1hL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vZGlzdC9zZWxlY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9kaXN0L3N0cmluZ2lmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL2Rpc3QvdmRvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL3NjaGVtYS9jb21tZW50LnNjaGVtYS5qc29uIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vc2NoZW1hL2NvbW1lbnRWYWx1ZS5zY2hlbWEuanNvbiIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL3NjaGVtYS9kb2N1bWVudC5zY2hlbWEuanNvbiIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL3NjaGVtYS9kb2N1bWVudEZyYWdtZW50LnNjaGVtYS5qc29uIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vc2NoZW1hL2RvY3VtZW50RnJhZ21lbnRWYWx1ZS5zY2hlbWEuanNvbiIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL3NjaGVtYS9kb2N1bWVudFR5cGUuanNvbiIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL3NjaGVtYS9kb2N1bWVudFR5cGVWYWx1ZS5zY2hlbWEuanNvbiIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL3NjaGVtYS9kb2N1bWVudFZhbHVlLnNjaGVtYS5qc29uIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vc2NoZW1hL2VsZW1lbnQuc2NoZW1hLmpzb24iLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9zY2hlbWEvZWxlbWVudFZhbHVlLnNjaGVtYS5qc29uIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vc2NoZW1hL3RleHQuc2NoZW1hLmpzb24iLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9zY2hlbWEvdGV4dFZhbHVlLnNjaGVtYS5qc29uIiwibm9kZV9tb2R1bGVzL21vanVsZS10ZW1wbGF0aW5nL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9qdWxlLXRyYW5zZm9ybS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vanVsZS11dGlscy9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vcnBoZG9tL2Rpc3QvbW9ycGhkb20uanMiLCJub2RlX21vZHVsZXMvbXR5cGUtbm9kZS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL210eXBlLW5vZGUvZGlzdC9zY2hlbWEuanMiLCJub2RlX21vZHVsZXMvbXR5cGUtbm9kZS9zY2hlbWEvZW1wdHlOb2RlLnNjaGVtYS5qc29uIiwibm9kZV9tb2R1bGVzL210eXBlLW5vZGUvc2NoZW1hL2VudGl0eU5vZGUuc2NoZW1hLmpzb24iLCJub2RlX21vZHVsZXMvbXR5cGUtbm9kZS9zY2hlbWEvZW50aXR5Tm9kZVZhbHVlLnNjaGVtYS5qc29uIiwibm9kZV9tb2R1bGVzL210eXBlLW5vZGUvc2NoZW1hL3BhcmVudE5vZGUuc2NoZW1hLmpzb24iLCJub2RlX21vZHVsZXMvbXR5cGUtdHY0L2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXR5cGUvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tdHlwZS9kaXN0L2pzb24tcHJlZGljYXRlcy5qcyIsIm5vZGVfbW9kdWxlcy9udGgtY2hlY2svY29tcGlsZS5qcyIsIm5vZGVfbW9kdWxlcy9udGgtY2hlY2svaW5kZXguanMiLCJub2RlX21vZHVsZXMvbnRoLWNoZWNrL3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RpY2t5L3RpY2t5LWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdHY0L3R2NC5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwic3JjXFxjbGllbnRcXGNvbXBvc2VyXFxkcmFrZS5qcyIsInNyY1xcY2xpZW50XFxjb21wb3NlclxcZmluZC5qcyIsInNyY1xcY2xpZW50XFxjb21wb3NlclxcaWRtYXAuanMiLCJzcmNcXGNsaWVudFxcY29tcG9zZXJcXGluZGV4LmpzIiwic3JjXFxjbGllbnRcXGluZGV4LmpzIiwic3JjXFxjbGllbnRcXHBvbHlmaWxscy5qcyIsInNyY1xcY29tcG9uZW50c1xcY29tcG9uZW50LXRyZWVcXHJlbmRlckNzcy5qcyIsInNyY1xcY29tcG9uZW50c1xcY29tcG9uZW50LXRyZWVcXHJlbmRlck5vZGUuanMiLCJzcmNcXGNvbXBvbmVudHNcXGNvbXBvbmVudFRyYW5zZm9ybU1hcHBlci5qcyIsInNyY1xcY29tcG9zZXItdHJlZVxcZGVmYXVsdE5vZGVUb0NvbXBvc2VyTm9kZS5qcyIsInNyY1xcY29tcG9zZXItdHJlZVxcZGVmYXVsdE5vZGVUb01vZGVsLmpzIiwic3JjXFxjb21wb3Nlci10cmVlXFxyZW5kZXJOb2RlLmpzIiwic3JjXFx0ZW1wbGF0ZXNcXGluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqQ0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3dkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaG1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBOztBQ0FBOztBQ0FBOztBQ0FBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ppQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoQkE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25FQTs7QUFFQTs7QUFDQSxJQUFNLFFBQVEsU0FBUixLQUFRLE9BQVE7QUFDcEIsTUFBTSxnQkFBZ0Isc0RBQXRCO0FBQ0EsTUFBTSxvQkFBb0IsOEJBQTFCO0FBRm9CLE1BR1osVUFIWSxHQUcwQixJQUgxQixDQUdaLFVBSFk7QUFBQSxNQUdBLE9BSEEsR0FHMEIsSUFIMUIsQ0FHQSxPQUhBO0FBQUEsTUFHUyxJQUhULEdBRzBCLElBSDFCLENBR1MsSUFIVDtBQUFBLE1BR2UsTUFIZixHQUcwQixJQUgxQixDQUdlLE1BSGY7OztBQUtwQixNQUFNLGNBQWMsU0FBZCxXQUFjO0FBQUEsV0FBTSxHQUFHLE9BQUgsQ0FBWSxpQkFBWixDQUFOO0FBQUEsR0FBcEI7O0FBRUEsTUFBTSxVQUFVLGlCQUFFLEVBQUYsRUFBTSxXQUFOLEVBQXVCO0FBQ3JDLFFBQUksVUFBVSxZQUFZLE9BQVosQ0FBcUIsaUJBQXJCLENBQWQ7O0FBRUEsUUFBSSxPQUFKLEVBQWE7QUFDWCxnQkFBVSxDQUFDLFlBQVksT0FBWixDQUFxQixhQUFyQixDQUFYO0FBQ0Q7O0FBRUQsUUFBSSxPQUFKLEVBQWE7QUFDWCxVQUFNLE9BQU8sS0FBSyxNQUFMLENBQWEsRUFBYixDQUFiO0FBQ0EsVUFBTSxhQUFhLEtBQUssZUFBTCxDQUFzQixXQUF0QixDQUFuQjs7QUFFQSxVQUFJLFNBQVMsVUFBYixFQUEwQixPQUFPLEtBQVA7O0FBRTFCLGdCQUFVLFdBQVcsT0FBWCxDQUFvQixJQUFwQixDQUFWO0FBQ0Q7O0FBRUQsV0FBTyxPQUFQO0FBQ0QsR0FqQkQ7O0FBbUJBLE1BQU0sVUFBVSxFQUFFLHdCQUFGLEVBQWUsZ0JBQWYsRUFBaEI7O0FBRUEsTUFBTSxRQUFRLFFBQVMsT0FBVCxDQUFkOztBQUVBLFFBQU0sRUFBTixDQUFVLE1BQVYsRUFBa0IsVUFBRSxFQUFGLEVBQU0sV0FBTixFQUFtQixpQkFBbkIsRUFBc0MsTUFBdEMsRUFBa0Q7QUFDbEUsUUFBTSxPQUFPLEtBQUssTUFBTCxDQUFhLEVBQWIsQ0FBYjtBQUNBLFFBQU0sYUFBYSxLQUFLLGVBQUwsQ0FBc0IsV0FBdEIsQ0FBbkI7O0FBRUEsUUFBSSxNQUFKLEVBQVk7QUFDVixVQUFNLGdCQUFnQixLQUFLLE1BQUwsQ0FBYSxNQUFiLENBQXRCO0FBQ0EsaUJBQVcsWUFBWCxDQUF5QixJQUF6QixFQUErQixhQUEvQjtBQUNELEtBSEQsTUFHTztBQUNMLGlCQUFXLE1BQVgsQ0FBbUIsSUFBbkI7QUFDRDs7QUFFRCxlQUFZLElBQVo7O0FBRUEsV0FBUSxJQUFSLEVBQWMsVUFBZCxFQUEwQixFQUExQixFQUE4QixXQUE5QixFQUEyQyxpQkFBM0MsRUFBOEQsTUFBOUQ7QUFDRCxHQWREOztBQWdCQSxTQUFPLEtBQVA7QUFDRCxDQS9DRDs7QUFpREEsT0FBTyxPQUFQLEdBQWlCLEtBQWpCOzs7QUNwREE7O0FBRUE7O0FBQ0EsSUFBTSxPQUFPLFNBQVAsSUFBTyxRQUFTO0FBQ3BCLE1BQU0sU0FBUyxTQUFULE1BQVM7QUFBQSxXQUFNLEdBQUcsYUFBSCxDQUFrQixnQkFBbEIsQ0FBTjtBQUFBLEdBQWY7QUFDQSxNQUFNLGNBQWMsU0FBZCxXQUFjO0FBQUEsV0FBTSxHQUFHLE9BQUgsQ0FBWSxnQkFBWixDQUFOO0FBQUEsR0FBcEI7QUFDQSxNQUFNLFNBQVMsU0FBVCxNQUFTO0FBQUEsV0FBTSxNQUFNLFFBQU4sQ0FBZ0IsT0FBUSxFQUFSLEVBQWEsRUFBN0IsQ0FBTjtBQUFBLEdBQWY7QUFDQSxNQUFNLGtCQUFrQixTQUFsQixlQUFrQjtBQUFBLFdBQU0sTUFBTSxRQUFOLENBQWdCLFlBQWEsRUFBYixFQUFrQixFQUFsQyxDQUFOO0FBQUEsR0FBeEI7O0FBRUEsU0FBTyxFQUFFLGNBQUYsRUFBVSx3QkFBVixFQUF1QixjQUF2QixFQUErQixnQ0FBL0IsRUFBUDtBQUNELENBUEQ7O0FBU0EsT0FBTyxPQUFQLEdBQWlCLElBQWpCOzs7QUNaQTs7QUFFQTs7Ozs7QUFJQSxJQUFNLFFBQVEsU0FBUixLQUFRLE9BQVE7QUFDcEIsTUFBTSxRQUFRLElBQUksR0FBSixFQUFkOztBQUVBLE1BQU0sV0FBVyxTQUFYLFFBQVcsS0FBTTtBQUNyQixRQUFJLE1BQU0sR0FBTixDQUFXLEVBQVgsQ0FBSixFQUFzQixPQUFPLE1BQU0sR0FBTixDQUFXLEVBQVgsQ0FBUDs7QUFFdEIsUUFBTSxPQUFPLEtBQUssSUFBTCxDQUFXO0FBQUEsYUFBSyxFQUFFLEVBQUYsT0FBVyxFQUFoQjtBQUFBLEtBQVgsQ0FBYjs7QUFFQSxVQUFNLEdBQU4sQ0FBVyxFQUFYLEVBQWUsSUFBZjs7QUFFQSxXQUFPLElBQVA7QUFDRCxHQVJEOztBQVVBLE1BQU0sVUFBVSxTQUFWLE9BQVUsT0FBUTtBQUN0QixTQUFLLElBQUwsQ0FBVztBQUFBLGFBQUssTUFBTSxHQUFOLENBQVcsRUFBRSxFQUFGLEVBQVgsRUFBbUIsQ0FBbkIsQ0FBTDtBQUFBLEtBQVg7QUFDRCxHQUZEOztBQUlBLFVBQVMsSUFBVDs7QUFFQSxTQUFPLE9BQU8sTUFBUCxDQUFlLEtBQWYsRUFBc0IsRUFBRSxrQkFBRixFQUFZLGdCQUFaLEVBQXRCLENBQVA7QUFDRCxDQXBCRDs7QUFzQkEsT0FBTyxPQUFQLEdBQWlCLEtBQWpCOzs7QUM1QkE7Ozs7QUFFQSxJQUFNLFVBQVUsUUFBUyxTQUFULENBQWhCO0FBQ0EsSUFBTSxXQUFXLFFBQVMsVUFBVCxDQUFqQjtBQUNBLElBQU0sUUFBUSxRQUFTLFNBQVQsQ0FBZDtBQUNBLElBQU0sUUFBUSxRQUFTLFNBQVQsQ0FBZDtBQUNBLElBQU0sT0FBTyxRQUFTLFFBQVQsQ0FBYjs7QUFFQSxJQUFNLGlCQUFpQjtBQUNyQixZQUFVLE9BQU8sTUFBUCxLQUFrQixXQUFsQixHQUFnQyxJQUFoQyxHQUF1QyxPQUFPLFFBRG5DO0FBRXJCLGtCQUZxQjtBQUdyQixvQkFIcUI7QUFJckIsWUFBVTtBQUpXLENBQXZCOztBQU9BLElBQU0sY0FBYyxTQUFkLFdBQWMsQ0FBRSxHQUFGLEVBQU8sSUFBUCxFQUFhLFFBQWIsRUFBMkI7QUFDN0MsTUFBSSxRQUFPLEdBQVAseUNBQU8sR0FBUCxPQUFlLFFBQW5CLEVBQ0UsTUFBTSxJQUFJLEtBQUosUUFBaUIsSUFBakIsU0FBMkIsUUFBM0Isa0JBQU47QUFDSCxDQUhEOztBQUtBOzs7Ozs7Ozs7QUFTQSxJQUFNLFdBQVcsU0FBWCxRQUFXLENBQUUsS0FBRixFQUFRLFVBQVIsRUFBb0IsT0FBcEIsRUFBaUM7QUFDaEQsWUFBVSxPQUFPLE1BQVAsQ0FBZSxFQUFmLEVBQW1CLGNBQW5CLEVBQW1DLE9BQW5DLENBQVY7O0FBRGdELGlCQUdFLE9BSEY7QUFBQSxNQUd4QyxRQUh3QyxZQUd4QyxRQUh3QztBQUFBLE1BRzlCLE9BSDhCLFlBRzlCLE9BSDhCO0FBQUEsTUFHckIsUUFIcUIsWUFHckIsUUFIcUI7QUFBQSxNQUdYLFFBSFcsWUFHWCxRQUhXOzs7QUFLaEQsY0FBYSxRQUFiLEVBQXVCLFVBQXZCLEVBQW1DLFFBQW5DO0FBQ0EsY0FBYSxVQUFiLEVBQXlCLFlBQXpCLEVBQXVDLFVBQXZDO0FBQ0EsY0FBYSxRQUFiLEVBQXVCLFVBQXZCLEVBQW1DLFFBQW5DOztBQUVBLE1BQU0sU0FBUSxNQUFPLEtBQVAsQ0FBZDtBQUNBLE1BQU0sT0FBTyxLQUFNLE1BQU4sQ0FBYjs7QUFFQSxNQUFNLGVBQWUsU0FBUyxhQUFULENBQXdCLFFBQXhCLENBQXJCOztBQUVBLE1BQU0sYUFBYSxXQUFZLEtBQVosQ0FBbkI7O0FBRUEsV0FBVSxZQUFWLEVBQXdCLFdBQVcsU0FBWCxFQUF4Qjs7QUFFQTs7Ozs7QUFLQSxNQUFNLGVBQWU7QUFDbkIseURBQ0U7QUFBQSxhQUFNLEdBQUcsVUFBVDtBQUFBLEtBRmlCOztBQUluQiwrQkFBMkIsbUNBQU07QUFDL0IsZUFBVSxFQUFWO0FBQ0QsS0FOa0I7O0FBUW5CLDhCQUEwQixrQ0FBTTtBQUM5QixVQUFNLGVBQWUsT0FBTyxPQUFQLENBQWdCLGVBQWhCLENBQXJCOztBQUVBLFVBQUksWUFBSixFQUNFLFNBQVUsRUFBVjtBQUNILEtBYmtCOztBQWVuQix5Q0FBcUMsNENBQU07QUFDekMseUJBQW9CLEVBQXBCO0FBQ0QsS0FqQmtCOztBQW1CbkIsdUNBQW1DLDBDQUFNO0FBQ3ZDLHVCQUFrQixFQUFsQjtBQUNEO0FBckJrQixHQUFyQjs7QUF3QkEsTUFBTSxpQkFBaUIsT0FBTyxJQUFQLENBQWEsWUFBYixDQUF2Qjs7QUFFQSxNQUFNLGNBQWMsU0FBZCxXQUFjLEtBQU07QUFDeEIsUUFBTSxXQUFXLGVBQWUsSUFBZixDQUFxQjtBQUFBLGFBQU8sR0FBRyxPQUFILENBQVksR0FBWixDQUFQO0FBQUEsS0FBckIsQ0FBakI7O0FBRUEsUUFBSSxRQUFKLEVBQWM7QUFDWixXQUFLLGFBQWMsUUFBZCxFQUEwQixFQUExQixDQUFMO0FBQ0Q7O0FBRUQsUUFBSSxFQUFKLEVBQ0UsWUFBYSxFQUFiO0FBQ0gsR0FURDs7QUFXQSxlQUFhLGdCQUFiLENBQStCLE9BQS9CLEVBQXdDLGFBQUs7QUFDM0MsZ0JBQWEsRUFBRSxNQUFmO0FBQ0QsR0FGRDs7QUFJQSxNQUFNLFdBQVcsU0FBWCxRQUFXLEtBQU07QUFDckIsUUFBTSxTQUFTLEdBQUcsVUFBSCxDQUFjLE9BQWQsQ0FBdUIsZ0JBQXZCLENBQWY7QUFDQSxRQUFNLE1BQU0sU0FBUyxhQUFULEdBQXlCLHFCQUFyQztBQUNBLFFBQU0saUJBQWlCLFNBQVMsMEJBQVQsR0FBc0Msb0NBQTdEOztBQUVBLE9BQUcsVUFBSCxDQUFjLFNBQWQsQ0FBd0IsTUFBeEIsQ0FBZ0MsY0FBaEM7O0FBRUEsUUFBTSxPQUFPLFNBQ1gsT0FBTSxRQUFOLENBQWdCLEdBQUcsVUFBSCxDQUFjLEVBQTlCLENBRFcsR0FFWCxLQUFLLGVBQUwsQ0FBc0IsR0FBRyxVQUF6QixDQUZGOztBQUlBLFFBQU0sY0FBYyxHQUFHLFVBQUgsQ0FBYyxPQUFkLENBQXVCLGdFQUF2QixDQUFwQjs7QUFFQSxXQUFRLElBQVIsRUFBYyxHQUFkLEVBQW1CLFdBQW5CO0FBQ0EsZUFBWSxJQUFaO0FBQ0QsR0FmRDs7QUFpQkEsTUFBTSxxQkFBcUIsU0FBckIsa0JBQXFCLEtBQU07QUFDL0IsUUFBTSxrQkFBa0IsS0FBSyxlQUFMLENBQXNCLEVBQXRCLENBQXhCO0FBQ0EsUUFBTSxXQUFXLGdCQUFnQixXQUFoQixFQUFqQjs7QUFFQSxhQUFTLE9BQVQsQ0FBa0IsZ0JBQVE7QUFDeEIsYUFBUSxJQUFSLEVBQWMsYUFBZCxFQUE2QixJQUE3QjtBQUNELEtBRkQ7O0FBSUEsZUFBWSxlQUFaO0FBQ0QsR0FURDs7QUFXQSxNQUFNLG1CQUFtQixTQUFuQixnQkFBbUIsS0FBTTtBQUM3QixRQUFNLGtCQUFrQixLQUFLLGVBQUwsQ0FBc0IsRUFBdEIsQ0FBeEI7QUFDQSxRQUFNLFdBQVcsZ0JBQWdCLFdBQWhCLEVBQWpCOztBQUVBLGFBQVMsT0FBVCxDQUFrQixnQkFBUTtBQUN4QixhQUFRLElBQVIsRUFBYyxhQUFkLEVBQTZCLEtBQTdCO0FBQ0QsS0FGRDs7QUFJQSxlQUFZLGVBQVo7QUFDRCxHQVREOztBQVdBLE1BQU0sV0FBVyxTQUFYLFFBQVcsS0FBTTtBQUNyQixRQUFNLFNBQVMsR0FBRyxPQUFILENBQVksZ0JBQVosQ0FBZjtBQUNBLFFBQU0sS0FBSyxPQUFPLEVBQWxCO0FBQ0EsUUFBTSxPQUFPLE9BQU0sUUFBTixDQUFnQixFQUFoQixDQUFiO0FBQ0EsUUFBTSxhQUFhLEtBQUssU0FBTCxFQUFuQjs7QUFFQSxTQUFLLE1BQUw7QUFDQTs7Ozs7Ozs7O0FBU0EsV0FBTyxNQUFQOztBQUVBLGVBQVksVUFBWjtBQUNELEdBbkJEOztBQXFCQSxNQUFNLFNBQVMsU0FBVCxNQUFTLENBQUUsSUFBRixFQUFRLEdBQVIsRUFBYSxXQUFiLEVBQThCO0FBQzNDLFNBQUssSUFBTCxDQUFXLEdBQVgsRUFBZ0IsV0FBaEI7QUFDRCxHQUZEOztBQUlBLE1BQU0sYUFBYSxTQUFiLFVBQWEsT0FBUTtBQUN6QixRQUFNLFNBQVMsU0FBUyxjQUFULENBQXlCLEtBQUssRUFBTCxFQUF6QixDQUFmO0FBQ0EsUUFBTSxhQUFhLEtBQUssU0FBTCxFQUFuQjs7QUFFQSxRQUFJLFFBQVEsQ0FBWjtBQUNBLFFBQUksaUJBQUo7O0FBRUEsUUFBSSxVQUFKLEVBQWdCO0FBQ2QsaUJBQVcsU0FBUyxjQUFULENBQXlCLFdBQVcsRUFBWCxFQUF6QixDQUFYO0FBQ0EsY0FBUSxTQUFTLE9BQVQsQ0FBaUIsS0FBakIsR0FBeUIsQ0FBekIsR0FBNkIsQ0FBckM7QUFDRDs7QUFFRCxRQUFNLFdBQVcsV0FBWSxJQUFaLEVBQWtCLEVBQUUsWUFBRixFQUFsQixDQUFqQjtBQUNBLFFBQU0sWUFBWSxTQUFTLFNBQVQsRUFBbEI7O0FBRUEsYUFBVSxNQUFWLEVBQWtCLFNBQWxCO0FBQ0QsR0FoQkQ7O0FBa0JBLE1BQUkscUJBQUo7O0FBRUEsTUFBTSxTQUFTLFNBQVQsTUFBUyxHQUFlO0FBQzVCLFFBQUksWUFBSixFQUFrQjtBQUNuQixHQUZEOztBQUlBLE1BQU0sWUFBWSxFQUFFLGdCQUFGLEVBQVcsc0JBQVgsRUFBdUIsVUFBdkIsRUFBNkIsY0FBN0IsRUFBbEI7O0FBRUEsTUFBTSxRQUFRLE1BQU8sU0FBUCxDQUFkOztBQUVBLE1BQU0sTUFBTTtBQUNWLFlBQVE7QUFBQSxhQUFNLGFBQWEsU0FBYixHQUF5QixFQUEvQjtBQUFBLEtBREU7QUFFVixVQUFNO0FBQUEsYUFBTSxLQUFOO0FBQUEsS0FGSTtBQUdWLFdBQU87QUFBQSxhQUFNLE1BQU47QUFBQSxLQUhHO0FBSVYsaUJBQWEsOEJBQVc7QUFDdEIsVUFBSSxPQUFPLE9BQVAsS0FBbUIsVUFBdkIsRUFDRSxlQUFjLE9BQWQ7O0FBRUYsYUFBTyxZQUFQO0FBQ0Q7QUFUUyxHQUFaOztBQVlBLFNBQU8sR0FBUDtBQUNELENBektEOztBQTJLQSxPQUFPLE9BQVAsR0FBaUIsUUFBakI7OztBQ3hNQTs7QUFFQSxJQUFNLFdBQVcsUUFBUyxZQUFULENBQWpCOztBQUVBLFFBQVMsYUFBVDs7QUFFQSxPQUFPLE1BQVAsR0FBZ0IsRUFBRSxrQkFBRixFQUFoQjs7QUFFQTs7Ozs7QUFLQTtBQUNBLElBQU0sY0FBYyxRQUFTLGVBQVQsQ0FBcEI7O0FBRUE7QUFDQTtBQUNBLElBQU0sZ0JBQWdCLFNBQWhCLGFBQWdCLEtBQU07QUFDMUIsTUFBTSxVQUFVLFNBQVYsT0FBVSxDQUFFLEVBQUYsRUFBTSxJQUFOLEVBQWdCO0FBQzlCLFFBQU0sUUFBUSxHQUFHLEtBQUgsQ0FBVSxJQUFWLENBQWQ7O0FBRUEsV0FBTyxNQUFNLFFBQU4sS0FBbUIsTUFBbkIsSUFBNkIsTUFBTSxRQUFOLEtBQW1CLE1BQXZEO0FBQ0QsR0FKRDs7QUFNQSxVQUFRLEdBQVIsR0FBYyxHQUFHLE9BQUgsQ0FBVyxHQUF6Qjs7QUFFQSxTQUFPLE9BQU8sTUFBUCxDQUFlLEVBQWYsRUFBbUIsRUFBRSxnQkFBRixFQUFuQixDQUFQO0FBQ0QsQ0FWRDs7QUFZQSxJQUFNLE9BQU8sWUFBYSxhQUFiLENBQWI7O0FBRUEsSUFBTSx3QkFBd0IsUUFBUyw4QkFBVCxDQUE5QjtBQUNBLElBQU0sYUFBYSxRQUFTLDZCQUFULENBQW5CO0FBQ0EsSUFBTSxhQUFhLFdBQVkscUJBQVosQ0FBbkI7O0FBRUEsSUFBTSxVQUFVLHNCQUFzQixLQUF0QixDQUE2QixZQUE3QixDQUFoQjtBQUNBLElBQU0sT0FBTyxLQUFNLE9BQU4sQ0FBYjs7QUFFQSxJQUFNLGNBQWMsU0FBVSxJQUFWLEVBQWdCLFVBQWhCLENBQXBCOzs7OztBQ3ZDQSxDQUFDLFVBQVUsWUFBVixFQUF3QjtBQUN4QixLQUFJLE9BQU8sYUFBYSxPQUFwQixLQUFnQyxVQUFwQyxFQUFnRDtBQUMvQyxlQUFhLE9BQWIsR0FBdUIsYUFBYSxpQkFBYixJQUFrQyxhQUFhLGtCQUEvQyxJQUFxRSxhQUFhLHFCQUFsRixJQUEyRyxTQUFTLE9BQVQsQ0FBaUIsUUFBakIsRUFBMkI7QUFDNUosT0FBSSxVQUFVLElBQWQ7QUFDQSxPQUFJLFdBQVcsQ0FBQyxRQUFRLFFBQVIsSUFBb0IsUUFBUSxhQUE3QixFQUE0QyxnQkFBNUMsQ0FBNkQsUUFBN0QsQ0FBZjtBQUNBLE9BQUksUUFBUSxDQUFaOztBQUVBLFVBQU8sU0FBUyxLQUFULEtBQW1CLFNBQVMsS0FBVCxNQUFvQixPQUE5QyxFQUF1RDtBQUN0RCxNQUFFLEtBQUY7QUFDQTs7QUFFRCxVQUFPLFFBQVEsU0FBUyxLQUFULENBQVIsQ0FBUDtBQUNBLEdBVkQ7QUFXQTs7QUFFRCxLQUFJLE9BQU8sYUFBYSxPQUFwQixLQUFnQyxVQUFwQyxFQUFnRDtBQUMvQyxlQUFhLE9BQWIsR0FBdUIsU0FBUyxPQUFULENBQWlCLFFBQWpCLEVBQTJCO0FBQ2pELE9BQUksVUFBVSxJQUFkOztBQUVBLFVBQU8sV0FBVyxRQUFRLFFBQVIsS0FBcUIsQ0FBdkMsRUFBMEM7QUFDekMsUUFBSSxRQUFRLE9BQVIsQ0FBZ0IsUUFBaEIsQ0FBSixFQUErQjtBQUM5QixZQUFPLE9BQVA7QUFDQTs7QUFFRCxjQUFVLFFBQVEsVUFBbEI7QUFDQTs7QUFFRCxVQUFPLElBQVA7QUFDQSxHQVpEO0FBYUE7QUFDRCxDQTlCRCxFQThCRyxPQUFPLE9BQVAsQ0FBZSxTQTlCbEI7OztBQ0FBOztBQUVBLElBQU0sWUFBWSxTQUFaLFNBQVksZUFBZ0I7QUFBQSxNQUN4QixNQUR3QixHQUNiLFlBRGEsQ0FDeEIsTUFEd0I7OztBQUdoQyxNQUFNLFlBQVksU0FBWixTQUFZLE9BQVE7QUFDeEIsUUFBSSxNQUFNLEVBQVY7O0FBRUEsUUFBTSxlQUFlLElBQUksR0FBSixFQUFyQjs7QUFFQSxTQUFLLElBQUwsQ0FBVyxnQkFBUTtBQUNqQixVQUFNLFFBQVEsS0FBSyxLQUFMLEVBQWQ7QUFDQSxVQUFNLGdCQUFnQixNQUFNLElBQTVCOztBQUVBLFVBQUksYUFBYSxHQUFiLENBQWtCLGFBQWxCLENBQUosRUFDRTs7QUFFRixtQkFBYSxHQUFiLENBQWtCLGFBQWxCOztBQUVBLFVBQU0sUUFBUSxPQUFRLGFBQVIsQ0FBZDs7QUFFQSxVQUFJLE9BQU8sS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QixlQUFPLEtBQVA7QUFDQSxlQUFPLEdBQVA7QUFDRDtBQUNGLEtBZkQ7O0FBaUJBLFdBQU8sR0FBUDtBQUNELEdBdkJEOztBQXlCQSxTQUFPLFNBQVA7QUFDRCxDQTdCRDs7QUErQkEsT0FBTyxPQUFQLEdBQWlCLFNBQWpCOzs7QUNqQ0E7O0FBRUEsSUFBTSxZQUFZLFFBQVMsaUJBQVQsQ0FBbEI7QUFDQSxJQUFNLFlBQVksUUFBUyxhQUFULENBQWxCOztBQUVBLElBQU0sYUFBYSxTQUFiLFVBQWEsZUFBZ0I7QUFDakMsTUFBTSxZQUFZLFVBQVcsWUFBWCxDQUFsQjtBQURpQyxNQUV6QixPQUZ5QixHQUViLFlBRmEsQ0FFekIsT0FGeUI7O0FBQUEsbUJBR0wsVUFBVyxZQUFYLENBSEs7QUFBQSxNQUd6QixlQUh5QixjQUd6QixlQUh5Qjs7QUFLakMsTUFBTSxnQkFBZ0I7QUFDcEIsdUJBQW1CO0FBREMsR0FBdEI7O0FBSUEsTUFBTSx1QkFBdUIsU0FBdkIsb0JBQXVCLE9BQVE7QUFDbkMsUUFBTSxRQUFRLEtBQUssS0FBTCxFQUFkO0FBQ0EsUUFBTSxnQkFBZ0IsTUFBTSxJQUE1QjtBQUNBLFFBQU0saUJBQWlCLE1BQU0sS0FBN0I7O0FBRUEsUUFBTSxNQUFNLFVBQVcsSUFBWCxDQUFaOztBQUVBLFFBQUksQ0FBQyxNQUFNLE9BQU4sQ0FBZSxlQUFlLFVBQTlCLENBQUwsRUFDRSxlQUFlLFVBQWYsR0FBNEIsRUFBNUI7O0FBRUYsbUJBQWUsVUFBZixDQUEwQixJQUExQixDQUErQjtBQUM3QixZQUFNO0FBRHVCLEtBQS9COztBQUlBLFNBQUssS0FBTCxDQUFZLEtBQVo7QUFDRCxHQWZEOztBQWlCQSxNQUFNLGFBQWEsU0FBYixVQUFhLE9BQVE7QUFDekIsUUFBTSxRQUFRLEtBQUssS0FBTCxFQUFkO0FBQ0EsUUFBTSxnQkFBZ0IsTUFBTSxJQUE1QjtBQUNBLFFBQU0saUJBQWlCLE1BQU0sS0FBN0I7O0FBRUEsUUFBSSxrQkFBa0IsVUFBdEIsRUFBa0M7QUFDaEMsMkJBQXNCLElBQXRCO0FBQ0Q7O0FBRUQsUUFBTSxNQUFNLGdCQUFpQixhQUFqQixFQUFnQyxjQUFoQyxDQUFaO0FBQ0EsUUFBTSxTQUFTLE9BQU8sTUFBUCxDQUFlLEVBQWYsRUFBbUIsYUFBbkIsRUFBa0MsUUFBUyxhQUFULENBQWxDLENBQWY7QUFDQSxRQUFNLGlCQUFpQixJQUFJLE1BQUosQ0FBWSxPQUFPLGlCQUFuQixDQUF2QjtBQUNBLFFBQU0sV0FBVyxLQUFLLFdBQUwsRUFBakI7O0FBRUEsUUFBSSxrQkFBa0IsU0FBUyxNQUEvQixFQUF1QztBQUNyQyxlQUFTLE9BQVQsQ0FBa0IscUJBQWE7QUFDN0IsWUFBTSxXQUFXLFdBQVksU0FBWixDQUFqQjs7QUFFQSxZQUFJLGVBQWUsUUFBZixPQUE4QixJQUE5QixJQUFzQyxlQUFlLFFBQWYsT0FBOEIsSUFBeEUsRUFBOEU7QUFDNUU7Ozs7Ozs7QUFRQSxjQUFNLFNBQVMsSUFBSSxLQUFKLENBQVcsV0FBWCxFQUF5QixNQUF6QixDQUFpQyxJQUFqQyxDQUFmOztBQUVBLGlCQUFPLE1BQVAsQ0FBZSxRQUFmO0FBQ0EseUJBQWUsTUFBZixDQUF1QixNQUF2Qjs7QUFFQTtBQUNEOztBQUVELHVCQUFlLE1BQWYsQ0FBdUIsUUFBdkI7QUFDRCxPQXJCRDtBQXNCRDs7QUFFRCxXQUFPLEdBQVA7QUFDRCxHQXhDRDs7QUEwQ0EsU0FBTyxVQUFQO0FBQ0QsQ0FyRUQ7O0FBdUVBLE9BQU8sT0FBUCxHQUFpQixVQUFqQjs7O0FDNUVBOztBQUVBLElBQU0sYUFBYSxRQUFTLGNBQVQsQ0FBbkI7QUFDQSxJQUFNLFdBQVcsUUFBUyxZQUFULENBQWpCO0FBQ0EsSUFBTSxrQkFBa0IsUUFBUyxrQkFBVCxDQUF4QjtBQUNBLElBQU0sUUFBUSxRQUFTLGNBQVQsQ0FBZDs7SUFFUSxLLEdBQVUsSyxDQUFWLEs7OztBQUVSLElBQU0sZ0JBQWdCLFNBQWhCLGFBQWdCLENBQUUsWUFBRixFQUFnQixhQUFoQixFQUErQixLQUEvQixFQUEwQztBQUM5RCxVQUFRLE1BQU8sS0FBUCxDQUFSOztBQUVBLE1BQU0sWUFBWSxTQUFTLE1BQVQsQ0FBaUIsS0FBakIsQ0FBbEI7O0FBSDhELE1BS3RELGNBTHNELEdBS2QsWUFMYyxDQUt0RCxjQUxzRDtBQUFBLE1BS3RDLE9BTHNDLEdBS2QsWUFMYyxDQUt0QyxPQUxzQztBQUFBLE1BSzdCLFVBTDZCLEdBS2QsWUFMYyxDQUs3QixVQUw2Qjs7O0FBTzlELE1BQU0sY0FBYyxPQUFPLElBQVAsQ0FBYSxPQUFiLENBQXBCOztBQUVBLE1BQU0sb0JBQW9CLFNBQXBCLGlCQUFvQjtBQUFBLFdBQ3hCLFdBQVcsT0FBWCxDQUFvQjtBQUFBLGFBQ2xCLGVBQWUsUUFBZixDQUF5QixFQUFFLEtBQUYsR0FBVSxJQUFuQyxDQURrQjtBQUFBLEtBQXBCLENBRHdCO0FBQUEsR0FBMUI7O0FBS0EsTUFBTSxZQUFZLFdBQVksYUFBWixDQUFsQjtBQUNBLE1BQU0sa0JBQWtCLFFBQVMsYUFBVCxDQUF4Qjs7QUFFQSxNQUFJLGFBQWEsQ0FBQyxlQUFsQixFQUFtQztBQUNqQyxXQUFPLGdCQUFpQixLQUFqQixFQUF3QixTQUF4QixDQUFQO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDLFNBQUQsSUFBYyxDQUFDLGVBQW5CLEVBQW9DO0FBQ2xDLFdBQU8sS0FBUDtBQUNEOztBQUVELE1BQU0sc0JBQXNCLFdBQVcsTUFBWCxDQUFtQixlQUFuQixDQUE1QjtBQUNBLE1BQU0sZ0JBQWdCLGtCQUFtQixtQkFBbkIsQ0FBdEI7O0FBRUEsZ0JBQWMsT0FBZCxDQUF1Qiw0QkFBb0I7QUFDekMsUUFBTSxRQUFRLGlCQUFpQixLQUFqQixFQUFkO0FBQ0EsUUFBTSxnQkFBZ0IsTUFBTSxJQUE1QjtBQUNBLFFBQU0scUJBQXFCLFdBQVksYUFBWixDQUEzQjs7QUFFQSxRQUFJLENBQUMsa0JBQUwsRUFBMEI7O0FBRTFCLFFBQU0sY0FBYyxXQUFXLFlBQVgsQ0FBeUIsZ0JBQXpCLENBQXBCO0FBQ0EsUUFBTSxZQUFZLFNBQVMsWUFBVCxDQUF1QixTQUF2QixFQUFrQyxXQUFsQyxDQUFsQjs7QUFFQSxRQUFJLENBQUMsU0FBTCxFQUFpQjs7QUFFakIsUUFBTSxpQkFBaUIsVUFBVSxLQUFWLEVBQXZCOztBQUVBLFFBQUksTUFBTSxTQUFWLEVBQXFCO0FBQ25CLFVBQU0sYUFBYSxTQUFTLE1BQVQsQ0FBaUIsU0FBakIsQ0FBbkI7O0FBRUEsVUFBTSxjQUFjLFdBQVcsR0FBWCxDQUFnQjtBQUFBLGVBQ2xDLGNBQWUsWUFBZixFQUE2QixhQUE3QixFQUE0QyxJQUE1QyxDQURrQztBQUFBLE9BQWhCLENBQXBCOztBQUlBLFVBQU0sa0JBQWtCLFNBQVMsTUFBVCxDQUFpQixXQUFqQixDQUF4QjtBQUNBLFVBQU0sa0JBQWtCLFVBQVUsU0FBVixFQUF4Qjs7QUFFQSxVQUFJLGVBQWUsWUFBbkIsRUFBaUM7QUFDL0IsWUFBTSx1QkFBdUIsZ0JBQWdCLEtBQWhCLEVBQTdCO0FBQ0EsNkJBQXFCLFlBQXJCLEdBQW9DLGVBQWUsWUFBbkQ7QUFDQSx3QkFBZ0IsS0FBaEIsQ0FBdUIsb0JBQXZCO0FBQ0Q7O0FBRUQsc0JBQWdCLFlBQWhCLENBQThCLGVBQTlCLEVBQStDLFNBQS9DO0FBQ0QsS0FqQkQsTUFpQk87QUFDTCxZQUFNLElBQUksS0FBSixDQUFXLG1DQUFYLENBQU47QUFDRDtBQUNGLEdBbENEOztBQW9DQSxVQUFRLFNBQVMsTUFBVCxDQUFpQixTQUFqQixDQUFSOztBQUVBLE1BQUksU0FBSixFQUNFLFFBQVEsZ0JBQWlCLEtBQWpCLEVBQXdCLFNBQXhCLENBQVI7O0FBRUYsU0FBTyxLQUFQO0FBQ0QsQ0F0RUQ7O0FBd0VBLE9BQU8sT0FBUCxHQUFpQixhQUFqQjs7O0FDakZBOztBQUVBLElBQU0sT0FBTyxRQUFTLE9BQVQsQ0FBYjtBQUNBLElBQU0sY0FBYyxRQUFTLHNCQUFULENBQXBCOztBQUVBLElBQU0saUJBQWlCO0FBQ3JCLFNBQU8sQ0FEYztBQUVyQixjQUFZLEtBQUssVUFGSTtBQUdyQix3QkFBc0IsS0FIRDtBQUlyQjtBQUpxQixDQUF2Qjs7QUFPQSxJQUFNLHFCQUFxQixTQUFyQixrQkFBcUIsQ0FBRSxJQUFGLEVBQVEsT0FBUixFQUFxQjtBQUM5QyxZQUFVLE9BQU8sTUFBUCxDQUFlLEVBQWYsRUFBbUIsY0FBbkIsRUFBbUMsT0FBbkMsQ0FBVjs7QUFEOEMsaUJBR21CLE9BSG5CO0FBQUEsTUFHdEMsS0FIc0MsWUFHdEMsS0FIc0M7QUFBQSxNQUcvQixVQUgrQixZQUcvQixVQUgrQjtBQUFBLE1BR25CLFdBSG1CLFlBR25CLFdBSG1CO0FBQUEsTUFHTixvQkFITSxZQUdOLG9CQUhNOzs7QUFLOUMsTUFBTSxRQUFRLFlBQWEsSUFBYixFQUFtQixFQUFFLFlBQUYsRUFBbkIsQ0FBZDs7QUFFQSxNQUFNLFFBQVE7QUFDWixVQUFNLGVBRE07QUFFWjtBQUZZLEdBQWQ7O0FBS0EsTUFBTSxnQkFBZ0IsV0FBWSxLQUFaLENBQXRCOztBQUVBLE1BQU0sdUJBQXVCLHdCQUF3QixDQUFDLE1BQU0sbUJBQTVEOztBQUVBLE1BQUksb0JBQUosRUFBMkI7QUFDekIsUUFBTSxXQUFXLEtBQUssV0FBTCxFQUFqQjs7QUFFQSxhQUFTLE9BQVQsQ0FBa0IscUJBQWE7QUFDN0IsVUFBTSxlQUFlLE9BQU8sTUFBUCxDQUNuQixFQURtQixFQUVuQixPQUZtQixFQUduQjtBQUNFLGVBQU8sUUFBUTtBQURqQixPQUhtQixDQUFyQjs7QUFRQSxVQUFNLHFCQUFxQixtQkFBb0IsU0FBcEIsRUFBK0IsWUFBL0IsQ0FBM0I7O0FBRUEsb0JBQWMsTUFBZCxDQUFzQixrQkFBdEI7QUFDRCxLQVpEO0FBYUQ7O0FBRUQsU0FBTyxhQUFQO0FBRUQsQ0FwQ0Q7O0FBc0NBLE9BQU8sT0FBUCxHQUFpQixrQkFBakI7OztBQ2xEQTs7ZUFFdUIsUUFBUyxjQUFULEM7SUFBZixVLFlBQUEsVTs7QUFFUixJQUFNLGlCQUFpQjtBQUNyQixTQUFPO0FBRGMsQ0FBdkI7O0FBSUEsSUFBTSxjQUFjLFNBQWQsV0FBYyxDQUFFLElBQUYsRUFBUSxPQUFSLEVBQXFCO0FBQ3ZDLFlBQVUsT0FBTyxNQUFQLENBQWUsRUFBZixFQUFtQixjQUFuQixFQUFtQyxPQUFuQyxDQUFWOztBQUR1QyxpQkFHckIsT0FIcUI7QUFBQSxNQUcvQixLQUgrQixZQUcvQixLQUgrQjs7O0FBS3ZDLE1BQU0sUUFBUSxLQUFLLEtBQUwsRUFBZDtBQUNBLE1BQU0sV0FBVyxLQUFLLFdBQUwsRUFBakI7O0FBRUEsTUFBTSxLQUFLLEtBQUssRUFBTCxFQUFYO0FBQ0EsTUFBTSxPQUFPLE1BQU0sSUFBTixJQUFjLEVBQTNCO0FBQ0EsTUFBTSxXQUFXLE9BQWpCO0FBQ0EsTUFBTSxXQUFXLEtBQUssUUFBTCxFQUFqQjtBQUNBLE1BQU0sUUFBWSxLQUFaLFVBQXdCLElBQXhCLFNBQWtDLFFBQWxDLFdBQWtELFNBQVMsTUFBM0QsT0FBTjtBQUNBLE1BQU0sVUFBVSxLQUFLLE9BQUwsRUFBaEI7O0FBRUEsTUFBSSxjQUFjLEtBQUssSUFBTCxDQUFXLGFBQVgsQ0FBbEI7O0FBRUEsZ0JBQWMsT0FBTyxXQUFQLEtBQXVCLFNBQXZCLEdBQW1DLFdBQW5DLEdBQWlELFFBQVEsQ0FBdkU7O0FBRUEsTUFBTSxzQkFBc0IsZUFBZSxDQUFDLENBQUMsS0FBSyxJQUFMLENBQVcscUJBQVgsQ0FBN0M7O0FBRUEsTUFBTSxVQUFVLFdBQVksS0FBSyxTQUFMLENBQWdCLEtBQWhCLENBQVosQ0FBaEI7QUFDQSxNQUFNLGdCQUFvQixLQUFwQixlQUFOOztBQUVBLE1BQU0sUUFBUTtBQUNaLFVBRFksRUFDUixZQURRLEVBQ0Qsa0JBREMsRUFDUyxrQkFEVCxFQUNtQixZQURuQixFQUMwQixnQkFEMUIsRUFDbUMsd0JBRG5DO0FBRVosNENBRlksRUFFUyxnQkFGVCxFQUVrQjtBQUZsQixHQUFkOztBQUtBLFNBQU8sS0FBUDtBQUNELENBOUJEOztBQWdDQSxPQUFPLE9BQVAsR0FBaUIsV0FBakI7OztBQ3hDQTs7QUFFQSxJQUFNLE9BQU8sUUFBUyxPQUFULENBQWI7QUFDQSxJQUFNLGNBQWMsUUFBUyxzQkFBVCxDQUFwQjtBQUNBLElBQU0scUJBQXFCLFFBQVMsNkJBQVQsQ0FBM0I7QUFDQSxJQUFNLHNCQUFzQixRQUFTLHlDQUFULENBQTVCOztBQUVBLElBQU0saUJBQWlCO0FBQ3JCLFNBQU8sQ0FEYztBQUVyQixjQUFZLEtBQUssVUFGSTtBQUdyQiwwQkFIcUI7QUFJckI7QUFKcUIsQ0FBdkI7O0FBT0EsSUFBTSxhQUFhLFNBQWIsVUFBYSxlQUFnQjtBQUNqQyxNQUFNLHNCQUFzQixvQkFBcUIsWUFBckIsQ0FBNUI7O0FBRUEsTUFBTSxhQUFhLFNBQWIsVUFBYSxDQUFFLElBQUYsRUFBUSxPQUFSLEVBQXFCO0FBQ3RDLGNBQVUsT0FBTyxNQUFQLENBQWUsRUFBZixFQUFtQixjQUFuQixFQUFtQyxPQUFuQyxDQUFWOztBQURzQyxtQkFHeUIsT0FIekI7QUFBQSxRQUc5QixXQUg4QixZQUc5QixXQUg4QjtBQUFBLFFBR2pCLGtCQUhpQixZQUdqQixrQkFIaUI7QUFBQSxRQUdHLEtBSEgsWUFHRyxLQUhIO0FBQUEsUUFHVSxVQUhWLFlBR1UsVUFIVjs7O0FBS3RDLFFBQU0sd0JBQXdCLEVBQUUsWUFBRixFQUFTLHNCQUFULEVBQXFCLHdCQUFyQixFQUE5QjtBQUNBLFFBQU0sZUFBZSxtQkFBb0IsSUFBcEIsRUFBMEIscUJBQTFCLENBQXJCO0FBQ0EsUUFBTSxnQkFBZ0Isb0JBQXFCLFlBQXJCLENBQXRCOztBQUVBLFdBQU8sYUFBUDtBQUNELEdBVkQ7O0FBWUEsU0FBTyxVQUFQO0FBQ0QsQ0FoQkQ7O0FBa0JBLE9BQU8sT0FBUCxHQUFpQixVQUFqQjs7O0FDaENBOztBQUVBLElBQU0sYUFBYSxRQUFTLG1CQUFULENBQW5CO0FBQ0EsSUFBTSxZQUFZLFFBQVMsV0FBVCxDQUFsQjtBQUNBLElBQU0sMkJBQTJCLFFBQVMsd0NBQVQsQ0FBakM7O0FBRUEsSUFBTSxjQUFjLFNBQWQsV0FBYyxDQUFFLFNBQUYsRUFBYSxLQUFiLEVBQW9CLElBQXBCLEVBQThCO0FBQ2hELE1BQU0sY0FBYyxVQUFVLGFBQVYsRUFBcEI7O0FBRUEsTUFBSSxDQUFDLFlBQVksUUFBWixDQUFzQixJQUF0QixDQUFMLEVBQW9DOztBQUVwQyxNQUFNLFNBQVMsVUFBVSxnQkFBVixDQUE0QixLQUE1QixFQUFtQyxJQUFuQyxDQUFmOztBQUVBLE1BQUksT0FBTyxLQUFYLEVBQW1COztBQUVuQixNQUFNLG9EQUFtRCxJQUFuRCxVQUE4RCxLQUFLLFNBQUwsQ0FBZ0IsT0FBTyxNQUF2QixDQUFwRTtBQUNBLFFBQU0sSUFBSSxLQUFKLENBQVcsT0FBWCxDQUFOO0FBQ0QsQ0FYRDs7QUFhQSxJQUFNLFlBQVksU0FBWixTQUFZLGVBQWdCO0FBQUEsTUFDeEIsVUFEd0IsR0FDMEIsWUFEMUIsQ0FDeEIsVUFEd0I7QUFBQSxNQUNaLFNBRFksR0FDMEIsWUFEMUIsQ0FDWixTQURZO0FBQUEsTUFDRCxhQURDLEdBQzBCLFlBRDFCLENBQ0QsYUFEQztBQUFBLE1BQ2MsT0FEZCxHQUMwQixZQUQxQixDQUNjLE9BRGQ7OztBQUdoQyxNQUFNLGFBQWEsV0FBWSxTQUFaLENBQW5CO0FBQ0EsTUFBTSxZQUFZLFVBQVcsT0FBWCxDQUFsQjs7QUFFQSxNQUFNLGtCQUFrQixTQUFsQixlQUFrQixDQUFFLElBQUYsRUFBUSxLQUFSLEVBQW1CO0FBQ3pDLFFBQU0sZ0JBQWdCLE9BQU8sTUFBUCxDQUFlLEVBQWYsRUFBbUIsY0FBZSxJQUFmLEtBQXlCLEVBQTVDLEVBQWdELEtBQWhELENBQXRCOztBQUVBLGdCQUFhLFNBQWIsRUFBd0IsYUFBeEIsRUFBdUMsSUFBdkM7O0FBRUEsUUFBTSxZQUFZLHlCQUEwQixZQUExQixFQUF3QyxJQUF4QyxFQUE4QyxhQUE5QyxDQUFsQjs7QUFFQSxXQUFPLFdBQVksSUFBWixFQUFrQixTQUFsQixDQUFQO0FBQ0QsR0FSRDs7QUFVQTtBQUNBLE1BQU0saUJBQWlCLFNBQWpCLGNBQWlCLENBQUUsSUFBRixFQUFRLEtBQVIsRUFBZSxRQUFmLEVBQTZCO0FBQ2xELFFBQUk7QUFDRixVQUFNLGdCQUFnQixPQUFPLE1BQVAsQ0FBZSxFQUFmLEVBQW1CLGNBQWMsUUFBakMsRUFBMkMsS0FBM0MsQ0FBdEI7O0FBRUEsVUFBSSxTQUFTLFVBQWIsRUFBeUI7QUFDdkIsWUFBTSxPQUFPLGdCQUFpQixJQUFqQixFQUF1QixLQUF2QixFQUErQixTQUEvQixFQUFiOztBQUVBLGVBQU8sTUFBUCxDQUFlLGFBQWYsRUFBOEIsRUFBRSxVQUFGLEVBQTlCO0FBQ0Q7O0FBRUQsa0JBQWEsU0FBYixFQUF3QixhQUF4QixFQUF1QyxVQUF2Qzs7QUFFQSxVQUFNLFlBQVkseUJBQTBCLFlBQTFCLEVBQXdDLFVBQXhDLEVBQW9ELGFBQXBELENBQWxCOztBQUVBLFVBQU0sTUFBTSxXQUFZLFVBQVosRUFBd0IsU0FBeEIsQ0FBWjs7QUFFQSxlQUFVLElBQVYsRUFBZ0IsR0FBaEI7QUFDRCxLQWhCRCxDQWdCRSxPQUFPLENBQVAsRUFBVTtBQUNWLGVBQVUsQ0FBVjtBQUNEO0FBQ0YsR0FwQkQ7O0FBc0JBLFNBQU8sRUFBRSw4QkFBRixFQUFrQixnQ0FBbEIsRUFBUDtBQUNELENBeENEOztBQTBDQSxPQUFPLE9BQVAsR0FBaUIsU0FBakIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwibW9kdWxlLmV4cG9ydHM9e1wic3R5bGVzXCI6e1wiY29tcG9zZXJcIjpcIi5jb21wb3NlciB7XFxyXFxuICBsaW5lLWhlaWdodDogMjtcXHJcXG59XFxyXFxuXFxyXFxuLmNvbXBvc2VyLW5vZGUge1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG4uY29tcG9zZXItbm9kZV9fdG9vbGJhciB7XFxyXFxuICBtaW4taGVpZ2h0OiAzZW07XFxyXFxuXFxyXFxuICBiYWNrZ3JvdW5kOiAjNjY2O1xcclxcbiAgY29sb3I6ICNmZmY7XFxyXFxuICBib3JkZXI6IDAuMDYyNXJlbSBzb2xpZCAjODg3O1xcclxcbiAgYm9yZGVyLWJvdHRvbTogMC4wNjI1cmVtIHNvbGlkICM0NDU7XFxyXFxuICBib3JkZXItcmlnaHQ6IDAuMDYyNXJlbSBzb2xpZCAjNDQ1O1xcclxcbiAgYm94LXNoYWRvdzogMC4xMjVyZW0gMC4xMjVyZW0gMC41cmVtIHJnYmEoIDAsIDAsIDAsIDAuMjUgKTtcXHJcXG4gIHRleHQtc2hhZG93OiAwLjA2MjVyZW0gMC4wNjI1cmVtIDAgIzMzNTtcXHJcXG59XFxyXFxuXFxyXFxuLmNvbXBvc2VyLW5vZGVfX3RpdGxlIHtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAzO1xcclxcbiAgcGFkZGluZzogMCAxcmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uY29tcG9zZXItbm9kZV9fY2hpbGRyZW4gPiAuY29tcG9zZXItbm9kZV9fdG9vbGJhciB7XFxyXFxuICBiYWNrZ3JvdW5kOiAjMDViO1xcclxcbiAgYm9yZGVyOiAwLjA2MjVyZW0gc29saWQgIzI3YztcXHJcXG4gIGJvcmRlci1ib3R0b206IDAuMDYyNXJlbSBzb2xpZCAjMDRiO1xcclxcbiAgYm9yZGVyLXJpZ2h0OiAwLjA2MjVyZW0gc29saWQgIzA0YjtcXHJcXG4gIHRleHQtc2hhZG93OiAwLjA2MjVyZW0gMC4wNjI1cmVtIDAgIzAzYjtcXHJcXG59XFxyXFxuXFxyXFxuLmNvbXBvc2VyLW5vZGUtLWVtcHR5ID4gLmNvbXBvc2VyLW5vZGVfX3Rvb2xiYXIge1xcclxcbiAgYmFja2dyb3VuZDogI2VlZTtcXHJcXG4gIGNvbG9yOiAjMjIyO1xcclxcbiAgYm9yZGVyOiAwLjA2MjVyZW0gc29saWQgI2ZmZTtcXHJcXG4gIGJvcmRlci1ib3R0b206IDAuMDYyNXJlbSBzb2xpZCAjY2NkO1xcclxcbiAgYm9yZGVyLXJpZ2h0OiAwLjA2MjVyZW0gc29saWQgI2NjZDtcXHJcXG4gIHRleHQtc2hhZG93OiAwLjA2MjVyZW0gMC4wNjI1cmVtIDAgI2JiZDtcXHJcXG59XFxyXFxuXFxyXFxuLmNvbXBvc2VyLW5vZGU6bm90KCBbZGF0YS1kZXB0aD1cXFwiMFxcXCJdICkgPiAuY29tcG9zZXItbm9kZV9fdG9vbGJhciB7XFxyXFxuICBjdXJzb3I6IG1vdmU7XFxyXFxufVxcclxcblxcclxcbi5jb21wb3Nlci1ub2RlX192aWV3IHtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDFlbTtcXHJcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxyXFxufVxcclxcblxcclxcbi5jb21wb3Nlci1ub2RlX192aWV3Omxhc3QtY2hpbGQge1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMDtcXHJcXG59XFxyXFxuXFxyXFxuLmNvbXBvc2VyLW5vZGVfX21haW4ge1xcclxcbiAgcGFkZGluZzogMC43NXJlbTtcXHJcXG4gIG1hcmdpbjogMC4yNXJlbTtcXHJcXG4gIG1hcmdpbi10b3A6IDA7XFxyXFxuXFxyXFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xcclxcbiAgYm94LXNoYWRvdzogMC4xMjVyZW0gMC4xMjVyZW0gMC41cmVtIHJnYmEoIDAsIDAsIDAsIDAuMjUgKTtcXHJcXG4gIGJvcmRlci1ib3R0b206IDAuMDYyNXJlbSBzb2xpZCAjZWVlO1xcclxcbn1cXHJcXG5cXHJcXG4uY29tcG9zZXItbm9kZS0tY29sbGFwc2VkID4gLmNvbXBvc2VyLW5vZGVfX21haW4sXFxyXFxuLmNvbXBvc2VyLW5vZGVfX2NoaWxkcmVuLS1jb2xsYXBzZWQgPiAuY29tcG9zZXItbm9kZV9fbWFpbiB7XFxyXFxuICBoZWlnaHQ6IDA7XFxyXFxuICBtYXJnaW46IDA7XFxyXFxuICBwYWRkaW5nOiAwO1xcclxcbiAgYm9yZGVyOiAwO1xcclxcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG59XFxyXFxuXFxyXFxuLmNvbXBvc2VyLW5vZGVfX2NoaWxkcmVuIHtcXHJcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxyXFxuXFxyXFxuICBib3gtc2hhZG93OiBpbnNldCAwLjEyNXJlbSAwLjEyNXJlbSAwLjVyZW0gcmdiYSggMCwgMCwgMCwgMC4yNSApO1xcclxcbiAgYmFja2dyb3VuZDogI2VlZjtcXHJcXG59XFxyXFxuXFxyXFxuLmNvbXBvc2VyLW5vZGVfX2NoaWxkcmVuID4gdWwge1xcclxcbiAgbWFyZ2luOiAwO1xcclxcbiAgcGFkZGluZzogMC41cmVtO1xcclxcbiAgbGlzdC1zdHlsZTogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLmNvbXBvc2VyLW5vZGVfX2NoaWxkcmVuLS1jb2xsYXBzZWQgPiB1bCB7XFxyXFxuICBoZWlnaHQ6IDA7XFxyXFxuICBwYWRkaW5nOiAwO1xcclxcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG59XFxyXFxuXFxyXFxuLmNvbXBvc2VyLW5vZGVfX2NoaWxkcmVuID4gdWwgPiBsaSB7XFxyXFxuICBtYXJnaW46IDA7XFxyXFxuICBwYWRkaW5nOiAwO1xcclxcbn1cXHJcXG5cXHJcXG4uY29tcG9zZXItbm9kZV9fYWN0aW9ucyB7XFxyXFxuICBkaXNwbGF5OiBibG9jaztcXHJcXG4gIGZsb2F0OiByaWdodDtcXHJcXG59XFxyXFxuXFxyXFxuLmNvbXBvc2VyLW5vZGVfX2FjdGlvbnMgPiBsaSB7XFxyXFxuICBkaXNwbGF5OiBibG9jaztcXHJcXG4gIGZsb2F0OiBsZWZ0O1xcclxcbn1cXHJcXG5cXHJcXG4uY29tcG9zZXItbm9kZV9fYWN0aW9uIHtcXHJcXG4gIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgcGFkZGluZzogMDtcXHJcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjg3NXJlbTtcXHJcXG4gIHdpZHRoOiAxLjg3NXJlbTtcXHJcXG4gIG1hcmdpbjogMC41cmVtIDA7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxyXFxuXFxyXFxuICBiYWNrZ3JvdW5kOiAjMzlmO1xcclxcbiAgY29sb3I6ICNmZmY7XFxyXFxuICBib3JkZXI6IDAuMDYyNXJlbSBzb2xpZCAjNWJmO1xcclxcbiAgYm9yZGVyLXJpZ2h0OiAwLjA2MjVyZW0gc29saWQgIzE3ZjtcXHJcXG4gIGJvcmRlci1ib3R0b206IDAuMDYyNXJlbSBzb2xpZCAjMTdmO1xcclxcbiAgdGV4dC1zaGFkb3c6IDAuMDYyNXJlbSAwLjA2MjVyZW0gMCAjMDZmO1xcclxcbn1cXHJcXG5cXHJcXG4uY29tcG9zZXItbm9kZV9fYWN0aW9ucyA+IGxpOmxhc3QtY2hpbGQgLmNvbXBvc2VyLW5vZGVfX2FjdGlvbiB7XFxyXFxuICBtYXJnaW4tcmlnaHQ6IDAuNXJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLmNvbXBvc2VyLW5vZGVfX2RlbGV0ZSB7XFxyXFxuICBiYWNrZ3JvdW5kOiAjZDIyO1xcclxcbiAgY29sb3I6ICNmZmY7XFxyXFxuICBib3JkZXI6IDAuMDYyNXJlbSBzb2xpZCAjZjQzO1xcclxcbiAgYm9yZGVyLXJpZ2h0OiAwLjA2MjVyZW0gc29saWQgI2IwNDtcXHJcXG4gIGJvcmRlci1ib3R0b206IDAuMDYyNXJlbSBzb2xpZCAjYjA0O1xcclxcbiAgdGV4dC1zaGFkb3c6IDAuMDYyNXJlbSAwLjA2MjVyZW0gMCAjYTA0O1xcclxcbn1cXHJcXG5cIixcImRvY3VtZW50XCI6XCIqIHtcXHJcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuICBtYXJnaW46IDA7XFxyXFxuICBwYWRkaW5nOiAwO1xcclxcbn1cXHJcXG5cXHJcXG5odG1sIHtcXHJcXG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xcclxcbn1cXHJcXG5cXHJcXG4uZ3UtdW5zZWxlY3RhYmxlIHtcXHJcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5ndS1taXJyb3Ige1xcclxcbiAgcG9zaXRpb246IGZpeGVkICFpbXBvcnRhbnQ7XFxyXFxuICBtYXJnaW46IDAgIWltcG9ydGFudDtcXHJcXG4gIHotaW5kZXg6IDk5OTkgIWltcG9ydGFudDtcXHJcXG4gIG9wYWNpdHk6IDAuODtcXHJcXG4gIC1tcy1maWx0ZXI6IFxcXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEoT3BhY2l0eT04MClcXFwiO1xcclxcbiAgZmlsdGVyOiBhbHBoYShvcGFjaXR5PTgwKTtcXHJcXG59XFxyXFxuXFxyXFxuLmd1LWhpZGUge1xcclxcbiAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG5cXHJcXG4uZ3UtdW5zZWxlY3RhYmxlIHtcXHJcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmUgIWltcG9ydGFudDtcXHJcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmUgIWltcG9ydGFudDtcXHJcXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZSAhaW1wb3J0YW50O1xcclxcbiAgdXNlci1zZWxlY3Q6IG5vbmUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuLmd1LXRyYW5zaXQge1xcclxcbiAgb3BhY2l0eTogMC4yO1xcclxcbiAgLW1zLWZpbHRlcjogXFxcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYShPcGFjaXR5PTIwKVxcXCI7XFxyXFxuICBmaWx0ZXI6IGFscGhhKG9wYWNpdHk9MjApO1xcclxcbn1cXHJcXG5cXHJcXG4ucmF0aW8ge1xcclxcbiAgd2lkdGg6IDRyZW07XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxufVxcclxcblxcclxcbi5yYXRpbyAuc2hpbSB7XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogMTAwJTtcXHJcXG59XFxyXFxuXFxyXFxuLnJhdGlvIC52aWV3cG9ydCB7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICB0b3A6IDA7XFxyXFxuICBsZWZ0OiAwO1xcclxcbiAgcmlnaHQ6IDA7XFxyXFxuICBib3R0b206IDA7XFxyXFxufVxcclxcblwifSxcInRlbXBsYXRlc1wiOntcImNvbXBvc2VyXCI6e1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZG9jdW1lbnRGcmFnbWVudFwiLFwiX2lkXCI6XCJkb2N1bWVudGZyYWdtZW50LTUyYzBhOGM5MTliNDljNGY2ZGE5MWU3M2I5ZWQ5ZTM0XCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZGl2XCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImNvbXBvc2VyXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTllODM0MjVkMTRjZDhlMjQ1NTVkZDgxNTI2ODY4ZDQ1XCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSxcImNvbXBvc2VyLW5vZGVcIjp7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJkb2N1bWVudEZyYWdtZW50XCIsXCJfaWRcIjpcImRvY3VtZW50ZnJhZ21lbnQtYWEyZTg5YWE2OWEzNThjZDMxNWU3MGRlNzQwYmJkNzhcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJkaXZcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZVwiLFwiZGF0YS10YWdcIjpcIm5vZGVUYWdcIn0sXCJfaWRcIjpcImVsZW1lbnQtNTQxNjk0OTNlNzZiYTEwNzEyNzZjNWFlOTc1MjViZjZcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgXCIsXCJfaWRcIjpcInRleHQtYjk3Y2Y4OGU4MmVjMTIzMmQ1NTJkZTY3MzlhMDA0MzlcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJoZWFkZXJcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZV9fdG9vbGJhclwifSxcIl9pZFwiOlwiZWxlbWVudC1lZGMxM2QyZTNjYTVlZTQxMmRjNzMzM2NmZTZkNGRkM1wifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWVkMTg2YWRkZjU4MTBkMGY0YTU5ZTRkNTViZDdlYmM2XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwic3BhblwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJjb21wb3Nlci1ub2RlX190aXRsZVwiLFwiZGF0YS10ZXh0XCI6XCJ0aXRsZVwifSxcIl9pZFwiOlwiZWxlbWVudC05ZDg2MGY2MDk3NmRlOGZiYmJhNDExZTEwMWJiMjAwMFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTlmY2M4NTFmMGE5ZjYwNzZlMjQ2ZjMwY2IxZDI1MzY1XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwidWxcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZV9fYWN0aW9uc1wifSxcIl9pZFwiOlwiZWxlbWVudC02NWRiYTM4Y2M2NWUwY2U2YTM4MzQzMWUxNDlmMmYxYlwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgXCIsXCJfaWRcIjpcInRleHQtYTYxMjcwNWMzNzM0NjkyODIwMTg0NmYxZjYwNGZhZjRcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJsaVwiLFwiYXR0cmlidXRlc1wiOnt9LFwiX2lkXCI6XCJlbGVtZW50LTc3MTBkMDM1NTFkZTIyZTJjNTcyZjdmMzA0MWU3OWMzXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwic3BhblwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJjb21wb3Nlci1ub2RlX19hY3Rpb24gY29tcG9zZXItbm9kZV9fZGVsZXRlXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTMyN2EwMzAxMjZjODhkNGU4MjM4Mjc5OTQ5NzI3M2MzXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiaVwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJmYSBmYS10cmFzaCBmYS1sZ1wifSxcIl9pZFwiOlwiZWxlbWVudC1lMjQzYmQ1ZGY4ZjQzOWYxMDU3NDZlZWY3NTE4MWM3YlwifSxcImNoaWxkcmVuXCI6W119XX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC1hZWZhZGU0OTU3MGI5MzY2YTliMjBmNjdiNzVhODU3OVwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gIFwiLFwiX2lkXCI6XCJ0ZXh0LTA5Yjk3NjI2YTBhNmI5M2E0ZjliZmM2ZjNhMjIxZmM3XCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblxcclxcbiAgXCIsXCJfaWRcIjpcInRleHQtNWNmMDJhZmI3NTI0NzFlN2Q4NmRhMTVhNmI0NTYyMGRcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJkaXZcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZV9fbWFpblwifSxcIl9pZFwiOlwiZWxlbWVudC01YjFmOWU2ZWMwMDg5ZDY5MTAyNTY2YjRlNzAwNWRiM1wifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWM2NWY3Y2Y1ZTM4YzI4MWUxMjczYWFmZjA1OTAyNjlkXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZGl2XCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImNvbXBvc2VyLW5vZGVfX3ZpZXdcIn0sXCJfaWRcIjpcImVsZW1lbnQtYmU3NTY4MTM1Njk4YjVjNzYwMzNlZTkyMGRjODNiZWNcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTg4NTQxYzI3NTIyOGZmZmE4MTk5N2MzZTc2ZDFmMjA0XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiY29kZVwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtaHRtbFwiOlwicHJldmlld1wifSxcIl9pZFwiOlwiZWxlbWVudC1mOTAzN2EzMDEyMzUyNDc0YzI0ZGNiZTQzYTY5ZWE2ZFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWNkM2JlMDJmMGQ1OWJiM2ZkNDk2MzAyM2Q1ZGY2ODAyXCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC0xZjQzNTUxN2Y4MmYyMmRjNThjZWY4MzA4Y2Q0ZDAyNlwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImZyYWdtZW50XCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS1ub3RcIjpcImlzRW1wdHlcIn0sXCJfaWRcIjpcImVsZW1lbnQtZWFmNWFkY2UwNjRmOTA2NTFmZWM4MTUxOWI1MGM3ZTBcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTMzZjVkOGM2MDI5ZDIyOGI0ODI5MWJkNzQ5YmExODRmXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZGl2XCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImNvbXBvc2VyLW5vZGVfX2NoaWxkcmVuXCIsXCJkYXRhLXRhZ1wiOlwiY2hpbGRXcmFwcGVyVGFnXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTkxMzlhZDcwMTRlNDhiNDAwOGI0NjdjMjk3ZWE1ZDgzXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTFjMTc4M2EzZTExYTM5YWU3YjVlM2Q0NDIwZjYwYWZmXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiaGVhZGVyXCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImNvbXBvc2VyLW5vZGVfX3Rvb2xiYXJcIn0sXCJfaWRcIjpcImVsZW1lbnQtMTVmOTg0NTllZGQwOTdlMzk2MjYwMWI3YzQwOGFiNDBcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICAgICAgICBcIixcIl9pZFwiOlwidGV4dC00NzljYWZiZGQ5ZWZhYzczNGNmNjhiYTk0MGYwMzExOFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcInNwYW5cIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZV9fdGl0bGVcIixcImRhdGEtdGV4dFwiOlwiY2hpbGRyZW5UaXRsZVwifSxcIl9pZFwiOlwiZWxlbWVudC1iMWZmZjJkZjM1ZGI2OGVjYTgyMmJjNDU4MGJmNTY0MVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWI5ODRlZDMwMzJiYWM3MjMzMjU1YjJlZDFjNWRmMzNhXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwidWxcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZV9fYWN0aW9uc1wifSxcIl9pZFwiOlwiZWxlbWVudC1mN2I1MTFkZDIzZjRmNTM5YWIwZGUwOGYwOTJiMWNiOVwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgICAgICAgXCIsXCJfaWRcIjpcInRleHQtMjVjMjhlYzJlNjgwYzllYjk5ZTc1MTc1YTEyMDgzMTdcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJsaVwiLFwiYXR0cmlidXRlc1wiOnt9LFwiX2lkXCI6XCJlbGVtZW50LWNiMWQwNDU5ZjNiMjA0OTRiNTFhNDI5ZmU0ZDBiYjMzXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwic3BhblwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJjb21wb3Nlci1ub2RlX19hY3Rpb24gY29tcG9zZXItbm9kZV9fY29sbGFwc2UtY2hpbGRyZW5cIn0sXCJfaWRcIjpcImVsZW1lbnQtNmVjYzMyYmExZDhlNDk4ODVhM2U0ZDMzNDcxYzBiODdcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJpXCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImZhIGZhLW1pbnVzLXNxdWFyZSBmYS1sZ1wifSxcIl9pZFwiOlwiZWxlbWVudC1mY2JiZTU3NWJiNTUxOWRlMWQ1M2U4ZDQ3YmQzMzVjYVwifSxcImNoaWxkcmVuXCI6W119XX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICAgICAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWYyM2UxMjA2OTRmNTczYThjZjY5YmQ1ZGVkMjE5NmZjXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwibGlcIixcImF0dHJpYnV0ZXNcIjp7fSxcIl9pZFwiOlwiZWxlbWVudC02YzkyMWE2MjA1MjRkYzAzMzE3MzdiMmZiNDdhMjkxZlwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcInNwYW5cIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZV9fYWN0aW9uIGNvbXBvc2VyLW5vZGVfX2V4cGFuZC1jaGlsZHJlblwifSxcIl9pZFwiOlwiZWxlbWVudC0yMzQ0YzdiMmI3N2M5YWM0NWM3MDBiMjYxZWE3YWE4OFwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImlcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiZmEgZmEtcGx1cy1zcXVhcmUgZmEtbGdcIn0sXCJfaWRcIjpcImVsZW1lbnQtNGZiZjk5MjMyNTQ2OGQ1MDY4YWU2NmVjN2YxNmNhYWZcIn0sXCJjaGlsZHJlblwiOltdfV19XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICAgICAgXCIsXCJfaWRcIjpcInRleHQtN2M4MzdmYzIxN2YyMzYzZTc5MmNhZjlhYjA5MjdhMTdcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgICBcIixcIl9pZFwiOlwidGV4dC01MzEyZjI3NDE3NjY2MTZmMWY4NzVlMWU2MzBkODY3NlwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTc4MzI0NDlmNTk0YTEyNzdjMjJlZGQ5M2NlYjQyNzQ3XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwidWxcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLWRyYWdzb3VyY2VcIjpcImNvbXBvc2VyXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTIyMzIxMTU2ZDI3NTc4ZDdiOTYyNGVhNzgyMTI5NjMyXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICBcIixcIl9pZFwiOlwidGV4dC1hZDhmOTllYzhjMDAzOTIxNjVhOTEwMmJmZjM0MTI3NFwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtZDZlMTFkOWFlZjcyN2FhN2ZhYTQ0N2UxYjE1NjEzYzVcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICBcIixcIl9pZFwiOlwidGV4dC1hZWJlMDAxZDE3NWUwOWIyZGY5MGEyYmQ0ODNhMDdlYlwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG5cIixcIl9pZFwiOlwidGV4dC0xYTM3ODZkOGMxNzI5OTBmMDJkNzgwMzJiYTFjYjIzMVwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG5cIixcIl9pZFwiOlwidGV4dC0yODZhOGZhMGYyYTQyODliZjkyZDZmNzgwMzg2NTRlNlwifSxcImNoaWxkcmVuXCI6W119XX0sXCJkb2N1bWVudFwiOntcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImRvY3VtZW50RnJhZ21lbnRcIixcIl9pZFwiOlwiZG9jdW1lbnRmcmFnbWVudC1iMGI3MDVmNjE3Y2JhYWQwYmI4NzY1MDdiOGM2NzIxMVwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImRvY3VtZW50VHlwZVwiLFwiX2lkXCI6XCJkb2N1bWVudFR5cGUtY2I4MGZkNmFiNzk0MTM3MWEzZTEyMmYzNTM2YWFkOTlcIixcIm5hbWVcIjpcImh0bWxcIixcInB1YmxpY0lkXCI6XCJcIixcInN5c3RlbUlkXCI6XCJcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LTBlODU4MjFlM2NmMjhjOTRhNmJkMDlkMGU2YmRjN2NkXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiaHRtbFwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJuby1qc1wiLFwibGFuZ1wiOlwiZW5cIn0sXCJfaWRcIjpcImVsZW1lbnQtZDgzOTk3YTI4N2U5ZTY0Y2JlNWNjZWE5M2Y5NWExMGRcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgXCIsXCJfaWRcIjpcInRleHQtNTc1Y2U3NDkwY2IzZDFiMzZkZDFiMjY1YWVlYzgxYjlcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJoZWFkXCIsXCJhdHRyaWJ1dGVzXCI6e30sXCJfaWRcIjpcImVsZW1lbnQtM2I1N2QwZjc4Y2RjOTg1Mzc2MjIyZDAxZjkzZGY1NjRcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC00Y2ZkOTIyZTZmNDAwZjhmY2Y5NjUyNGNiMWYwYzZiNFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcIm1ldGFcIixcImF0dHJpYnV0ZXNcIjp7XCJjaGFyc2V0XCI6XCJ1dGYtOFwifSxcIl9pZFwiOlwiZWxlbWVudC01YzYyZjFiM2I2ZGE5NjUxZDU4NjE5ZmM5NGE3NjZhZVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWFiMGI3ZTUwOGUzOWI2YTMwMWQ4ZjZmNzY2ODhlZjc0XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwibWV0YVwiLFwiYXR0cmlidXRlc1wiOntcIm5hbWVcIjpcInZpZXdwb3J0XCIsXCJjb250ZW50XCI6XCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MS4wXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTY3NWJhYzY2Y2RlOTdiNDQ3Njc2YzRiNTM0NWY4YmQzXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtNjg5OTBiNDE4NGU3MjdjNDA0MzNhZmQ5MDgxNjM0MmNcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJ0aXRsZVwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtdGV4dFwiOlwiZG9jdW1lbnRUaXRsZVwifSxcIl9pZFwiOlwiZWxlbWVudC1mMDZhOTgzY2YwNzljZjQ1NmUzZGI4NThhNDdmM2JiNVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWUzYmJlNjU4M2Y3NTY0MjNiMGUxNTk2Y2QzZTY1NmQxXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZnJhZ21lbnRcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLWVhY2hcIjpcImhlYWRTdHlsZXNcIn0sXCJfaWRcIjpcImVsZW1lbnQtMmY0ZGUyZTM5ZWFiZGEwZjdiYjQwYjQ5YWE5MDI3ZDdcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTI3YTVjMGMyOWM3ODBiYTQ3MTlkMzU1MDM3NGIyZGZiXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZnJhZ21lbnRcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLWluY2x1ZGVcIjpcInN0eWxlXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTFmMjg0Nzg2ZmNmMDdmY2YzZWQwZGQxYTVjOTJiM2FjXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtOGIwNjMzNTIxNDJmNDYzODdhMWNlODg1OTMwYWEwZDRcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTYzYzc4MDBiYzkwYzdkOGQ5NWUxZjcyN2I1NmMzM2FmXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZnJhZ21lbnRcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLWVhY2hcIjpcImhlYWRTY3JpcHRzXCJ9LFwiX2lkXCI6XCJlbGVtZW50LWI0MzNkN2IyY2MxODZiZTU0NzljZjdhZjhiZmVlYTk0XCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICBcIixcIl9pZFwiOlwidGV4dC05M2Y4YTJmM2Q4NTYzNzk1MDc2NThjM2Y2N2VmNmViZVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImZyYWdtZW50XCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS1pbmNsdWRlXCI6XCJzY3JpcHRcIn0sXCJfaWRcIjpcImVsZW1lbnQtZWVlODJkNjg2ZmExZTdhYzUzMzA2NDRiYmMyNDk5NDhcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC03YzM3OGFlMjVjYmVkYWYwZGU5MDJlNDhiYTY0YmM4N1wifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gIFwiLFwiX2lkXCI6XCJ0ZXh0LWU4NTUyOWVkM2MwOGE2MzQ4NTFmMDQxZWRiNmNlOTE4XCJ9LFwiY2hpbGRyZW5cIjpbXX1dfV19XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gIFwiLFwiX2lkXCI6XCJ0ZXh0LTliYTNiNmY3NTgyNTUyZTg2ZjZkYWEyMmNhYjMzNzlhXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiYm9keVwiLFwiYXR0cmlidXRlc1wiOnt9LFwiX2lkXCI6XCJlbGVtZW50LWY1N2RjY2MxMmFlZmI0MzhiMmY2MTNlMjRkMTFiMWYyXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtZTMwMTNmODI1ZWEyNWIwNmQ3NWNiYTRiM2RiMzJlYjZcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJkaXZcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLWNvbnRhaW5lclwiOlwiXCIsXCJkYXRhLWh0bWxcIjpcImJvZHlcIn0sXCJfaWRcIjpcImVsZW1lbnQtZmNhYzYxYmFhNjk2ODYwMzA3OTAwMDU1MjhlNDVlMWZcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC01ZDc0ODYxYjg4OWNkMTAyYmQ1ZDMyMWUwNjFhNzMwNlwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImZyYWdtZW50XCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS1lYWNoXCI6XCJzY3JpcHRzXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTA3NGQwOThmNjBkYjU2ZjYyZjVmMjU0NGJjZmNhMDQ5XCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICBcIixcIl9pZFwiOlwidGV4dC1kZjJhNmU5ZGJkNmJiZjhhNTUyYjk3Zjk2YWY2NDc4ZFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImZyYWdtZW50XCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS1pbmNsdWRlXCI6XCJzY3JpcHRcIn0sXCJfaWRcIjpcImVsZW1lbnQtNTc2NjBiZjdmODRkOWIxZWYwZTRlY2Q1YzJhNzcyMzRcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC1iNjE3ZjMyODBhYmYwNjViNTk5ODYwYTE1MzdlZTc1MlwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gIFwiLFwiX2lkXCI6XCJ0ZXh0LTNlOGExMzE1NjZmNWZhMzY1NmZkNjZmMjA0ZGE1Yzc1XCJ9LFwiY2hpbGRyZW5cIjpbXX1dfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuXCIsXCJfaWRcIjpcInRleHQtZWVmNDNiNjJiMjEyZjhhZjYxYTYzZWJlMjBmZDRmYmNcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuXCIsXCJfaWRcIjpcInRleHQtZGUxNWUxZDM1Yzg0M2E1NTc1MTE5NzQxNDQyZDFkYjZcIn0sXCJjaGlsZHJlblwiOltdfV19LFwic2NyaXB0XCI6e1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZG9jdW1lbnRGcmFnbWVudFwiLFwiX2lkXCI6XCJkb2N1bWVudGZyYWdtZW50LWQyNWI0NmY1YTU4Yjg0NWI5NDdiMjVkNWFjMTJlNDA5XCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZnJhZ21lbnRcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLWlmXCI6XCJ0ZXh0XCJ9LFwiX2lkXCI6XCJlbGVtZW50LWQzNjc3ZDBjMjM4NmY1ZjRmNGI4ZTdjZGU4NmZhZjhjXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gIFwiLFwiX2lkXCI6XCJ0ZXh0LWVjYTUxMDFjNGIyMWEwYzIyMjFiODBlMTEzY2M4YmNjXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwic2NyaXB0XCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS1odG1sXCI6XCJ0ZXh0XCJ9LFwiX2lkXCI6XCJlbGVtZW50LTNmNzlhZTZkODkzYWJlMDgxOGQ5ZDcwMDU0MDk1ZDY4XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG5cIixcIl9pZFwiOlwidGV4dC1hMDNlODg1ZTBhZDI2YWEwMjAwZmUyOTBmNWQ5Y2EzZlwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG5cIixcIl9pZFwiOlwidGV4dC00MjI2MzRiMGIwMTEyMDI5NWVjMjYwYmFkNmU1YjQwZlwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImZyYWdtZW50XCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS1pZlwiOlwic3JjXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTdkZTRmYjgxN2FkZTVlZmNiMWU5M2RkM2JhMzNhM2Q1XCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gIFwiLFwiX2lkXCI6XCJ0ZXh0LWRhYWFmOTY1Yzg5ZTE3YjA3NGU0MDk4ZTI3ZDUyZGEzXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwic2NyaXB0XCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS10YWdcIjpcInNyY1wifSxcIl9pZFwiOlwiZWxlbWVudC01NTA5YzA3Mzg3MDJhMDRiNzRjMjllNDU4NDY1ZThmNFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuXCIsXCJfaWRcIjpcInRleHQtZWViYTYwODYwNDVkMzE3MjZiNGMxMTk1OTU1NWNkZWZcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuXCIsXCJfaWRcIjpcInRleHQtZjJhYWI4ZTgzZWIzNDE0ODRkM2Y4ZDYwZjExMTFjZWVcIn0sXCJjaGlsZHJlblwiOltdfV19LFwic3R5bGVcIjp7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJkb2N1bWVudEZyYWdtZW50XCIsXCJfaWRcIjpcImRvY3VtZW50ZnJhZ21lbnQtNThlYjYzOGI5ZGZmYjJjOGUwNWEyMmZjZGZkZjUzYWJcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJmcmFnbWVudFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtaWZcIjpcInRleHRcIn0sXCJfaWRcIjpcImVsZW1lbnQtZmMwNmFlOTFkNjliNzJlYWY2MTk4NzNlNzVjNzZhZGNcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgXCIsXCJfaWRcIjpcInRleHQtN2ZhMjk4ZWQwNDFiYTVkYTI2NTQxNzM5YjNiYTMxZmJcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJzdHlsZVwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtaHRtbFwiOlwidGV4dFwifSxcIl9pZFwiOlwiZWxlbWVudC0wYzM5MWQ2ZGI0ZmU2N2ZmMzMwYzA4OTVmOTkwYmRlMVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuXCIsXCJfaWRcIjpcInRleHQtMjgwNzIyNzFkODdhZDExODI3YWIwZTNkY2U4M2EwYTlcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuXCIsXCJfaWRcIjpcInRleHQtYWNiMzhkYzU5NTNkZmRlMjg2YzZmOTUwMDQyOGVkMjNcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJmcmFnbWVudFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtaWZcIjpcInNyY1wifSxcIl9pZFwiOlwiZWxlbWVudC1mMWNiMGJiOTA2ZDMzNGVkMzkwMDZlNjQzZDYwZDllNFwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICBcIixcIl9pZFwiOlwidGV4dC1mOThhZWU5M2ZhYmVlOTBjOGVhZjk5OWVkZWFkMWRhOFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImxpbmtcIixcImF0dHJpYnV0ZXNcIjp7XCJyZWxcIjpcInN0eWxlc2hlZXRcIixcImRhdGEtdGFnXCI6XCJzcmNcIn0sXCJfaWRcIjpcImVsZW1lbnQtYmQ3Njk2YjU2NDU3NDA4Y2VjYzBlYjAzYmE3NzM4MDlcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LWM2ZDI1MmQzNWY1YzBiZWY1ODdlZWNkM2Y4MWQwYTY2XCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LWY2NjcxZGQ2MTQxMmU4MDMyMzhiYTg0YjEwMzAyOWRlXCJ9LFwiY2hpbGRyZW5cIjpbXX1dfX0sXCJzY2hlbWFzXCI6e1wiY29tcG9zZXItbm9kZVwiOntcImlkXCI6XCJjb21wb3Nlci1ub2RlXCIsXCJ0eXBlXCI6XCJvYmplY3RcIixcInByb3BlcnRpZXNcIjp7XCJpZFwiOntcIiRyZWZcIjpcIm5vbkVtcHR5U3RyaW5nXCJ9LFwidGl0bGVcIjp7XCIkcmVmXCI6XCJub25FbXB0eVN0cmluZ1wifSxcInRyZWVUeXBlXCI6e1wiJHJlZlwiOlwibm9uRW1wdHlTdHJpbmdcIn0sXCJub2RlVHlwZVwiOntcIiRyZWZcIjpcIm5vbkVtcHR5U3RyaW5nXCJ9LFwiZGVwdGhcIjp7XCJ0eXBlXCI6XCJpbnRlZ2VyXCJ9LFwiaXNFbXB0eVwiOntcInR5cGVcIjpcImJvb2xlYW5cIn0sXCJpc0NvbGxhcHNlZFwiOntcInR5cGVcIjpcImJvb2xlYW5cIn0sXCJpc0NoaWxkcmVuQ29sbGFwc2VkXCI6e1widHlwZVwiOlwiYm9vbGVhblwifSxcInByZXZpZXdcIjp7XCIkcmVmXCI6XCJub25FbXB0eVN0cmluZ1wifSxcImNoaWxkcmVuVGl0bGVcIjp7XCIkcmVmXCI6XCJub25FbXB0eVN0cmluZ1wifX0sXCJyZXF1aXJlZFwiOltcImlkXCIsXCJ0aXRsZVwiLFwidHJlZVR5cGVcIixcIm5vZGVUeXBlXCIsXCJkZXB0aFwiLFwicHJldmlld1wiLFwiY2hpbGRyZW5UaXRsZVwiXX0sXCJkb2N1bWVudFwiOntcImlkXCI6XCJkb2N1bWVudFwiLFwidHlwZVwiOlwib2JqZWN0XCIsXCJwcm9wZXJ0aWVzXCI6e1wiZG9jdW1lbnRUaXRsZVwiOntcIiRyZWZcIjpcIm5vbkVtcHR5U3RyaW5nXCJ9LFwiaGVhZFN0eWxlc1wiOntcInR5cGVcIjpcImFycmF5XCIsXCJpdGVtc1wiOntcIiRyZWZcIjpcInN0eWxlXCJ9fSxcImhlYWRTY3JpcHRzXCI6e1widHlwZVwiOlwiYXJyYXlcIixcIml0ZW1zXCI6e1wiJHJlZlwiOlwic2NyaXB0XCJ9fSxcInNjcmlwdHNcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwiaXRlbXNcIjp7XCIkcmVmXCI6XCJzY3JpcHRcIn19fSxcInJlcXVpcmVkXCI6W1wiZG9jdW1lbnRUaXRsZVwiXX0sXCJzY3JpcHRcIjp7XCJpZFwiOlwic2NyaXB0XCIsXCIkcmVmXCI6XCJodG1sUmVzb3VyY2VcIn0sXCJzdHlsZVwiOntcImlkXCI6XCJzdHlsZVwiLFwiJHJlZlwiOlwiaHRtbFJlc291cmNlXCJ9LFwiY29tcG9uZW50Q29uZmlnXCI6e1wiaWRcIjpcImNvbXBvbmVudENvbmZpZ1wiLFwidHlwZVwiOlwib2JqZWN0XCIsXCJwcm9wZXJ0aWVzXCI6e1wiY29udGFpbmVyU2VsZWN0b3JcIjp7XCIkcmVmXCI6XCJub25FbXB0eVN0cmluZ1wifX19LFwiaHRtbFJlc291cmNlXCI6e1wiaWRcIjpcImh0bWxSZXNvdXJjZVwiLFwib25lT2ZcIjpbe1wiJHJlZlwiOlwiaHRtbFJlc291cmNlVGV4dFwifSx7XCIkcmVmXCI6XCJodG1sUmVzb3VyY2VTcmNcIn1dfSxcImh0bWxSZXNvdXJjZVNyY1wiOntcImlkXCI6XCJodG1sUmVzb3VyY2VTcmNcIixcInR5cGVcIjpcIm9iamVjdFwiLFwicHJvcGVydGllc1wiOntcInNyY1wiOntcInR5cGVcIjpcInN0cmluZ1wifX0sXCJyZXF1aXJlZFwiOltcInNyY1wiXX0sXCJodG1sUmVzb3VyY2VUZXh0XCI6e1wiaWRcIjpcImh0bWxSZXNvdXJjZVRleHRcIixcInR5cGVcIjpcIm9iamVjdFwiLFwicHJvcGVydGllc1wiOntcInRleHRcIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIn19LFwicmVxdWlyZWRcIjpbXCJ0ZXh0XCJdfSxcIm5vbkVtcHR5U3RyaW5nXCI6e1wiaWRcIjpcIm5vbkVtcHR5U3RyaW5nXCIsXCJ0eXBlXCI6XCJzdHJpbmdcIixcInBhdHRlcm5cIjpcIl4oPyFcXFxccyokKS4rXCJ9fSxcImRlZmF1bHRNb2RlbHNcIjp7XCJkb2N1bWVudFwiOntcImRvY3VtZW50VGl0bGVcIjpcIk5ldyBEb2N1bWVudFwifX0sXCJjb25maWdzXCI6e1wiY29tcG9zZXJcIjp7XCJjb250YWluZXJTZWxlY3RvclwiOlwiLmNvbXBvc2VyXCJ9LFwiY29tcG9zZXItbm9kZVwiOntcImNvbnRhaW5lclNlbGVjdG9yXCI6XCIuY29tcG9zZXItbm9kZV9fY2hpbGRyZW4gPiB1bFwifSxcImRvY3VtZW50XCI6e1wiY29udGFpbmVyU2VsZWN0b3JcIjpcImJvZHkgPiBbZGF0YS1jb250YWluZXJdXCJ9fSxcInRyYW5zZm9ybXNcIjp7XCJjb21wb3Nlci1ub2RlXCI6e1wibm9kZVRhZ1wiOlt7XCIkaWZcIjpbe1wiJHZhbHVlXCI6XCJpc0NvbGxhcHNlZFwifSx7XCJhZGRDbGFzc1wiOlwiY29tcG9zZXItbm9kZS0tY29sbGFwc2VkXCJ9XX0se1wiJGlmXCI6W3tcIiR2YWx1ZVwiOlwiaXNFbXB0eVwifSx7XCJhZGRDbGFzc1wiOlwiY29tcG9zZXItbm9kZS0tZW1wdHlcIn1dfSx7XCJhdHRyXCI6W1wiaWRcIix7XCIkdmFsdWVcIjpcImlkXCJ9XX0se1wiYXR0clwiOltcImRhdGEtdHJlZVR5cGVcIix7XCIkdmFsdWVcIjpcInRyZWVUeXBlXCJ9XX0se1wiYXR0clwiOltcImRhdGEtbm9kZVR5cGVcIix7XCIkdmFsdWVcIjpcIm5vZGVUeXBlXCJ9XX0se1wiYXR0clwiOltcImRhdGEtZGVwdGhcIix7XCIkdmFsdWVcIjpcImRlcHRoXCJ9XX1dLFwiY2hpbGRXcmFwcGVyVGFnXCI6W3tcIiRpZlwiOlt7XCIkdmFsdWVcIjpcImlzQ2hpbGRyZW5Db2xsYXBzZWRcIn0se1wiYWRkQ2xhc3NcIjpcImNvbXBvc2VyLW5vZGVfX2NoaWxkcmVuLS1jb2xsYXBzZWRcIn1dfSx7XCJhdHRyXCI6W1wiaWRcIix7XCIkdmFsdWVcIjpcImlkXCJ9XX1dfSxcInNjcmlwdFwiOntcInNyY1wiOntcIiRpZlwiOlt7XCIkdmFsdWVcIjpcInNyY1wifSx7XCJhdHRyXCI6W1wic3JjXCIse1wiJHZhbHVlXCI6XCJzcmNcIn1dfV19fSxcInN0eWxlXCI6e1wic3JjXCI6e1wiJGlmXCI6W3tcIiR2YWx1ZVwiOlwic3JjXCJ9LHtcImF0dHJcIjpbXCJocmVmXCIse1wiJHZhbHVlXCI6XCJzcmNcIn1dfV19fX0sXCJjb21wb25lbnROYW1lc1wiOltcImNvbXBvc2VyXCIsXCJjb21wb3Nlci1ub2RlXCIsXCJkb2N1bWVudFwiLFwic2NyaXB0XCIsXCJzdHlsZVwiXSxcImNvbXBvbmVudHNcIjp7XCJjb21wb3NlclwiOntcImNvbmZpZ1wiOntcImNvbnRhaW5lclNlbGVjdG9yXCI6XCIuY29tcG9zZXJcIn0sXCJzdHlsZVwiOlwiLmNvbXBvc2VyIHtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAyO1xcclxcbn1cXHJcXG5cXHJcXG4uY29tcG9zZXItbm9kZSB7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbi5jb21wb3Nlci1ub2RlX190b29sYmFyIHtcXHJcXG4gIG1pbi1oZWlnaHQ6IDNlbTtcXHJcXG5cXHJcXG4gIGJhY2tncm91bmQ6ICM2NjY7XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG4gIGJvcmRlcjogMC4wNjI1cmVtIHNvbGlkICM4ODc7XFxyXFxuICBib3JkZXItYm90dG9tOiAwLjA2MjVyZW0gc29saWQgIzQ0NTtcXHJcXG4gIGJvcmRlci1yaWdodDogMC4wNjI1cmVtIHNvbGlkICM0NDU7XFxyXFxuICBib3gtc2hhZG93OiAwLjEyNXJlbSAwLjEyNXJlbSAwLjVyZW0gcmdiYSggMCwgMCwgMCwgMC4yNSApO1xcclxcbiAgdGV4dC1zaGFkb3c6IDAuMDYyNXJlbSAwLjA2MjVyZW0gMCAjMzM1O1xcclxcbn1cXHJcXG5cXHJcXG4uY29tcG9zZXItbm9kZV9fdGl0bGUge1xcclxcbiAgbGluZS1oZWlnaHQ6IDM7XFxyXFxuICBwYWRkaW5nOiAwIDFyZW07XFxyXFxufVxcclxcblxcclxcbi5jb21wb3Nlci1ub2RlX19jaGlsZHJlbiA+IC5jb21wb3Nlci1ub2RlX190b29sYmFyIHtcXHJcXG4gIGJhY2tncm91bmQ6ICMwNWI7XFxyXFxuICBib3JkZXI6IDAuMDYyNXJlbSBzb2xpZCAjMjdjO1xcclxcbiAgYm9yZGVyLWJvdHRvbTogMC4wNjI1cmVtIHNvbGlkICMwNGI7XFxyXFxuICBib3JkZXItcmlnaHQ6IDAuMDYyNXJlbSBzb2xpZCAjMDRiO1xcclxcbiAgdGV4dC1zaGFkb3c6IDAuMDYyNXJlbSAwLjA2MjVyZW0gMCAjMDNiO1xcclxcbn1cXHJcXG5cXHJcXG4uY29tcG9zZXItbm9kZS0tZW1wdHkgPiAuY29tcG9zZXItbm9kZV9fdG9vbGJhciB7XFxyXFxuICBiYWNrZ3JvdW5kOiAjZWVlO1xcclxcbiAgY29sb3I6ICMyMjI7XFxyXFxuICBib3JkZXI6IDAuMDYyNXJlbSBzb2xpZCAjZmZlO1xcclxcbiAgYm9yZGVyLWJvdHRvbTogMC4wNjI1cmVtIHNvbGlkICNjY2Q7XFxyXFxuICBib3JkZXItcmlnaHQ6IDAuMDYyNXJlbSBzb2xpZCAjY2NkO1xcclxcbiAgdGV4dC1zaGFkb3c6IDAuMDYyNXJlbSAwLjA2MjVyZW0gMCAjYmJkO1xcclxcbn1cXHJcXG5cXHJcXG4uY29tcG9zZXItbm9kZTpub3QoIFtkYXRhLWRlcHRoPVxcXCIwXFxcIl0gKSA+IC5jb21wb3Nlci1ub2RlX190b29sYmFyIHtcXHJcXG4gIGN1cnNvcjogbW92ZTtcXHJcXG59XFxyXFxuXFxyXFxuLmNvbXBvc2VyLW5vZGVfX3ZpZXcge1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMWVtO1xcclxcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG59XFxyXFxuXFxyXFxuLmNvbXBvc2VyLW5vZGVfX3ZpZXc6bGFzdC1jaGlsZCB7XFxyXFxuICBtYXJnaW4tYm90dG9tOiAwO1xcclxcbn1cXHJcXG5cXHJcXG4uY29tcG9zZXItbm9kZV9fbWFpbiB7XFxyXFxuICBwYWRkaW5nOiAwLjc1cmVtO1xcclxcbiAgbWFyZ2luOiAwLjI1cmVtO1xcclxcbiAgbWFyZ2luLXRvcDogMDtcXHJcXG5cXHJcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuICBib3gtc2hhZG93OiAwLjEyNXJlbSAwLjEyNXJlbSAwLjVyZW0gcmdiYSggMCwgMCwgMCwgMC4yNSApO1xcclxcbiAgYm9yZGVyLWJvdHRvbTogMC4wNjI1cmVtIHNvbGlkICNlZWU7XFxyXFxufVxcclxcblxcclxcbi5jb21wb3Nlci1ub2RlLS1jb2xsYXBzZWQgPiAuY29tcG9zZXItbm9kZV9fbWFpbixcXHJcXG4uY29tcG9zZXItbm9kZV9fY2hpbGRyZW4tLWNvbGxhcHNlZCA+IC5jb21wb3Nlci1ub2RlX19tYWluIHtcXHJcXG4gIGhlaWdodDogMDtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG4gIHBhZGRpbmc6IDA7XFxyXFxuICBib3JkZXI6IDA7XFxyXFxuICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbn1cXHJcXG5cXHJcXG4uY29tcG9zZXItbm9kZV9fY2hpbGRyZW4ge1xcclxcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG5cXHJcXG4gIGJveC1zaGFkb3c6IGluc2V0IDAuMTI1cmVtIDAuMTI1cmVtIDAuNXJlbSByZ2JhKCAwLCAwLCAwLCAwLjI1ICk7XFxyXFxuICBiYWNrZ3JvdW5kOiAjZWVmO1xcclxcbn1cXHJcXG5cXHJcXG4uY29tcG9zZXItbm9kZV9fY2hpbGRyZW4gPiB1bCB7XFxyXFxuICBtYXJnaW46IDA7XFxyXFxuICBwYWRkaW5nOiAwLjVyZW07XFxyXFxuICBsaXN0LXN0eWxlOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4uY29tcG9zZXItbm9kZV9fY2hpbGRyZW4tLWNvbGxhcHNlZCA+IHVsIHtcXHJcXG4gIGhlaWdodDogMDtcXHJcXG4gIHBhZGRpbmc6IDA7XFxyXFxuICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbn1cXHJcXG5cXHJcXG4uY29tcG9zZXItbm9kZV9fY2hpbGRyZW4gPiB1bCA+IGxpIHtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG4gIHBhZGRpbmc6IDA7XFxyXFxufVxcclxcblxcclxcbi5jb21wb3Nlci1ub2RlX19hY3Rpb25zIHtcXHJcXG4gIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgZmxvYXQ6IHJpZ2h0O1xcclxcbn1cXHJcXG5cXHJcXG4uY29tcG9zZXItbm9kZV9fYWN0aW9ucyA+IGxpIHtcXHJcXG4gIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgZmxvYXQ6IGxlZnQ7XFxyXFxufVxcclxcblxcclxcbi5jb21wb3Nlci1ub2RlX19hY3Rpb24ge1xcclxcbiAgZGlzcGxheTogYmxvY2s7XFxyXFxuICBwYWRkaW5nOiAwO1xcclxcbiAgZm9udC1zaXplOiAxcmVtO1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuODc1cmVtO1xcclxcbiAgd2lkdGg6IDEuODc1cmVtO1xcclxcbiAgbWFyZ2luOiAwLjVyZW0gMDtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gIGN1cnNvcjogZGVmYXVsdDtcXHJcXG5cXHJcXG4gIGJhY2tncm91bmQ6ICMzOWY7XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG4gIGJvcmRlcjogMC4wNjI1cmVtIHNvbGlkICM1YmY7XFxyXFxuICBib3JkZXItcmlnaHQ6IDAuMDYyNXJlbSBzb2xpZCAjMTdmO1xcclxcbiAgYm9yZGVyLWJvdHRvbTogMC4wNjI1cmVtIHNvbGlkICMxN2Y7XFxyXFxuICB0ZXh0LXNoYWRvdzogMC4wNjI1cmVtIDAuMDYyNXJlbSAwICMwNmY7XFxyXFxufVxcclxcblxcclxcbi5jb21wb3Nlci1ub2RlX19hY3Rpb25zID4gbGk6bGFzdC1jaGlsZCAuY29tcG9zZXItbm9kZV9fYWN0aW9uIHtcXHJcXG4gIG1hcmdpbi1yaWdodDogMC41cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uY29tcG9zZXItbm9kZV9fZGVsZXRlIHtcXHJcXG4gIGJhY2tncm91bmQ6ICNkMjI7XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG4gIGJvcmRlcjogMC4wNjI1cmVtIHNvbGlkICNmNDM7XFxyXFxuICBib3JkZXItcmlnaHQ6IDAuMDYyNXJlbSBzb2xpZCAjYjA0O1xcclxcbiAgYm9yZGVyLWJvdHRvbTogMC4wNjI1cmVtIHNvbGlkICNiMDQ7XFxyXFxuICB0ZXh0LXNoYWRvdzogMC4wNjI1cmVtIDAuMDYyNXJlbSAwICNhMDQ7XFxyXFxufVxcclxcblwiLFwidGVtcGxhdGVcIjp7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJkb2N1bWVudEZyYWdtZW50XCIsXCJfaWRcIjpcImRvY3VtZW50ZnJhZ21lbnQtNTJjMGE4YzkxOWI0OWM0ZjZkYTkxZTczYjllZDllMzRcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJkaXZcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXJcIn0sXCJfaWRcIjpcImVsZW1lbnQtOWU4MzQyNWQxNGNkOGUyNDU1NWRkODE1MjY4NjhkNDVcIn0sXCJjaGlsZHJlblwiOltdfV19fSxcImNvbXBvc2VyLW5vZGVcIjp7XCJjb25maWdcIjp7XCJjb250YWluZXJTZWxlY3RvclwiOlwiLmNvbXBvc2VyLW5vZGVfX2NoaWxkcmVuID4gdWxcIn0sXCJzY2hlbWFcIjp7XCJpZFwiOlwiY29tcG9zZXItbm9kZVwiLFwidHlwZVwiOlwib2JqZWN0XCIsXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjp7XCIkcmVmXCI6XCJub25FbXB0eVN0cmluZ1wifSxcInRpdGxlXCI6e1wiJHJlZlwiOlwibm9uRW1wdHlTdHJpbmdcIn0sXCJ0cmVlVHlwZVwiOntcIiRyZWZcIjpcIm5vbkVtcHR5U3RyaW5nXCJ9LFwibm9kZVR5cGVcIjp7XCIkcmVmXCI6XCJub25FbXB0eVN0cmluZ1wifSxcImRlcHRoXCI6e1widHlwZVwiOlwiaW50ZWdlclwifSxcImlzRW1wdHlcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCJ9LFwiaXNDb2xsYXBzZWRcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCJ9LFwiaXNDaGlsZHJlbkNvbGxhcHNlZFwiOntcInR5cGVcIjpcImJvb2xlYW5cIn0sXCJwcmV2aWV3XCI6e1wiJHJlZlwiOlwibm9uRW1wdHlTdHJpbmdcIn0sXCJjaGlsZHJlblRpdGxlXCI6e1wiJHJlZlwiOlwibm9uRW1wdHlTdHJpbmdcIn19LFwicmVxdWlyZWRcIjpbXCJpZFwiLFwidGl0bGVcIixcInRyZWVUeXBlXCIsXCJub2RlVHlwZVwiLFwiZGVwdGhcIixcInByZXZpZXdcIixcImNoaWxkcmVuVGl0bGVcIl19LFwidGVtcGxhdGVcIjp7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJkb2N1bWVudEZyYWdtZW50XCIsXCJfaWRcIjpcImRvY3VtZW50ZnJhZ21lbnQtYWEyZTg5YWE2OWEzNThjZDMxNWU3MGRlNzQwYmJkNzhcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJkaXZcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZVwiLFwiZGF0YS10YWdcIjpcIm5vZGVUYWdcIn0sXCJfaWRcIjpcImVsZW1lbnQtNTQxNjk0OTNlNzZiYTEwNzEyNzZjNWFlOTc1MjViZjZcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgXCIsXCJfaWRcIjpcInRleHQtYjk3Y2Y4OGU4MmVjMTIzMmQ1NTJkZTY3MzlhMDA0MzlcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJoZWFkZXJcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZV9fdG9vbGJhclwifSxcIl9pZFwiOlwiZWxlbWVudC1lZGMxM2QyZTNjYTVlZTQxMmRjNzMzM2NmZTZkNGRkM1wifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWVkMTg2YWRkZjU4MTBkMGY0YTU5ZTRkNTViZDdlYmM2XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwic3BhblwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJjb21wb3Nlci1ub2RlX190aXRsZVwiLFwiZGF0YS10ZXh0XCI6XCJ0aXRsZVwifSxcIl9pZFwiOlwiZWxlbWVudC05ZDg2MGY2MDk3NmRlOGZiYmJhNDExZTEwMWJiMjAwMFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTlmY2M4NTFmMGE5ZjYwNzZlMjQ2ZjMwY2IxZDI1MzY1XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwidWxcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZV9fYWN0aW9uc1wifSxcIl9pZFwiOlwiZWxlbWVudC02NWRiYTM4Y2M2NWUwY2U2YTM4MzQzMWUxNDlmMmYxYlwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgXCIsXCJfaWRcIjpcInRleHQtYTYxMjcwNWMzNzM0NjkyODIwMTg0NmYxZjYwNGZhZjRcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJsaVwiLFwiYXR0cmlidXRlc1wiOnt9LFwiX2lkXCI6XCJlbGVtZW50LTc3MTBkMDM1NTFkZTIyZTJjNTcyZjdmMzA0MWU3OWMzXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwic3BhblwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJjb21wb3Nlci1ub2RlX19hY3Rpb24gY29tcG9zZXItbm9kZV9fZGVsZXRlXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTMyN2EwMzAxMjZjODhkNGU4MjM4Mjc5OTQ5NzI3M2MzXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiaVwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJmYSBmYS10cmFzaCBmYS1sZ1wifSxcIl9pZFwiOlwiZWxlbWVudC1lMjQzYmQ1ZGY4ZjQzOWYxMDU3NDZlZWY3NTE4MWM3YlwifSxcImNoaWxkcmVuXCI6W119XX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC1hZWZhZGU0OTU3MGI5MzY2YTliMjBmNjdiNzVhODU3OVwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gIFwiLFwiX2lkXCI6XCJ0ZXh0LTA5Yjk3NjI2YTBhNmI5M2E0ZjliZmM2ZjNhMjIxZmM3XCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblxcclxcbiAgXCIsXCJfaWRcIjpcInRleHQtNWNmMDJhZmI3NTI0NzFlN2Q4NmRhMTVhNmI0NTYyMGRcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJkaXZcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZV9fbWFpblwifSxcIl9pZFwiOlwiZWxlbWVudC01YjFmOWU2ZWMwMDg5ZDY5MTAyNTY2YjRlNzAwNWRiM1wifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWM2NWY3Y2Y1ZTM4YzI4MWUxMjczYWFmZjA1OTAyNjlkXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZGl2XCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImNvbXBvc2VyLW5vZGVfX3ZpZXdcIn0sXCJfaWRcIjpcImVsZW1lbnQtYmU3NTY4MTM1Njk4YjVjNzYwMzNlZTkyMGRjODNiZWNcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTg4NTQxYzI3NTIyOGZmZmE4MTk5N2MzZTc2ZDFmMjA0XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiY29kZVwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtaHRtbFwiOlwicHJldmlld1wifSxcIl9pZFwiOlwiZWxlbWVudC1mOTAzN2EzMDEyMzUyNDc0YzI0ZGNiZTQzYTY5ZWE2ZFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWNkM2JlMDJmMGQ1OWJiM2ZkNDk2MzAyM2Q1ZGY2ODAyXCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC0xZjQzNTUxN2Y4MmYyMmRjNThjZWY4MzA4Y2Q0ZDAyNlwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImZyYWdtZW50XCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS1ub3RcIjpcImlzRW1wdHlcIn0sXCJfaWRcIjpcImVsZW1lbnQtZWFmNWFkY2UwNjRmOTA2NTFmZWM4MTUxOWI1MGM3ZTBcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTMzZjVkOGM2MDI5ZDIyOGI0ODI5MWJkNzQ5YmExODRmXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZGl2XCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImNvbXBvc2VyLW5vZGVfX2NoaWxkcmVuXCIsXCJkYXRhLXRhZ1wiOlwiY2hpbGRXcmFwcGVyVGFnXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTkxMzlhZDcwMTRlNDhiNDAwOGI0NjdjMjk3ZWE1ZDgzXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTFjMTc4M2EzZTExYTM5YWU3YjVlM2Q0NDIwZjYwYWZmXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiaGVhZGVyXCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImNvbXBvc2VyLW5vZGVfX3Rvb2xiYXJcIn0sXCJfaWRcIjpcImVsZW1lbnQtMTVmOTg0NTllZGQwOTdlMzk2MjYwMWI3YzQwOGFiNDBcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICAgICAgICBcIixcIl9pZFwiOlwidGV4dC00NzljYWZiZGQ5ZWZhYzczNGNmNjhiYTk0MGYwMzExOFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcInNwYW5cIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZV9fdGl0bGVcIixcImRhdGEtdGV4dFwiOlwiY2hpbGRyZW5UaXRsZVwifSxcIl9pZFwiOlwiZWxlbWVudC1iMWZmZjJkZjM1ZGI2OGVjYTgyMmJjNDU4MGJmNTY0MVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWI5ODRlZDMwMzJiYWM3MjMzMjU1YjJlZDFjNWRmMzNhXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwidWxcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZV9fYWN0aW9uc1wifSxcIl9pZFwiOlwiZWxlbWVudC1mN2I1MTFkZDIzZjRmNTM5YWIwZGUwOGYwOTJiMWNiOVwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgICAgICAgXCIsXCJfaWRcIjpcInRleHQtMjVjMjhlYzJlNjgwYzllYjk5ZTc1MTc1YTEyMDgzMTdcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJsaVwiLFwiYXR0cmlidXRlc1wiOnt9LFwiX2lkXCI6XCJlbGVtZW50LWNiMWQwNDU5ZjNiMjA0OTRiNTFhNDI5ZmU0ZDBiYjMzXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwic3BhblwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJjb21wb3Nlci1ub2RlX19hY3Rpb24gY29tcG9zZXItbm9kZV9fY29sbGFwc2UtY2hpbGRyZW5cIn0sXCJfaWRcIjpcImVsZW1lbnQtNmVjYzMyYmExZDhlNDk4ODVhM2U0ZDMzNDcxYzBiODdcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJpXCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImZhIGZhLW1pbnVzLXNxdWFyZSBmYS1sZ1wifSxcIl9pZFwiOlwiZWxlbWVudC1mY2JiZTU3NWJiNTUxOWRlMWQ1M2U4ZDQ3YmQzMzVjYVwifSxcImNoaWxkcmVuXCI6W119XX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICAgICAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWYyM2UxMjA2OTRmNTczYThjZjY5YmQ1ZGVkMjE5NmZjXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwibGlcIixcImF0dHJpYnV0ZXNcIjp7fSxcIl9pZFwiOlwiZWxlbWVudC02YzkyMWE2MjA1MjRkYzAzMzE3MzdiMmZiNDdhMjkxZlwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcInNwYW5cIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZV9fYWN0aW9uIGNvbXBvc2VyLW5vZGVfX2V4cGFuZC1jaGlsZHJlblwifSxcIl9pZFwiOlwiZWxlbWVudC0yMzQ0YzdiMmI3N2M5YWM0NWM3MDBiMjYxZWE3YWE4OFwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImlcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiZmEgZmEtcGx1cy1zcXVhcmUgZmEtbGdcIn0sXCJfaWRcIjpcImVsZW1lbnQtNGZiZjk5MjMyNTQ2OGQ1MDY4YWU2NmVjN2YxNmNhYWZcIn0sXCJjaGlsZHJlblwiOltdfV19XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICAgICAgXCIsXCJfaWRcIjpcInRleHQtN2M4MzdmYzIxN2YyMzYzZTc5MmNhZjlhYjA5MjdhMTdcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgICBcIixcIl9pZFwiOlwidGV4dC01MzEyZjI3NDE3NjY2MTZmMWY4NzVlMWU2MzBkODY3NlwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTc4MzI0NDlmNTk0YTEyNzdjMjJlZGQ5M2NlYjQyNzQ3XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwidWxcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLWRyYWdzb3VyY2VcIjpcImNvbXBvc2VyXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTIyMzIxMTU2ZDI3NTc4ZDdiOTYyNGVhNzgyMTI5NjMyXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICBcIixcIl9pZFwiOlwidGV4dC1hZDhmOTllYzhjMDAzOTIxNjVhOTEwMmJmZjM0MTI3NFwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtZDZlMTFkOWFlZjcyN2FhN2ZhYTQ0N2UxYjE1NjEzYzVcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICBcIixcIl9pZFwiOlwidGV4dC1hZWJlMDAxZDE3NWUwOWIyZGY5MGEyYmQ0ODNhMDdlYlwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG5cIixcIl9pZFwiOlwidGV4dC0xYTM3ODZkOGMxNzI5OTBmMDJkNzgwMzJiYTFjYjIzMVwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG5cIixcIl9pZFwiOlwidGV4dC0yODZhOGZhMGYyYTQyODliZjkyZDZmNzgwMzg2NTRlNlwifSxcImNoaWxkcmVuXCI6W119XX0sXCJ0cmFuc2Zvcm1cIjp7XCJub2RlVGFnXCI6W3tcIiRpZlwiOlt7XCIkdmFsdWVcIjpcImlzQ29sbGFwc2VkXCJ9LHtcImFkZENsYXNzXCI6XCJjb21wb3Nlci1ub2RlLS1jb2xsYXBzZWRcIn1dfSx7XCIkaWZcIjpbe1wiJHZhbHVlXCI6XCJpc0VtcHR5XCJ9LHtcImFkZENsYXNzXCI6XCJjb21wb3Nlci1ub2RlLS1lbXB0eVwifV19LHtcImF0dHJcIjpbXCJpZFwiLHtcIiR2YWx1ZVwiOlwiaWRcIn1dfSx7XCJhdHRyXCI6W1wiZGF0YS10cmVlVHlwZVwiLHtcIiR2YWx1ZVwiOlwidHJlZVR5cGVcIn1dfSx7XCJhdHRyXCI6W1wiZGF0YS1ub2RlVHlwZVwiLHtcIiR2YWx1ZVwiOlwibm9kZVR5cGVcIn1dfSx7XCJhdHRyXCI6W1wiZGF0YS1kZXB0aFwiLHtcIiR2YWx1ZVwiOlwiZGVwdGhcIn1dfV0sXCJjaGlsZFdyYXBwZXJUYWdcIjpbe1wiJGlmXCI6W3tcIiR2YWx1ZVwiOlwiaXNDaGlsZHJlbkNvbGxhcHNlZFwifSx7XCJhZGRDbGFzc1wiOlwiY29tcG9zZXItbm9kZV9fY2hpbGRyZW4tLWNvbGxhcHNlZFwifV19LHtcImF0dHJcIjpbXCJpZFwiLHtcIiR2YWx1ZVwiOlwiaWRcIn1dfV19fSxcImRvY3VtZW50XCI6e1wiY29uZmlnXCI6e1wiY29udGFpbmVyU2VsZWN0b3JcIjpcImJvZHkgPiBbZGF0YS1jb250YWluZXJdXCJ9LFwiZGVmYXVsdE1vZGVsXCI6e1wiZG9jdW1lbnRUaXRsZVwiOlwiTmV3IERvY3VtZW50XCJ9LFwic2NoZW1hXCI6e1wiaWRcIjpcImRvY3VtZW50XCIsXCJ0eXBlXCI6XCJvYmplY3RcIixcInByb3BlcnRpZXNcIjp7XCJkb2N1bWVudFRpdGxlXCI6e1wiJHJlZlwiOlwibm9uRW1wdHlTdHJpbmdcIn0sXCJoZWFkU3R5bGVzXCI6e1widHlwZVwiOlwiYXJyYXlcIixcIml0ZW1zXCI6e1wiJHJlZlwiOlwic3R5bGVcIn19LFwiaGVhZFNjcmlwdHNcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwiaXRlbXNcIjp7XCIkcmVmXCI6XCJzY3JpcHRcIn19LFwic2NyaXB0c1wiOntcInR5cGVcIjpcImFycmF5XCIsXCJpdGVtc1wiOntcIiRyZWZcIjpcInNjcmlwdFwifX19LFwicmVxdWlyZWRcIjpbXCJkb2N1bWVudFRpdGxlXCJdfSxcInN0eWxlXCI6XCIqIHtcXHJcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuICBtYXJnaW46IDA7XFxyXFxuICBwYWRkaW5nOiAwO1xcclxcbn1cXHJcXG5cXHJcXG5odG1sIHtcXHJcXG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xcclxcbn1cXHJcXG5cXHJcXG4uZ3UtdW5zZWxlY3RhYmxlIHtcXHJcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5ndS1taXJyb3Ige1xcclxcbiAgcG9zaXRpb246IGZpeGVkICFpbXBvcnRhbnQ7XFxyXFxuICBtYXJnaW46IDAgIWltcG9ydGFudDtcXHJcXG4gIHotaW5kZXg6IDk5OTkgIWltcG9ydGFudDtcXHJcXG4gIG9wYWNpdHk6IDAuODtcXHJcXG4gIC1tcy1maWx0ZXI6IFxcXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEoT3BhY2l0eT04MClcXFwiO1xcclxcbiAgZmlsdGVyOiBhbHBoYShvcGFjaXR5PTgwKTtcXHJcXG59XFxyXFxuXFxyXFxuLmd1LWhpZGUge1xcclxcbiAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG5cXHJcXG4uZ3UtdW5zZWxlY3RhYmxlIHtcXHJcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmUgIWltcG9ydGFudDtcXHJcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmUgIWltcG9ydGFudDtcXHJcXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZSAhaW1wb3J0YW50O1xcclxcbiAgdXNlci1zZWxlY3Q6IG5vbmUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuLmd1LXRyYW5zaXQge1xcclxcbiAgb3BhY2l0eTogMC4yO1xcclxcbiAgLW1zLWZpbHRlcjogXFxcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYShPcGFjaXR5PTIwKVxcXCI7XFxyXFxuICBmaWx0ZXI6IGFscGhhKG9wYWNpdHk9MjApO1xcclxcbn1cXHJcXG5cXHJcXG4ucmF0aW8ge1xcclxcbiAgd2lkdGg6IDRyZW07XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxufVxcclxcblxcclxcbi5yYXRpbyAuc2hpbSB7XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogMTAwJTtcXHJcXG59XFxyXFxuXFxyXFxuLnJhdGlvIC52aWV3cG9ydCB7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICB0b3A6IDA7XFxyXFxuICBsZWZ0OiAwO1xcclxcbiAgcmlnaHQ6IDA7XFxyXFxuICBib3R0b206IDA7XFxyXFxufVxcclxcblwiLFwidGVtcGxhdGVcIjp7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJkb2N1bWVudEZyYWdtZW50XCIsXCJfaWRcIjpcImRvY3VtZW50ZnJhZ21lbnQtYjBiNzA1ZjYxN2NiYWFkMGJiODc2NTA3YjhjNjcyMTFcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJkb2N1bWVudFR5cGVcIixcIl9pZFwiOlwiZG9jdW1lbnRUeXBlLWNiODBmZDZhYjc5NDEzNzFhM2UxMjJmMzUzNmFhZDk5XCIsXCJuYW1lXCI6XCJodG1sXCIsXCJwdWJsaWNJZFwiOlwiXCIsXCJzeXN0ZW1JZFwiOlwiXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG5cIixcIl9pZFwiOlwidGV4dC0wZTg1ODIxZTNjZjI4Yzk0YTZiZDA5ZDBlNmJkYzdjZFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImh0bWxcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwibm8tanNcIixcImxhbmdcIjpcImVuXCJ9LFwiX2lkXCI6XCJlbGVtZW50LWQ4Mzk5N2EyODdlOWU2NGNiZTVjY2VhOTNmOTVhMTBkXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gIFwiLFwiX2lkXCI6XCJ0ZXh0LTU3NWNlNzQ5MGNiM2QxYjM2ZGQxYjI2NWFlZWM4MWI5XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiaGVhZFwiLFwiYXR0cmlidXRlc1wiOnt9LFwiX2lkXCI6XCJlbGVtZW50LTNiNTdkMGY3OGNkYzk4NTM3NjIyMmQwMWY5M2RmNTY0XCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtNGNmZDkyMmU2ZjQwMGY4ZmNmOTY1MjRjYjFmMGM2YjRcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJtZXRhXCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2hhcnNldFwiOlwidXRmLThcIn0sXCJfaWRcIjpcImVsZW1lbnQtNWM2MmYxYjNiNmRhOTY1MWQ1ODYxOWZjOTRhNzY2YWVcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC1hYjBiN2U1MDhlMzliNmEzMDFkOGY2Zjc2Njg4ZWY3NFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcIm1ldGFcIixcImF0dHJpYnV0ZXNcIjp7XCJuYW1lXCI6XCJ2aWV3cG9ydFwiLFwiY29udGVudFwiOlwid2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMFwifSxcIl9pZFwiOlwiZWxlbWVudC02NzViYWM2NmNkZTk3YjQ0NzY3NmM0YjUzNDVmOGJkM1wifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTY4OTkwYjQxODRlNzI3YzQwNDMzYWZkOTA4MTYzNDJjXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwidGl0bGVcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLXRleHRcIjpcImRvY3VtZW50VGl0bGVcIn0sXCJfaWRcIjpcImVsZW1lbnQtZjA2YTk4M2NmMDc5Y2Y0NTZlM2RiODU4YTQ3ZjNiYjVcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC1lM2JiZTY1ODNmNzU2NDIzYjBlMTU5NmNkM2U2NTZkMVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImZyYWdtZW50XCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS1lYWNoXCI6XCJoZWFkU3R5bGVzXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTJmNGRlMmUzOWVhYmRhMGY3YmI0MGI0OWFhOTAyN2Q3XCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICBcIixcIl9pZFwiOlwidGV4dC0yN2E1YzBjMjljNzgwYmE0NzE5ZDM1NTAzNzRiMmRmYlwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImZyYWdtZW50XCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS1pbmNsdWRlXCI6XCJzdHlsZVwifSxcIl9pZFwiOlwiZWxlbWVudC0xZjI4NDc4NmZjZjA3ZmNmM2VkMGRkMWE1YzkyYjNhY1wifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LThiMDYzMzUyMTQyZjQ2Mzg3YTFjZTg4NTkzMGFhMGQ0XCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC02M2M3ODAwYmM5MGM3ZDhkOTVlMWY3MjdiNTZjMzNhZlwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImZyYWdtZW50XCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS1lYWNoXCI6XCJoZWFkU2NyaXB0c1wifSxcIl9pZFwiOlwiZWxlbWVudC1iNDMzZDdiMmNjMTg2YmU1NDc5Y2Y3YWY4YmZlZWE5NFwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgXCIsXCJfaWRcIjpcInRleHQtOTNmOGEyZjNkODU2Mzc5NTA3NjU4YzNmNjdlZjZlYmVcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJmcmFnbWVudFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtaW5jbHVkZVwiOlwic2NyaXB0XCJ9LFwiX2lkXCI6XCJlbGVtZW50LWVlZTgyZDY4NmZhMWU3YWM1MzMwNjQ0YmJjMjQ5OTQ4XCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtN2MzNzhhZTI1Y2JlZGFmMGRlOTAyZTQ4YmE2NGJjODdcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICBcIixcIl9pZFwiOlwidGV4dC1lODU1MjllZDNjMDhhNjM0ODUxZjA0MWVkYjZjZTkxOFwifSxcImNoaWxkcmVuXCI6W119XX1dfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICBcIixcIl9pZFwiOlwidGV4dC05YmEzYjZmNzU4MjU1MmU4NmY2ZGFhMjJjYWIzMzc5YVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImJvZHlcIixcImF0dHJpYnV0ZXNcIjp7fSxcIl9pZFwiOlwiZWxlbWVudC1mNTdkY2NjMTJhZWZiNDM4YjJmNjEzZTI0ZDExYjFmMlwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWUzMDEzZjgyNWVhMjViMDZkNzVjYmE0YjNkYjMyZWI2XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZGl2XCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS1jb250YWluZXJcIjpcIlwiLFwiZGF0YS1odG1sXCI6XCJib2R5XCJ9LFwiX2lkXCI6XCJlbGVtZW50LWZjYWM2MWJhYTY5Njg2MDMwNzkwMDA1NTI4ZTQ1ZTFmXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtNWQ3NDg2MWI4ODljZDEwMmJkNWQzMjFlMDYxYTczMDZcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJmcmFnbWVudFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtZWFjaFwiOlwic2NyaXB0c1wifSxcIl9pZFwiOlwiZWxlbWVudC0wNzRkMDk4ZjYwZGI1NmY2MmY1ZjI1NDRiY2ZjYTA0OVwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgXCIsXCJfaWRcIjpcInRleHQtZGYyYTZlOWRiZDZiYmY4YTU1MmI5N2Y5NmFmNjQ3OGRcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJmcmFnbWVudFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtaW5jbHVkZVwiOlwic2NyaXB0XCJ9LFwiX2lkXCI6XCJlbGVtZW50LTU3NjYwYmY3Zjg0ZDliMWVmMGU0ZWNkNWMyYTc3MjM0XCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtYjYxN2YzMjgwYWJmMDY1YjU5OTg2MGExNTM3ZWU3NTJcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICBcIixcIl9pZFwiOlwidGV4dC0zZThhMTMxNTY2ZjVmYTM2NTZmZDY2ZjIwNGRhNWM3NVwifSxcImNoaWxkcmVuXCI6W119XX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LWVlZjQzYjYyYjIxMmY4YWY2MWE2M2ViZTIwZmQ0ZmJjXCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LWRlMTVlMWQzNWM4NDNhNTU3NTExOTc0MTQ0MmQxZGI2XCJ9LFwiY2hpbGRyZW5cIjpbXX1dfX0sXCJzY3JpcHRcIjp7XCJzY2hlbWFcIjp7XCJpZFwiOlwic2NyaXB0XCIsXCIkcmVmXCI6XCJodG1sUmVzb3VyY2VcIn0sXCJ0ZW1wbGF0ZVwiOntcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImRvY3VtZW50RnJhZ21lbnRcIixcIl9pZFwiOlwiZG9jdW1lbnRmcmFnbWVudC1kMjViNDZmNWE1OGI4NDViOTQ3YjI1ZDVhYzEyZTQwOVwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImZyYWdtZW50XCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS1pZlwiOlwidGV4dFwifSxcIl9pZFwiOlwiZWxlbWVudC1kMzY3N2QwYzIzODZmNWY0ZjRiOGU3Y2RlODZmYWY4Y1wifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICBcIixcIl9pZFwiOlwidGV4dC1lY2E1MTAxYzRiMjFhMGMyMjIxYjgwZTExM2NjOGJjY1wifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcInNjcmlwdFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtaHRtbFwiOlwidGV4dFwifSxcIl9pZFwiOlwiZWxlbWVudC0zZjc5YWU2ZDg5M2FiZTA4MThkOWQ3MDA1NDA5NWQ2OFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuXCIsXCJfaWRcIjpcInRleHQtYTAzZTg4NWUwYWQyNmFhMDIwMGZlMjkwZjVkOWNhM2ZcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuXCIsXCJfaWRcIjpcInRleHQtNDIyNjM0YjBiMDExMjAyOTVlYzI2MGJhZDZlNWI0MGZcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJmcmFnbWVudFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtaWZcIjpcInNyY1wifSxcIl9pZFwiOlwiZWxlbWVudC03ZGU0ZmI4MTdhZGU1ZWZjYjFlOTNkZDNiYTMzYTNkNVwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICBcIixcIl9pZFwiOlwidGV4dC1kYWFhZjk2NWM4OWUxN2IwNzRlNDA5OGUyN2Q1MmRhM1wifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcInNjcmlwdFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtdGFnXCI6XCJzcmNcIn0sXCJfaWRcIjpcImVsZW1lbnQtNTUwOWMwNzM4NzAyYTA0Yjc0YzI5ZTQ1ODQ2NWU4ZjRcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LWVlYmE2MDg2MDQ1ZDMxNzI2YjRjMTE5NTk1NTVjZGVmXCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LWYyYWFiOGU4M2ViMzQxNDg0ZDNmOGQ2MGYxMTExY2VlXCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSxcInRyYW5zZm9ybVwiOntcInNyY1wiOntcIiRpZlwiOlt7XCIkdmFsdWVcIjpcInNyY1wifSx7XCJhdHRyXCI6W1wic3JjXCIse1wiJHZhbHVlXCI6XCJzcmNcIn1dfV19fX0sXCJzdHlsZVwiOntcInNjaGVtYVwiOntcImlkXCI6XCJzdHlsZVwiLFwiJHJlZlwiOlwiaHRtbFJlc291cmNlXCJ9LFwidGVtcGxhdGVcIjp7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJkb2N1bWVudEZyYWdtZW50XCIsXCJfaWRcIjpcImRvY3VtZW50ZnJhZ21lbnQtNThlYjYzOGI5ZGZmYjJjOGUwNWEyMmZjZGZkZjUzYWJcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJmcmFnbWVudFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtaWZcIjpcInRleHRcIn0sXCJfaWRcIjpcImVsZW1lbnQtZmMwNmFlOTFkNjliNzJlYWY2MTk4NzNlNzVjNzZhZGNcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgXCIsXCJfaWRcIjpcInRleHQtN2ZhMjk4ZWQwNDFiYTVkYTI2NTQxNzM5YjNiYTMxZmJcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJzdHlsZVwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtaHRtbFwiOlwidGV4dFwifSxcIl9pZFwiOlwiZWxlbWVudC0wYzM5MWQ2ZGI0ZmU2N2ZmMzMwYzA4OTVmOTkwYmRlMVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuXCIsXCJfaWRcIjpcInRleHQtMjgwNzIyNzFkODdhZDExODI3YWIwZTNkY2U4M2EwYTlcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuXCIsXCJfaWRcIjpcInRleHQtYWNiMzhkYzU5NTNkZmRlMjg2YzZmOTUwMDQyOGVkMjNcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJmcmFnbWVudFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtaWZcIjpcInNyY1wifSxcIl9pZFwiOlwiZWxlbWVudC1mMWNiMGJiOTA2ZDMzNGVkMzkwMDZlNjQzZDYwZDllNFwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICBcIixcIl9pZFwiOlwidGV4dC1mOThhZWU5M2ZhYmVlOTBjOGVhZjk5OWVkZWFkMWRhOFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImxpbmtcIixcImF0dHJpYnV0ZXNcIjp7XCJyZWxcIjpcInN0eWxlc2hlZXRcIixcImRhdGEtdGFnXCI6XCJzcmNcIn0sXCJfaWRcIjpcImVsZW1lbnQtYmQ3Njk2YjU2NDU3NDA4Y2VjYzBlYjAzYmE3NzM4MDlcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LWM2ZDI1MmQzNWY1YzBiZWY1ODdlZWNkM2Y4MWQwYTY2XCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LWY2NjcxZGQ2MTQxMmU4MDMyMzhiYTg0YjEwMzAyOWRlXCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSxcInRyYW5zZm9ybVwiOntcInNyY1wiOntcIiRpZlwiOlt7XCIkdmFsdWVcIjpcInNyY1wifSx7XCJhdHRyXCI6W1wiaHJlZlwiLHtcIiR2YWx1ZVwiOlwic3JjXCJ9XX1dfX19fSxcImRhdGFzXCI6e1wiZGF0YS1zbWFsbFwiOntcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImZyYWdtZW50XCIsXCJfaWRcIjpcImZyYWdtZW50LWU4ZDA5MTVkNmIzNjFjZGM0NWFkZTgyNDNhOTI1ZmUzXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGFnXCIsXCJuYW1lXCI6XCJzdHJvbmdcIixcImF0dHJcIjp7fSxcIl9pZFwiOlwidGFnLTllMTlhNGE0OWNiODIwYjNjOWRlMjY1N2QxMTExMDZlXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGFnXCIsXCJuYW1lXCI6XCJoMlwiLFwiYXR0clwiOntcImlkXCI6XCJteUhlYWRlclwiLFwiY2xhc3NcIjpcInByaW1hcnktaGVhZGVyXCJ9LFwiX2lkXCI6XCJoMi1mYzNhZDAyZTk0M2NiODk3OWVkOTVmMDA4MjU0ZTdjNFwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wiZGF0YVwiOlwiSGVsbG8gXCIsXCJub2RlVHlwZVwiOlwidGV4dFwiLFwiX2lkXCI6XCJ0ZXh0LWU4NDMwZTc3ODU3OGRjYjhhNWNlZjE3ZmNmZGQ5Njc1XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwiZGF0YVwiOlwiQ2hyaXNcIixcIl9pZFwiOlwidGV4dC1kZmRlYTc3NDJhMjRkN2RjY2VjZTNmMGM2Y2E4ZWM4MFwifSxcImNoaWxkcmVuXCI6W119XX1dfX19IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBUcmVlID0gcmVxdWlyZSgnMXRyZWUnKTtcbnZhciBkZWZhdWx0QWRhcHRlciA9IHJlcXVpcmUoJzF0cmVlL2Rpc3QvYWRhcHRlci9kZWZhdWx0Jyk7XG5cbnZhciBiYXNlUGx1Z2lucyA9IE9iamVjdC5rZXlzKFRyZWUucGx1Z2lucykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIFRyZWUucGx1Z2luc1trZXldO1xufSk7XG5cbnZhciBNdHJlZSA9IGZ1bmN0aW9uIE10cmVlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgZXhjbHVkZUJhc2UgPSBhcmdzLnNvbWUoZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgJiYgYXJnO1xuICB9KTtcblxuICB2YXIgYWRhcHRlciA9IGRlZmF1bHRBZGFwdGVyO1xuICB2YXIgcGx1Z2lucyA9IGV4Y2x1ZGVCYXNlID8gW10gOiBiYXNlUGx1Z2lucztcblxuICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgIHBsdWdpbnMgPSBhcmcuY29uY2F0KHBsdWdpbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2lucyA9IFthcmddLmNvbmNhdChwbHVnaW5zKTtcbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhcmcpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGFkYXB0ZXIgPSBhcmc7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gVHJlZS5hZGFwdGVyKGFkYXB0ZXIsIHBsdWdpbnMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNdHJlZTsiLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCAnLi9kaXN0JyApXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIFRyZWUgPSByZXF1aXJlKCcxdHJlZScpO1xudmFyIFQgPSByZXF1aXJlKCdtdHlwZScpO1xudmFyIHBhdGhzID0gcmVxdWlyZSgnLi9wYXRocycpO1xuXG52YXIgcGF0aEZyb21Ob2RlID0gcGF0aHMucGF0aEZyb21Ob2RlLFxuICAgIG5vZGVGcm9tUGF0aCA9IHBhdGhzLm5vZGVGcm9tUGF0aDtcblxuXG52YXIgdCA9IFQoKTtcblxudmFyIHZhbHVlVHlwZXMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xuXG52YXIgZXh0ZW5kVmFsdWUgPSBmdW5jdGlvbiBleHRlbmRWYWx1ZShub2RlLCB2YWx1ZSkge1xuICByZXR1cm4gbm9kZS52YWx1ZShPYmplY3QuYXNzaWduKHt9LCBub2RlLnZhbHVlKCksIHZhbHVlKSk7XG59O1xuXG52YXIgdG9Ob2RlID0gZnVuY3Rpb24gdG9Ob2RlKGpzb25PYmosIHBhcmVudCkge1xuICB2YXIgY3JlYXRlID0gcGFyZW50ID8gcGFyZW50LmNyZWF0ZU5vZGUgOiBUcmVlLmNyZWF0ZVJvb3Q7XG5cbiAgdmFyIG5vZGVUeXBlID0gdC5vZihqc29uT2JqKTtcbiAgdmFyIHZhbHVlID0geyBub2RlVHlwZTogbm9kZVR5cGUgfTtcblxuICBpZiAodmFsdWVUeXBlcy5pbmNsdWRlcyhub2RlVHlwZSkpIHZhbHVlLm5vZGVWYWx1ZSA9IGpzb25PYmo7XG5cbiAgdmFyIG5vZGUgPSBjcmVhdGUodmFsdWUpO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gJ2FycmF5Jykge1xuICAgIGpzb25PYmouZm9yRWFjaChmdW5jdGlvbiAoZWwsIGluZGV4KSB7XG4gICAgICB2YXIgYXJyYXlJdGVtTm9kZSA9IHRvTm9kZShlbCwgbm9kZSk7XG5cbiAgICAgIGV4dGVuZFZhbHVlKGFycmF5SXRlbU5vZGUsIHsgYXJyYXlJbmRleDogaW5kZXggfSk7XG5cbiAgICAgIG5vZGUuYXBwZW5kKGFycmF5SXRlbU5vZGUpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKG5vZGVUeXBlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBwcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmtleXMoanNvbk9iaik7XG5cbiAgICBwcm9wZXJ0eU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBwcm9wZXJ0eVZhbHVlID0ganNvbk9ialtuYW1lXTtcbiAgICAgIHZhciB2YWx1ZU5vZGUgPSB0b05vZGUocHJvcGVydHlWYWx1ZSwgbm9kZSk7XG5cbiAgICAgIGV4dGVuZFZhbHVlKHZhbHVlTm9kZSwgeyBwcm9wZXJ0eU5hbWU6IG5hbWUgfSk7XG5cbiAgICAgIG5vZGUuYXBwZW5kKHZhbHVlTm9kZSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbnZhciB0b1RyZWUgPSBmdW5jdGlvbiB0b1RyZWUoanNvbk9iaikge1xuICByZXR1cm4gdG9Ob2RlKGpzb25PYmosIG51bGwpO1xufTtcblxudmFyIHRvSnNvbiA9IGZ1bmN0aW9uIHRvSnNvbih0cmVlKSB7XG4gIHZhciB2YWx1ZSA9IHRyZWUudmFsdWUoKTtcbiAgdmFyIG5vZGVUeXBlID0gdmFsdWUubm9kZVR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSAnbnVsbCcpIHJldHVybiBudWxsO1xuXG4gIGlmICh2YWx1ZVR5cGVzLmluY2x1ZGVzKG5vZGVUeXBlKSkgcmV0dXJuIHZhbHVlLm5vZGVWYWx1ZTtcblxuICBpZiAobm9kZVR5cGUgPT09ICdhcnJheScpIHJldHVybiB0cmVlLmdldENoaWxkcmVuKCkubWFwKHRvSnNvbik7XG5cbiAgaWYgKG5vZGVUeXBlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9iaiA9IHt9O1xuXG4gICAgICB0cmVlLmdldENoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZVZhbHVlTm9kZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBuYW1lVmFsdWVOb2RlLnZhbHVlKCk7XG4gICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSB2YWx1ZS5wcm9wZXJ0eU5hbWU7XG5cbiAgICAgICAgdmFyIHByb3BlcnR5VmFsdWUgPSB0b0pzb24obmFtZVZhbHVlTm9kZSk7XG5cbiAgICAgICAgb2JqW3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0eVZhbHVlO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHY6IG9ialxuICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICBpZiAoKHR5cGVvZiBfcmV0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihfcmV0KSkgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0LnY7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgbm9kZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IHRvVHJlZTogdG9UcmVlLCB0b0pzb246IHRvSnNvbiwgcGF0aEZyb21Ob2RlOiBwYXRoRnJvbU5vZGUsIG5vZGVGcm9tUGF0aDogbm9kZUZyb21QYXRoIH07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2x1Z0Zyb21Ob2RlID0gZnVuY3Rpb24gc2x1Z0Zyb21Ob2RlKG5vZGUpIHtcbiAgdmFyIHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgaWYgKCFwYXJlbnQpIHJldHVybiAnJCc7XG5cbiAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZSgpO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUucHJvcGVydHlOYW1lID09PSAnc3RyaW5nJykgcmV0dXJuIHZhbHVlLnByb3BlcnR5TmFtZTtcblxuICBpZiAodHlwZW9mIHZhbHVlLmFycmF5SW5kZXggPT09ICdudW1iZXInKSByZXR1cm4gdmFsdWUuYXJyYXlJbmRleCArICcnO1xufTtcblxudmFyIHBhdGhGcm9tTm9kZSA9IGZ1bmN0aW9uIHBhdGhGcm9tTm9kZShub2RlKSB7XG4gIHZhciBwYXJlbnRXaXRoU2x1ZyA9IG5vZGUuY2xvc2VzdChmdW5jdGlvbiAobikge1xuICAgIHJldHVybiAhIXNsdWdGcm9tTm9kZShuKSAmJiBuLmdldCgpICE9PSBub2RlLmdldCgpO1xuICB9KTtcblxuICBpZiAoIXBhcmVudFdpdGhTbHVnKSByZXR1cm4gJyQnO1xuXG4gIHZhciBwYXJlbnRQYXRoID0gcGF0aEZyb21Ob2RlKHBhcmVudFdpdGhTbHVnKTtcbiAgdmFyIHNsdWcgPSBzbHVnRnJvbU5vZGUobm9kZSk7XG5cbiAgaWYgKHNsdWcpIHJldHVybiBwYXJlbnRQYXRoICsgJy8nICsgc2x1Zztcbn07XG5cbnZhciBub2RlRnJvbVBhdGggPSBmdW5jdGlvbiBub2RlRnJvbVBhdGgodHJlZSwgcGF0aCkge1xuICByZXR1cm4gdHJlZS5maW5kKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIHBhdGggPT09IHBhdGhGcm9tTm9kZShub2RlKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgcGF0aEZyb21Ob2RlOiBwYXRoRnJvbU5vZGUsIG5vZGVGcm9tUGF0aDogbm9kZUZyb21QYXRoIH07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9UcmVlID0gcmVxdWlyZSgnLi90b1RyZWUnKTtcbnZhciB0b0pzb24gPSByZXF1aXJlKCcuL3RvSnNvbicpO1xudmFyIHBhdGhzID0gcmVxdWlyZSgnLi9wYXRocycpO1xuXG52YXIgcGF0aEZyb21Ob2RlID0gcGF0aHMucGF0aEZyb21Ob2RlLFxuICAgIG5vZGVGcm9tUGF0aCA9IHBhdGhzLm5vZGVGcm9tUGF0aDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgdG9UcmVlOiB0b1RyZWUsIHRvSnNvbjogdG9Kc29uLCBwYXRoRnJvbU5vZGU6IHBhdGhGcm9tTm9kZSwgbm9kZUZyb21QYXRoOiBub2RlRnJvbVBhdGggfTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBzbHVnRnJvbU5vZGUgPSBmdW5jdGlvbiBzbHVnRnJvbU5vZGUobm9kZSkge1xuICB2YXIgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcblxuICBpZiAoIXBhcmVudCkgcmV0dXJuICckJztcblxuICB2YXIgdmFsdWUgPSBub2RlLnZhbHVlKCk7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZS5wcm9wZXJ0eU5hbWUgPT09ICdzdHJpbmcnKSByZXR1cm4gdmFsdWUucHJvcGVydHlOYW1lO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUuYXJyYXlJbmRleCA9PT0gJ251bWJlcicpIHJldHVybiB2YWx1ZS5hcnJheUluZGV4ICsgJyc7XG59O1xuXG52YXIgcGF0aEZyb21Ob2RlID0gZnVuY3Rpb24gcGF0aEZyb21Ob2RlKG5vZGUpIHtcbiAgdmFyIHBhcmVudFdpdGhTbHVnID0gbm9kZS5jbG9zZXN0KGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuICEhc2x1Z0Zyb21Ob2RlKG4pICYmIG4uZ2V0KCkgIT09IG5vZGUuZ2V0KCk7XG4gIH0pO1xuXG4gIGlmICghcGFyZW50V2l0aFNsdWcpIHJldHVybiAnJCc7XG5cbiAgdmFyIG5vZGVQYXRoID0gcGF0aEZyb21Ob2RlKHBhcmVudFdpdGhTbHVnKTtcbiAgdmFyIHNsdWcgPSBzbHVnRnJvbU5vZGUobm9kZSk7XG5cbiAgaWYgKHNsdWcpIG5vZGVQYXRoICs9ICcvJyArIHNsdWc7XG5cbiAgcmV0dXJuIG5vZGVQYXRoO1xufTtcblxuLy8gdGhpcyBpcyBlYXN5IGJ1dCBpbmVmZmljZW50LCBpdCdzIHZlcnkgc2ltcGxlIHRvIHVzZSB0aGUgcGF0aCBzZWdtZW50cyB0b1xuLy8gdHJhdmVyc2UgdGhlIHRyZWUsIHJlcGxhY2UhXG52YXIgbm9kZUZyb21QYXRoID0gZnVuY3Rpb24gbm9kZUZyb21QYXRoKHNjaGVtYVRyZWUsIHBhdGgpIHtcbiAgcmV0dXJuIHNjaGVtYVRyZWUuZmluZChmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBwYXRoID09PSBwYXRoRnJvbU5vZGUobm9kZSk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IHBhdGhGcm9tTm9kZTogcGF0aEZyb21Ob2RlLCBub2RlRnJvbVBhdGg6IG5vZGVGcm9tUGF0aCB9OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgdmFsdWVNYXBwZXIgPSBmdW5jdGlvbiB2YWx1ZU1hcHBlcihub2RlKSB7XG4gIHZhciB2YWx1ZSA9IG5vZGUudmFsdWUoKTtcblxuICB2YXIgc2NoZW1hID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUpO1xuXG4gIGlmICh2YWx1ZS50eXBlID09PSAndW5pb24nKSB7XG4gICAgc2NoZW1hLnR5cGUgPSB2YWx1ZS50eXBlc1VuaW9uO1xuXG4gICAgZGVsZXRlIHNjaGVtYS50eXBlc1VuaW9uO1xuICB9IGVsc2UgaWYgKHZhbHVlLnR5cGUgPT09ICdhbnknKSB7XG4gICAgZGVsZXRlIHNjaGVtYS50eXBlO1xuICB9XG5cbiAgcmV0dXJuIHNjaGVtYTtcbn07XG5cbnZhciBkZWxldGVGcm9tVmFsdWUgPSBmdW5jdGlvbiBkZWxldGVGcm9tVmFsdWUobm9kZSwgcHJvcGVydHlOYW1lKSB7XG4gIHZhciB2YWx1ZSA9IG5vZGUudmFsdWUoKTtcblxuICBkZWxldGUgdmFsdWVbcHJvcGVydHlOYW1lXTtcblxuICBub2RlLnZhbHVlKHZhbHVlKTtcbn07XG5cbnZhciBwcm9wZXJ0eVBvcHVsYXRvcnMgPSB7XG4gIHByb3BlcnR5TmFtZTogZnVuY3Rpb24gcHJvcGVydHlOYW1lKG5vZGUsIHNjaGVtYSkge1xuICAgIGlmIChfdHlwZW9mKHNjaGVtYS5wcm9wZXJ0aWVzKSAhPT0gJ29iamVjdCcpIHNjaGVtYS5wcm9wZXJ0aWVzID0ge307XG5cbiAgICB2YXIgdmFsdWUgPSBub2RlLnZhbHVlKCk7XG4gICAgdmFyIHByb3BlcnR5TmFtZSA9IHZhbHVlLnByb3BlcnR5TmFtZTtcblxuXG4gICAgZGVsZXRlRnJvbVZhbHVlKG5vZGUsICdwcm9wZXJ0eU5hbWUnKTtcblxuICAgIHNjaGVtYS5wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0gPSB0b0pzb24obm9kZSk7XG4gIH0sXG4gIHByb3BlcnR5UGF0dGVybjogZnVuY3Rpb24gcHJvcGVydHlQYXR0ZXJuKG5vZGUsIHNjaGVtYSkge1xuICAgIGlmIChfdHlwZW9mKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykgIT09ICdvYmplY3QnKSBzY2hlbWEucGF0dGVyblByb3BlcnRpZXMgPSB7fTtcblxuICAgIHZhciB2YWx1ZSA9IG5vZGUudmFsdWUoKTtcbiAgICB2YXIgcGF0dGVybiA9IHZhbHVlLnByb3BlcnR5UGF0dGVybjtcblxuICAgIGRlbGV0ZUZyb21WYWx1ZShub2RlLCAncHJvcGVydHlQYXR0ZXJuJyk7XG5cbiAgICBzY2hlbWEucGF0dGVyblByb3BlcnRpZXNbcGF0dGVybl0gPSB0b0pzb24obm9kZSk7XG4gIH0sXG4gIGFkZGl0aW9uYWxQcm9wZXJ0aWVzU2NoZW1hOiBmdW5jdGlvbiBhZGRpdGlvbmFsUHJvcGVydGllc1NjaGVtYShub2RlLCBzY2hlbWEpIHtcbiAgICBkZWxldGVGcm9tVmFsdWUobm9kZSwgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzU2NoZW1hJyk7XG5cbiAgICBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPSB0b0pzb24obm9kZSk7XG4gIH0sXG4gIGFycmF5SXRlbTogZnVuY3Rpb24gYXJyYXlJdGVtKG5vZGUsIHNjaGVtYSkge1xuICAgIGRlbGV0ZUZyb21WYWx1ZShub2RlLCAnYXJyYXlJdGVtJyk7XG5cbiAgICBzY2hlbWEuaXRlbXMgPSB0b0pzb24obm9kZSk7XG4gIH0sXG4gIGFycmF5SW5kZXg6IGZ1bmN0aW9uIGFycmF5SW5kZXgobm9kZSwgc2NoZW1hKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykpIHNjaGVtYS5pdGVtcyA9IFtdO1xuXG4gICAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZSgpO1xuICAgIHZhciBhcnJheUluZGV4ID0gdmFsdWUuYXJyYXlJbmRleDtcblxuXG4gICAgZGVsZXRlRnJvbVZhbHVlKG5vZGUsICdhcnJheUluZGV4Jyk7XG5cbiAgICBzY2hlbWEuaXRlbXNbYXJyYXlJbmRleF0gPSB0b0pzb24obm9kZSk7XG4gIH0sXG4gIGFueU9mOiBmdW5jdGlvbiBhbnlPZihub2RlLCBzY2hlbWEpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hLmFueU9mKSkgc2NoZW1hLmFueU9mID0gW107XG5cbiAgICBkZWxldGVGcm9tVmFsdWUobm9kZSwgJ2FueU9mJyk7XG5cbiAgICB2YXIgY2hpbGRTY2hlbWEgPSB0b0pzb24obm9kZSk7XG5cbiAgICBzY2hlbWEuYW55T2YucHVzaChjaGlsZFNjaGVtYSk7XG4gIH0sXG4gIGFsbE9mOiBmdW5jdGlvbiBhbGxPZihub2RlLCBzY2hlbWEpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hLmFsbE9mKSkgc2NoZW1hLmFsbE9mID0gW107XG5cbiAgICBkZWxldGVGcm9tVmFsdWUobm9kZSwgJ2FsbE9mJyk7XG5cbiAgICB2YXIgY2hpbGRTY2hlbWEgPSB0b0pzb24obm9kZSk7XG5cbiAgICBzY2hlbWEuYWxsT2YucHVzaChjaGlsZFNjaGVtYSk7XG4gIH0sXG4gIG9uZU9mOiBmdW5jdGlvbiBvbmVPZihub2RlLCBzY2hlbWEpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hLm9uZU9mKSkgc2NoZW1hLm9uZU9mID0gW107XG5cbiAgICBkZWxldGVGcm9tVmFsdWUobm9kZSwgJ29uZU9mJyk7XG5cbiAgICB2YXIgY2hpbGRTY2hlbWEgPSB0b0pzb24obm9kZSk7XG5cbiAgICBzY2hlbWEub25lT2YucHVzaChjaGlsZFNjaGVtYSk7XG4gIH0sXG4gIG5vdDogZnVuY3Rpb24gbm90KG5vZGUsIHNjaGVtYSkge1xuICAgIGRlbGV0ZUZyb21WYWx1ZShub2RlLCAnbm90Jyk7XG5cbiAgICBzY2hlbWEubm90ID0gdG9Kc29uKG5vZGUpO1xuICB9XG59O1xuXG52YXIgcG9wdWxhdG9yUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHByb3BlcnR5UG9wdWxhdG9ycyk7XG5cbnZhciBuZXN0aW5nTWFwcGVyID0gZnVuY3Rpb24gbmVzdGluZ01hcHBlcihub2RlKSB7XG4gIHZhciBzY2hlbWEgPSB2YWx1ZU1hcHBlcihub2RlKTtcblxuICB2YXIgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG5cbiAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGROb2RlKSB7XG4gICAgdmFyIHZhbHVlID0gY2hpbGROb2RlLnZhbHVlKCk7XG5cbiAgICB2YXIgcG9wdWxhdGVGb3IgPSBwb3B1bGF0b3JQcm9wZXJ0aWVzLmZpbHRlcihmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgICByZXR1cm4gcHJvcGVydHlOYW1lIGluIHZhbHVlO1xuICAgIH0pO1xuXG4gICAgcG9wdWxhdGVGb3IuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgICB2YXIgcG9wdWxhdG9yID0gcHJvcGVydHlQb3B1bGF0b3JzW3Byb3BlcnR5TmFtZV07XG5cbiAgICAgIHBvcHVsYXRvcihjaGlsZE5vZGUsIHNjaGVtYSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBzY2hlbWE7XG59O1xuXG52YXIgdmFsdWVNYXBwZXJzID0ge1xuICBvYmplY3Q6IG5lc3RpbmdNYXBwZXIsXG4gIGFycmF5OiBuZXN0aW5nTWFwcGVyLFxuICBhbnk6IG5lc3RpbmdNYXBwZXIsXG4gIHVuaW9uOiBuZXN0aW5nTWFwcGVyLFxuICBzdHJpbmc6IHZhbHVlTWFwcGVyLFxuICBudW1iZXI6IHZhbHVlTWFwcGVyLFxuICBib29sZWFuOiB2YWx1ZU1hcHBlcixcbiAgaW50ZWdlcjogdmFsdWVNYXBwZXIsXG4gIG51bGw6IHZhbHVlTWFwcGVyXG59O1xuXG52YXIgdG9Kc29uID0gZnVuY3Rpb24gdG9Kc29uKG5vZGUpIHtcbiAgbm9kZSA9IG5vZGUuY2xvbmUoKTtcblxuICB2YXIgdmFsdWUgPSBub2RlLnZhbHVlKCk7XG4gIHZhciBzY2hlbWFUeXBlID0gdmFsdWUudHlwZTtcbiAgdmFyIG1hcHBlciA9IHZhbHVlTWFwcGVyc1tzY2hlbWFUeXBlXTtcblxuICByZXR1cm4gbWFwcGVyKG5vZGUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB0b0pzb247IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBUcmVlID0gcmVxdWlyZSgnMXRyZWUnKTtcblxudmFyIGNyZWF0ZXNOZXN0aW5nID0ge1xuICBvYmplY3Q6IFsncHJvcGVydGllcycsICdhZGRpdGlvbmFsUHJvcGVydGllcycsICdkZWZpbml0aW9ucycsICdwYXR0ZXJuUHJvcGVydGllcycsICdkZXBlbmRlbmNpZXMnLCAnYWxsT2YnLCAnYW55T2YnLCAnb25lT2YnLCAnbm90J10sXG4gIGFycmF5OiBbJ2l0ZW1zJ11cbn07XG5cbmNyZWF0ZXNOZXN0aW5nLmFueSA9IGNyZWF0ZXNOZXN0aW5nLm9iamVjdC5jb25jYXQoY3JlYXRlc05lc3RpbmcuYXJyYXkpO1xuY3JlYXRlc05lc3RpbmcudW5pb24gPSBjcmVhdGVzTmVzdGluZy5hbnk7XG5cbnZhciB2YWx1ZU1hcHBlciA9IGZ1bmN0aW9uIHZhbHVlTWFwcGVyKHNjaGVtYSkge1xuICB2YXIgdmFsdWUgPSBPYmplY3QuYXNzaWduKHt9LCBzY2hlbWEpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS50eXBlKSkge1xuICAgIHZhbHVlLnR5cGUgPSAndW5pb24nO1xuICAgIHZhbHVlLnR5cGVzVW5pb24gPSBzY2hlbWEudHlwZS5zbGljZSgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZS50eXBlID0gJ2FueSc7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgbmVzdGluZ01hcHBlciA9IGZ1bmN0aW9uIG5lc3RpbmdNYXBwZXIoc2NoZW1hKSB7XG4gIHZhciB2YWx1ZSA9IHZhbHVlTWFwcGVyKHNjaGVtYSk7XG5cbiAgdmFyIGNyZWF0ZXNOZXN0aW5nRGVmID0gY3JlYXRlc05lc3RpbmdbdmFsdWUudHlwZV07XG5cbiAgY3JlYXRlc05lc3RpbmdEZWYuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgZGVsZXRlIHZhbHVlW3Byb3BlcnR5TmFtZV07XG4gIH0pO1xuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBub2RlVmFsdWVNYXBwZXJzID0ge1xuICBzdHJpbmc6IHZhbHVlTWFwcGVyLFxuICBudW1iZXI6IHZhbHVlTWFwcGVyLFxuICBpbnRlZ2VyOiB2YWx1ZU1hcHBlcixcbiAgYm9vbGVhbjogdmFsdWVNYXBwZXIsXG4gIG51bGw6IHZhbHVlTWFwcGVyLFxuICBvYmplY3Q6IG5lc3RpbmdNYXBwZXIsXG4gIGFycmF5OiBuZXN0aW5nTWFwcGVyLFxuICBhbnk6IG5lc3RpbmdNYXBwZXJcbn07XG5cbnZhciBleHRlbmRWYWx1ZSA9IGZ1bmN0aW9uIGV4dGVuZFZhbHVlKG5vZGUsIHZhbHVlKSB7XG4gIHJldHVybiBub2RlLnZhbHVlKE9iamVjdC5hc3NpZ24oe30sIG5vZGUudmFsdWUoKSwgdmFsdWUpKTtcbn07XG5cbnZhciBjcmVhdGVQcm9wZXJ0eU5vZGUgPSBmdW5jdGlvbiBjcmVhdGVQcm9wZXJ0eU5vZGUoc2NoZW1hLCBub2RlLCBwcm9wZXJ0eU5hbWUpIHtcbiAgdmFyIHByb3BlcnR5U2NoZW1hID0gc2NoZW1hLnByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcbiAgdmFyIHByb3BlcnR5Tm9kZSA9IHRvTm9kZShwcm9wZXJ0eVNjaGVtYSwgbm9kZSk7XG5cbiAgZXh0ZW5kVmFsdWUocHJvcGVydHlOb2RlLCB7IHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lIH0pO1xuXG4gIHJldHVybiBwcm9wZXJ0eU5vZGU7XG59O1xuXG52YXIgY3JlYXRlQWRkaXRpb25hbFByb3BlcnRpZXNOb2RlID0gZnVuY3Rpb24gY3JlYXRlQWRkaXRpb25hbFByb3BlcnRpZXNOb2RlKHNjaGVtYSwgbm9kZSkge1xuICB2YXIgYWRkaXRpb25hbFByb3BlcnRpZXNTY2hlbWEgPSBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXM7XG4gIHZhciBhZGRpdGlvbmFsUHJvcGVydGllc05vZGUgPSB0b05vZGUoYWRkaXRpb25hbFByb3BlcnRpZXNTY2hlbWEsIG5vZGUpO1xuXG4gIGV4dGVuZFZhbHVlKGFkZGl0aW9uYWxQcm9wZXJ0aWVzTm9kZSwgeyBhZGRpdGlvbmFsUHJvcGVydGllc1NjaGVtYTogdHJ1ZSB9KTtcblxuICByZXR1cm4gYWRkaXRpb25hbFByb3BlcnRpZXNOb2RlO1xufTtcblxudmFyIGNyZWF0ZVBhdHRlcm5Qcm9wZXJ0eU5vZGUgPSBmdW5jdGlvbiBjcmVhdGVQYXR0ZXJuUHJvcGVydHlOb2RlKHNjaGVtYSwgbm9kZSwgcGF0dGVybikge1xuICB2YXIgcGF0dGVyblByb3BlcnR5U2NoZW1hID0gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzW3BhdHRlcm5dO1xuICB2YXIgcGF0dGVyblByb3BlcnR5Tm9kZSA9IHRvTm9kZShwYXR0ZXJuUHJvcGVydHlTY2hlbWEsIG5vZGUpO1xuXG4gIGV4dGVuZFZhbHVlKHBhdHRlcm5Qcm9wZXJ0eU5vZGUsIHsgcHJvcGVydHlQYXR0ZXJuOiBwYXR0ZXJuIH0pO1xuXG4gIHJldHVybiBwYXR0ZXJuUHJvcGVydHlOb2RlO1xufTtcblxudmFyIGNyZWF0ZUNvbWJpbmluZ05vZGUgPSBmdW5jdGlvbiBjcmVhdGVDb21iaW5pbmdOb2RlKGNvbWJpbmVTY2hlbWEsIG5vZGUsIGNvbWJpbmVOYW1lKSB7XG4gIHZhciBjb21iaW5lTm9kZSA9IHRvTm9kZShjb21iaW5lU2NoZW1hLCBub2RlKTtcblxuICBleHRlbmRWYWx1ZShjb21iaW5lTm9kZSwgX2RlZmluZVByb3BlcnR5KHt9LCBjb21iaW5lTmFtZSwgdHJ1ZSkpO1xuXG4gIHJldHVybiBjb21iaW5lTm9kZTtcbn07XG5cbnZhciBjcmVhdGVJdGVtc05vZGUgPSBmdW5jdGlvbiBjcmVhdGVJdGVtc05vZGUoc2NoZW1hLCBub2RlKSB7XG4gIHZhciBpdGVtc1NjaGVtYSA9IHNjaGVtYS5pdGVtcztcbiAgdmFyIGl0ZW1zTm9kZSA9IHRvTm9kZShpdGVtc1NjaGVtYSwgbm9kZSk7XG5cbiAgZXh0ZW5kVmFsdWUoaXRlbXNOb2RlLCB7IGFycmF5SXRlbTogdHJ1ZSB9KTtcblxuICByZXR1cm4gaXRlbXNOb2RlO1xufTtcblxudmFyIGNyZWF0ZUl0ZW1UdXBsZU5vZGUgPSBmdW5jdGlvbiBjcmVhdGVJdGVtVHVwbGVOb2RlKHR1cGxlU2NoZW1hLCBub2RlLCBpbmRleCkge1xuICB2YXIgaXRlbVR1cGxlTm9kZSA9IHRvTm9kZSh0dXBsZVNjaGVtYSwgbm9kZSk7XG5cbiAgZXh0ZW5kVmFsdWUoaXRlbVR1cGxlTm9kZSwgeyBhcnJheUluZGV4OiBpbmRleCB9KTtcblxuICByZXR1cm4gaXRlbVR1cGxlTm9kZTtcbn07XG5cbnZhciBjb21iaW5lQXJyYXlUeXBlcyA9IFsnYW55T2YnLCAnYWxsT2YnLCAnb25lT2YnXTtcblxudmFyIGNoaWxkcmVuUG9wdWxhdG9ycyA9IHtcbiAgb2JqZWN0OiBmdW5jdGlvbiBvYmplY3Qoc2NoZW1hLCBub2RlKSB7XG4gICAgaWYgKHNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgcHJvcGVydHlOYW1lcyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKTtcblxuICAgICAgcHJvcGVydHlOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgdmFyIHByb3BlcnR5Tm9kZSA9IGNyZWF0ZVByb3BlcnR5Tm9kZShzY2hlbWEsIG5vZGUsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgIG5vZGUuYXBwZW5kKHByb3BlcnR5Tm9kZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB2YXIgdmFsdWUgPSBub2RlLnZhbHVlKCk7XG5cbiAgICAgIHZhbHVlLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xuXG4gICAgICBub2RlLnZhbHVlKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKF90eXBlb2Yoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBhZGRpdGlvbmFsUHJvcGVydGllc05vZGUgPSBjcmVhdGVBZGRpdGlvbmFsUHJvcGVydGllc05vZGUoc2NoZW1hLCBub2RlKTtcblxuICAgICAgbm9kZS5hcHBlbmQoYWRkaXRpb25hbFByb3BlcnRpZXNOb2RlKTtcbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hLmRlZmluaXRpb25zKSB0aHJvdyBuZXcgRXJyb3IoJ2RlZmluaXRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcblxuICAgIGlmIChzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBwYXR0ZXJucyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcyk7XG5cbiAgICAgIHBhdHRlcm5zLmZvckVhY2goZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICAgICAgdmFyIHBhdHRlcm5Qcm9wZXJ0eU5vZGUgPSBjcmVhdGVQYXR0ZXJuUHJvcGVydHlOb2RlKHNjaGVtYSwgbm9kZSwgcGF0dGVybik7XG4gICAgICAgIG5vZGUuYXBwZW5kKHBhdHRlcm5Qcm9wZXJ0eU5vZGUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHNjaGVtYS5kZXBlbmRlbmNpZXMpIHRocm93IG5ldyBFcnJvcignZGVwZW5kZW5jaWVzIG5vdCBzdXBwb3J0ZWQnKTtcblxuICAgIGNvbWJpbmVBcnJheVR5cGVzLmZvckVhY2goZnVuY3Rpb24gKGNvbWJpbmVOYW1lKSB7XG4gICAgICBpZiAoc2NoZW1hW2NvbWJpbmVOYW1lXSkge1xuICAgICAgICB2YXIgY29tYmluZURlZiA9IHNjaGVtYVtjb21iaW5lTmFtZV07XG5cbiAgICAgICAgY29tYmluZURlZi5mb3JFYWNoKGZ1bmN0aW9uIChjb21iaW5lU2NoZW1hKSB7XG4gICAgICAgICAgdmFyIGNvbWJpbmVOb2RlID0gY3JlYXRlQ29tYmluaW5nTm9kZShjb21iaW5lU2NoZW1hLCBub2RlLCBjb21iaW5lTmFtZSk7XG5cbiAgICAgICAgICBub2RlLmFwcGVuZChjb21iaW5lTm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHNjaGVtYS5ub3QpIHtcbiAgICAgIHZhciBjb21iaW5lU2NoZW1hID0gc2NoZW1hLm5vdDtcbiAgICAgIHZhciBjb21iaW5lTm9kZSA9IGNyZWF0ZUNvbWJpbmluZ05vZGUoY29tYmluZVNjaGVtYSwgbm9kZSwgJ25vdCcpO1xuXG4gICAgICBub2RlLmFwcGVuZChjb21iaW5lTm9kZSk7XG4gICAgfVxuICB9LFxuICBhcnJheTogZnVuY3Rpb24gYXJyYXkoc2NoZW1hLCBub2RlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLml0ZW1zKSkge1xuICAgICAgc2NoZW1hLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKHR1cGxlU2NoZW1hLCBpbmRleCkge1xuICAgICAgICB2YXIgaXRlbVR1cGxlTm9kZSA9IGNyZWF0ZUl0ZW1UdXBsZU5vZGUodHVwbGVTY2hlbWEsIG5vZGUsIGluZGV4KTtcblxuICAgICAgICBub2RlLmFwcGVuZChpdGVtVHVwbGVOb2RlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZihzY2hlbWEuaXRlbXMpID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGl0ZW1zTm9kZSA9IGNyZWF0ZUl0ZW1zTm9kZShzY2hlbWEsIG5vZGUpO1xuXG4gICAgICBub2RlLmFwcGVuZChpdGVtc05vZGUpO1xuICAgIH1cbiAgfSxcbiAgYW55OiBmdW5jdGlvbiBhbnkoc2NoZW1hLCBub2RlKSB7XG4gICAgY2hpbGRyZW5Qb3B1bGF0b3JzLm9iamVjdChzY2hlbWEsIG5vZGUpO1xuICAgIGNoaWxkcmVuUG9wdWxhdG9ycy5hcnJheShzY2hlbWEsIG5vZGUpO1xuICB9XG59O1xuXG52YXIgY29udGFpbmVyTm9kZVR5cGVzID0gT2JqZWN0LmtleXMoY2hpbGRyZW5Qb3B1bGF0b3JzKTtcblxudmFyIHRvTm9kZSA9IGZ1bmN0aW9uIHRvTm9kZShzY2hlbWEsIHBhcmVudCkge1xuICB2YXIgY3JlYXRlID0gcGFyZW50ID8gcGFyZW50LmNyZWF0ZU5vZGUgOiBUcmVlLmNyZWF0ZVJvb3Q7XG5cbiAgdmFyIHNjaGVtYVR5cGUgPSB0eXBlb2Ygc2NoZW1hLnR5cGUgPT09ICdzdHJpbmcnID8gc2NoZW1hLnR5cGUgOiAnYW55JztcbiAgdmFyIHZhbHVlTWFwcGVyID0gbm9kZVZhbHVlTWFwcGVyc1tzY2hlbWFUeXBlXTtcbiAgdmFyIHZhbHVlID0gdmFsdWVNYXBwZXIoc2NoZW1hKTtcbiAgdmFyIG5vZGUgPSBjcmVhdGUodmFsdWUpO1xuXG4gIGlmIChjb250YWluZXJOb2RlVHlwZXMuaW5jbHVkZXMoc2NoZW1hVHlwZSkpIHtcbiAgICB2YXIgY2hpbGRyZW5Qb3B1bGF0b3IgPSBjaGlsZHJlblBvcHVsYXRvcnNbc2NoZW1hVHlwZV07XG5cbiAgICBjaGlsZHJlblBvcHVsYXRvcihzY2hlbWEsIG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG52YXIgdG9UcmVlID0gZnVuY3Rpb24gdG9UcmVlKHNjaGVtYSkge1xuICByZXR1cm4gdG9Ob2RlKHNjaGVtYSwgbnVsbCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRvVHJlZTsiLCIndXNlIHN0cmljdCdcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSggJy4vZGlzdCcgKVxyXG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVOb2RlOiBmdW5jdGlvbiBjcmVhdGVOb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH07XG4gIH0sXG4gIGFyZ1R5cGVzOiBbJ25vZGVWYWx1ZSddLFxuICByZXR1cm5UeXBlOiAnbm9kZScsXG4gIGNhdGVnb3JpZXM6IFsnbWFuaXB1bGF0aW9uJywgJ2FkYXB0ZXInXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDaGlsZHJlbjogZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obm9kZSkge1xuICAgIHJldHVybiBub2RlLmNoaWxkcmVuO1xuICB9LFxuICBhcmdUeXBlczogWydub2RlJ10sXG4gIHJldHVyblR5cGU6ICdbbm9kZV0nLFxuICBjYXRlZ29yaWVzOiBbJ3RyYXZlcnNhbCcsICdhZGFwdGVyJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlTm9kZSA9IHJlcXVpcmUoJy4vY3JlYXRlTm9kZScpO1xudmFyIGdldENoaWxkcmVuID0gcmVxdWlyZSgnLi9nZXRDaGlsZHJlbicpO1xudmFyIGluc2VydEJlZm9yZSA9IHJlcXVpcmUoJy4vaW5zZXJ0QmVmb3JlJyk7XG52YXIgcmVtb3ZlID0gcmVxdWlyZSgnLi9yZW1vdmUnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vdmFsdWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IGNyZWF0ZU5vZGU6IGNyZWF0ZU5vZGUsIGdldENoaWxkcmVuOiBnZXRDaGlsZHJlbiwgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsIHJlbW92ZTogcmVtb3ZlLCB2YWx1ZTogdmFsdWUgfTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIGluc2VydEJlZm9yZShmbiwgcm9vdCwgcGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gICAgaWYgKHJvb3QpIGZuLnJlbW92ZShmbiwgcm9vdCwgY2hpbGROb2RlKTtcblxuICAgIGlmIChyZWZlcmVuY2VOb2RlKSB7XG4gICAgICB2YXIgcmVmZXJlbmNlSW5kZXggPSBwYXJlbnROb2RlLmNoaWxkcmVuLmluZGV4T2YocmVmZXJlbmNlTm9kZSk7XG5cbiAgICAgIHBhcmVudE5vZGUuY2hpbGRyZW4uc3BsaWNlKHJlZmVyZW5jZUluZGV4LCAwLCBjaGlsZE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnROb2RlLmNoaWxkcmVuLnB1c2goY2hpbGROb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGROb2RlO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdyb290Tm9kZScsICdub2RlJywgJ25vZGUnLCAnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnbm9kZScsXG4gIHJlcXVpcmVzOiBbJ3JlbW92ZSddLFxuICBjYXRlZ29yaWVzOiBbJ21hbmlwdWxhdGlvbicsICdhZGFwdGVyJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoZm4sIHJvb3QsIG5vZGUpIHtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IGZuLmdldFBhcmVudChmbiwgcm9vdCwgbm9kZSk7XG5cbiAgICBpZiAoIXBhcmVudE5vZGUpIHJldHVybjtcblxuICAgIHZhciBpbmRleCA9IHBhcmVudE5vZGUuY2hpbGRyZW4uaW5kZXhPZihub2RlKTtcblxuICAgIHBhcmVudE5vZGUuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdyb290Tm9kZScsICdub2RlJ10sXG4gIHJldHVyblR5cGU6ICdub2RlJyxcbiAgcmVxdWlyZXM6IFsnZ2V0UGFyZW50J10sXG4gIGNhdGVnb3JpZXM6IFsnbWFuaXB1bGF0aW9uJywgJ2FkYXB0ZXInXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobm9kZSwgX3ZhbHVlKSB7XG4gICAgaWYgKF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBub2RlLnZhbHVlID0gX3ZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlLnZhbHVlO1xuICB9LFxuICBhcmdUeXBlczogWydub2RlJywgJ25vZGVWYWx1ZT8nXSxcbiAgcmV0dXJuVHlwZTogJ25vZGVWYWx1ZScsXG4gIGNhdGVnb3JpZXM6IFsnbWFuaXB1bGF0aW9uJywgJ2FkYXB0ZXInXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVOb2RlOiBmdW5jdGlvbiBjcmVhdGVOb2RlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQWRhcHRlciBkb2VzIG5vdCBpbXBsZW1lbnQgY3JlYXRlTm9kZScpO1xuICB9LFxuICBhcmdUeXBlczogWydub2RlVmFsdWUnXSxcbiAgcmV0dXJuVHlwZTogJ25vZGUnLFxuICBjYXRlZ29yaWVzOiBbJ21hbmlwdWxhdGlvbicsICdhZGFwdGVyJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q2hpbGRyZW46IGZ1bmN0aW9uIGdldENoaWxkcmVuKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQWRhcHRlciBkb2VzIG5vdCBpbXBsZW1lbnQgZ2V0Q2hpbGRyZW4nKTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnW25vZGVdJyxcbiAgY2F0ZWdvcmllczogWyd0cmF2ZXJzYWwnLCAnYWRhcHRlciddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluc2VydEJlZm9yZTogZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQWRhcHRlciBkb2VzIG5vdCBpbXBsZW1lbnQgaW5zZXJ0QmVmb3JlJyk7XG4gIH0sXG4gIGFyZ1R5cGVzOiBbJ2ZuJywgJ3Jvb3ROb2RlJywgJ25vZGUnLCAnbm9kZScsICdub2RlJ10sXG4gIHJldHVyblR5cGU6ICdub2RlJyxcbiAgcmVxdWlyZXM6IFsncmVtb3ZlJ10sXG4gIGNhdGVnb3JpZXM6IFsnbWFuaXB1bGF0aW9uJywgJ2FkYXB0ZXInXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkYXB0ZXIgZG9lcyBub3QgaW1wbGVtZW50IHJlbW92ZScpO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdyb290Tm9kZScsICdub2RlJ10sXG4gIHJldHVyblR5cGU6ICdub2RlJyxcbiAgcmVxdWlyZXM6IFsnZ2V0UGFyZW50J10sXG4gIGNhdGVnb3JpZXM6IFsnbWFuaXB1bGF0aW9uJywgJ2FkYXB0ZXInXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBZGFwdGVyIGRvZXMgbm90IGltcGxlbWVudCB2YWx1ZScpO1xuICB9LFxuICBhcmdUeXBlczogWydub2RlJywgJ25vZGVWYWx1ZT8nXSxcbiAgcmV0dXJuVHlwZTogJ25vZGVWYWx1ZScsXG4gIGNhdGVnb3JpZXM6IFsnbWFuaXB1bGF0aW9uJywgJ2FkYXB0ZXInXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhcHBlbmQgPSByZXF1aXJlKCcuL21hbmlwdWxhdGlvbi9hcHBlbmQnKTtcbnZhciBlbXB0eSA9IHJlcXVpcmUoJy4vbWFuaXB1bGF0aW9uL2VtcHR5Jyk7XG52YXIgaW5zZXJ0QWZ0ZXIgPSByZXF1aXJlKCcuL21hbmlwdWxhdGlvbi9pbnNlcnRBZnRlcicpO1xudmFyIGluc2VydEF0ID0gcmVxdWlyZSgnLi9tYW5pcHVsYXRpb24vaW5zZXJ0QXQnKTtcbnZhciBwcmVwZW5kID0gcmVxdWlyZSgnLi9tYW5pcHVsYXRpb24vcHJlcGVuZCcpO1xudmFyIHJlbW92ZUF0ID0gcmVxdWlyZSgnLi9tYW5pcHVsYXRpb24vcmVtb3ZlQXQnKTtcbnZhciByZXBsYWNlQ2hpbGQgPSByZXF1aXJlKCcuL21hbmlwdWxhdGlvbi9yZXBsYWNlQ2hpbGQnKTtcbnZhciB1bndyYXAgPSByZXF1aXJlKCcuL21hbmlwdWxhdGlvbi91bndyYXAnKTtcbnZhciB3cmFwID0gcmVxdWlyZSgnLi9tYW5pcHVsYXRpb24vd3JhcCcpO1xuXG52YXIgYW5jZXN0b3JzID0gcmVxdWlyZSgnLi90cmF2ZXJzYWwvYW5jZXN0b3JzJyk7XG52YXIgY2hpbGRBdCA9IHJlcXVpcmUoJy4vdHJhdmVyc2FsL2NoaWxkQXQnKTtcbnZhciBjbG9zZXN0ID0gcmVxdWlyZSgnLi90cmF2ZXJzYWwvY2xvc2VzdCcpO1xudmFyIGNvbnRhaW5zID0gcmVxdWlyZSgnLi90cmF2ZXJzYWwvY29udGFpbnMnKTtcbnZhciBkZXNjZW5kZW50cyA9IHJlcXVpcmUoJy4vdHJhdmVyc2FsL2Rlc2NlbmRlbnRzJyk7XG52YXIgZmluZCA9IHJlcXVpcmUoJy4vdHJhdmVyc2FsL2ZpbmQnKTtcbnZhciBmaW5kQWxsID0gcmVxdWlyZSgnLi90cmF2ZXJzYWwvZmluZEFsbCcpO1xudmFyIGZpcnN0Q2hpbGQgPSByZXF1aXJlKCcuL3RyYXZlcnNhbC9maXJzdENoaWxkJyk7XG52YXIgZ2V0UGFyZW50ID0gcmVxdWlyZSgnLi90cmF2ZXJzYWwvZ2V0UGFyZW50Jyk7XG52YXIgaGFzQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNhbC9oYXNDaGlsZHJlbicpO1xudmFyIGlzRW1wdHkgPSByZXF1aXJlKCcuL3RyYXZlcnNhbC9pc0VtcHR5Jyk7XG52YXIgbGFzdENoaWxkID0gcmVxdWlyZSgnLi90cmF2ZXJzYWwvbGFzdENoaWxkJyk7XG52YXIgbmV4dFNpYmxpbmcgPSByZXF1aXJlKCcuL3RyYXZlcnNhbC9uZXh0U2libGluZycpO1xudmFyIHByZXZpb3VzU2libGluZyA9IHJlcXVpcmUoJy4vdHJhdmVyc2FsL3ByZXZpb3VzU2libGluZycpO1xudmFyIHNpYmxpbmdzID0gcmVxdWlyZSgnLi90cmF2ZXJzYWwvc2libGluZ3MnKTtcbnZhciB3YWxrID0gcmVxdWlyZSgnLi90cmF2ZXJzYWwvd2FsaycpO1xudmFyIHdhbGtVcCA9IHJlcXVpcmUoJy4vdHJhdmVyc2FsL3dhbGtVcCcpO1xuXG52YXIgY3JlYXRlTm9kZSA9IHJlcXVpcmUoJy4vYWRhcHRlci9jcmVhdGVOb2RlJyk7XG52YXIgZ2V0Q2hpbGRyZW4gPSByZXF1aXJlKCcuL2FkYXB0ZXIvZ2V0Q2hpbGRyZW4nKTtcbnZhciBpbnNlcnRCZWZvcmUgPSByZXF1aXJlKCcuL2FkYXB0ZXIvaW5zZXJ0QmVmb3JlJyk7XG52YXIgcmVtb3ZlID0gcmVxdWlyZSgnLi9hZGFwdGVyL3JlbW92ZScpO1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi9hZGFwdGVyL3ZhbHVlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhcHBlbmQ6IGFwcGVuZCwgZW1wdHk6IGVtcHR5LCBpbnNlcnRBZnRlcjogaW5zZXJ0QWZ0ZXIsIGluc2VydEF0OiBpbnNlcnRBdCwgcHJlcGVuZDogcHJlcGVuZCwgcmVtb3ZlQXQ6IHJlbW92ZUF0LCByZXBsYWNlQ2hpbGQ6IHJlcGxhY2VDaGlsZCxcbiAgdW53cmFwOiB1bndyYXAsIHdyYXA6IHdyYXAsIGFuY2VzdG9yczogYW5jZXN0b3JzLCBjaGlsZEF0OiBjaGlsZEF0LCBjbG9zZXN0OiBjbG9zZXN0LCBjb250YWluczogY29udGFpbnMsIGRlc2NlbmRlbnRzOiBkZXNjZW5kZW50cywgZmluZDogZmluZCxcbiAgZmluZEFsbDogZmluZEFsbCwgZmlyc3RDaGlsZDogZmlyc3RDaGlsZCwgZ2V0UGFyZW50OiBnZXRQYXJlbnQsIGhhc0NoaWxkcmVuOiBoYXNDaGlsZHJlbiwgaXNFbXB0eTogaXNFbXB0eSwgbGFzdENoaWxkOiBsYXN0Q2hpbGQsIG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcbiAgcHJldmlvdXNTaWJsaW5nOiBwcmV2aW91c1NpYmxpbmcsIHNpYmxpbmdzOiBzaWJsaW5ncywgd2Fsazogd2Fsaywgd2Fsa1VwOiB3YWxrVXAsIGNyZWF0ZU5vZGU6IGNyZWF0ZU5vZGUsIGdldENoaWxkcmVuOiBnZXRDaGlsZHJlbixcbiAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsIHJlbW92ZTogcmVtb3ZlLCB2YWx1ZTogdmFsdWVcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXBwZW5kOiBmdW5jdGlvbiBhcHBlbmQoZm4sIHJvb3QsIHBhcmVudE5vZGUsIGNoaWxkTm9kZSkge1xuICAgIHJldHVybiBmbi5pbnNlcnRCZWZvcmUoZm4sIHJvb3QsIHBhcmVudE5vZGUsIGNoaWxkTm9kZSk7XG4gIH0sXG4gIGFyZ1R5cGVzOiBbJ2ZuJywgJ3Jvb3ROb2RlJywgJ25vZGUnLCAnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnbm9kZScsXG4gIHJlcXVpcmVzOiBbJ2luc2VydEJlZm9yZSddLFxuICBjYXRlZ29yaWVzOiBbJ21hbmlwdWxhdGlvbiddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVtcHR5OiBmdW5jdGlvbiBlbXB0eShmbiwgcm9vdCwgcGFyZW50Tm9kZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IGZuLmdldENoaWxkcmVuKHBhcmVudE5vZGUpLnNsaWNlKCk7XG5cbiAgICByZXR1cm4gY2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uIChyZW1vdmVkLCBub2RlKSB7XG4gICAgICByZW1vdmVkLnB1c2goZm4ucmVtb3ZlKGZuLCBwYXJlbnROb2RlLCBub2RlKSk7XG5cbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0sIFtdKTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAncm9vdE5vZGUnLCAnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnW25vZGVdJyxcbiAgcmVxdWlyZXM6IFsnZ2V0Q2hpbGRyZW4nLCAncmVtb3ZlJ10sXG4gIGNhdGVnb3JpZXM6IFsnbWFuaXB1bGF0aW9uJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5zZXJ0QWZ0ZXI6IGZ1bmN0aW9uIGluc2VydEFmdGVyKGZuLCByb290LCBwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBmbi5nZXRDaGlsZHJlbihwYXJlbnROb2RlKTtcbiAgICB2YXIgcmVmZXJlbmNlSW5kZXggPSBjaGlsZHJlbi5pbmRleE9mKHJlZmVyZW5jZU5vZGUpO1xuICAgIHZhciBiZWZvcmVOb2RlID0gY2hpbGRyZW5bcmVmZXJlbmNlSW5kZXggKyAxXTtcblxuICAgIHJldHVybiBmbi5pbnNlcnRCZWZvcmUoZm4sIHJvb3QsIHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgYmVmb3JlTm9kZSk7XG4gIH0sXG4gIGFyZ1R5cGVzOiBbJ2ZuJywgJ3Jvb3ROb2RlJywgJ25vZGUnLCAnbm9kZScsICdub2RlJ10sXG4gIHJldHVyblR5cGU6ICdub2RlJyxcbiAgcmVxdWlyZXM6IFsnZ2V0Q2hpbGRyZW4nLCAnaW5zZXJ0QmVmb3JlJ10sXG4gIGNhdGVnb3JpZXM6IFsnbWFuaXB1bGF0aW9uJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5zZXJ0QXQ6IGZ1bmN0aW9uIGluc2VydEF0KGZuLCByb290LCBwYXJlbnROb2RlLCBjaGlsZE5vZGUsIGluZGV4KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gZm4uZ2V0Q2hpbGRyZW4ocGFyZW50Tm9kZSk7XG4gICAgdmFyIHJlZmVyZW5jZU5vZGUgPSBjaGlsZHJlbltpbmRleF07XG5cbiAgICByZXR1cm4gZm4uaW5zZXJ0QmVmb3JlKGZuLCByb290LCBwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdyb290Tm9kZScsICdub2RlJywgJ25vZGUnLCAnaW50ZWdlciddLFxuICByZXR1cm5UeXBlOiAnbm9kZScsXG4gIHJlcXVpcmVzOiBbJ2dldENoaWxkcmVuJywgJ2luc2VydEJlZm9yZSddLFxuICBjYXRlZ29yaWVzOiBbJ21hbmlwdWxhdGlvbiddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHByZXBlbmQ6IGZ1bmN0aW9uIHByZXBlbmQoZm4sIHJvb3QsIHBhcmVudE5vZGUsIGNoaWxkTm9kZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IGZuLmdldENoaWxkcmVuKHBhcmVudE5vZGUpO1xuXG4gICAgLy8gaWYgY2hpbGRbIDAgXSBpcyB1bmRlZmluZWQgdGhpcyBpcyB0aGUgc2FtZSBhcyBhcHBlbmRcbiAgICByZXR1cm4gZm4uaW5zZXJ0QmVmb3JlKGZuLCByb290LCBwYXJlbnROb2RlLCBjaGlsZE5vZGUsIGNoaWxkcmVuWzBdKTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAncm9vdE5vZGUnLCAnbm9kZScsICdub2RlJ10sXG4gIHJldHVyblR5cGU6ICdub2RlJyxcbiAgcmVxdWlyZXM6IFsnZ2V0Q2hpbGRyZW4nLCAnaW5zZXJ0QmVmb3JlJ10sXG4gIGNhdGVnb3JpZXM6IFsnbWFuaXB1bGF0aW9uJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVtb3ZlQXQ6IGZ1bmN0aW9uIHJlbW92ZUF0KGZuLCByb290LCBwYXJlbnROb2RlLCBpbmRleCkge1xuICAgIHZhciBjaGlsZHJlbiA9IGZuLmdldENoaWxkcmVuKHBhcmVudE5vZGUpO1xuICAgIHZhciBjaGlsZE5vZGUgPSBjaGlsZHJlbltpbmRleF07XG5cbiAgICByZXR1cm4gZm4ucmVtb3ZlKGZuLCByb290LCBjaGlsZE5vZGUpO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdyb290Tm9kZScsICdub2RlJywgJ2ludGVnZXInXSxcbiAgcmV0dXJuVHlwZTogJ25vZGUnLFxuICByZXF1aXJlczogWydnZXRDaGlsZHJlbicsICdyZW1vdmUnXSxcbiAgY2F0ZWdvcmllczogWydtYW5pcHVsYXRpb24nXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZXBsYWNlQ2hpbGQ6IGZ1bmN0aW9uIHJlcGxhY2VDaGlsZChmbiwgcm9vdCwgcGFyZW50Tm9kZSwgbmV3Tm9kZSwgb2xkTm9kZSkge1xuICAgIGZuLmluc2VydEJlZm9yZShmbiwgcm9vdCwgcGFyZW50Tm9kZSwgbmV3Tm9kZSwgb2xkTm9kZSk7XG5cbiAgICByZXR1cm4gZm4ucmVtb3ZlKGZuLCByb290LCBvbGROb2RlKTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAncm9vdE5vZGUnLCAnbm9kZScsICdub2RlJywgJ25vZGUnXSxcbiAgcmV0dXJuVHlwZTogJ25vZGUnLFxuICByZXF1aXJlczogWydpbnNlcnRCZWZvcmUnLCAncmVtb3ZlJ10sXG4gIGNhdGVnb3JpZXM6IFsnbWFuaXB1bGF0aW9uJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdW53cmFwOiBmdW5jdGlvbiB1bndyYXAoZm4sIHJvb3QsIG5vZGUpIHtcbiAgICB2YXIgcGFyZW50ID0gZm4uZ2V0UGFyZW50KGZuLCByb290LCBub2RlKTtcbiAgICB2YXIgZ3JhbmRwYXJlbnQgPSBmbi5nZXRQYXJlbnQoZm4sIHJvb3QsIHBhcmVudCk7XG4gICAgdmFyIGNoaWxkcmVuID0gZm4uZ2V0Q2hpbGRyZW4ocGFyZW50KTtcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gZm4uaW5zZXJ0QmVmb3JlKGZuLCByb290LCBncmFuZHBhcmVudCwgY2hpbGQsIHBhcmVudCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZm4ucmVtb3ZlKGZuLCByb290LCBwYXJlbnQpO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdyb290Tm9kZScsICdub2RlJ10sXG4gIHJldHVyblR5cGU6ICdub2RlJyxcbiAgcmVxdWlyZXM6IFsnZ2V0UGFyZW50JywgJ2dldENoaWxkcmVuJywgJ2luc2VydEJlZm9yZScsICdyZW1vdmUnXSxcbiAgY2F0ZWdvcmllczogWydtYW5pcHVsYXRpb24nXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3cmFwOiBmdW5jdGlvbiB3cmFwKGZuLCByb290LCBub2RlLCBuZXdOb2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IGZuLmdldFBhcmVudChmbiwgcm9vdCwgbm9kZSk7XG5cbiAgICBmbi5pbnNlcnRCZWZvcmUoZm4sIHJvb3QsIHBhcmVudCwgbmV3Tm9kZSwgbm9kZSk7XG4gICAgZm4uYXBwZW5kKGZuLCByb290LCBuZXdOb2RlLCBub2RlKTtcblxuICAgIHJldHVybiBuZXdOb2RlO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdyb290Tm9kZScsICdub2RlJywgJ25vZGUnXSxcbiAgcmV0dXJuVHlwZTogJ25vZGUnLFxuICByZXF1aXJlczogWydnZXRQYXJlbnQnLCAnaW5zZXJ0QmVmb3JlJywgJ2FwcGVuZCddLFxuICBjYXRlZ29yaWVzOiBbJ21hbmlwdWxhdGlvbiddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFuY2VzdG9yczogZnVuY3Rpb24gYW5jZXN0b3JzKGZuLCByb290LCBub2RlKSB7XG4gICAgdmFyIHBhcmVudE5vZGVzID0gW107XG5cbiAgICB2YXIgcGFyZW50ID0gZm4uZ2V0UGFyZW50KGZuLCByb290LCBub2RlKTtcblxuICAgIGlmIChwYXJlbnQpIGZuLndhbGtVcChmbiwgcm9vdCwgcGFyZW50LCBmdW5jdGlvbiAobikge1xuICAgICAgcGFyZW50Tm9kZXMucHVzaChuKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwYXJlbnROb2RlcztcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAncm9vdE5vZGUnLCAnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnW25vZGVdJyxcbiAgcmVxdWlyZXM6IFsnZ2V0UGFyZW50JywgJ3dhbGtVcCddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNoaWxkQXQ6IGZ1bmN0aW9uIGNoaWxkQXQoZm4sIG5vZGUsIGkpIHtcbiAgICByZXR1cm4gZm4uZ2V0Q2hpbGRyZW4obm9kZSlbaV07XG4gIH0sXG4gIGFyZ1R5cGVzOiBbJ2ZuJywgJ25vZGUnLCAnaW50ZWdlciddLFxuICByZXR1cm5UeXBlOiAnbm9kZScsXG4gIHJlcXVpcmVzOiBbJ2dldENoaWxkcmVuJ10sXG4gIGNhdGVnb3JpZXM6IFsndHJhdmVyc2FsJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2xvc2VzdDogZnVuY3Rpb24gY2xvc2VzdChmbiwgcm9vdCwgbm9kZSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIHRhcmdldE5vZGUgPSB2b2lkIDA7XG5cbiAgICBmbi53YWxrVXAoZm4sIHJvb3QsIG5vZGUsIGZ1bmN0aW9uIChjdXJyZW50Tm9kZSkge1xuICAgICAgaWYgKHByZWRpY2F0ZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgdGFyZ2V0Tm9kZSA9IGN1cnJlbnROb2RlO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRhcmdldE5vZGU7XG4gIH0sXG4gIGFyZ1R5cGVzOiBbJ2ZuJywgJ3Jvb3ROb2RlJywgJ25vZGUnLCAnbm9kZSA9PiBib29sZWFuJ10sXG4gIHJldHVyblR5cGU6ICdub2RlJyxcbiAgcmVxdWlyZXM6IFsnd2Fsa1VwJ10sXG4gIGNhdGVnb3JpZXM6IFsndHJhdmVyc2FsJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29udGFpbnM6IGZ1bmN0aW9uIGNvbnRhaW5zKGZuLCBub2RlLCBwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gISFmbi5maW5kKGZuLCBub2RlLCBwcmVkaWNhdGUpO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdub2RlJywgJ25vZGUgPT4gYm9vbGVhbiddLFxuICByZXR1cm5UeXBlOiAnYm9vbGVhbicsXG4gIHJlcXVpcmVzOiBbJ2ZpbmQnXSxcbiAgY2F0ZWdvcmllczogWyd0cmF2ZXJzYWwnXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXNjZW5kZW50czogZnVuY3Rpb24gZGVzY2VuZGVudHMoZm4sIG5vZGUpIHtcbiAgICByZXR1cm4gZm4uZmluZEFsbChmbiwgbm9kZSwgZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBuICE9PSBub2RlO1xuICAgIH0pO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdub2RlJ10sXG4gIHJldHVyblR5cGU6ICdbbm9kZV0nLFxuICByZXF1aXJlczogWydmaW5kQWxsJ10sXG4gIGNhdGVnb3JpZXM6IFsndHJhdmVyc2FsJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChmbiwgbm9kZSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIHRhcmdldE5vZGUgPSB2b2lkIDA7XG5cbiAgICBmbi53YWxrKGZuLCBub2RlLCBmdW5jdGlvbiAoY3VycmVudE5vZGUpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoY3VycmVudE5vZGUpKSB7XG4gICAgICAgIHRhcmdldE5vZGUgPSBjdXJyZW50Tm9kZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0YXJnZXROb2RlO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdub2RlJywgJ25vZGUgPT4gYm9vbGVhbiddLFxuICByZXR1cm5UeXBlOiAnbm9kZScsXG4gIHJlcXVpcmVzOiBbJ3dhbGsnXSxcbiAgY2F0ZWdvcmllczogWyd0cmF2ZXJzYWwnXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmaW5kQWxsOiBmdW5jdGlvbiBmaW5kQWxsKGZuLCBub2RlLCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgbm9kZXMgPSBbXTtcblxuICAgIGZuLndhbGsoZm4sIG5vZGUsIGZ1bmN0aW9uIChjdXJyZW50Tm9kZSkge1xuICAgICAgaWYgKHByZWRpY2F0ZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgbm9kZXMucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH0sXG4gIGFyZ1R5cGVzOiBbJ2ZuJywgJ25vZGUnLCAnbm9kZSA9PiBib29sZWFuJ10sXG4gIHJldHVyblR5cGU6ICdbbm9kZV0nLFxuICByZXF1aXJlczogWyd3YWxrJ10sXG4gIGNhdGVnb3JpZXM6IFsndHJhdmVyc2FsJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmlyc3RDaGlsZDogZnVuY3Rpb24gZmlyc3RDaGlsZChmbiwgbm9kZSkge1xuICAgIHJldHVybiBmbi5nZXRDaGlsZHJlbihub2RlKVswXTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnbm9kZScsXG4gIHJlcXVpcmVzOiBbJ2dldENoaWxkcmVuJ10sXG4gIGNhdGVnb3JpZXM6IFsndHJhdmVyc2FsJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0UGFyZW50OiBmdW5jdGlvbiBnZXRQYXJlbnQoZm4sIHJvb3QsIG5vZGUpIHtcbiAgICByZXR1cm4gZm4uZmluZChmbiwgcm9vdCwgZnVuY3Rpb24gKGN1cnJlbnROb2RlKSB7XG4gICAgICByZXR1cm4gZm4uZ2V0Q2hpbGRyZW4oY3VycmVudE5vZGUpLmluY2x1ZGVzKG5vZGUpO1xuICAgIH0pO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdyb290Tm9kZScsICdub2RlJ10sXG4gIHJldHVyblR5cGU6ICdub2RlJyxcbiAgcmVxdWlyZXM6IFsnZmluZCcsICdnZXRDaGlsZHJlbiddLFxuICBjYXRlZ29yaWVzOiBbJ3RyYXZlcnNhbCddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGhhc0NoaWxkcmVuOiBmdW5jdGlvbiBoYXNDaGlsZHJlbihmbiwgbm9kZSkge1xuICAgIHJldHVybiBmbi5nZXRDaGlsZHJlbihub2RlKS5sZW5ndGggPiAwO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdub2RlJ10sXG4gIHJldHVyblR5cGU6ICdib29sZWFuJyxcbiAgcmVxdWlyZXM6IFsnZ2V0Q2hpbGRyZW4nXSxcbiAgY2F0ZWdvcmllczogWyd0cmF2ZXJzYWwnXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KGZuLCBub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgYXJnVHlwZXM6IFsnZm4nLCAnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnYm9vbGVhbicsXG4gIHJlcXVpcmVzOiBbXSxcbiAgY2F0ZWdvcmllczogWyd0cmF2ZXJzYWwnXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsYXN0Q2hpbGQ6IGZ1bmN0aW9uIGxhc3RDaGlsZChmbiwgbm9kZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IGZuLmdldENoaWxkcmVuKG5vZGUpO1xuXG4gICAgcmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdub2RlJ10sXG4gIHJldHVyblR5cGU6ICdub2RlJyxcbiAgcmVxdWlyZXM6IFsnZ2V0Q2hpbGRyZW4nXSxcbiAgY2F0ZWdvcmllczogWyd0cmF2ZXJzYWwnXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBuZXh0U2libGluZzogZnVuY3Rpb24gbmV4dFNpYmxpbmcoZm4sIHJvb3QsIG5vZGUpIHtcbiAgICB2YXIgcGFyZW50ID0gZm4uZ2V0UGFyZW50KGZuLCByb290LCBub2RlKTtcbiAgICB2YXIgY2hpbGRyZW4gPSBmbi5nZXRDaGlsZHJlbihwYXJlbnQpO1xuXG4gICAgdmFyIGluZGV4ID0gY2hpbGRyZW4uaW5kZXhPZihub2RlKTtcblxuICAgIHJldHVybiBjaGlsZHJlbltpbmRleCArIDFdO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdyb290Tm9kZScsICdub2RlJ10sXG4gIHJldHVyblR5cGU6ICdub2RlJyxcbiAgcmVxdWlyZXM6IFsnZ2V0UGFyZW50JywgJ2dldENoaWxkcmVuJ10sXG4gIGNhdGVnb3JpZXM6IFsndHJhdmVyc2FsJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcHJldmlvdXNTaWJsaW5nOiBmdW5jdGlvbiBwcmV2aW91c1NpYmxpbmcoZm4sIHJvb3QsIG5vZGUpIHtcbiAgICB2YXIgcGFyZW50ID0gZm4uZ2V0UGFyZW50KGZuLCByb290LCBub2RlKTtcbiAgICB2YXIgY2hpbGRyZW4gPSBmbi5nZXRDaGlsZHJlbihwYXJlbnQpO1xuXG4gICAgdmFyIGluZGV4ID0gY2hpbGRyZW4uaW5kZXhPZihub2RlKTtcblxuICAgIHJldHVybiBjaGlsZHJlbltpbmRleCAtIDFdO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdyb290Tm9kZScsICdub2RlJ10sXG4gIHJldHVyblR5cGU6ICdub2RlJyxcbiAgcmVxdWlyZXM6IFsnZ2V0UGFyZW50JywgJ2dldENoaWxkcmVuJ10sXG4gIGNhdGVnb3JpZXM6IFsndHJhdmVyc2FsJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2libGluZ3M6IGZ1bmN0aW9uIHNpYmxpbmdzKGZuLCByb290LCBub2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IGZuLmdldFBhcmVudChmbiwgcm9vdCwgbm9kZSk7XG4gICAgdmFyIGNoaWxkcmVuID0gZm4uZ2V0Q2hpbGRyZW4ocGFyZW50KTtcblxuICAgIHJldHVybiBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQgIT09IG5vZGU7XG4gICAgfSk7XG4gIH0sXG4gIGFyZ1R5cGVzOiBbJ2ZuJywgJ3Jvb3ROb2RlJywgJ25vZGUnXSxcbiAgcmV0dXJuVHlwZTogJ1tub2RlXScsXG4gIHJlcXVpcmVzOiBbJ2dldFBhcmVudCcsICdnZXRDaGlsZHJlbiddLFxuICBjYXRlZ29yaWVzOiBbJ3RyYXZlcnNhbCddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHdhbGs6IGZ1bmN0aW9uIHdhbGsoZm4sIG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB2b2lkIDAsXG4gICAgICAgIHBhcmVudCA9IHZvaWQgMCxcbiAgICAgICAgZGVwdGggPSB2b2lkIDAsXG4gICAgICAgIGkgPSB2b2lkIDAsXG4gICAgICAgIGNoaWxkcmVuID0gdm9pZCAwLFxuICAgICAgICBzdG9wID0gdm9pZCAwO1xuICAgIHZhciBub2RlcyA9IFtub2RlXTtcbiAgICB2YXIgcGFyZW50cyA9IFtudWxsXTtcbiAgICB2YXIgZGVwdGhzID0gWzBdO1xuXG4gICAgd2hpbGUgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgY3VycmVudCA9IG5vZGVzLnBvcCgpO1xuICAgICAgcGFyZW50ID0gcGFyZW50cy5wb3AoKTtcbiAgICAgIGRlcHRoID0gZGVwdGhzLnBvcCgpO1xuXG4gICAgICBzdG9wID0gY2FsbGJhY2soY3VycmVudCwgcGFyZW50LCBkZXB0aCk7XG5cbiAgICAgIGlmIChzdG9wKSBicmVhaztcblxuICAgICAgY2hpbGRyZW4gPSBmbi5nZXRDaGlsZHJlbihjdXJyZW50KTtcblxuICAgICAgZm9yIChpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbm9kZXMucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgZGVwdGhzLnB1c2goZGVwdGggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGFyZ1R5cGVzOiBbJ2ZuJywgJ25vZGUnLCAnKCBub2RlLCBub2RlLCBpbnRlZ2VyICkgPT4gYm9vbGVhbiddLFxuICByZXF1aXJlczogWydnZXRDaGlsZHJlbiddLFxuICBjYXRlZ29yaWVzOiBbJ3RyYXZlcnNhbCddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHdhbGtVcDogZnVuY3Rpb24gd2Fsa1VwKGZuLCByb290LCBub2RlLCBjYWxsYmFjaykge1xuICAgIHZhciBzdG9wID0gY2FsbGJhY2sobm9kZSk7XG5cbiAgICBpZiAoIXN0b3ApIHtcbiAgICAgIHZhciBwYXJlbnQgPSBmbi5nZXRQYXJlbnQoZm4sIHJvb3QsIG5vZGUpO1xuICAgICAgd2hpbGUgKHBhcmVudCAmJiAhc3RvcCkge1xuICAgICAgICBzdG9wID0gY2FsbGJhY2socGFyZW50KTtcbiAgICAgICAgaWYgKCFzdG9wKSBwYXJlbnQgPSBmbi5nZXRQYXJlbnQoZm4sIHJvb3QsIHBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBhcmdUeXBlczogWydmbicsICdyb290Tm9kZScsICdub2RlJywgJ25vZGUgPT4gYm9vbGVhbiddLFxuICByZXF1aXJlczogWydnZXRQYXJlbnQnXSxcbiAgY2F0ZWdvcmllczogWyd0cmF2ZXJzYWwnXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBiYXNlRGVmcyA9IHJlcXVpcmUoJy4vZGVmcycpO1xuXG52YXIgbWFwcGVyID0gZnVuY3Rpb24gbWFwcGVyKGRlZnMpIHtcbiAgdmFyIG1ha2VGbiA9IGZ1bmN0aW9uIG1ha2VGbihuYW1lKSB7XG4gICAgdmFyIGZuRGVmID0gZGVmc1tuYW1lXTtcbiAgICB2YXIgZm4gPSBmbkRlZltuYW1lXTtcblxuICAgIGZuLmRlZiA9IGZuRGVmO1xuXG4gICAgcmV0dXJuIGZuO1xuICB9O1xuXG4gIHZhciBmbmFtZXMgPSBPYmplY3Qua2V5cyhkZWZzKTtcblxuICByZXR1cm4gZm5hbWVzLnJlZHVjZShmdW5jdGlvbiAoZm5zLCBuYW1lKSB7XG4gICAgZm5zW25hbWVdID0gbWFrZUZuKG5hbWUpO1xuXG4gICAgcmV0dXJuIGZucztcbiAgfSwge30pO1xufTtcblxudmFyIGZuRmFjdG9yeSA9IGZ1bmN0aW9uIGZuRmFjdG9yeShhZGFwdGVyKSB7XG4gIHZhciBhZGFwdGVyRGVmcyA9IE9iamVjdC5rZXlzKGFkYXB0ZXIpLnJlZHVjZShmdW5jdGlvbiAoZGVmcywgZm5hbWUpIHtcbiAgICB2YXIgYWRhcHRlckRlZiA9IGFkYXB0ZXJbZm5hbWVdO1xuXG4gICAgaWYgKHR5cGVvZiBhZGFwdGVyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgZm4gPSBhZGFwdGVyRGVmO1xuICAgICAgYWRhcHRlckRlZiA9IGFkYXB0ZXJEZWYuZGVmIHx8IGJhc2VEZWZzW2ZuYW1lXSB8fCB7fTtcbiAgICAgIGFkYXB0ZXJEZWZbZm5hbWVdID0gZm47XG4gICAgfVxuXG4gICAgZGVmc1tmbmFtZV0gPSBhZGFwdGVyRGVmO1xuXG4gICAgcmV0dXJuIGRlZnM7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gbWFwcGVyKE9iamVjdC5hc3NpZ24oe30sIGJhc2VEZWZzLCBhZGFwdGVyRGVmcykpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmbkZhY3Rvcnk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL3BvbHlmaWxscycpO1xuXG52YXIgZGVmYXVsdEFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXIvZGVmYXVsdCcpO1xudmFyIGZuRmFjdG9yeSA9IHJlcXVpcmUoJy4vZm4tZmFjdG9yeScpO1xuXG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vcGx1Z2lucy9tZXRhJyk7XG52YXIgcGFyZW50TWFwID0gcmVxdWlyZSgnLi9wbHVnaW5zL3BhcmVudC1tYXAnKTtcbnZhciBzZXJpYWxpemVyID0gcmVxdWlyZSgnLi9wbHVnaW5zL3NlcmlhbGl6ZXInKTtcbnZhciB3cmFwTm9kZXMgPSByZXF1aXJlKCcuL3BsdWdpbnMvd3JhcC1ub2RlcycpO1xudmFyIGFjY2VwdHMgPSByZXF1aXJlKCcuL3BsdWdpbnMvYWNjZXB0cycpO1xudmFyIG5vZGVUeXBlID0gcmVxdWlyZSgnLi9wbHVnaW5zL25vZGVUeXBlJyk7XG52YXIgaWQgPSByZXF1aXJlKCcuL3BsdWdpbnMvaWQnKTtcblxudmFyIHBsdWdpbnMgPSB7IHBhcmVudE1hcDogcGFyZW50TWFwLCBhY2NlcHRzOiBhY2NlcHRzLCBub2RlVHlwZTogbm9kZVR5cGUsIGlkOiBpZCwgc2VyaWFsaXplcjogc2VyaWFsaXplciwgbWV0YTogbWV0YSwgd3JhcE5vZGVzOiB3cmFwTm9kZXMgfTtcbnZhciBwbHVnaW5BcnJheSA9IE9iamVjdC5rZXlzKHBsdWdpbnMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBwbHVnaW5zW2tleV07XG59KTtcblxudmFyIHRyZWVGYWN0b3J5ID0gZnVuY3Rpb24gdHJlZUZhY3RvcnkoYWRhcHRlciwgcGx1Z2lucykge1xuICB2YXIgZm4gPSBmbkZhY3RvcnkoYWRhcHRlcik7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocGx1Z2lucykpIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgcmV0dXJuIHBsdWdpbihmbik7XG4gIH0pO1xuXG4gIC8vIGNyZWF0ZSB3cmFwcGVkIEFQSVxuICB2YXIgVHJlZSA9IGZ1bmN0aW9uIFRyZWUocm9vdCkge1xuICAgIHJldHVybiBmbi5jcmVhdGVUcmVlKHJvb3QpO1xuICB9O1xuXG4gIHZhciBmbmFtZXMgPSBPYmplY3Qua2V5cyhmbik7XG5cbiAgZm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGZuYW1lKSB7XG4gICAgdmFyIGZ1bmMgPSBmbltmbmFtZV07XG4gICAgdmFyIGRlZiA9IGZ1bmMuZGVmIHx8IHt9O1xuICAgIHZhciBhcmdUeXBlcyA9IEFycmF5LmlzQXJyYXkoZGVmLmFyZ1R5cGVzKSA/IGRlZi5hcmdUeXBlcyA6IFtdO1xuXG4gICAgVHJlZVtmbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJnVHlwZXMuaW5jbHVkZXMoJ2ZuJykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBbZm5dLmNvbmNhdChhcmdzKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgVHJlZS5jcmVhdGVSb290ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIFRyZWUoVHJlZS5jcmVhdGVOb2RlKHZhbHVlKSk7XG4gIH07XG4gIFRyZWUuZm4gPSBmbjtcbiAgVHJlZS5hZGFwdGVyID0gdHJlZUZhY3Rvcnk7XG4gIFRyZWUucGx1Z2luID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIHJldHVybiBwbHVnaW4oZm4pO1xuICB9O1xuICBUcmVlLnBsdWdpbnMgPSBwbHVnaW5zO1xuXG4gIHJldHVybiBUcmVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB0cmVlRmFjdG9yeShkZWZhdWx0QWRhcHRlciwgcGx1Z2luQXJyYXkpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFjY2VwdHNOb2RlID0gZnVuY3Rpb24gYWNjZXB0c05vZGUoZm4pIHtcbiAgdmFyIGFjY2VwdHMgPSBmdW5jdGlvbiBhY2NlcHRzKGZuLCBub2RlLCBjaGlsZE5vZGUpIHtcbiAgICByZXR1cm4gIWZuLmlzRW1wdHkoZm4sIG5vZGUpO1xuICB9OyAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICBhY2NlcHRzLmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydmbicsICdub2RlJywgJ25vZGUnXSxcbiAgICByZXR1cm5UeXBlOiAnYm9vbGVhbicsXG4gICAgcmVxdWlyZTogWydpc0VtcHR5J10sXG4gICAgY2F0ZWdvcmllczogWydub2RlJywgJ3BsdWdpbiddXG4gIH07XG5cbiAgdmFyIG9yaWdpbmFsSW5zZXJ0QmVmb3JlID0gZm4uaW5zZXJ0QmVmb3JlO1xuXG4gIHZhciBpbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiBpbnNlcnRCZWZvcmUoZm4sIHJvb3QsIHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAgIGlmICghZm4uYWNjZXB0cyhmbiwgcGFyZW50Tm9kZSwgY2hpbGROb2RlKSkgdGhyb3cgbmV3IEVycm9yKCdOb2RlIGNhbm5vdCBhY2NlcHQgdGhpcyBjaGlsZCcpO1xuXG4gICAgcmV0dXJuIG9yaWdpbmFsSW5zZXJ0QmVmb3JlKGZuLCByb290LCBwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICB9O1xuXG4gIGluc2VydEJlZm9yZS5kZWYgPSBvcmlnaW5hbEluc2VydEJlZm9yZS5kZWY7XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZm4sIHsgYWNjZXB0czogYWNjZXB0cywgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFjY2VwdHNOb2RlOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnbW9qdWxlLXV0aWxzJyk7XG5cbnZhciBsYXp5SWQgPSBmdW5jdGlvbiBsYXp5SWQoZm4pIHtcbiAgdmFyIGlkID0gZnVuY3Rpb24gaWQoZm4sIG5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSBmbi52YWx1ZShub2RlKTtcblxuICAgIGlmICh2YWx1ZS5faWQpIHJldHVybiB2YWx1ZS5faWQ7XG5cbiAgICB2YXIgbm9kZVR5cGUgPSBmbi5ub2RlVHlwZShmbiwgbm9kZSk7XG4gICAgdmFyIGlkID0gdXRpbHMuaWQobm9kZVR5cGUpO1xuXG4gICAgdmFsdWUuX2lkID0gaWQ7XG5cbiAgICBmbi52YWx1ZShub2RlLCB2YWx1ZSk7XG5cbiAgICByZXR1cm4gaWQ7XG4gIH07XG5cbiAgaWQuZGVmID0ge1xuICAgIGFyZ1R5cGVzOiBbJ2ZuJywgJ25vZGUnXSxcbiAgICByZXR1cm5UeXBlOiAnc3RyaW5nJyxcbiAgICByZXF1aXJlOiBbJ3ZhbHVlJywgJ25vZGVUeXBlJ10sXG4gICAgY2F0ZWdvcmllczogWydub2RlJywgJ3BsdWdpbiddXG4gIH07XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZm4sIHsgaWQ6IGlkIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBsYXp5SWQ7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKlxuICBHZXQvc2V0IHJ1bnRpbWUgZGF0YSBmb3Igbm9kZXMgdGhhdCBhcmVuJ3Qgd3JpdHRlbiB0byB0aGUgbm9kZXMgdGhlbXNlbHZlc1xuXG4gIEZvciBleGFtcGxlLCB3aGVuIHZpc3VhbGlzaW5nIHRyZWVzIHlvdSBtaWdodCB3YW50IHRvIGFsbG93IHRoZSB1c2VyIHRvXG4gIGNvbGxhcHNlIG9yIGV4cGFuZCBub2RlcyBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBzZXNzaW9uLCBidXQgbm90IGFjdHVhbGx5XG4gIG1vZGlmeSB0aGUgbm9kZXMgdGhlbXNlbHZlc1xuKi9cblxudmFyIG1ldGFQbHVnaW4gPSBmdW5jdGlvbiBtZXRhUGx1Z2luKGZuKSB7XG4gIHZhciBtZXRhTWFwID0gbmV3IE1hcCgpO1xuXG4gIHZhciBtZXRhID0gZnVuY3Rpb24gbWV0YShmbiwgbm9kZSwga2V5LCB2YWx1ZSkge1xuICAgIGlmICghbWV0YU1hcC5oYXMobm9kZSkpIHtcbiAgICAgIG1ldGFNYXAuc2V0KG5vZGUsIHt9KTtcbiAgICB9XG5cbiAgICB2YXIgb2JqID0gbWV0YU1hcC5nZXQobm9kZSk7XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH07XG5cbiAgbWV0YS5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnZm4nLCAnbm9kZScsICdzdHJpbmcnLCAnYW55J10sXG4gICAgcmV0dXJuVHlwZTogJ2FueScsXG4gICAgcmVxdWlyZXM6IFtdLFxuICAgIGNhdGVnb3JpZXM6IFsnbWV0YScsICdwbHVnaW4nXVxuICB9O1xuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKGZuLCB7IG1ldGE6IG1ldGEgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1ldGFQbHVnaW47IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0Tm9kZVR5cGUgPSBmdW5jdGlvbiBnZXROb2RlVHlwZShmbikge1xuICB2YXIgbm9kZVR5cGUgPSBmdW5jdGlvbiBub2RlVHlwZShmbiwgbm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IGZuLnZhbHVlKG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5ub2RlVHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubm9kZVR5cGUubGVuZ3RoID4gMCkgcmV0dXJuIHZhbHVlLm5vZGVUeXBlO1xuXG4gICAgcmV0dXJuICd0cmVlTm9kZSc7XG4gIH07XG5cbiAgbm9kZVR5cGUuZGVmID0ge1xuICAgIGFyZ1R5cGVzOiBbJ2ZuJywgJ25vZGUnXSxcbiAgICByZXR1cm5UeXBlOiAnc3RyaW5nJyxcbiAgICByZXF1aXJlOiBbJ3ZhbHVlJ10sXG4gICAgY2F0ZWdvcmllczogWydub2RlJywgJ3BsdWdpbiddXG4gIH07XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZm4sIHsgbm9kZVR5cGU6IG5vZGVUeXBlIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXROb2RlVHlwZTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBwYXJlbnRNYXAgPSBmdW5jdGlvbiBwYXJlbnRNYXAoZm4pIHtcbiAgdmFyIHBhcmVudHMgPSBuZXcgTWFwKCk7XG5cbiAgdmFyIG9yaWdpbmFsID0ge1xuICAgIGluc2VydEJlZm9yZTogZm4uaW5zZXJ0QmVmb3JlLFxuICAgIHJlbW92ZTogZm4ucmVtb3ZlLFxuICAgIGdldFBhcmVudDogZm4uZ2V0UGFyZW50XG4gIH07XG5cbiAgdmFyIGluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIGluc2VydEJlZm9yZShmbiwgcm9vdCwgcGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gICAgdmFyIHZhbHVlID0gb3JpZ2luYWwuaW5zZXJ0QmVmb3JlKGZuLCByb290LCBwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuXG4gICAgcGFyZW50cy5zZXQoY2hpbGROb2RlLCBwYXJlbnROb2RlKTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICB2YXIgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGZuLCByb290LCBub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gb3JpZ2luYWwucmVtb3ZlKGZuLCByb290LCBub2RlKTtcblxuICAgIHBhcmVudHMuc2V0KG5vZGUsIG51bGwpO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIHZhciBnZXRQYXJlbnQgPSBmdW5jdGlvbiBnZXRQYXJlbnQoZm4sIHJvb3QsIG5vZGUpIHtcbiAgICB2YXIgcGFyZW50ID0gcGFyZW50cy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIXBhcmVudCAmJiBvcmlnaW5hbC5nZXRQYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IG9yaWdpbmFsLmdldFBhcmVudChmbiwgcm9vdCwgbm9kZSk7XG4gICAgICBwYXJlbnRzLnNldChub2RlLCBwYXJlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJlbnQ7XG4gIH07XG5cbiAgdmFyIHdyYXBwZWQgPSB7IGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLCByZW1vdmU6IHJlbW92ZSwgZ2V0UGFyZW50OiBnZXRQYXJlbnQgfTtcblxuICBPYmplY3Qua2V5cyh3cmFwcGVkKS5mb3JFYWNoKGZ1bmN0aW9uIChmbmFtZSkge1xuICAgIHdyYXBwZWRbZm5hbWVdLmRlZiA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgd3JhcHM6IG9yaWdpbmFsW2ZuYW1lXVxuICAgIH0sIG9yaWdpbmFsW2ZuYW1lXS5kZWYpO1xuXG4gICAgd3JhcHBlZFtmbmFtZV0uZGVmLmNhdGVnb3JpZXMucHVzaCgncGFyZW50TWFwJywgJ3BsdWdpbicpO1xuICB9KTtcblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihmbiwgd3JhcHBlZCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudE1hcDsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjbG9uZU9iaiA9IGZ1bmN0aW9uIGNsb25lT2JqKG9iaikge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn07XG5cbnZhciBzZXJpYWxpemVyID0gZnVuY3Rpb24gc2VyaWFsaXplcihmbikge1xuICB2YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKG5vZGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGZuLnZhbHVlKG5vZGUpLFxuICAgICAgY2hpbGRyZW46IGZuLmdldENoaWxkcmVuKG5vZGUpLm1hcChzZXJpYWxpemUpXG4gICAgfTtcbiAgfTtcblxuICBzZXJpYWxpemUuZGVmID0ge1xuICAgIGFyZ1R5cGVzOiBbJ25vZGUnXSxcbiAgICByZXR1cm5UeXBlOiAnb2JqZWN0JyxcbiAgICByZXF1aXJlczogWyd2YWx1ZScsICdnZXRDaGlsZHJlbiddLFxuICAgIGNhdGVnb3JpZXM6IFsnc2VyaWFsaXplcicsICdwbHVnaW4nXVxuICB9O1xuXG4gIHZhciBkZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIGRlc2VyaWFsaXplKG9iaikge1xuICAgIHZhciBwYXJlbnROb2RlID0gZm4uY3JlYXRlTm9kZShvYmoudmFsdWUpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLmNoaWxkcmVuKSkge1xuICAgICAgb2JqLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGZuLmFwcGVuZChmbiwgbnVsbCwgcGFyZW50Tm9kZSwgZGVzZXJpYWxpemUoY2hpbGQpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJlbnROb2RlO1xuICB9O1xuXG4gIGRlc2VyaWFsaXplLmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydvYmplY3QnXSxcbiAgICByZXR1cm5UeXBlOiAnbm9kZScsXG4gICAgcmVxdWlyZXM6IFsnY3JlYXRlTm9kZScsICdhcHBlbmQnXSxcbiAgICBjYXRlZ29yaWVzOiBbJ3NlcmlhbGl6ZXInLCAncGx1Z2luJ11cbiAgfTtcblxuICB2YXIgY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShmbiwgbm9kZSkge1xuICAgIHJldHVybiBmbi5kZXNlcmlhbGl6ZShjbG9uZU9iaihmbi5zZXJpYWxpemUobm9kZSkpKTtcbiAgfTtcblxuICBjbG9uZS5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnZm4nLCAnbm9kZSddLFxuICAgIHJldHVyblR5cGU6ICdub2RlJyxcbiAgICByZXF1aXJlczogWydzZXJpYWxpemUnLCAnZGVzZXJpYWxpemUnXSxcbiAgICBjYXRlZ29yaWVzOiBbJ2Nsb25lJywgJ3BsdWdpbiddXG4gIH07XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZm4sIHsgc2VyaWFsaXplOiBzZXJpYWxpemUsIGRlc2VyaWFsaXplOiBkZXNlcmlhbGl6ZSwgY2xvbmU6IGNsb25lIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXJpYWxpemVyOyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBzaWduYXR1cmVUb0RlZiA9IGZ1bmN0aW9uIHNpZ25hdHVyZVRvRGVmKHNpZykge1xuICB2YXIgc2VncyA9IHNpZy5zcGxpdCgnPT4nKTtcbiAgdmFyIGFyZ1R5cGVzID0gc2Vnc1swXS5yZXBsYWNlKCcoJywgJycpLnJlcGxhY2UoJyknLCAnJykuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiBhcmcudHJpbSgpO1xuICB9KTtcbiAgdmFyIHJldHVyblR5cGUgPSBzZWdzWzFdLnRyaW0oKTtcblxuICByZXR1cm4geyBhcmdUeXBlczogYXJnVHlwZXMsIHJldHVyblR5cGU6IHJldHVyblR5cGUgfTtcbn07XG5cbnZhciBhcmdzTWFwID0gZnVuY3Rpb24gYXJnc01hcChmbiwgYXJnVHlwZXMsIG1hcCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciB3cmFwcGVkQXJncyA9IGFyZ1R5cGVzLm1hcChmdW5jdGlvbiAodHlwZU5hbWUsIGkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbaV07XG5cbiAgICAgIGlmIChtYXBbdHlwZU5hbWVdKSB7XG4gICAgICAgIHJldHVybiBtYXBbdHlwZU5hbWVdKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZuLmFwcGx5KHVuZGVmaW5lZCwgX3RvQ29uc3VtYWJsZUFycmF5KHdyYXBwZWRBcmdzKSk7XG4gIH07XG59O1xuXG52YXIgY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59O1xuXG52YXIgd3JhcE5vZGVzID0gZnVuY3Rpb24gd3JhcE5vZGVzKF9mbikge1xuICB2YXIgZm5hbWVzID0gT2JqZWN0LmtleXMoX2ZuKTtcblxuICB2YXIgd3JhcHBlZEZuID0gZnVuY3Rpb24gd3JhcHBlZEZuKHJvb3QsIF9ub2RlLCBmbmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHZhciBmdW5jID0gX2ZuW2ZuYW1lXTtcbiAgICAgIHZhciBkZWYgPSBmdW5jLmRlZiB8fCB7fTtcbiAgICAgIHZhciBhcmdUeXBlcyA9IGRlZiAmJiBBcnJheS5pc0FycmF5KGRlZi5hcmdUeXBlcykgPyBkZWYuYXJnVHlwZXMgOiBbXTtcblxuICAgICAgdmFyIGZpcnN0Tm9kZSA9IGZhbHNlO1xuXG4gICAgICB2YXIgY3VycnlNYXAgPSB7XG4gICAgICAgIGZuOiBmdW5jdGlvbiBmbigpIHtcbiAgICAgICAgICByZXR1cm4gX2ZuO1xuICAgICAgICB9LFxuICAgICAgICByb290Tm9kZTogZnVuY3Rpb24gcm9vdE5vZGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH0sXG4gICAgICAgIG5vZGU6IGZ1bmN0aW9uIG5vZGUoKSB7XG4gICAgICAgICAgaWYgKCFmaXJzdE5vZGUpIHtcbiAgICAgICAgICAgIGZpcnN0Tm9kZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gX25vZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFyZ3Muc2hpZnQoKS5nZXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYW55OiBmdW5jdGlvbiBhbnkoKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3Muc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGFyZ01hcCA9IHtcbiAgICAgICAgcm9vdE5vZGU6IGZ1bmN0aW9uIHJvb3ROb2RlKG4pIHtcbiAgICAgICAgICByZXR1cm4gd3JhcHBlZE5vZGUocm9vdCwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIG5vZGU6IGZ1bmN0aW9uIG5vZGUobikge1xuICAgICAgICAgIHJldHVybiB3cmFwcGVkTm9kZShyb290LCBuKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGN1cnJpZWQgPSBhcmdUeXBlcy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKGN1cnJ5TWFwW3RdKSByZXR1cm4gY3VycnlNYXBbdF0oKTtcblxuICAgICAgICBpZiAodC5pbmRleE9mKCc9PicpICE9PSAtMSkge1xuICAgICAgICAgIHZhciBfZGVmID0gc2lnbmF0dXJlVG9EZWYodCk7XG4gICAgICAgICAgdmFyIGZuQXJnID0gYXJncy5zaGlmdCgpO1xuXG4gICAgICAgICAgcmV0dXJuIGFyZ3NNYXAoZm5BcmcsIF9kZWYuYXJnVHlwZXMsIGFyZ01hcCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3VycnlNYXAuYW55KCk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBfdG9Db25zdW1hYmxlQXJyYXkoY3VycmllZCkpO1xuXG4gICAgICBpZiAoZGVmLnJldHVyblR5cGUgPT09ICdub2RlJykge1xuICAgICAgICByZXN1bHQgPSB3cmFwcGVkTm9kZShyb290LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIGlmIChkZWYucmV0dXJuVHlwZSA9PT0gJ1tub2RlXScpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm1hcChmdW5jdGlvbiAobikge1xuICAgICAgICAgIHJldHVybiB3cmFwcGVkTm9kZShyb290LCBuKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgd3JhcHBlZE5vZGUgPSBmdW5jdGlvbiB3cmFwcGVkTm9kZShyb290LCBub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbm9kZTtcblxuICAgIHZhciB3cmFwcGVkID0gZm5hbWVzLnJlZHVjZShmdW5jdGlvbiAod3JhcHBlZE5vZGUsIGZuYW1lKSB7XG4gICAgICB3cmFwcGVkTm9kZVtmbmFtZV0gPSB3cmFwcGVkRm4ocm9vdCwgbm9kZSwgZm5hbWUpO1xuXG4gICAgICByZXR1cm4gd3JhcHBlZE5vZGU7XG4gICAgfSwge30pO1xuXG4gICAgd3JhcHBlZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIHdyYXBwZWQuZ2V0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByb290O1xuICAgIH07XG5cbiAgICAvLyBhc3Npc3Qgd2l0aCBkZWJ1Z2dpbmdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod3JhcHBlZCwgJ192YWx1ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gY2xvbmUoX2ZuLnZhbHVlKG5vZGUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod3JhcHBlZCwgJ19jaGlsZHJlbicsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gY2xvbmUoX2ZuLmdldENoaWxkcmVuKG5vZGUpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB3cmFwcGVkO1xuICB9O1xuXG4gIHZhciBjcmVhdGVUcmVlID0gZnVuY3Rpb24gY3JlYXRlVHJlZShyb290KSB7XG4gICAgcmV0dXJuIHdyYXBwZWROb2RlKHJvb3QsIHJvb3QpO1xuICB9O1xuXG4gIGNyZWF0ZVRyZWUuZGVmID0ge1xuICAgIGFyZ1R5cGVzOiBbJ25vZGVWYWx1ZSddLFxuICAgIHJldHVyblR5cGU6ICd3cmFwcGVkTm9kZScsXG4gICAgcmVxdWlyZXM6IFsnY3JlYXRlTm9kZSddLFxuICAgIGNhdGVnb3JpZXM6IFsnd3JhcHBlZC1ub2RlcycsICdwbHVnaW4nXVxuICB9O1xuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKF9mbiwgeyBjcmVhdGVUcmVlOiBjcmVhdGVUcmVlIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwTm9kZXM7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlICovXG5pZiAoIUFycmF5LnByb3RvdHlwZS5pbmNsdWRlcykge1xuICBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiAoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4Ki8pIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgTyA9IE9iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuID0gcGFyc2VJbnQoTy5sZW5ndGgpIHx8IDA7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbiA9IHBhcnNlSW50KGFyZ3VtZW50c1sxXSkgfHwgMDtcbiAgICB2YXIgaztcbiAgICBpZiAobiA+PSAwKSB7XG4gICAgICBrID0gbjtcbiAgICB9IGVsc2Uge1xuICAgICAgayA9IGxlbiArIG47XG4gICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgayA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjdXJyZW50RWxlbWVudDtcbiAgICB3aGlsZSAoayA8IGxlbikge1xuICAgICAgY3VycmVudEVsZW1lbnQgPSBPW2tdO1xuICAgICAgaWYgKHNlYXJjaEVsZW1lbnQgPT09IGN1cnJlbnRFbGVtZW50IHx8IHNlYXJjaEVsZW1lbnQgIT09IHNlYXJjaEVsZW1lbnQgJiYgY3VycmVudEVsZW1lbnQgIT09IGN1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaysrO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59XG4vKmVzbGludC1lbmFibGUgKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF0b2EgKGEsIG4pIHsgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEsIG4pOyB9XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiBiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0dHJ1ZUZ1bmM6IGZ1bmN0aW9uIHRydWVGdW5jKCl7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cdGZhbHNlRnVuYzogZnVuY3Rpb24gZmFsc2VGdW5jKCl7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59OyIsIiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXI7XG52YXIgU2xvd0J1ZmZlciA9IGJ1ZmZlci5TbG93QnVmZmVyO1xudmFyIE1BWF9MRU4gPSBidWZmZXIua01heExlbmd0aCB8fCAyMTQ3NDgzNjQ3O1xuZXhwb3J0cy5hbGxvYyA9IGZ1bmN0aW9uIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IG5vdCBiZSBudW1iZXInKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHNpemUgPiBNQVhfTEVOKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpemUgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgdmFyIGVuYyA9IGVuY29kaW5nO1xuICB2YXIgX2ZpbGwgPSBmaWxsO1xuICBpZiAoX2ZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuYyA9IHVuZGVmaW5lZDtcbiAgICBfZmlsbCA9IDA7XG4gIH1cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIGlmICh0eXBlb2YgX2ZpbGwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGZpbGxCdWYgPSBuZXcgQnVmZmVyKF9maWxsLCBlbmMpO1xuICAgIHZhciBmbGVuID0gZmlsbEJ1Zi5sZW5ndGg7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgc2l6ZSkge1xuICAgICAgYnVmW2ldID0gZmlsbEJ1ZltpICUgZmxlbl07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKF9maWxsKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufVxuZXhwb3J0cy5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIGFsbG9jVW5zYWZlKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAoc2l6ZSA+IE1BWF9MRU4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTtcbn1cbmV4cG9ydHMuZnJvbSA9IGZ1bmN0aW9uIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5mcm9tID09PSAnZnVuY3Rpb24nICYmICghZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgVWludDhBcnJheS5mcm9tICE9PSBCdWZmZXIuZnJvbSkpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KTtcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgdmFyIG9mZnNldCA9IGVuY29kaW5nT3JPZmZzZXQ7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICB2YXIgbGVuID0gbGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgbGVuID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbGVuID0gdmFsdWUuYnl0ZUxlbmd0aCAtIG9mZnNldDtcbiAgICB9XG4gICAgaWYgKG9mZnNldCA+PSB2YWx1ZS5ieXRlTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKGxlbiA+IHZhbHVlLmJ5dGVMZW5ndGggLSBvZmZzZXQpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCdWZmZXIodmFsdWUubGVuZ3RoKTtcbiAgICB2YWx1ZS5jb3B5KG91dCwgMCwgMCwgdmFsdWUubGVuZ3RoKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gdmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkodmFsdWUuZGF0YSkpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLmRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgJyArICdBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpO1xufVxuZXhwb3J0cy5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiBhbGxvY1Vuc2FmZVNsb3coc2l6ZSkge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyhzaXplKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHNpemUgPj0gTUFYX0xFTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIHJldHVybiBuZXcgU2xvd0J1ZmZlcihzaXplKTtcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRpY2t5ID0gcmVxdWlyZSgndGlja3knKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWJvdW5jZSAoZm4sIGFyZ3MsIGN0eCkge1xuICBpZiAoIWZuKSB7IHJldHVybjsgfVxuICB0aWNreShmdW5jdGlvbiBydW4gKCkge1xuICAgIGZuLmFwcGx5KGN0eCB8fCBudWxsLCBhcmdzIHx8IFtdKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXRvYSA9IHJlcXVpcmUoJ2F0b2EnKTtcbnZhciBkZWJvdW5jZSA9IHJlcXVpcmUoJy4vZGVib3VuY2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbWl0dGVyICh0aGluZywgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBldnQgPSB7fTtcbiAgaWYgKHRoaW5nID09PSB1bmRlZmluZWQpIHsgdGhpbmcgPSB7fTsgfVxuICB0aGluZy5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICAgIGlmICghZXZ0W3R5cGVdKSB7XG4gICAgICBldnRbdHlwZV0gPSBbZm5dO1xuICAgIH0gZWxzZSB7XG4gICAgICBldnRbdHlwZV0ucHVzaChmbik7XG4gICAgfVxuICAgIHJldHVybiB0aGluZztcbiAgfTtcbiAgdGhpbmcub25jZSA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICAgIGZuLl9vbmNlID0gdHJ1ZTsgLy8gdGhpbmcub2ZmKGZuKSBzdGlsbCB3b3JrcyFcbiAgICB0aGluZy5vbih0eXBlLCBmbik7XG4gICAgcmV0dXJuIHRoaW5nO1xuICB9O1xuICB0aGluZy5vZmYgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGMgPT09IDEpIHtcbiAgICAgIGRlbGV0ZSBldnRbdHlwZV07XG4gICAgfSBlbHNlIGlmIChjID09PSAwKSB7XG4gICAgICBldnQgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGV0ID0gZXZ0W3R5cGVdO1xuICAgICAgaWYgKCFldCkgeyByZXR1cm4gdGhpbmc7IH1cbiAgICAgIGV0LnNwbGljZShldC5pbmRleE9mKGZuKSwgMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGluZztcbiAgfTtcbiAgdGhpbmcuZW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IGF0b2EoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpbmcuZW1pdHRlclNuYXBzaG90KGFyZ3Muc2hpZnQoKSkuYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG4gIHRoaW5nLmVtaXR0ZXJTbmFwc2hvdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGV0ID0gKGV2dFt0eXBlXSB8fCBbXSkuc2xpY2UoMCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gYXRvYShhcmd1bWVudHMpO1xuICAgICAgdmFyIGN0eCA9IHRoaXMgfHwgdGhpbmc7XG4gICAgICBpZiAodHlwZSA9PT0gJ2Vycm9yJyAmJiBvcHRzLnRocm93cyAhPT0gZmFsc2UgJiYgIWV0Lmxlbmd0aCkgeyB0aHJvdyBhcmdzLmxlbmd0aCA9PT0gMSA/IGFyZ3NbMF0gOiBhcmdzOyB9XG4gICAgICBldC5mb3JFYWNoKGZ1bmN0aW9uIGVtaXR0ZXIgKGxpc3Rlbikge1xuICAgICAgICBpZiAob3B0cy5hc3luYykgeyBkZWJvdW5jZShsaXN0ZW4sIGFyZ3MsIGN0eCk7IH0gZWxzZSB7IGxpc3Rlbi5hcHBseShjdHgsIGFyZ3MpOyB9XG4gICAgICAgIGlmIChsaXN0ZW4uX29uY2UpIHsgdGhpbmcub2ZmKHR5cGUsIGxpc3Rlbik7IH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaW5nO1xuICAgIH07XG4gIH07XG4gIHJldHVybiB0aGluZztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjdXN0b21FdmVudCA9IHJlcXVpcmUoJ2N1c3RvbS1ldmVudCcpO1xudmFyIGV2ZW50bWFwID0gcmVxdWlyZSgnLi9ldmVudG1hcCcpO1xudmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbnZhciBhZGRFdmVudCA9IGFkZEV2ZW50RWFzeTtcbnZhciByZW1vdmVFdmVudCA9IHJlbW92ZUV2ZW50RWFzeTtcbnZhciBoYXJkQ2FjaGUgPSBbXTtcblxuaWYgKCFnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICBhZGRFdmVudCA9IGFkZEV2ZW50SGFyZDtcbiAgcmVtb3ZlRXZlbnQgPSByZW1vdmVFdmVudEhhcmQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGQ6IGFkZEV2ZW50LFxuICByZW1vdmU6IHJlbW92ZUV2ZW50LFxuICBmYWJyaWNhdGU6IGZhYnJpY2F0ZUV2ZW50XG59O1xuXG5mdW5jdGlvbiBhZGRFdmVudEVhc3kgKGVsLCB0eXBlLCBmbiwgY2FwdHVyaW5nKSB7XG4gIHJldHVybiBlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBjYXB0dXJpbmcpO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudEhhcmQgKGVsLCB0eXBlLCBmbikge1xuICByZXR1cm4gZWwuYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIHdyYXAoZWwsIHR5cGUsIGZuKSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50RWFzeSAoZWwsIHR5cGUsIGZuLCBjYXB0dXJpbmcpIHtcbiAgcmV0dXJuIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGNhcHR1cmluZyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50SGFyZCAoZWwsIHR5cGUsIGZuKSB7XG4gIHZhciBsaXN0ZW5lciA9IHVud3JhcChlbCwgdHlwZSwgZm4pO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICByZXR1cm4gZWwuZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmYWJyaWNhdGVFdmVudCAoZWwsIHR5cGUsIG1vZGVsKSB7XG4gIHZhciBlID0gZXZlbnRtYXAuaW5kZXhPZih0eXBlKSA9PT0gLTEgPyBtYWtlQ3VzdG9tRXZlbnQoKSA6IG1ha2VDbGFzc2ljRXZlbnQoKTtcbiAgaWYgKGVsLmRpc3BhdGNoRXZlbnQpIHtcbiAgICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xuICB9IGVsc2Uge1xuICAgIGVsLmZpcmVFdmVudCgnb24nICsgdHlwZSwgZSk7XG4gIH1cbiAgZnVuY3Rpb24gbWFrZUNsYXNzaWNFdmVudCAoKSB7XG4gICAgdmFyIGU7XG4gICAgaWYgKGRvYy5jcmVhdGVFdmVudCkge1xuICAgICAgZSA9IGRvYy5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoZG9jLmNyZWF0ZUV2ZW50T2JqZWN0KSB7XG4gICAgICBlID0gZG9jLmNyZWF0ZUV2ZW50T2JqZWN0KCk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9XG4gIGZ1bmN0aW9uIG1ha2VDdXN0b21FdmVudCAoKSB7XG4gICAgcmV0dXJuIG5ldyBjdXN0b21FdmVudCh0eXBlLCB7IGRldGFpbDogbW9kZWwgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JhcHBlckZhY3RvcnkgKGVsLCB0eXBlLCBmbikge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcHBlciAob3JpZ2luYWxFdmVudCkge1xuICAgIHZhciBlID0gb3JpZ2luYWxFdmVudCB8fCBnbG9iYWwuZXZlbnQ7XG4gICAgZS50YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCA9IGUucHJldmVudERlZmF1bHQgfHwgZnVuY3Rpb24gcHJldmVudERlZmF1bHQgKCkgeyBlLnJldHVyblZhbHVlID0gZmFsc2U7IH07XG4gICAgZS5zdG9wUHJvcGFnYXRpb24gPSBlLnN0b3BQcm9wYWdhdGlvbiB8fCBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24gKCkgeyBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7IH07XG4gICAgZS53aGljaCA9IGUud2hpY2ggfHwgZS5rZXlDb2RlO1xuICAgIGZuLmNhbGwoZWwsIGUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB3cmFwIChlbCwgdHlwZSwgZm4pIHtcbiAgdmFyIHdyYXBwZXIgPSB1bndyYXAoZWwsIHR5cGUsIGZuKSB8fCB3cmFwcGVyRmFjdG9yeShlbCwgdHlwZSwgZm4pO1xuICBoYXJkQ2FjaGUucHVzaCh7XG4gICAgd3JhcHBlcjogd3JhcHBlcixcbiAgICBlbGVtZW50OiBlbCxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGZuOiBmblxuICB9KTtcbiAgcmV0dXJuIHdyYXBwZXI7XG59XG5cbmZ1bmN0aW9uIHVud3JhcCAoZWwsIHR5cGUsIGZuKSB7XG4gIHZhciBpID0gZmluZChlbCwgdHlwZSwgZm4pO1xuICBpZiAoaSkge1xuICAgIHZhciB3cmFwcGVyID0gaGFyZENhY2hlW2ldLndyYXBwZXI7XG4gICAgaGFyZENhY2hlLnNwbGljZShpLCAxKTsgLy8gZnJlZSB1cCBhIHRhZCBvZiBtZW1vcnlcbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kIChlbCwgdHlwZSwgZm4pIHtcbiAgdmFyIGksIGl0ZW07XG4gIGZvciAoaSA9IDA7IGkgPCBoYXJkQ2FjaGUubGVuZ3RoOyBpKyspIHtcbiAgICBpdGVtID0gaGFyZENhY2hlW2ldO1xuICAgIGlmIChpdGVtLmVsZW1lbnQgPT09IGVsICYmIGl0ZW0udHlwZSA9PT0gdHlwZSAmJiBpdGVtLmZuID09PSBmbikge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBldmVudG1hcCA9IFtdO1xudmFyIGV2ZW50bmFtZSA9ICcnO1xudmFyIHJvbiA9IC9eb24vO1xuXG5mb3IgKGV2ZW50bmFtZSBpbiBnbG9iYWwpIHtcbiAgaWYgKHJvbi50ZXN0KGV2ZW50bmFtZSkpIHtcbiAgICBldmVudG1hcC5wdXNoKGV2ZW50bmFtZS5zbGljZSgyKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBldmVudG1hcDtcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFkYXB0ZXJGYWN0b3J5O1xuXG5mdW5jdGlvbiBhZGFwdGVyRmFjdG9yeShpbXBsZW1lbnRhdGlvbil7XG5cdGVuc3VyZUltcGxlbWVudGF0aW9uKGltcGxlbWVudGF0aW9uKTtcblxuXHR2YXIgYWRhcHRlciA9IHt9XG5cblx0dmFyIGJhc2VBZGFwdGVyID0ge1xuXHRcdHJlbW92ZVN1YnNldHM6IGZ1bmN0aW9uIChub2Rlcyl7XG5cdFx0XHRyZXR1cm4gcmVtb3ZlU3Vic2V0cyhhZGFwdGVyLCBub2Rlcyk7XG5cdFx0fSxcblx0XHRleGlzdHNPbmU6IGZ1bmN0aW9uKHRlc3QsIGVsZW1zKXtcblx0XHRcdHJldHVybiBleGlzdHNPbmUoYWRhcHRlciwgdGVzdCwgZWxlbXMpO1xuXHRcdH0sXG5cdFx0Z2V0U2libGluZ3M6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0cmV0dXJuIGdldFNpYmxpbmdzKGFkYXB0ZXIsIGVsZW0pO1xuXHRcdH0sXG5cdFx0aGFzQXR0cmliOiBmdW5jdGlvbihlbGVtLCBuYW1lKXtcblx0XHRcdHJldHVybiBoYXNBdHRyaWIoYWRhcHRlciwgZWxlbSwgbmFtZSk7XG5cdFx0fSxcblx0XHRmaW5kT25lOiBmdW5jdGlvbih0ZXN0LCBhcnIpe1xuXHRcdFx0cmV0dXJuIGZpbmRPbmUoYWRhcHRlciwgdGVzdCwgYXJyKTtcblx0XHR9LFxuXHRcdGZpbmRBbGw6IGZ1bmN0aW9uKHRlc3QsIGVsZW1zKXtcblx0XHRcdHJldHVybiBmaW5kQWxsKGFkYXB0ZXIsIHRlc3QsIGVsZW1zKVxuXHRcdH1cblx0fTtcblxuXHRPYmplY3QuYXNzaWduKGFkYXB0ZXIsIGJhc2VBZGFwdGVyLCBpbXBsZW1lbnRhdGlvbik7XG5cblx0cmV0dXJuIGFkYXB0ZXI7XG59XG5cbnZhciBleHBlY3RJbXBsZW1lbnRlZCA9IFtcblx0XCJpc1RhZ1wiLCBcImdldEF0dHJpYnV0ZVZhbHVlXCIsIFwiZ2V0Q2hpbGRyZW5cIiwgXCJnZXROYW1lXCIsIFwiZ2V0UGFyZW50XCIsXG5cdFwiZ2V0VGV4dFwiXG5dO1xuXG5mdW5jdGlvbiBlbnN1cmVJbXBsZW1lbnRhdGlvbihpbXBsZW1lbnRhdGlvbil7XG5cdGlmKCFpbXBsZW1lbnRhdGlvbilcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBpbXBsZW1lbnRhdGlvblwiKVxuXG5cdHZhciBub3RJbXBsZW1lbnRlZCA9IGV4cGVjdEltcGxlbWVudGVkLmZpbHRlcihmdW5jdGlvbihmbmFtZSl7XG5cdFx0cmV0dXJuIHR5cGVvZiBpbXBsZW1lbnRhdGlvbltmbmFtZV0gIT09IFwiZnVuY3Rpb25cIjtcblx0fSk7XG5cblx0aWYobm90SW1wbGVtZW50ZWQubGVuZ3RoKXtcblx0XHR2YXIgbm90TGlzdCA9IFwiKFwiICsgbm90SW1wbGVtZW50ZWQuam9pbihcIiwgXCIpICsgXCIpXCI7XG5cdFx0dmFyIG1lc3NhZ2UgPSBcIkV4cGVjdGVkIGZ1bmN0aW9ucyBcIiArIG5vdExpc3QgKyBcIiB0byBiZSBpbXBsZW1lbnRlZFwiO1xuXHRcdHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdWJzZXRzKGFkYXB0ZXIsIG5vZGVzKXtcblx0dmFyIGlkeCA9IG5vZGVzLmxlbmd0aCwgbm9kZSwgYW5jZXN0b3IsIHJlcGxhY2U7XG5cblx0Ly8gQ2hlY2sgaWYgZWFjaCBub2RlIChvciBvbmUgb2YgaXRzIGFuY2VzdG9ycykgaXMgYWxyZWFkeSBjb250YWluZWQgaW4gdGhlXG5cdC8vIGFycmF5LlxuXHR3aGlsZSgtLWlkeCA+IC0xKXtcblx0XHRub2RlID0gYW5jZXN0b3IgPSBub2Rlc1tpZHhdO1xuXG5cdFx0Ly8gVGVtcG9yYXJpbHkgcmVtb3ZlIHRoZSBub2RlIHVuZGVyIGNvbnNpZGVyYXRpb25cblx0XHRub2Rlc1tpZHhdID0gbnVsbDtcblx0XHRyZXBsYWNlID0gdHJ1ZTtcblxuXHRcdHdoaWxlKGFuY2VzdG9yKXtcblx0XHRcdGlmKG5vZGVzLmluZGV4T2YoYW5jZXN0b3IpID4gLTEpe1xuXHRcdFx0XHRyZXBsYWNlID0gZmFsc2U7XG5cdFx0XHRcdG5vZGVzLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGFuY2VzdG9yID0gYWRhcHRlci5nZXRQYXJlbnQoYW5jZXN0b3IpXG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIG5vZGUgaGFzIGJlZW4gZm91bmQgdG8gYmUgdW5pcXVlLCByZS1pbnNlcnQgaXQuXG5cdFx0aWYocmVwbGFjZSl7XG5cdFx0XHRub2Rlc1tpZHhdID0gbm9kZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbm9kZXM7XG59XG5cbmZ1bmN0aW9uIGV4aXN0c09uZShhZGFwdGVyLCB0ZXN0LCBlbGVtcyl7XG5cdHJldHVybiBlbGVtcy5zb21lKGZ1bmN0aW9uKGVsZW0pe1xuXHRcdHJldHVybiBhZGFwdGVyLmlzVGFnKGVsZW0pID9cblx0XHRcdHRlc3QoZWxlbSkgfHwgYWRhcHRlci5leGlzdHNPbmUodGVzdCwgYWRhcHRlci5nZXRDaGlsZHJlbihlbGVtKSkgOlxuXHRcdFx0ZmFsc2U7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBnZXRTaWJsaW5ncyhhZGFwdGVyLCBlbGVtKXtcblx0dmFyIHBhcmVudCA9IGFkYXB0ZXIuZ2V0UGFyZW50KGVsZW0pO1xuXHRyZXR1cm4gcGFyZW50ICYmIGFkYXB0ZXIuZ2V0Q2hpbGRyZW4ocGFyZW50KTtcbn1cblxuXG5mdW5jdGlvbiBoYXNBdHRyaWIoYWRhcHRlciwgZWxlbSwgbmFtZSl7XG5cdHJldHVybiBhZGFwdGVyLmdldEF0dHJpYnV0ZVZhbHVlKGVsZW0sbmFtZSkgIT09IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBmaW5kT25lKGFkYXB0ZXIsIHRlc3QsIGFycil7XG5cdHZhciBlbGVtID0gbnVsbDtcblxuXHRmb3IodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGwgJiYgIWVsZW07IGkrKyl7XG5cdFx0aWYodGVzdChhcnJbaV0pKXtcblx0XHRcdGVsZW0gPSBhcnJbaV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjaGlsZHMgPSBhZGFwdGVyLmdldENoaWxkcmVuKGFycltpXSk7XG5cdFx0XHRpZihjaGlsZHMgJiYgY2hpbGRzLmxlbmd0aCA+IDApe1xuXHRcdFx0XHRlbGVtID0gYWRhcHRlci5maW5kT25lKHRlc3QsIGNoaWxkcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGZpbmRBbGwoYWRhcHRlciwgdGVzdCwgZWxlbXMpe1xuXHR2YXIgcmVzdWx0ID0gW107XG5cblx0Zm9yKHZhciBpID0gMCwgaiA9IGVsZW1zLmxlbmd0aDsgaSA8IGo7IGkrKyl7XG5cdFx0aWYoIWFkYXB0ZXIuaXNUYWcoZWxlbXNbaV0pKSBjb250aW51ZTtcblx0XHRpZih0ZXN0KGVsZW1zW2ldKSkgcmVzdWx0LnB1c2goZWxlbXNbaV0pO1xuXHRcdHZhciBjaGlsZHMgPSBhZGFwdGVyLmdldENoaWxkcmVuKGVsZW1zW2ldKTtcblx0XHRpZihjaGlsZHMpIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoYWRhcHRlci5maW5kQWxsKHRlc3QsIGNoaWxkcykpO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU3NlbGVjdDtcblxudmFyIERvbVV0aWxzICAgICAgID0gcmVxdWlyZShcImRvbXV0aWxzXCIpLFxuXHRmYWxzZUZ1bmMgICAgICA9IHJlcXVpcmUoXCJib29sYmFzZVwiKS5mYWxzZUZ1bmMsXG5cdGNvbXBpbGVGYWN0b3J5ID0gcmVxdWlyZShcIi4vbGliL2NvbXBpbGUuanNcIiksXG5cdGRlZmF1bHRDb21waWxlID0gY29tcGlsZUZhY3RvcnkoRG9tVXRpbHMpO1xuXG5mdW5jdGlvbiBhZGFwdGVyQ29tcGlsZShhZGFwdGVyKXtcblx0cmV0dXJuIGFkYXB0ZXIgPT09IERvbVV0aWxzID8gZGVmYXVsdENvbXBpbGUgOiBjb21waWxlRmFjdG9yeShhZGFwdGVyKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0b3JGdW5jKHNlYXJjaEZ1bmMpe1xuXHRyZXR1cm4gZnVuY3Rpb24gc2VsZWN0KHF1ZXJ5LCBlbGVtcywgb3B0aW9ucyl7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblx0XHRvcHRpb25zLmFkYXB0ZXIgPSBvcHRpb25zLmFkYXB0ZXIgfHwgRG9tVXRpbHM7XG5cdFx0dmFyIGNvbXBpbGUgPSBhZGFwdGVyQ29tcGlsZShvcHRpb25zLmFkYXB0ZXIpO1xuXG5cdFx0aWYodHlwZW9mIHF1ZXJ5ICE9PSBcImZ1bmN0aW9uXCIpIHF1ZXJ5ID0gY29tcGlsZS5jb21waWxlVW5zYWZlKHF1ZXJ5LCBvcHRpb25zLCBlbGVtcyk7XG5cdFx0aWYocXVlcnkuc2hvdWxkVGVzdE5leHRTaWJsaW5ncykgZWxlbXMgPSBhcHBlbmROZXh0U2libGluZ3MoKG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0KSB8fCBlbGVtcywgb3B0aW9ucy5hZGFwdGVyKTtcblx0XHRpZighQXJyYXkuaXNBcnJheShlbGVtcykpIGVsZW1zID0gb3B0aW9ucy5hZGFwdGVyLmdldENoaWxkcmVuKGVsZW1zKTtcblx0XHRlbHNlIGVsZW1zID0gb3B0aW9ucy5hZGFwdGVyLnJlbW92ZVN1YnNldHMoZWxlbXMpO1xuXHRcdHJldHVybiBzZWFyY2hGdW5jKHF1ZXJ5LCBlbGVtcywgb3B0aW9ucyk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIGdldE5leHRTaWJsaW5ncyhlbGVtLCBhZGFwdGVyKXtcblx0dmFyIHNpYmxpbmdzID0gYWRhcHRlci5nZXRTaWJsaW5ncyhlbGVtKTtcblx0aWYoIUFycmF5LmlzQXJyYXkoc2libGluZ3MpKSByZXR1cm4gW107XG5cdHNpYmxpbmdzID0gc2libGluZ3Muc2xpY2UoMCk7XG5cdHdoaWxlKHNpYmxpbmdzLnNoaWZ0KCkgIT09IGVsZW0pO1xuXHRyZXR1cm4gc2libGluZ3M7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZE5leHRTaWJsaW5ncyhlbGVtcywgYWRhcHRlcil7XG5cdC8vIE9yZGVyIG1hdHRlcnMgYmVjYXVzZSBqUXVlcnkgc2VlbXMgdG8gY2hlY2sgdGhlIGNoaWxkcmVuIGJlZm9yZSB0aGUgc2libGluZ3Ncblx0aWYoIUFycmF5LmlzQXJyYXkoZWxlbXMpKSBlbGVtcyA9IFtlbGVtc107XG5cdHZhciBuZXdFbGVtcyA9IGVsZW1zLnNsaWNlKDApO1xuXG5cdGZvcih2YXIgaSA9IDAsIGxlbiA9IGVsZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcblx0XHR2YXIgbmV4dFNpYmxpbmdzID0gZ2V0TmV4dFNpYmxpbmdzKG5ld0VsZW1zW2ldLCBhZGFwdGVyKTtcblx0XHRuZXdFbGVtcy5wdXNoLmFwcGx5KG5ld0VsZW1zLCBuZXh0U2libGluZ3MpO1xuXHR9XG5cdHJldHVybiBuZXdFbGVtcztcbn1cblxudmFyIHNlbGVjdEFsbCA9IGdldFNlbGVjdG9yRnVuYyhmdW5jdGlvbiBzZWxlY3RBbGwocXVlcnksIGVsZW1zLCBvcHRpb25zKXtcblx0cmV0dXJuIChxdWVyeSA9PT0gZmFsc2VGdW5jIHx8ICFlbGVtcyB8fCBlbGVtcy5sZW5ndGggPT09IDApID8gW10gOiBvcHRpb25zLmFkYXB0ZXIuZmluZEFsbChxdWVyeSwgZWxlbXMpO1xufSk7XG5cbnZhciBzZWxlY3RPbmUgPSBnZXRTZWxlY3RvckZ1bmMoZnVuY3Rpb24gc2VsZWN0T25lKHF1ZXJ5LCBlbGVtcywgb3B0aW9ucyl7XG5cdHJldHVybiAocXVlcnkgPT09IGZhbHNlRnVuYyB8fCAhZWxlbXMgfHwgZWxlbXMubGVuZ3RoID09PSAwKSA/IG51bGwgOiBvcHRpb25zLmFkYXB0ZXIuZmluZE9uZShxdWVyeSwgZWxlbXMpO1xufSk7XG5cbmZ1bmN0aW9uIGlzKGVsZW0sIHF1ZXJ5LCBvcHRpb25zKXtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblx0b3B0aW9ucy5hZGFwdGVyID0gb3B0aW9ucy5hZGFwdGVyIHx8IERvbVV0aWxzO1xuXHR2YXIgY29tcGlsZSA9IGFkYXB0ZXJDb21waWxlKG9wdGlvbnMuYWRhcHRlcik7XG5cdHJldHVybiAodHlwZW9mIHF1ZXJ5ID09PSBcImZ1bmN0aW9uXCIgPyBxdWVyeSA6IGNvbXBpbGUocXVlcnksIG9wdGlvbnMpKShlbGVtKTtcbn1cblxuLypcblx0dGhlIGV4cG9ydGVkIGludGVyZmFjZVxuKi9cbmZ1bmN0aW9uIENTU3NlbGVjdChxdWVyeSwgZWxlbXMsIG9wdGlvbnMpe1xuXHRyZXR1cm4gc2VsZWN0QWxsKHF1ZXJ5LCBlbGVtcywgb3B0aW9ucyk7XG59XG5cbkNTU3NlbGVjdC5jb21waWxlID0gZGVmYXVsdENvbXBpbGU7XG5DU1NzZWxlY3QuZmlsdGVycyA9IGRlZmF1bHRDb21waWxlLlBzZXVkb3MuZmlsdGVycztcbkNTU3NlbGVjdC5wc2V1ZG9zID0gZGVmYXVsdENvbXBpbGUuUHNldWRvcy5wc2V1ZG9zO1xuXG5DU1NzZWxlY3Quc2VsZWN0QWxsID0gc2VsZWN0QWxsO1xuQ1NTc2VsZWN0LnNlbGVjdE9uZSA9IHNlbGVjdE9uZTtcblxuQ1NTc2VsZWN0LmlzID0gaXM7XG5cbi8vbGVnYWN5IG1ldGhvZHMgKG1pZ2h0IGJlIHJlbW92ZWQpXG5DU1NzZWxlY3QucGFyc2UgPSBkZWZhdWx0Q29tcGlsZTtcbkNTU3NlbGVjdC5pdGVyYXRlID0gc2VsZWN0QWxsO1xuXG4vL2hvb2tzXG5DU1NzZWxlY3QuX2NvbXBpbGVVbnNhZmUgPSBkZWZhdWx0Q29tcGlsZS5jb21waWxlVW5zYWZlO1xuQ1NTc2VsZWN0Ll9jb21waWxlVG9rZW4gPSBkZWZhdWx0Q29tcGlsZS5jb21waWxlVG9rZW47XG4iLCJ2YXIgZmFsc2VGdW5jID0gcmVxdWlyZShcImJvb2xiYXNlXCIpLmZhbHNlRnVuYztcblxuLy9odHRwczovL2dpdGh1Yi5jb20vc2xldml0aGFuL1hSZWdFeHAvYmxvYi9tYXN0ZXIvc3JjL3hyZWdleHAuanMjTDQ2OVxudmFyIHJlQ2hhcnMgPSAvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2c7XG5cbmZ1bmN0aW9uIGZhY3RvcnkoYWRhcHRlcil7XG5cdC8qXG5cdFx0YXR0cmlidXRlIHNlbGVjdG9yc1xuXHQqL1xuXHR2YXIgYXR0cmlidXRlUnVsZXMgPSB7XG5cdFx0X19wcm90b19fOiBudWxsLFxuXHRcdGVxdWFsczogZnVuY3Rpb24obmV4dCwgZGF0YSl7XG5cdFx0XHR2YXIgbmFtZSAgPSBkYXRhLm5hbWUsXG5cdFx0XHRcdHZhbHVlID0gZGF0YS52YWx1ZTtcblxuXHRcdFx0aWYoZGF0YS5pZ25vcmVDYXNlKXtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiBlcXVhbHNJQyhlbGVtKXtcblx0XHRcdFx0XHR2YXIgYXR0ciA9IGFkYXB0ZXIuZ2V0QXR0cmlidXRlVmFsdWUoZWxlbSwgbmFtZSk7XG5cdFx0XHRcdFx0cmV0dXJuIGF0dHIgIT0gbnVsbCAmJiBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IHZhbHVlICYmIG5leHQoZWxlbSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBlcXVhbHMoZWxlbSl7XG5cdFx0XHRcdHJldHVybiBhZGFwdGVyLmdldEF0dHJpYnV0ZVZhbHVlKGVsZW0sIG5hbWUpID09PSB2YWx1ZSAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0fTtcblx0XHR9LFxuXHRcdGh5cGhlbjogZnVuY3Rpb24obmV4dCwgZGF0YSl7XG5cdFx0XHR2YXIgbmFtZSAgPSBkYXRhLm5hbWUsXG5cdFx0XHRcdHZhbHVlID0gZGF0YS52YWx1ZSxcblx0XHRcdFx0bGVuID0gdmFsdWUubGVuZ3RoO1xuXG5cdFx0XHRpZihkYXRhLmlnbm9yZUNhc2Upe1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGh5cGhlbklDKGVsZW0pe1xuXHRcdFx0XHRcdHZhciBhdHRyID0gYWRhcHRlci5nZXRBdHRyaWJ1dGVWYWx1ZShlbGVtLCBuYW1lKTtcblx0XHRcdFx0XHRyZXR1cm4gYXR0ciAhPSBudWxsICYmXG5cdFx0XHRcdFx0XHRcdChhdHRyLmxlbmd0aCA9PT0gbGVuIHx8IGF0dHIuY2hhckF0KGxlbikgPT09IFwiLVwiKSAmJlxuXHRcdFx0XHRcdFx0XHRhdHRyLnN1YnN0cigwLCBsZW4pLnRvTG93ZXJDYXNlKCkgPT09IHZhbHVlICYmXG5cdFx0XHRcdFx0XHRcdG5leHQoZWxlbSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBoeXBoZW4oZWxlbSl7XG5cdFx0XHRcdHZhciBhdHRyID0gYWRhcHRlci5nZXRBdHRyaWJ1dGVWYWx1ZShlbGVtLCBuYW1lKTtcblx0XHRcdFx0cmV0dXJuIGF0dHIgIT0gbnVsbCAmJlxuXHRcdFx0XHRcdFx0YXR0ci5zdWJzdHIoMCwgbGVuKSA9PT0gdmFsdWUgJiZcblx0XHRcdFx0XHRcdChhdHRyLmxlbmd0aCA9PT0gbGVuIHx8IGF0dHIuY2hhckF0KGxlbikgPT09IFwiLVwiKSAmJlxuXHRcdFx0XHRcdFx0bmV4dChlbGVtKTtcblx0XHRcdH07XG5cdFx0fSxcblx0XHRlbGVtZW50OiBmdW5jdGlvbihuZXh0LCBkYXRhKXtcblx0XHRcdHZhciBuYW1lID0gZGF0YS5uYW1lLFxuXHRcdFx0XHR2YWx1ZSA9IGRhdGEudmFsdWU7XG5cblx0XHRcdGlmKC9cXHMvLnRlc3QodmFsdWUpKXtcblx0XHRcdFx0cmV0dXJuIGZhbHNlRnVuYztcblx0XHRcdH1cblxuXHRcdFx0dmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlQ2hhcnMsIFwiXFxcXCQmXCIpO1xuXG5cdFx0XHR2YXIgcGF0dGVybiA9IFwiKD86XnxcXFxccylcIiArIHZhbHVlICsgXCIoPzokfFxcXFxzKVwiLFxuXHRcdFx0XHRmbGFncyA9IGRhdGEuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIixcblx0XHRcdFx0cmVnZXggPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGVsZW1lbnQoZWxlbSl7XG5cdFx0XHRcdHZhciBhdHRyID0gYWRhcHRlci5nZXRBdHRyaWJ1dGVWYWx1ZShlbGVtLCBuYW1lKTtcblx0XHRcdFx0cmV0dXJuIGF0dHIgIT0gbnVsbCAmJiByZWdleC50ZXN0KGF0dHIpICYmIG5leHQoZWxlbSk7XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0ZXhpc3RzOiBmdW5jdGlvbihuZXh0LCBkYXRhKXtcblx0XHRcdHZhciBuYW1lID0gZGF0YS5uYW1lO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGV4aXN0cyhlbGVtKXtcblx0XHRcdFx0cmV0dXJuIGFkYXB0ZXIuaGFzQXR0cmliKGVsZW0sIG5hbWUpICYmIG5leHQoZWxlbSk7XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0c3RhcnQ6IGZ1bmN0aW9uKG5leHQsIGRhdGEpe1xuXHRcdFx0dmFyIG5hbWUgID0gZGF0YS5uYW1lLFxuXHRcdFx0XHR2YWx1ZSA9IGRhdGEudmFsdWUsXG5cdFx0XHRcdGxlbiA9IHZhbHVlLmxlbmd0aDtcblxuXHRcdFx0aWYobGVuID09PSAwKXtcblx0XHRcdFx0cmV0dXJuIGZhbHNlRnVuYztcblx0XHRcdH1cblxuXHRcdFx0aWYoZGF0YS5pZ25vcmVDYXNlKXtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiBzdGFydElDKGVsZW0pe1xuXHRcdFx0XHRcdHZhciBhdHRyID0gYWRhcHRlci5nZXRBdHRyaWJ1dGVWYWx1ZShlbGVtLCBuYW1lKTtcblx0XHRcdFx0XHRyZXR1cm4gYXR0ciAhPSBudWxsICYmIGF0dHIuc3Vic3RyKDAsIGxlbikudG9Mb3dlckNhc2UoKSA9PT0gdmFsdWUgJiYgbmV4dChlbGVtKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHN0YXJ0KGVsZW0pe1xuXHRcdFx0XHR2YXIgYXR0ciA9IGFkYXB0ZXIuZ2V0QXR0cmlidXRlVmFsdWUoZWxlbSwgbmFtZSk7XG5cdFx0XHRcdHJldHVybiBhdHRyICE9IG51bGwgJiYgYXR0ci5zdWJzdHIoMCwgbGVuKSA9PT0gdmFsdWUgJiYgbmV4dChlbGVtKTtcblx0XHRcdH07XG5cdFx0fSxcblx0XHRlbmQ6IGZ1bmN0aW9uKG5leHQsIGRhdGEpe1xuXHRcdFx0dmFyIG5hbWUgID0gZGF0YS5uYW1lLFxuXHRcdFx0XHR2YWx1ZSA9IGRhdGEudmFsdWUsXG5cdFx0XHRcdGxlbiAgID0gLXZhbHVlLmxlbmd0aDtcblxuXHRcdFx0aWYobGVuID09PSAwKXtcblx0XHRcdFx0cmV0dXJuIGZhbHNlRnVuYztcblx0XHRcdH1cblxuXHRcdFx0aWYoZGF0YS5pZ25vcmVDYXNlKXtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiBlbmRJQyhlbGVtKXtcblx0XHRcdFx0XHR2YXIgYXR0ciA9IGFkYXB0ZXIuZ2V0QXR0cmlidXRlVmFsdWUoZWxlbSwgbmFtZSk7XG5cdFx0XHRcdFx0cmV0dXJuIGF0dHIgIT0gbnVsbCAmJiBhdHRyLnN1YnN0cihsZW4pLnRvTG93ZXJDYXNlKCkgPT09IHZhbHVlICYmIG5leHQoZWxlbSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBlbmQoZWxlbSl7XG5cdFx0XHRcdHZhciBhdHRyID0gYWRhcHRlci5nZXRBdHRyaWJ1dGVWYWx1ZShlbGVtLCBuYW1lKTtcblx0XHRcdFx0cmV0dXJuIGF0dHIgIT0gbnVsbCAmJiBhdHRyLnN1YnN0cihsZW4pID09PSB2YWx1ZSAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0fTtcblx0XHR9LFxuXHRcdGFueTogZnVuY3Rpb24obmV4dCwgZGF0YSl7XG5cdFx0XHR2YXIgbmFtZSAgPSBkYXRhLm5hbWUsXG5cdFx0XHRcdHZhbHVlID0gZGF0YS52YWx1ZTtcblxuXHRcdFx0aWYodmFsdWUgPT09IFwiXCIpe1xuXHRcdFx0XHRyZXR1cm4gZmFsc2VGdW5jO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihkYXRhLmlnbm9yZUNhc2Upe1xuXHRcdFx0XHR2YXIgcmVnZXggPSBuZXcgUmVnRXhwKHZhbHVlLnJlcGxhY2UocmVDaGFycywgXCJcXFxcJCZcIiksIFwiaVwiKTtcblxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gYW55SUMoZWxlbSl7XG5cdFx0XHRcdFx0dmFyIGF0dHIgPSBhZGFwdGVyLmdldEF0dHJpYnV0ZVZhbHVlKGVsZW0sIG5hbWUpO1xuXHRcdFx0XHRcdHJldHVybiBhdHRyICE9IG51bGwgJiYgcmVnZXgudGVzdChhdHRyKSAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gYW55KGVsZW0pe1xuXHRcdFx0XHR2YXIgYXR0ciA9IGFkYXB0ZXIuZ2V0QXR0cmlidXRlVmFsdWUoZWxlbSwgbmFtZSk7XG5cdFx0XHRcdHJldHVybiBhdHRyICE9IG51bGwgJiYgYXR0ci5pbmRleE9mKHZhbHVlKSA+PSAwICYmIG5leHQoZWxlbSk7XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0bm90OiBmdW5jdGlvbihuZXh0LCBkYXRhKXtcblx0XHRcdHZhciBuYW1lICA9IGRhdGEubmFtZSxcblx0XHRcdFx0dmFsdWUgPSBkYXRhLnZhbHVlO1xuXG5cdFx0XHRpZih2YWx1ZSA9PT0gXCJcIil7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiBub3RFbXB0eShlbGVtKXtcblx0XHRcdFx0XHRyZXR1cm4gISFhZGFwdGVyLmdldEF0dHJpYnV0ZVZhbHVlKGVsZW0sIG5hbWUpICYmIG5leHQoZWxlbSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYoZGF0YS5pZ25vcmVDYXNlKXtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiBub3RJQyhlbGVtKXtcblx0XHRcdFx0XHR2YXIgYXR0ciA9IGFkYXB0ZXIuZ2V0QXR0cmlidXRlVmFsdWUoZWxlbSwgbmFtZSk7XG5cdFx0XHRcdFx0cmV0dXJuIGF0dHIgIT0gbnVsbCAmJiBhdHRyLnRvTG93ZXJDYXNlKCkgIT09IHZhbHVlICYmIG5leHQoZWxlbSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBub3QoZWxlbSl7XG5cdFx0XHRcdHJldHVybiBhZGFwdGVyLmdldEF0dHJpYnV0ZVZhbHVlKGVsZW0sIG5hbWUpICE9PSB2YWx1ZSAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0fTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIHtcblx0XHRjb21waWxlOiBmdW5jdGlvbihuZXh0LCBkYXRhLCBvcHRpb25zKXtcblx0XHRcdGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5zdHJpY3QgJiYgKFxuXHRcdFx0XHRkYXRhLmlnbm9yZUNhc2UgfHwgZGF0YS5hY3Rpb24gPT09IFwibm90XCJcblx0XHRcdCkpIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGF0dHJpYnV0ZSBzZWxlY3RvclwiKTtcblx0XHRcdHJldHVybiBhdHRyaWJ1dGVSdWxlc1tkYXRhLmFjdGlvbl0obmV4dCwgZGF0YSk7XG5cdFx0fSxcblx0XHRydWxlczogYXR0cmlidXRlUnVsZXNcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5O1xuIiwiLypcblx0Y29tcGlsZXMgYSBzZWxlY3RvciB0byBhbiBleGVjdXRhYmxlIGZ1bmN0aW9uXG4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBpbGVGYWN0b3J5O1xuXG52YXIgcGFyc2UgICAgICAgICAgPSByZXF1aXJlKFwiY3NzLXdoYXRcIiksXG5cdEJhc2VGdW5jcyAgICAgID0gcmVxdWlyZShcImJvb2xiYXNlXCIpLFxuXHRzb3J0UnVsZXMgICAgICA9IHJlcXVpcmUoXCIuL3NvcnQuanNcIiksXG5cdHByb2NlZHVyZSAgICAgID0gcmVxdWlyZShcIi4vcHJvY2VkdXJlLmpzb25cIiksXG5cdHJ1bGVzRmFjdG9yeSAgID0gcmVxdWlyZShcIi4vZ2VuZXJhbC5qc1wiKSxcblx0cHNldWRvc0ZhY3RvcnkgPSByZXF1aXJlKFwiLi9wc2V1ZG9zLmpzXCIpLFxuXHR0cnVlRnVuYyAgICAgICA9IEJhc2VGdW5jcy50cnVlRnVuYyxcblx0ZmFsc2VGdW5jICAgICAgPSBCYXNlRnVuY3MuZmFsc2VGdW5jO1xuXG5mdW5jdGlvbiBjb21waWxlRmFjdG9yeShhZGFwdGVyKXtcblx0dmFyIFBzZXVkb3MgICAgID0gcHNldWRvc0ZhY3RvcnkoYWRhcHRlciksXG5cdFx0ZmlsdGVycyAgICAgPSBQc2V1ZG9zLmZpbHRlcnMsXG5cdFx0UnVsZXMgXHRcdFx0PSBydWxlc0ZhY3RvcnkoYWRhcHRlciwgUHNldWRvcyk7XG5cblx0ZnVuY3Rpb24gY29tcGlsZShzZWxlY3Rvciwgb3B0aW9ucywgY29udGV4dCl7XG5cdFx0dmFyIG5leHQgPSBjb21waWxlVW5zYWZlKHNlbGVjdG9yLCBvcHRpb25zLCBjb250ZXh0KTtcblx0XHRyZXR1cm4gd3JhcChuZXh0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHdyYXAobmV4dCl7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGJhc2UoZWxlbSl7XG5cdFx0XHRyZXR1cm4gYWRhcHRlci5pc1RhZyhlbGVtKSAmJiBuZXh0KGVsZW0pO1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBjb21waWxlVW5zYWZlKHNlbGVjdG9yLCBvcHRpb25zLCBjb250ZXh0KXtcblx0XHR2YXIgdG9rZW4gPSBwYXJzZShzZWxlY3Rvciwgb3B0aW9ucyk7XG5cdFx0cmV0dXJuIGNvbXBpbGVUb2tlbih0b2tlbiwgb3B0aW9ucywgY29udGV4dCk7XG5cdH1cblxuXHRmdW5jdGlvbiBpbmNsdWRlc1Njb3BlUHNldWRvKHQpe1xuXHRcdHJldHVybiB0LnR5cGUgPT09IFwicHNldWRvXCIgJiYgKFxuXHRcdFx0dC5uYW1lID09PSBcInNjb3BlXCIgfHwgKFxuXHRcdFx0XHRBcnJheS5pc0FycmF5KHQuZGF0YSkgJiZcblx0XHRcdFx0dC5kYXRhLnNvbWUoZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGEuc29tZShpbmNsdWRlc1Njb3BlUHNldWRvKTtcblx0XHRcdFx0fSlcblx0XHRcdClcblx0XHQpO1xuXHR9XG5cblx0dmFyIERFU0NFTkRBTlRfVE9LRU4gPSB7dHlwZTogXCJkZXNjZW5kYW50XCJ9LFxuXHRcdEZMRVhJQkxFX0RFU0NFTkRBTlRfVE9LRU4gPSB7dHlwZTogXCJfZmxleGlibGVEZXNjZW5kYW50XCJ9LFxuXHRcdFNDT1BFX1RPS0VOID0ge3R5cGU6IFwicHNldWRvXCIsIG5hbWU6IFwic2NvcGVcIn0sXG5cdFx0UExBQ0VIT0xERVJfRUxFTUVOVCA9IHt9O1xuXG5cdC8vQ1NTIDQgU3BlYyAoRHJhZnQpOiAzLjMuMS4gQWJzb2x1dGl6aW5nIGEgU2NvcGUtcmVsYXRpdmUgU2VsZWN0b3Jcblx0Ly9odHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnM0LyNhYnNvbHV0aXppbmdcblx0ZnVuY3Rpb24gYWJzb2x1dGl6ZSh0b2tlbiwgY29udGV4dCl7XG5cdFx0Ly9UT0RPIGJldHRlciBjaGVjayBpZiBjb250ZXh0IGlzIGRvY3VtZW50XG5cdFx0dmFyIGhhc0NvbnRleHQgPSAhIWNvbnRleHQgJiYgISFjb250ZXh0Lmxlbmd0aCAmJiBjb250ZXh0LmV2ZXJ5KGZ1bmN0aW9uKGUpe1xuXHRcdFx0cmV0dXJuIGUgPT09IFBMQUNFSE9MREVSX0VMRU1FTlQgfHwgISFhZGFwdGVyLmdldFBhcmVudChlKTtcblx0XHR9KTtcblxuXG5cdFx0dG9rZW4uZm9yRWFjaChmdW5jdGlvbih0KXtcblx0XHRcdGlmKHQubGVuZ3RoID4gMCAmJiBpc1RyYXZlcnNhbCh0WzBdKSAmJiB0WzBdLnR5cGUgIT09IFwiZGVzY2VuZGFudFwiKXtcblx0XHRcdFx0Ly9kb24ndCByZXR1cm4gaW4gZWxzZSBicmFuY2hcblx0XHRcdH0gZWxzZSBpZihoYXNDb250ZXh0ICYmICFpbmNsdWRlc1Njb3BlUHNldWRvKHQpKXtcblx0XHRcdFx0dC51bnNoaWZ0KERFU0NFTkRBTlRfVE9LRU4pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0LnVuc2hpZnQoU0NPUEVfVE9LRU4pO1xuXHRcdH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29tcGlsZVRva2VuKHRva2VuLCBvcHRpb25zLCBjb250ZXh0KXtcblx0XHR0b2tlbiA9IHRva2VuLmZpbHRlcihmdW5jdGlvbih0KXsgcmV0dXJuIHQubGVuZ3RoID4gMDsgfSk7XG5cblx0XHR0b2tlbi5mb3JFYWNoKHNvcnRSdWxlcyk7XG5cblx0XHR2YXIgaXNBcnJheUNvbnRleHQgPSBBcnJheS5pc0FycmF5KGNvbnRleHQpO1xuXG5cdFx0Y29udGV4dCA9IChvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCkgfHwgY29udGV4dDtcblxuXHRcdGlmKGNvbnRleHQgJiYgIWlzQXJyYXlDb250ZXh0KSBjb250ZXh0ID0gW2NvbnRleHRdO1xuXG5cdFx0YWJzb2x1dGl6ZSh0b2tlbiwgY29udGV4dCk7XG5cblx0XHR2YXIgc2hvdWxkVGVzdE5leHRTaWJsaW5ncyA9IGZhbHNlO1xuXG5cdFx0dmFyIHF1ZXJ5ID0gdG9rZW5cblx0XHRcdC5tYXAoZnVuY3Rpb24ocnVsZXMpe1xuXHRcdFx0XHRpZihydWxlc1swXSAmJiBydWxlc1sxXSAmJiBydWxlc1swXS5uYW1lID09PSBcInNjb3BlXCIpe1xuXHRcdFx0XHRcdHZhciBydWxlVHlwZSA9IHJ1bGVzWzFdLnR5cGU7XG5cdFx0XHRcdFx0aWYoaXNBcnJheUNvbnRleHQgJiYgcnVsZVR5cGUgPT09IFwiZGVzY2VuZGFudFwiKSBydWxlc1sxXSA9IEZMRVhJQkxFX0RFU0NFTkRBTlRfVE9LRU47XG5cdFx0XHRcdFx0ZWxzZSBpZihydWxlVHlwZSA9PT0gXCJhZGphY2VudFwiIHx8IHJ1bGVUeXBlID09PSBcInNpYmxpbmdcIikgc2hvdWxkVGVzdE5leHRTaWJsaW5ncyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGNvbXBpbGVSdWxlcyhydWxlcywgb3B0aW9ucywgY29udGV4dCk7XG5cdFx0XHR9KVxuXHRcdFx0LnJlZHVjZShyZWR1Y2VSdWxlcywgZmFsc2VGdW5jKTtcblxuXHRcdHF1ZXJ5LnNob3VsZFRlc3ROZXh0U2libGluZ3MgPSBzaG91bGRUZXN0TmV4dFNpYmxpbmdzO1xuXG5cdFx0cmV0dXJuIHF1ZXJ5O1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNUcmF2ZXJzYWwodCl7XG5cdFx0cmV0dXJuIHByb2NlZHVyZVt0LnR5cGVdIDwgMDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXBpbGVSdWxlcyhydWxlcywgb3B0aW9ucywgY29udGV4dCl7XG5cdFx0cmV0dXJuIHJ1bGVzLnJlZHVjZShmdW5jdGlvbihmdW5jLCBydWxlKXtcblx0XHRcdGlmKGZ1bmMgPT09IGZhbHNlRnVuYykgcmV0dXJuIGZ1bmM7XG5cdFx0XHRyZXR1cm4gUnVsZXNbcnVsZS50eXBlXShmdW5jLCBydWxlLCBvcHRpb25zLCBjb250ZXh0KTtcblx0XHR9LCBvcHRpb25zICYmIG9wdGlvbnMucm9vdEZ1bmMgfHwgdHJ1ZUZ1bmMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVkdWNlUnVsZXMoYSwgYil7XG5cdFx0aWYoYiA9PT0gZmFsc2VGdW5jIHx8IGEgPT09IHRydWVGdW5jKXtcblx0XHRcdHJldHVybiBhO1xuXHRcdH1cblx0XHRpZihhID09PSBmYWxzZUZ1bmMgfHwgYiA9PT0gdHJ1ZUZ1bmMpe1xuXHRcdFx0cmV0dXJuIGI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNvbWJpbmUoZWxlbSl7XG5cdFx0XHRyZXR1cm4gYShlbGVtKSB8fCBiKGVsZW0pO1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBjb250YWluc1RyYXZlcnNhbCh0KXtcblx0XHRyZXR1cm4gdC5zb21lKGlzVHJhdmVyc2FsKTtcblx0fVxuXG5cdC8vOm5vdCwgOmhhcyBhbmQgOm1hdGNoZXMgaGF2ZSB0byBjb21waWxlIHNlbGVjdG9yc1xuXHQvL2RvaW5nIHRoaXMgaW4gbGliL3BzZXVkb3MuanMgd291bGQgbGVhZCB0byBjaXJjdWxhciBkZXBlbmRlbmNpZXMsXG5cdC8vc28gd2UgYWRkIHRoZW0gaGVyZVxuXHRmaWx0ZXJzLm5vdCA9IGZ1bmN0aW9uKG5leHQsIHRva2VuLCBvcHRpb25zLCBjb250ZXh0KXtcblx0XHR2YXIgb3B0cyA9IHtcblx0XHRcdHhtbE1vZGU6ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy54bWxNb2RlKSxcblx0XHRcdHN0cmljdDogISEob3B0aW9ucyAmJiBvcHRpb25zLnN0cmljdClcblx0XHR9O1xuXG5cdFx0aWYob3B0cy5zdHJpY3Qpe1xuXHRcdFx0aWYodG9rZW4ubGVuZ3RoID4gMSB8fCB0b2tlbi5zb21lKGNvbnRhaW5zVHJhdmVyc2FsKSl7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImNvbXBsZXggc2VsZWN0b3JzIGluIDpub3QgYXJlbid0IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGVcIik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGZ1bmMgPSBjb21waWxlVG9rZW4odG9rZW4sIG9wdHMsIGNvbnRleHQpO1xuXG5cdFx0aWYoZnVuYyA9PT0gZmFsc2VGdW5jKSByZXR1cm4gbmV4dDtcblx0XHRpZihmdW5jID09PSB0cnVlRnVuYykgIHJldHVybiBmYWxzZUZ1bmM7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHRyZXR1cm4gIWZ1bmMoZWxlbSkgJiYgbmV4dChlbGVtKTtcblx0XHR9O1xuXHR9O1xuXG5cdGZpbHRlcnMuaGFzID0gZnVuY3Rpb24obmV4dCwgdG9rZW4sIG9wdGlvbnMpe1xuXHRcdHZhciBvcHRzID0ge1xuXHRcdFx0eG1sTW9kZTogISEob3B0aW9ucyAmJiBvcHRpb25zLnhtbE1vZGUpLFxuXHRcdFx0c3RyaWN0OiAhIShvcHRpb25zICYmIG9wdGlvbnMuc3RyaWN0KVxuXHRcdH07XG5cblx0XHQvL0ZJWE1FOiBVc2VzIGFuIGFycmF5IGFzIGEgcG9pbnRlciB0byB0aGUgY3VycmVudCBlbGVtZW50IChzaWRlIGVmZmVjdHMpXG5cdFx0dmFyIGNvbnRleHQgPSB0b2tlbi5zb21lKGNvbnRhaW5zVHJhdmVyc2FsKSA/IFtQTEFDRUhPTERFUl9FTEVNRU5UXSA6IG51bGw7XG5cblx0XHR2YXIgZnVuYyA9IGNvbXBpbGVUb2tlbih0b2tlbiwgb3B0cywgY29udGV4dCk7XG5cblx0XHRpZihmdW5jID09PSBmYWxzZUZ1bmMpIHJldHVybiBmYWxzZUZ1bmM7XG5cdFx0aWYoZnVuYyA9PT0gdHJ1ZUZ1bmMpe1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0XHRyZXR1cm4gYWRhcHRlci5nZXRDaGlsZHJlbihlbGVtKS5zb21lKGFkYXB0ZXIuaXNUYWcpICYmIG5leHQoZWxlbSk7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGZ1bmMgPSB3cmFwKGZ1bmMpO1xuXG5cdFx0aWYoY29udGV4dCl7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gaGFzKGVsZW0pe1xuXHRcdFx0XHRyZXR1cm4gbmV4dChlbGVtKSAmJiAoXG5cdFx0XHRcdFx0KGNvbnRleHRbMF0gPSBlbGVtKSwgYWRhcHRlci5leGlzdHNPbmUoZnVuYywgYWRhcHRlci5nZXRDaGlsZHJlbihlbGVtKSlcblx0XHRcdFx0KTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGhhcyhlbGVtKXtcblx0XHRcdHJldHVybiBuZXh0KGVsZW0pICYmIGFkYXB0ZXIuZXhpc3RzT25lKGZ1bmMsIGFkYXB0ZXIuZ2V0Q2hpbGRyZW4oZWxlbSkpO1xuXHRcdH07XG5cdH07XG5cblx0ZmlsdGVycy5tYXRjaGVzID0gZnVuY3Rpb24obmV4dCwgdG9rZW4sIG9wdGlvbnMsIGNvbnRleHQpe1xuXHRcdHZhciBvcHRzID0ge1xuXHRcdFx0eG1sTW9kZTogISEob3B0aW9ucyAmJiBvcHRpb25zLnhtbE1vZGUpLFxuXHRcdFx0c3RyaWN0OiAhIShvcHRpb25zICYmIG9wdGlvbnMuc3RyaWN0KSxcblx0XHRcdHJvb3RGdW5jOiBuZXh0XG5cdFx0fTtcblxuXHRcdHJldHVybiBjb21waWxlVG9rZW4odG9rZW4sIG9wdHMsIGNvbnRleHQpO1xuXHR9O1xuXG5cdGNvbXBpbGUuY29tcGlsZVRva2VuID0gY29tcGlsZVRva2VuO1xuXHRjb21waWxlLmNvbXBpbGVVbnNhZmUgPSBjb21waWxlVW5zYWZlO1xuXHRjb21waWxlLlBzZXVkb3MgPSBQc2V1ZG9zO1xuXG5cdHJldHVybiBjb21waWxlO1xufVxuIiwidmFyIGF0dHJpYnV0ZUZhY3RvcnkgPSByZXF1aXJlKFwiLi9hdHRyaWJ1dGVzLmpzXCIpO1xuXG5mdW5jdGlvbiBnZW5lcmFsRmFjdG9yeShhZGFwdGVyLCBQc2V1ZG9zKXtcblx0Lypcblx0XHRhbGwgYXZhaWxhYmxlIHJ1bGVzXG5cdCovXG5cdHJldHVybiB7XG5cdFx0X19wcm90b19fOiBudWxsLFxuXG5cdFx0YXR0cmlidXRlOiBhdHRyaWJ1dGVGYWN0b3J5KGFkYXB0ZXIpLmNvbXBpbGUsXG5cdFx0cHNldWRvOiBQc2V1ZG9zLmNvbXBpbGUsXG5cblx0XHQvL3RhZ3Ncblx0XHR0YWc6IGZ1bmN0aW9uKG5leHQsIGRhdGEpe1xuXHRcdFx0dmFyIG5hbWUgPSBkYXRhLm5hbWU7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gdGFnKGVsZW0pe1xuXHRcdFx0XHRyZXR1cm4gYWRhcHRlci5nZXROYW1lKGVsZW0pID09PSBuYW1lICYmIG5leHQoZWxlbSk7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHQvL3RyYXZlcnNhbFxuXHRcdGRlc2NlbmRhbnQ6IGZ1bmN0aW9uKG5leHQpe1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGRlc2NlbmRhbnQoZWxlbSl7XG5cblx0XHRcdFx0dmFyIGZvdW5kID0gZmFsc2U7XG5cblx0XHRcdFx0d2hpbGUoIWZvdW5kICYmIChlbGVtID0gYWRhcHRlci5nZXRQYXJlbnQoZWxlbSkpKXtcblx0XHRcdFx0XHRmb3VuZCA9IG5leHQoZWxlbSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZm91bmQ7XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0X2ZsZXhpYmxlRGVzY2VuZGFudDogZnVuY3Rpb24obmV4dCl7XG5cdFx0XHQvLyBJbmNsdWRlIGVsZW1lbnQgaXRzZWxmLCBvbmx5IHVzZWQgd2hpbGUgcXVlcnlpbmcgYW4gYXJyYXlcblx0XHRcdHJldHVybiBmdW5jdGlvbiBkZXNjZW5kYW50KGVsZW0pe1xuXG5cdFx0XHRcdHZhciBmb3VuZCA9IG5leHQoZWxlbSk7XG5cblx0XHRcdFx0d2hpbGUoIWZvdW5kICYmIChlbGVtID0gYWRhcHRlci5nZXRQYXJlbnQoZWxlbSkpKXtcblx0XHRcdFx0XHRmb3VuZCA9IG5leHQoZWxlbSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZm91bmQ7XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0cGFyZW50OiBmdW5jdGlvbihuZXh0LCBkYXRhLCBvcHRpb25zKXtcblx0XHRcdGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5zdHJpY3QpIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBzZWxlY3RvciBpc24ndCBwYXJ0IG9mIENTUzNcIik7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBwYXJlbnQoZWxlbSl7XG5cdFx0XHRcdHJldHVybiBhZGFwdGVyLmdldENoaWxkcmVuKGVsZW0pLnNvbWUodGVzdCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRmdW5jdGlvbiB0ZXN0KGVsZW0pe1xuXHRcdFx0XHRyZXR1cm4gYWRhcHRlci5pc1RhZyhlbGVtKSAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y2hpbGQ6IGZ1bmN0aW9uKG5leHQpe1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGNoaWxkKGVsZW0pe1xuXHRcdFx0XHR2YXIgcGFyZW50ID0gYWRhcHRlci5nZXRQYXJlbnQoZWxlbSk7XG5cdFx0XHRcdHJldHVybiAhIXBhcmVudCAmJiBuZXh0KHBhcmVudCk7XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0c2libGluZzogZnVuY3Rpb24obmV4dCl7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gc2libGluZyhlbGVtKXtcblx0XHRcdFx0dmFyIHNpYmxpbmdzID0gYWRhcHRlci5nZXRTaWJsaW5ncyhlbGVtKTtcblxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2libGluZ3MubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRcdGlmKGFkYXB0ZXIuaXNUYWcoc2libGluZ3NbaV0pKXtcblx0XHRcdFx0XHRcdGlmKHNpYmxpbmdzW2ldID09PSBlbGVtKSBicmVhaztcblx0XHRcdFx0XHRcdGlmKG5leHQoc2libGluZ3NbaV0pKSByZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0YWRqYWNlbnQ6IGZ1bmN0aW9uKG5leHQpe1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGFkamFjZW50KGVsZW0pe1xuXHRcdFx0XHR2YXIgc2libGluZ3MgPSBhZGFwdGVyLmdldFNpYmxpbmdzKGVsZW0pLFxuXHRcdFx0XHRcdGxhc3RFbGVtZW50O1xuXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzaWJsaW5ncy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdFx0aWYoYWRhcHRlci5pc1RhZyhzaWJsaW5nc1tpXSkpe1xuXHRcdFx0XHRcdFx0aWYoc2libGluZ3NbaV0gPT09IGVsZW0pIGJyZWFrO1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQgPSBzaWJsaW5nc1tpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gISFsYXN0RWxlbWVudCAmJiBuZXh0KGxhc3RFbGVtZW50KTtcblx0XHRcdH07XG5cdFx0fSxcblx0XHR1bml2ZXJzYWw6IGZ1bmN0aW9uKG5leHQpe1xuXHRcdFx0cmV0dXJuIG5leHQ7XG5cdFx0fVxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYWxGYWN0b3J5O1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcInVuaXZlcnNhbFwiOiA1MCxcbiAgXCJ0YWdcIjogMzAsXG4gIFwiYXR0cmlidXRlXCI6IDEsXG4gIFwicHNldWRvXCI6IDAsXG4gIFwiZGVzY2VuZGFudFwiOiAtMSxcbiAgXCJjaGlsZFwiOiAtMSxcbiAgXCJwYXJlbnRcIjogLTEsXG4gIFwic2libGluZ1wiOiAtMSxcbiAgXCJhZGphY2VudFwiOiAtMVxufVxuIiwiLypcblx0cHNldWRvIHNlbGVjdG9yc1xuXG5cdC0tLVxuXG5cdHRoZXkgYXJlIGF2YWlsYWJsZSBpbiB0d28gZm9ybXM6XG5cdCogZmlsdGVycyBjYWxsZWQgd2hlbiB0aGUgc2VsZWN0b3Jcblx0ICBpcyBjb21waWxlZCBhbmQgcmV0dXJuIGEgZnVuY3Rpb25cblx0ICB0aGF0IG5lZWRzIHRvIHJldHVybiBuZXh0KClcblx0KiBwc2V1ZG9zIGdldCBjYWxsZWQgb24gZXhlY3V0aW9uXG5cdCAgdGhleSBuZWVkIHRvIHJldHVybiBhIGJvb2xlYW5cbiovXG5cbnZhciBnZXROQ2hlY2sgICAgICAgICA9IHJlcXVpcmUoXCJudGgtY2hlY2tcIiksXG5cdEJhc2VGdW5jcyAgICAgICAgID0gcmVxdWlyZShcImJvb2xiYXNlXCIpLFxuXHRhdHRyaWJ1dGVzRmFjdG9yeSA9IHJlcXVpcmUoXCIuL2F0dHJpYnV0ZXMuanNcIiksXG5cdHRydWVGdW5jICAgICAgICAgID0gQmFzZUZ1bmNzLnRydWVGdW5jLFxuXHRmYWxzZUZ1bmMgICAgICAgICA9IEJhc2VGdW5jcy5mYWxzZUZ1bmM7XG5cbmZ1bmN0aW9uIGZpbHRlcnNGYWN0b3J5KGFkYXB0ZXIpe1xuXHR2YXIgYXR0cmlidXRlcyAgPSBhdHRyaWJ1dGVzRmFjdG9yeShhZGFwdGVyKSxcblx0XHRjaGVja0F0dHJpYiA9IGF0dHJpYnV0ZXMucnVsZXMuZXF1YWxzO1xuXG5cdC8vaGVscGVyIG1ldGhvZHNcblx0ZnVuY3Rpb24gZXF1YWxzKGEsIGIpe1xuXHRcdGlmKHR5cGVvZiBhZGFwdGVyLmVxdWFscyA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gYWRhcHRlci5lcXVhbHMoYSwgYik7XG5cblx0XHRyZXR1cm4gYSA9PT0gYjtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEF0dHJpYkZ1bmMobmFtZSwgdmFsdWUpe1xuXHRcdHZhciBkYXRhID0ge25hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZX07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGF0dHJpYkZ1bmMobmV4dCl7XG5cdFx0XHRyZXR1cm4gY2hlY2tBdHRyaWIobmV4dCwgZGF0YSk7XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldENoaWxkRnVuYyhuZXh0KXtcblx0XHRyZXR1cm4gZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHRyZXR1cm4gISFhZGFwdGVyLmdldFBhcmVudChlbGVtKSAmJiBuZXh0KGVsZW0pO1xuXHRcdH07XG5cdH1cblxuXHR2YXIgZmlsdGVycyA9IHtcblx0XHRjb250YWluczogZnVuY3Rpb24obmV4dCwgdGV4dCl7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gY29udGFpbnMoZWxlbSl7XG5cdFx0XHRcdHJldHVybiBuZXh0KGVsZW0pICYmIGFkYXB0ZXIuZ2V0VGV4dChlbGVtKS5pbmRleE9mKHRleHQpID49IDA7XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0aWNvbnRhaW5zOiBmdW5jdGlvbihuZXh0LCB0ZXh0KXtcblx0XHRcdHZhciBpdGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiBpY29udGFpbnMoZWxlbSl7XG5cdFx0XHRcdHJldHVybiBuZXh0KGVsZW0pICYmXG5cdFx0XHRcdFx0YWRhcHRlci5nZXRUZXh0KGVsZW0pLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihpdGV4dCkgPj0gMDtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8vbG9jYXRpb24gc3BlY2lmaWMgbWV0aG9kc1xuXHRcdFwibnRoLWNoaWxkXCI6IGZ1bmN0aW9uKG5leHQsIHJ1bGUpe1xuXHRcdFx0dmFyIGZ1bmMgPSBnZXROQ2hlY2socnVsZSk7XG5cblx0XHRcdGlmKGZ1bmMgPT09IGZhbHNlRnVuYykgcmV0dXJuIGZ1bmM7XG5cdFx0XHRpZihmdW5jID09PSB0cnVlRnVuYykgIHJldHVybiBnZXRDaGlsZEZ1bmMobmV4dCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBudGhDaGlsZChlbGVtKXtcblx0XHRcdFx0dmFyIHNpYmxpbmdzID0gYWRhcHRlci5nZXRTaWJsaW5ncyhlbGVtKTtcblxuXHRcdFx0XHRmb3IodmFyIGkgPSAwLCBwb3MgPSAwOyBpIDwgc2libGluZ3MubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRcdGlmKGFkYXB0ZXIuaXNUYWcoc2libGluZ3NbaV0pKXtcblx0XHRcdFx0XHRcdGlmKHNpYmxpbmdzW2ldID09PSBlbGVtKSBicmVhaztcblx0XHRcdFx0XHRcdGVsc2UgcG9zKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZ1bmMocG9zKSAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0fTtcblx0XHR9LFxuXHRcdFwibnRoLWxhc3QtY2hpbGRcIjogZnVuY3Rpb24obmV4dCwgcnVsZSl7XG5cdFx0XHR2YXIgZnVuYyA9IGdldE5DaGVjayhydWxlKTtcblxuXHRcdFx0aWYoZnVuYyA9PT0gZmFsc2VGdW5jKSByZXR1cm4gZnVuYztcblx0XHRcdGlmKGZ1bmMgPT09IHRydWVGdW5jKSAgcmV0dXJuIGdldENoaWxkRnVuYyhuZXh0KTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIG50aExhc3RDaGlsZChlbGVtKXtcblx0XHRcdFx0dmFyIHNpYmxpbmdzID0gYWRhcHRlci5nZXRTaWJsaW5ncyhlbGVtKTtcblxuXHRcdFx0XHRmb3IodmFyIHBvcyA9IDAsIGkgPSBzaWJsaW5ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG5cdFx0XHRcdFx0aWYoYWRhcHRlci5pc1RhZyhzaWJsaW5nc1tpXSkpe1xuXHRcdFx0XHRcdFx0aWYoc2libGluZ3NbaV0gPT09IGVsZW0pIGJyZWFrO1xuXHRcdFx0XHRcdFx0ZWxzZSBwb3MrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZnVuYyhwb3MpICYmIG5leHQoZWxlbSk7XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0XCJudGgtb2YtdHlwZVwiOiBmdW5jdGlvbihuZXh0LCBydWxlKXtcblx0XHRcdHZhciBmdW5jID0gZ2V0TkNoZWNrKHJ1bGUpO1xuXG5cdFx0XHRpZihmdW5jID09PSBmYWxzZUZ1bmMpIHJldHVybiBmdW5jO1xuXHRcdFx0aWYoZnVuYyA9PT0gdHJ1ZUZ1bmMpICByZXR1cm4gZ2V0Q2hpbGRGdW5jKG5leHQpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gbnRoT2ZUeXBlKGVsZW0pe1xuXHRcdFx0XHR2YXIgc2libGluZ3MgPSBhZGFwdGVyLmdldFNpYmxpbmdzKGVsZW0pO1xuXG5cdFx0XHRcdGZvcih2YXIgcG9zID0gMCwgaSA9IDA7IGkgPCBzaWJsaW5ncy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdFx0aWYoYWRhcHRlci5pc1RhZyhzaWJsaW5nc1tpXSkpe1xuXHRcdFx0XHRcdFx0aWYoc2libGluZ3NbaV0gPT09IGVsZW0pIGJyZWFrO1xuXHRcdFx0XHRcdFx0aWYoYWRhcHRlci5nZXROYW1lKHNpYmxpbmdzW2ldKSA9PT0gYWRhcHRlci5nZXROYW1lKGVsZW0pKSBwb3MrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZnVuYyhwb3MpICYmIG5leHQoZWxlbSk7XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0XCJudGgtbGFzdC1vZi10eXBlXCI6IGZ1bmN0aW9uKG5leHQsIHJ1bGUpe1xuXHRcdFx0dmFyIGZ1bmMgPSBnZXROQ2hlY2socnVsZSk7XG5cblx0XHRcdGlmKGZ1bmMgPT09IGZhbHNlRnVuYykgcmV0dXJuIGZ1bmM7XG5cdFx0XHRpZihmdW5jID09PSB0cnVlRnVuYykgIHJldHVybiBnZXRDaGlsZEZ1bmMobmV4dCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBudGhMYXN0T2ZUeXBlKGVsZW0pe1xuXHRcdFx0XHR2YXIgc2libGluZ3MgPSBhZGFwdGVyLmdldFNpYmxpbmdzKGVsZW0pO1xuXG5cdFx0XHRcdGZvcih2YXIgcG9zID0gMCwgaSA9IHNpYmxpbmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcblx0XHRcdFx0XHRpZihhZGFwdGVyLmlzVGFnKHNpYmxpbmdzW2ldKSl7XG5cdFx0XHRcdFx0XHRpZihzaWJsaW5nc1tpXSA9PT0gZWxlbSkgYnJlYWs7XG5cdFx0XHRcdFx0XHRpZihhZGFwdGVyLmdldE5hbWUoc2libGluZ3NbaV0pID09PSBhZGFwdGVyLmdldE5hbWUoZWxlbSkpIHBvcysrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBmdW5jKHBvcykgJiYgbmV4dChlbGVtKTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8vVE9ETyBkZXRlcm1pbmUgdGhlIGFjdHVhbCByb290IGVsZW1lbnRcblx0XHRyb290OiBmdW5jdGlvbihuZXh0KXtcblx0XHRcdHJldHVybiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdFx0cmV0dXJuICFhZGFwdGVyLmdldFBhcmVudChlbGVtKSAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0c2NvcGU6IGZ1bmN0aW9uKG5leHQsIHJ1bGUsIG9wdGlvbnMsIGNvbnRleHQpe1xuXHRcdFx0aWYoIWNvbnRleHQgfHwgY29udGV4dC5sZW5ndGggPT09IDApe1xuXHRcdFx0XHQvL2VxdWl2YWxlbnQgdG8gOnJvb3Rcblx0XHRcdFx0cmV0dXJuIGZpbHRlcnMucm9vdChuZXh0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYoY29udGV4dC5sZW5ndGggPT09IDEpe1xuXHRcdFx0XHQvL05PVEU6IGNhbid0IGJlIHVucGFja2VkLCBhcyA6aGFzIHVzZXMgdGhpcyBmb3Igc2lkZS1lZmZlY3RzXG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdFx0XHRyZXR1cm4gZXF1YWxzKGNvbnRleHRbMF0sIGVsZW0pICYmIG5leHQoZWxlbSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuaW5kZXhPZihlbGVtKSA+PSAwICYmIG5leHQoZWxlbSk7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHQvL2pRdWVyeSBleHRlbnNpb25zIChvdGhlcnMgZm9sbG93IGFzIHBzZXVkb3MpXG5cdFx0Y2hlY2tib3g6IGdldEF0dHJpYkZ1bmMoXCJ0eXBlXCIsIFwiY2hlY2tib3hcIiksXG5cdFx0ZmlsZTogZ2V0QXR0cmliRnVuYyhcInR5cGVcIiwgXCJmaWxlXCIpLFxuXHRcdHBhc3N3b3JkOiBnZXRBdHRyaWJGdW5jKFwidHlwZVwiLCBcInBhc3N3b3JkXCIpLFxuXHRcdHJhZGlvOiBnZXRBdHRyaWJGdW5jKFwidHlwZVwiLCBcInJhZGlvXCIpLFxuXHRcdHJlc2V0OiBnZXRBdHRyaWJGdW5jKFwidHlwZVwiLCBcInJlc2V0XCIpLFxuXHRcdGltYWdlOiBnZXRBdHRyaWJGdW5jKFwidHlwZVwiLCBcImltYWdlXCIpLFxuXHRcdHN1Ym1pdDogZ2V0QXR0cmliRnVuYyhcInR5cGVcIiwgXCJzdWJtaXRcIilcblx0fTtcblx0cmV0dXJuIGZpbHRlcnM7XG59XG5cbmZ1bmN0aW9uIHBzZXVkb3NGYWN0b3J5KGFkYXB0ZXIpe1xuXHQvL2hlbHBlciBtZXRob2RzXG5cdGZ1bmN0aW9uIGdldEZpcnN0RWxlbWVudChlbGVtcyl7XG5cdFx0Zm9yKHZhciBpID0gMDsgZWxlbXMgJiYgaSA8IGVsZW1zLmxlbmd0aDsgaSsrKXtcblx0XHRcdGlmKGFkYXB0ZXIuaXNUYWcoZWxlbXNbaV0pKSByZXR1cm4gZWxlbXNbaV07XG5cdFx0fVxuXHR9XG5cblx0Ly93aGlsZSBmaWx0ZXJzIGFyZSBwcmVjb21waWxlZCwgcHNldWRvcyBnZXQgY2FsbGVkIHdoZW4gdGhleSBhcmUgbmVlZGVkXG5cdHZhciBwc2V1ZG9zID0ge1xuXHRcdGVtcHR5OiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdHJldHVybiAhYWRhcHRlci5nZXRDaGlsZHJlbihlbGVtKS5zb21lKGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0XHRyZXR1cm4gYWRhcHRlci5pc1RhZyhlbGVtKSB8fCBlbGVtLnR5cGUgPT09IFwidGV4dFwiO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiZmlyc3QtY2hpbGRcIjogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHRyZXR1cm4gZ2V0Rmlyc3RFbGVtZW50KGFkYXB0ZXIuZ2V0U2libGluZ3MoZWxlbSkpID09PSBlbGVtO1xuXHRcdH0sXG5cdFx0XCJsYXN0LWNoaWxkXCI6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0dmFyIHNpYmxpbmdzID0gYWRhcHRlci5nZXRTaWJsaW5ncyhlbGVtKTtcblxuXHRcdFx0Zm9yKHZhciBpID0gc2libGluZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuXHRcdFx0XHRpZihzaWJsaW5nc1tpXSA9PT0gZWxlbSkgcmV0dXJuIHRydWU7XG5cdFx0XHRcdGlmKGFkYXB0ZXIuaXNUYWcoc2libGluZ3NbaV0pKSBicmVhaztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0XCJmaXJzdC1vZi10eXBlXCI6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0dmFyIHNpYmxpbmdzID0gYWRhcHRlci5nZXRTaWJsaW5ncyhlbGVtKTtcblxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHNpYmxpbmdzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0aWYoYWRhcHRlci5pc1RhZyhzaWJsaW5nc1tpXSkpe1xuXHRcdFx0XHRcdGlmKHNpYmxpbmdzW2ldID09PSBlbGVtKSByZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRpZihhZGFwdGVyLmdldE5hbWUoc2libGluZ3NbaV0pID09PSBhZGFwdGVyLmdldE5hbWUoZWxlbSkpIGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdFwibGFzdC1vZi10eXBlXCI6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0dmFyIHNpYmxpbmdzID0gYWRhcHRlci5nZXRTaWJsaW5ncyhlbGVtKTtcblxuXHRcdFx0Zm9yKHZhciBpID0gc2libGluZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuXHRcdFx0XHRpZihhZGFwdGVyLmlzVGFnKHNpYmxpbmdzW2ldKSl7XG5cdFx0XHRcdFx0aWYoc2libGluZ3NbaV0gPT09IGVsZW0pIHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdGlmKGFkYXB0ZXIuZ2V0TmFtZShzaWJsaW5nc1tpXSkgPT09IGFkYXB0ZXIuZ2V0TmFtZShlbGVtKSkgYnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0XCJvbmx5LW9mLXR5cGVcIjogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHR2YXIgc2libGluZ3MgPSBhZGFwdGVyLmdldFNpYmxpbmdzKGVsZW0pO1xuXG5cdFx0XHRmb3IodmFyIGkgPSAwLCBqID0gc2libGluZ3MubGVuZ3RoOyBpIDwgajsgaSsrKXtcblx0XHRcdFx0aWYoYWRhcHRlci5pc1RhZyhzaWJsaW5nc1tpXSkpe1xuXHRcdFx0XHRcdGlmKHNpYmxpbmdzW2ldID09PSBlbGVtKSBjb250aW51ZTtcblx0XHRcdFx0XHRpZihhZGFwdGVyLmdldE5hbWUoc2libGluZ3NbaV0pID09PSBhZGFwdGVyLmdldE5hbWUoZWxlbSkpIHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcdFwib25seS1jaGlsZFwiOiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdHZhciBzaWJsaW5ncyA9IGFkYXB0ZXIuZ2V0U2libGluZ3MoZWxlbSk7XG5cblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzaWJsaW5ncy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdGlmKGFkYXB0ZXIuaXNUYWcoc2libGluZ3NbaV0pICYmIHNpYmxpbmdzW2ldICE9PSBlbGVtKSByZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLzptYXRjaGVzKGEsIGFyZWEsIGxpbmspW2hyZWZdXG5cdFx0bGluazogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHRyZXR1cm4gYWRhcHRlci5oYXNBdHRyaWIoZWxlbSwgXCJocmVmXCIpO1xuXHRcdH0sXG5cdFx0dmlzaXRlZDogZmFsc2VGdW5jLCAvL3NlZW1zIHRvIGJlIGEgdmFsaWQgaW1wbGVtZW50YXRpb25cblx0XHQvL1RPRE86IDphbnktbGluayBvbmNlIHRoZSBuYW1lIGlzIGZpbmFsaXplZCAoYXMgYW4gYWxpYXMgb2YgOmxpbmspXG5cblx0XHQvL2Zvcm1zXG5cdFx0Ly90byBjb25zaWRlcjogOnRhcmdldFxuXG5cdFx0Ly86bWF0Y2hlcyhbc2VsZWN0ZWRdLCBzZWxlY3Q6bm90KFttdWx0aXBsZV0pOm5vdCg+IG9wdGlvbltzZWxlY3RlZF0pID4gb3B0aW9uOmZpcnN0LW9mLXR5cGUpXG5cdFx0c2VsZWN0ZWQ6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0aWYoYWRhcHRlci5oYXNBdHRyaWIoZWxlbSwgXCJzZWxlY3RlZFwiKSkgcmV0dXJuIHRydWU7XG5cdFx0XHRlbHNlIGlmKGFkYXB0ZXIuZ2V0TmFtZShlbGVtKSAhPT0gXCJvcHRpb25cIikgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHQvL3RoZSBmaXJzdCA8b3B0aW9uPiBpbiBhIDxzZWxlY3Q+IGlzIGFsc28gc2VsZWN0ZWRcblx0XHRcdHZhciBwYXJlbnQgPSBhZGFwdGVyLmdldFBhcmVudChlbGVtKTtcblxuXHRcdFx0aWYoXG5cdFx0XHRcdCFwYXJlbnQgfHxcblx0XHRcdFx0YWRhcHRlci5nZXROYW1lKHBhcmVudCkgIT09IFwic2VsZWN0XCIgfHxcblx0XHRcdFx0YWRhcHRlci5oYXNBdHRyaWIocGFyZW50LCBcIm11bHRpcGxlXCIpXG5cdFx0XHQpIHJldHVybiBmYWxzZTtcblxuXHRcdFx0dmFyIHNpYmxpbmdzID0gYWRhcHRlci5nZXRDaGlsZHJlbihwYXJlbnQpLFxuXHRcdFx0XHRzYXdFbGVtICA9IGZhbHNlO1xuXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2libGluZ3MubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRpZihhZGFwdGVyLmlzVGFnKHNpYmxpbmdzW2ldKSl7XG5cdFx0XHRcdFx0aWYoc2libGluZ3NbaV0gPT09IGVsZW0pe1xuXHRcdFx0XHRcdFx0c2F3RWxlbSA9IHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmKCFzYXdFbGVtKXtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYoYWRhcHRlci5oYXNBdHRyaWIoc2libGluZ3NbaV0sIFwic2VsZWN0ZWRcIikpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2F3RWxlbTtcblx0XHR9LFxuXHRcdC8vaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjZGlzYWJsZWQtZWxlbWVudHNcblx0XHQvLzptYXRjaGVzKFxuXHRcdC8vICA6bWF0Y2hlcyhidXR0b24sIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBtZW51aXRlbSwgb3B0Z3JvdXAsIG9wdGlvbilbZGlzYWJsZWRdLFxuXHRcdC8vICBvcHRncm91cFtkaXNhYmxlZF0gPiBvcHRpb24pLFxuXHRcdC8vIGZpZWxkc2V0W2Rpc2FibGVkXSAqIC8vVE9ETyBub3QgY2hpbGQgb2YgZmlyc3QgPGxlZ2VuZD5cblx0XHQvLylcblx0XHRkaXNhYmxlZDogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHRyZXR1cm4gYWRhcHRlci5oYXNBdHRyaWIoZWxlbSwgXCJkaXNhYmxlZFwiKTtcblx0XHR9LFxuXHRcdGVuYWJsZWQ6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0cmV0dXJuICFhZGFwdGVyLmhhc0F0dHJpYihlbGVtLCBcImRpc2FibGVkXCIpO1xuXHRcdH0sXG5cdFx0Ly86bWF0Y2hlcyg6bWF0Y2hlcyg6cmFkaW8sIDpjaGVja2JveClbY2hlY2tlZF0sIDpzZWxlY3RlZCkgKFRPRE8gbWVudWl0ZW0pXG5cdFx0Y2hlY2tlZDogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHRyZXR1cm4gYWRhcHRlci5oYXNBdHRyaWIoZWxlbSwgXCJjaGVja2VkXCIpIHx8IHBzZXVkb3Muc2VsZWN0ZWQoZWxlbSk7XG5cdFx0fSxcblx0XHQvLzptYXRjaGVzKGlucHV0LCBzZWxlY3QsIHRleHRhcmVhKVtyZXF1aXJlZF1cblx0XHRyZXF1aXJlZDogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHRyZXR1cm4gYWRhcHRlci5oYXNBdHRyaWIoZWxlbSwgXCJyZXF1aXJlZFwiKTtcblx0XHR9LFxuXHRcdC8vOm1hdGNoZXMoaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEpOm5vdChbcmVxdWlyZWRdKVxuXHRcdG9wdGlvbmFsOiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdHJldHVybiAhYWRhcHRlci5oYXNBdHRyaWIoZWxlbSwgXCJyZXF1aXJlZFwiKTtcblx0XHR9LFxuXG5cdFx0Ly9qUXVlcnkgZXh0ZW5zaW9uc1xuXG5cdFx0Ly86bm90KDplbXB0eSlcblx0XHRwYXJlbnQ6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0cmV0dXJuICFwc2V1ZG9zLmVtcHR5KGVsZW0pO1xuXHRcdH0sXG5cdFx0Ly86bWF0Y2hlcyhoMSwgaDIsIGgzLCBoNCwgaDUsIGg2KVxuXHRcdGhlYWRlcjogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHR2YXIgbmFtZSA9IGFkYXB0ZXIuZ2V0TmFtZShlbGVtKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImgxXCIgfHxcblx0XHRcdFx0XHRuYW1lID09PSBcImgyXCIgfHxcblx0XHRcdFx0XHRuYW1lID09PSBcImgzXCIgfHxcblx0XHRcdFx0XHRuYW1lID09PSBcImg0XCIgfHxcblx0XHRcdFx0XHRuYW1lID09PSBcImg1XCIgfHxcblx0XHRcdFx0XHRuYW1lID09PSBcImg2XCI7XG5cdFx0fSxcblxuXHRcdC8vOm1hdGNoZXMoYnV0dG9uLCBpbnB1dFt0eXBlPWJ1dHRvbl0pXG5cdFx0YnV0dG9uOiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdHZhciBuYW1lID0gYWRhcHRlci5nZXROYW1lKGVsZW0pO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiYnV0dG9uXCIgfHxcblx0XHRcdFx0XHRuYW1lID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0XHRhZGFwdGVyLmdldEF0dHJpYnV0ZVZhbHVlKGVsZW0sIFwidHlwZVwiKSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXHRcdC8vOm1hdGNoZXMoaW5wdXQsIHRleHRhcmVhLCBzZWxlY3QsIGJ1dHRvbilcblx0XHRpbnB1dDogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHR2YXIgbmFtZSA9IGFkYXB0ZXIuZ2V0TmFtZShlbGVtKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgfHxcblx0XHRcdFx0XHRuYW1lID09PSBcInRleHRhcmVhXCIgfHxcblx0XHRcdFx0XHRuYW1lID09PSBcInNlbGVjdFwiIHx8XG5cdFx0XHRcdFx0bmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXHRcdC8vaW5wdXQ6bWF0Y2hlcyg6bm90KFt0eXBlIT0nJ10pLCBbdHlwZT0ndGV4dCcgaV0pXG5cdFx0dGV4dDogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBhZGFwdGVyLmdldE5hbWUoZWxlbSkgPT09IFwiaW5wdXRcIiAmJiAoXG5cdFx0XHRcdCEoYXR0ciA9IGFkYXB0ZXIuZ2V0QXR0cmlidXRlVmFsdWUoZWxlbSwgXCJ0eXBlXCIpKSB8fFxuXHRcdFx0XHRhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiXG5cdFx0XHQpO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gcHNldWRvcztcbn1cblxuZnVuY3Rpb24gdmVyaWZ5QXJncyhmdW5jLCBuYW1lLCBzdWJzZWxlY3Qpe1xuXHRpZihzdWJzZWxlY3QgPT09IG51bGwpe1xuXHRcdGlmKGZ1bmMubGVuZ3RoID4gMSAmJiBuYW1lICE9PSBcInNjb3BlXCIpe1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwicHNldWRvLXNlbGVjdG9yIDpcIiArIG5hbWUgKyBcIiByZXF1aXJlcyBhbiBhcmd1bWVudFwiKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYoZnVuYy5sZW5ndGggPT09IDEpe1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwicHNldWRvLXNlbGVjdG9yIDpcIiArIG5hbWUgKyBcIiBkb2Vzbid0IGhhdmUgYW55IGFyZ3VtZW50c1wiKTtcblx0XHR9XG5cdH1cbn1cblxuLy9GSVhNRSB0aGlzIGZlZWxzIGhhY2t5XG52YXIgcmVfQ1NTMyA9IC9eKD86KD86bnRofGxhc3R8Zmlyc3R8b25seSktKD86Y2hpbGR8b2YtdHlwZSl8cm9vdHxlbXB0eXwoPzplbnxkaXMpYWJsZWR8Y2hlY2tlZHxub3QpJC87XG5cbmZ1bmN0aW9uIGZhY3RvcnkoYWRhcHRlcil7XG5cdHZhciBwc2V1ZG9zID0gcHNldWRvc0ZhY3RvcnkoYWRhcHRlcik7XG5cdHZhciBmaWx0ZXJzID0gZmlsdGVyc0ZhY3RvcnkoYWRhcHRlcik7XG5cblx0cmV0dXJuIHtcblx0XHRjb21waWxlOiBmdW5jdGlvbihuZXh0LCBkYXRhLCBvcHRpb25zLCBjb250ZXh0KXtcblx0XHRcdHZhciBuYW1lID0gZGF0YS5uYW1lLFxuXHRcdFx0XHRzdWJzZWxlY3QgPSBkYXRhLmRhdGE7XG5cblx0XHRcdGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5zdHJpY3QgJiYgIXJlX0NTUzMudGVzdChuYW1lKSl7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIjpcIiArIG5hbWUgKyBcIiBpc24ndCBwYXJ0IG9mIENTUzNcIik7XG5cdFx0XHR9XG5cblx0XHRcdGlmKHR5cGVvZiBmaWx0ZXJzW25hbWVdID09PSBcImZ1bmN0aW9uXCIpe1xuXHRcdFx0XHR2ZXJpZnlBcmdzKGZpbHRlcnNbbmFtZV0sIG5hbWUsICBzdWJzZWxlY3QpO1xuXHRcdFx0XHRyZXR1cm4gZmlsdGVyc1tuYW1lXShuZXh0LCBzdWJzZWxlY3QsIG9wdGlvbnMsIGNvbnRleHQpO1xuXHRcdFx0fSBlbHNlIGlmKHR5cGVvZiBwc2V1ZG9zW25hbWVdID09PSBcImZ1bmN0aW9uXCIpe1xuXHRcdFx0XHR2YXIgZnVuYyA9IHBzZXVkb3NbbmFtZV07XG5cdFx0XHRcdHZlcmlmeUFyZ3MoZnVuYywgbmFtZSwgc3Vic2VsZWN0KTtcblxuXHRcdFx0XHRpZihuZXh0ID09PSB0cnVlRnVuYykgcmV0dXJuIGZ1bmM7XG5cblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHBzZXVkb0FyZ3MoZWxlbSl7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmMoZWxlbSwgc3Vic2VsZWN0KSAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5tYXRjaGVkIHBzZXVkby1jbGFzcyA6XCIgKyBuYW1lKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGZpbHRlcnM6IGZpbHRlcnMsXG5cdFx0cHNldWRvczogcHNldWRvc1xuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHNvcnRCeVByb2NlZHVyZTtcblxuLypcblx0c29ydCB0aGUgcGFydHMgb2YgdGhlIHBhc3NlZCBzZWxlY3Rvcixcblx0YXMgdGhlcmUgaXMgcG90ZW50aWFsIGZvciBvcHRpbWl6YXRpb25cblx0KHNvbWUgdHlwZXMgb2Ygc2VsZWN0b3JzIGFyZSBmYXN0ZXIgdGhhbiBvdGhlcnMpXG4qL1xuXG52YXIgcHJvY2VkdXJlID0gcmVxdWlyZShcIi4vcHJvY2VkdXJlLmpzb25cIik7XG5cbnZhciBhdHRyaWJ1dGVzID0ge1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGV4aXN0czogMTAsXG5cdGVxdWFsczogOCxcblx0bm90OiA3LFxuXHRzdGFydDogNixcblx0ZW5kOiA2LFxuXHRhbnk6IDUsXG5cdGh5cGhlbjogNCxcblx0ZWxlbWVudDogNFxufTtcblxuZnVuY3Rpb24gc29ydEJ5UHJvY2VkdXJlKGFycil7XG5cdHZhciBwcm9jcyA9IGFyci5tYXAoZ2V0UHJvY2VkdXJlKTtcblx0Zm9yKHZhciBpID0gMTsgaSA8IGFyci5sZW5ndGg7IGkrKyl7XG5cdFx0dmFyIHByb2NOZXcgPSBwcm9jc1tpXTtcblxuXHRcdGlmKHByb2NOZXcgPCAwKSBjb250aW51ZTtcblxuXHRcdGZvcih2YXIgaiA9IGkgLSAxOyBqID49IDAgJiYgcHJvY05ldyA8IHByb2NzW2pdOyBqLS0pe1xuXHRcdFx0dmFyIHRva2VuID0gYXJyW2ogKyAxXTtcblx0XHRcdGFycltqICsgMV0gPSBhcnJbal07XG5cdFx0XHRhcnJbal0gPSB0b2tlbjtcblx0XHRcdHByb2NzW2ogKyAxXSA9IHByb2NzW2pdO1xuXHRcdFx0cHJvY3Nbal0gPSBwcm9jTmV3O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBnZXRQcm9jZWR1cmUodG9rZW4pe1xuXHR2YXIgcHJvYyA9IHByb2NlZHVyZVt0b2tlbi50eXBlXTtcblxuXHRpZihwcm9jID09PSBwcm9jZWR1cmUuYXR0cmlidXRlKXtcblx0XHRwcm9jID0gYXR0cmlidXRlc1t0b2tlbi5hY3Rpb25dO1xuXG5cdFx0aWYocHJvYyA9PT0gYXR0cmlidXRlcy5lcXVhbHMgJiYgdG9rZW4ubmFtZSA9PT0gXCJpZFwiKXtcblx0XHRcdC8vcHJlZmVyIElEIHNlbGVjdG9ycyAoZWcuICNJRClcblx0XHRcdHByb2MgPSA5O1xuXHRcdH1cblxuXHRcdGlmKHRva2VuLmlnbm9yZUNhc2Upe1xuXHRcdFx0Ly9pZ25vcmVDYXNlIGFkZHMgc29tZSBvdmVyaGVhZCwgcHJlZmVyIFwibm9ybWFsXCIgdG9rZW5cblx0XHRcdC8vdGhpcyBpcyBhIGJpbmFyeSBvcGVyYXRpb24sIHRvIGVuc3VyZSBpdCdzIHN0aWxsIGFuIGludFxuXHRcdFx0cHJvYyA+Pj0gMTtcblx0XHR9XG5cdH0gZWxzZSBpZihwcm9jID09PSBwcm9jZWR1cmUucHNldWRvKXtcblx0XHRpZighdG9rZW4uZGF0YSl7XG5cdFx0XHRwcm9jID0gMztcblx0XHR9IGVsc2UgaWYodG9rZW4ubmFtZSA9PT0gXCJoYXNcIiB8fCB0b2tlbi5uYW1lID09PSBcImNvbnRhaW5zXCIpe1xuXHRcdFx0cHJvYyA9IDA7IC8vZXhwZW5zaXZlIGluIGFueSBjYXNlXG5cdFx0fSBlbHNlIGlmKHRva2VuLm5hbWUgPT09IFwibWF0Y2hlc1wiIHx8IHRva2VuLm5hbWUgPT09IFwibm90XCIpe1xuXHRcdFx0cHJvYyA9IDA7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdG9rZW4uZGF0YS5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdC8vVE9ETyBiZXR0ZXIgaGFuZGxpbmcgb2YgY29tcGxleCBzZWxlY3RvcnNcblx0XHRcdFx0aWYodG9rZW4uZGF0YVtpXS5sZW5ndGggIT09IDEpIGNvbnRpbnVlO1xuXHRcdFx0XHR2YXIgY3VyID0gZ2V0UHJvY2VkdXJlKHRva2VuLmRhdGFbaV1bMF0pO1xuXHRcdFx0XHQvL2F2b2lkIGV4ZWN1dGluZyA6aGFzIG9yIDpjb250YWluc1xuXHRcdFx0XHRpZihjdXIgPT09IDApe1xuXHRcdFx0XHRcdHByb2MgPSAwO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGN1ciA+IHByb2MpIHByb2MgPSBjdXI7XG5cdFx0XHR9XG5cdFx0XHRpZih0b2tlbi5kYXRhLmxlbmd0aCA+IDEgJiYgcHJvYyA+IDApIHByb2MgLT0gMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvYyA9IDE7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBwcm9jO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2U7XG5cbnZhciByZV9uYW1lID0gL14oPzpcXFxcLnxbXFx3XFwtXFx1MDBjMC1cXHVGRkZGXSkrLyxcbiAgICByZV9lc2NhcGUgPSAvXFxcXChbXFxkYS1mXXsxLDZ9XFxzP3woXFxzKXwuKS9pZyxcbiAgICAvL21vZGlmaWVkIHZlcnNpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvYmxvYi9tYXN0ZXIvc3JjL3NpenpsZS5qcyNMODdcbiAgICByZV9hdHRyID0gL15cXHMqKCg/OlxcXFwufFtcXHdcXHUwMGMwLVxcdUZGRkZcXC1dKSspXFxzKig/OihcXFM/KT1cXHMqKD86KFsnXCJdKSguKj8pXFwzfCgjPyg/OlxcXFwufFtcXHdcXHUwMGMwLVxcdUZGRkZcXC1dKSopfCl8KVxccyooaSk/XFxdLztcblxudmFyIGFjdGlvblR5cGVzID0ge1xuXHRfX3Byb3RvX186IG51bGwsXG5cdFwidW5kZWZpbmVkXCI6IFwiZXhpc3RzXCIsXG5cdFwiXCI6ICBcImVxdWFsc1wiLFxuXHRcIn5cIjogXCJlbGVtZW50XCIsXG5cdFwiXlwiOiBcInN0YXJ0XCIsXG5cdFwiJFwiOiBcImVuZFwiLFxuXHRcIipcIjogXCJhbnlcIixcblx0XCIhXCI6IFwibm90XCIsXG5cdFwifFwiOiBcImh5cGhlblwiXG59O1xuXG52YXIgc2ltcGxlU2VsZWN0b3JzID0ge1xuXHRfX3Byb3RvX186IG51bGwsXG5cdFwiPlwiOiBcImNoaWxkXCIsXG5cdFwiPFwiOiBcInBhcmVudFwiLFxuXHRcIn5cIjogXCJzaWJsaW5nXCIsXG5cdFwiK1wiOiBcImFkamFjZW50XCJcbn07XG5cbnZhciBhdHRyaWJTZWxlY3RvcnMgPSB7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0XCIjXCI6IFtcImlkXCIsIFwiZXF1YWxzXCJdLFxuXHRcIi5cIjogW1wiY2xhc3NcIiwgXCJlbGVtZW50XCJdXG59O1xuXG4vL3BzZXVkb3MsIHdob3NlIGRhdGEtcHJvcGVydHkgaXMgcGFyc2VkIGFzIHdlbGxcbnZhciB1bnBhY2tQc2V1ZG9zID0ge1xuXHRfX3Byb3RvX186IG51bGwsXG5cdFwiaGFzXCI6IHRydWUsXG5cdFwibm90XCI6IHRydWUsXG5cdFwibWF0Y2hlc1wiOiB0cnVlXG59O1xuXG52YXIgc3RyaXBRdW90ZXNGcm9tUHNldWRvcyA9IHtcblx0X19wcm90b19fOiBudWxsLFxuXHRcImNvbnRhaW5zXCI6IHRydWUsXG5cdFwiaWNvbnRhaW5zXCI6IHRydWVcbn07XG5cbnZhciBxdW90ZXMgPSB7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0XCJcXFwiXCI6IHRydWUsXG5cdFwiJ1wiOiB0cnVlXG59O1xuXG4vL3VuZXNjYXBlIGZ1bmN0aW9uIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvYmxvYi9tYXN0ZXIvc3JjL3NpenpsZS5qcyNMMTM5XG5mdW5jdGlvbiBmdW5lc2NhcGUoIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHQvLyBTdXBwb3J0OiBGaXJlZm94XG5cdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0ZXNjYXBlZCA6XG5cdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdGhpZ2ggPCAwID9cblx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVDU1Moc3RyKXtcblx0cmV0dXJuIHN0ci5yZXBsYWNlKHJlX2VzY2FwZSwgZnVuZXNjYXBlKTtcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGMpe1xuXHRyZXR1cm4gYyA9PT0gXCIgXCIgfHwgYyA9PT0gXCJcXG5cIiB8fCBjID09PSBcIlxcdFwiIHx8IGMgPT09IFwiXFxmXCIgfHwgYyA9PT0gXCJcXHJcIjtcbn1cblxuZnVuY3Rpb24gcGFyc2Uoc2VsZWN0b3IsIG9wdGlvbnMpe1xuXHR2YXIgc3Vic2VsZWN0cyA9IFtdO1xuXG5cdHNlbGVjdG9yID0gcGFyc2VTZWxlY3RvcihzdWJzZWxlY3RzLCBzZWxlY3RvciArIFwiXCIsIG9wdGlvbnMpO1xuXG5cdGlmKHNlbGVjdG9yICE9PSBcIlwiKXtcblx0XHR0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJVbm1hdGNoZWQgc2VsZWN0b3I6IFwiICsgc2VsZWN0b3IpO1xuXHR9XG5cblx0cmV0dXJuIHN1YnNlbGVjdHM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2VsZWN0b3Ioc3Vic2VsZWN0cywgc2VsZWN0b3IsIG9wdGlvbnMpe1xuXHR2YXIgdG9rZW5zID0gW10sXG5cdFx0c2F3V1MgPSBmYWxzZSxcblx0XHRkYXRhLCBmaXJzdENoYXIsIG5hbWUsIHF1b3Q7XG5cblx0ZnVuY3Rpb24gZ2V0TmFtZSgpe1xuXHRcdHZhciBzdWIgPSBzZWxlY3Rvci5tYXRjaChyZV9uYW1lKVswXTtcblx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnN1YnN0cihzdWIubGVuZ3RoKTtcblx0XHRyZXR1cm4gdW5lc2NhcGVDU1Moc3ViKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHN0cmlwV2hpdGVzcGFjZShzdGFydCl7XG5cdFx0d2hpbGUoaXNXaGl0ZXNwYWNlKHNlbGVjdG9yLmNoYXJBdChzdGFydCkpKSBzdGFydCsrO1xuXHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc3Vic3RyKHN0YXJ0KTtcblx0fVxuXG5cdHN0cmlwV2hpdGVzcGFjZSgwKTtcblxuXHR3aGlsZShzZWxlY3RvciAhPT0gXCJcIil7XG5cdFx0Zmlyc3RDaGFyID0gc2VsZWN0b3IuY2hhckF0KDApO1xuXG5cdFx0aWYoaXNXaGl0ZXNwYWNlKGZpcnN0Q2hhcikpe1xuXHRcdFx0c2F3V1MgPSB0cnVlO1xuXHRcdFx0c3RyaXBXaGl0ZXNwYWNlKDEpO1xuXHRcdH0gZWxzZSBpZihmaXJzdENoYXIgaW4gc2ltcGxlU2VsZWN0b3JzKXtcblx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBzaW1wbGVTZWxlY3RvcnNbZmlyc3RDaGFyXX0pO1xuXHRcdFx0c2F3V1MgPSBmYWxzZTtcblxuXHRcdFx0c3RyaXBXaGl0ZXNwYWNlKDEpO1xuXHRcdH0gZWxzZSBpZihmaXJzdENoYXIgPT09IFwiLFwiKXtcblx0XHRcdGlmKHRva2Vucy5sZW5ndGggPT09IDApe1xuXHRcdFx0XHR0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJlbXB0eSBzdWItc2VsZWN0b3JcIik7XG5cdFx0XHR9XG5cdFx0XHRzdWJzZWxlY3RzLnB1c2godG9rZW5zKTtcblx0XHRcdHRva2VucyA9IFtdO1xuXHRcdFx0c2F3V1MgPSBmYWxzZTtcblx0XHRcdHN0cmlwV2hpdGVzcGFjZSgxKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYoc2F3V1Mpe1xuXHRcdFx0XHRpZih0b2tlbnMubGVuZ3RoID4gMCl7XG5cdFx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFwiZGVzY2VuZGFudFwifSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2F3V1MgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYoZmlyc3RDaGFyID09PSBcIipcIil7XG5cdFx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc3Vic3RyKDEpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogXCJ1bml2ZXJzYWxcIn0pO1xuXHRcdFx0fSBlbHNlIGlmKGZpcnN0Q2hhciBpbiBhdHRyaWJTZWxlY3RvcnMpe1xuXHRcdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnN1YnN0cigxKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHR5cGU6IFwiYXR0cmlidXRlXCIsXG5cdFx0XHRcdFx0bmFtZTogYXR0cmliU2VsZWN0b3JzW2ZpcnN0Q2hhcl1bMF0sXG5cdFx0XHRcdFx0YWN0aW9uOiBhdHRyaWJTZWxlY3RvcnNbZmlyc3RDaGFyXVsxXSxcblx0XHRcdFx0XHR2YWx1ZTogZ2V0TmFtZSgpLFxuXHRcdFx0XHRcdGlnbm9yZUNhc2U6IGZhbHNlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIGlmKGZpcnN0Q2hhciA9PT0gXCJbXCIpe1xuXHRcdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnN1YnN0cigxKTtcblx0XHRcdFx0ZGF0YSA9IHNlbGVjdG9yLm1hdGNoKHJlX2F0dHIpO1xuXHRcdFx0XHRpZighZGF0YSl7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IFN5bnRheEVycm9yKFwiTWFsZm9ybWVkIGF0dHJpYnV0ZSBzZWxlY3RvcjogXCIgKyBzZWxlY3Rvcik7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zdWJzdHIoZGF0YVswXS5sZW5ndGgpO1xuXHRcdFx0XHRuYW1lID0gdW5lc2NhcGVDU1MoZGF0YVsxXSk7XG5cblx0XHRcdFx0aWYoXG5cdFx0XHRcdFx0IW9wdGlvbnMgfHwgKFxuXHRcdFx0XHRcdFx0XCJsb3dlckNhc2VBdHRyaWJ1dGVOYW1lc1wiIGluIG9wdGlvbnMgP1xuXHRcdFx0XHRcdFx0XHRvcHRpb25zLmxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzIDpcblx0XHRcdFx0XHRcdFx0IW9wdGlvbnMueG1sTW9kZVxuXHRcdFx0XHRcdClcblx0XHRcdFx0KXtcblx0XHRcdFx0XHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHR5cGU6IFwiYXR0cmlidXRlXCIsXG5cdFx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0XHRhY3Rpb246IGFjdGlvblR5cGVzW2RhdGFbMl1dLFxuXHRcdFx0XHRcdHZhbHVlOiB1bmVzY2FwZUNTUyhkYXRhWzRdIHx8IGRhdGFbNV0gfHwgXCJcIiksXG5cdFx0XHRcdFx0aWdub3JlQ2FzZTogISFkYXRhWzZdXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHR9IGVsc2UgaWYoZmlyc3RDaGFyID09PSBcIjpcIil7XG5cdFx0XHRcdGlmKHNlbGVjdG9yLmNoYXJBdCgxKSA9PT0gXCI6XCIpe1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc3Vic3RyKDIpO1xuXHRcdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBcInBzZXVkby1lbGVtZW50XCIsIG5hbWU6IGdldE5hbWUoKS50b0xvd2VyQ2FzZSgpfSk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnN1YnN0cigxKTtcblxuXHRcdFx0XHRuYW1lID0gZ2V0TmFtZSgpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdGRhdGEgPSBudWxsO1xuXG5cdFx0XHRcdGlmKHNlbGVjdG9yLmNoYXJBdCgwKSA9PT0gXCIoXCIpe1xuXHRcdFx0XHRcdGlmKG5hbWUgaW4gdW5wYWNrUHNldWRvcyl7XG5cdFx0XHRcdFx0XHRxdW90ID0gc2VsZWN0b3IuY2hhckF0KDEpO1xuXHRcdFx0XHRcdFx0dmFyIHF1b3RlZCA9IHF1b3QgaW4gcXVvdGVzO1xuXG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnN1YnN0cihxdW90ZWQgKyAxKTtcblxuXHRcdFx0XHRcdFx0ZGF0YSA9IFtdO1xuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPSBwYXJzZVNlbGVjdG9yKGRhdGEsIHNlbGVjdG9yLCBvcHRpb25zKTtcblxuXHRcdFx0XHRcdFx0aWYocXVvdGVkKXtcblx0XHRcdFx0XHRcdFx0aWYoc2VsZWN0b3IuY2hhckF0KDApICE9PSBxdW90KXtcblx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJ1bm1hdGNoZWQgcXVvdGVzIGluIDpcIiArIG5hbWUpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc3Vic3RyKDEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmKHNlbGVjdG9yLmNoYXJBdCgwKSAhPT0gXCIpXCIpe1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJtaXNzaW5nIGNsb3NpbmcgcGFyZW50aGVzaXMgaW4gOlwiICsgbmFtZSArIFwiIFwiICsgc2VsZWN0b3IpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnN1YnN0cigxKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIHBvcyA9IDEsIGNvdW50ZXIgPSAxO1xuXG5cdFx0XHRcdFx0XHRmb3IoOyBjb3VudGVyID4gMCAmJiBwb3MgPCBzZWxlY3Rvci5sZW5ndGg7IHBvcysrKXtcblx0XHRcdFx0XHRcdFx0aWYoc2VsZWN0b3IuY2hhckF0KHBvcykgPT09IFwiKFwiKSBjb3VudGVyKys7XG5cdFx0XHRcdFx0XHRcdGVsc2UgaWYoc2VsZWN0b3IuY2hhckF0KHBvcykgPT09IFwiKVwiKSBjb3VudGVyLS07XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmKGNvdW50ZXIpe1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJwYXJlbnRoZXNpcyBub3QgbWF0Y2hlZFwiKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZGF0YSA9IHNlbGVjdG9yLnN1YnN0cigxLCBwb3MgLSAyKTtcblx0XHRcdFx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc3Vic3RyKHBvcyk7XG5cblx0XHRcdFx0XHRcdGlmKG5hbWUgaW4gc3RyaXBRdW90ZXNGcm9tUHNldWRvcyl7XG5cdFx0XHRcdFx0XHRcdHF1b3QgPSBkYXRhLmNoYXJBdCgwKTtcblxuXHRcdFx0XHRcdFx0XHRpZihxdW90ID09PSBkYXRhLnNsaWNlKC0xKSAmJiBxdW90IGluIHF1b3Rlcyl7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YSA9IGRhdGEuc2xpY2UoMSwgLTEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0ZGF0YSA9IHVuZXNjYXBlQ1NTKGRhdGEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBcInBzZXVkb1wiLCBuYW1lOiBuYW1lLCBkYXRhOiBkYXRhfSk7XG5cdFx0XHR9IGVsc2UgaWYocmVfbmFtZS50ZXN0KHNlbGVjdG9yKSl7XG5cdFx0XHRcdG5hbWUgPSBnZXROYW1lKCk7XG5cblx0XHRcdFx0aWYoIW9wdGlvbnMgfHwgKFwibG93ZXJDYXNlVGFnc1wiIGluIG9wdGlvbnMgPyBvcHRpb25zLmxvd2VyQ2FzZVRhZ3MgOiAhb3B0aW9ucy54bWxNb2RlKSl7XG5cdFx0XHRcdFx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBcInRhZ1wiLCBuYW1lOiBuYW1lfSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udHlwZSA9PT0gXCJkZXNjZW5kYW50XCIpe1xuXHRcdFx0XHRcdHRva2Vucy5wb3AoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhZGRUb2tlbihzdWJzZWxlY3RzLCB0b2tlbnMpO1xuXHRcdFx0XHRyZXR1cm4gc2VsZWN0b3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0YWRkVG9rZW4oc3Vic2VsZWN0cywgdG9rZW5zKTtcblxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZFRva2VuKHN1YnNlbGVjdHMsIHRva2Vucyl7XG5cdGlmKHN1YnNlbGVjdHMubGVuZ3RoID4gMCAmJiB0b2tlbnMubGVuZ3RoID09PSAwKXtcblx0XHR0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJlbXB0eSBzdWItc2VsZWN0b3JcIik7XG5cdH1cblxuXHRzdWJzZWxlY3RzLnB1c2godG9rZW5zKTtcbn1cbiIsIlxudmFyIE5hdGl2ZUN1c3RvbUV2ZW50ID0gZ2xvYmFsLkN1c3RvbUV2ZW50O1xuXG5mdW5jdGlvbiB1c2VOYXRpdmUgKCkge1xuICB0cnkge1xuICAgIHZhciBwID0gbmV3IE5hdGl2ZUN1c3RvbUV2ZW50KCdjYXQnLCB7IGRldGFpbDogeyBmb286ICdiYXInIH0gfSk7XG4gICAgcmV0dXJuICAnY2F0JyA9PT0gcC50eXBlICYmICdiYXInID09PSBwLmRldGFpbC5mb287XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ3Jvc3MtYnJvd3NlciBgQ3VzdG9tRXZlbnRgIGNvbnN0cnVjdG9yLlxuICpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC5DdXN0b21FdmVudFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVzZU5hdGl2ZSgpID8gTmF0aXZlQ3VzdG9tRXZlbnQgOlxuXG4vLyBJRSA+PSA5XG4nZnVuY3Rpb24nID09PSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPyBmdW5jdGlvbiBDdXN0b21FdmVudCAodHlwZSwgcGFyYW1zKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gIGlmIChwYXJhbXMpIHtcbiAgICBlLmluaXRDdXN0b21FdmVudCh0eXBlLCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICB9IGVsc2Uge1xuICAgIGUuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSwgdm9pZCAwKTtcbiAgfVxuICByZXR1cm4gZTtcbn0gOlxuXG4vLyBJRSA8PSA4XG5mdW5jdGlvbiBDdXN0b21FdmVudCAodHlwZSwgcGFyYW1zKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTtcbiAgZS50eXBlID0gdHlwZTtcbiAgaWYgKHBhcmFtcykge1xuICAgIGUuYnViYmxlcyA9IEJvb2xlYW4ocGFyYW1zLmJ1YmJsZXMpO1xuICAgIGUuY2FuY2VsYWJsZSA9IEJvb2xlYW4ocGFyYW1zLmNhbmNlbGFibGUpO1xuICAgIGUuZGV0YWlsID0gcGFyYW1zLmRldGFpbDtcbiAgfSBlbHNlIHtcbiAgICBlLmJ1YmJsZXMgPSBmYWxzZTtcbiAgICBlLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICBlLmRldGFpbCA9IHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZTtcbn1cbiIsIi8qXG4gIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiovXG52YXIgRWxlbWVudFR5cGUgPSByZXF1aXJlKCdkb21lbGVtZW50dHlwZScpO1xudmFyIGVudGl0aWVzID0gcmVxdWlyZSgnZW50aXRpZXMnKTtcblxuLypcbiAgQm9vbGVhbiBBdHRyaWJ1dGVzXG4qL1xudmFyIGJvb2xlYW5BdHRyaWJ1dGVzID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIGFsbG93ZnVsbHNjcmVlbjogdHJ1ZSxcbiAgYXN5bmM6IHRydWUsXG4gIGF1dG9mb2N1czogdHJ1ZSxcbiAgYXV0b3BsYXk6IHRydWUsXG4gIGNoZWNrZWQ6IHRydWUsXG4gIGNvbnRyb2xzOiB0cnVlLFxuICBkZWZhdWx0OiB0cnVlLFxuICBkZWZlcjogdHJ1ZSxcbiAgZGlzYWJsZWQ6IHRydWUsXG4gIGhpZGRlbjogdHJ1ZSxcbiAgaXNtYXA6IHRydWUsXG4gIGxvb3A6IHRydWUsXG4gIG11bHRpcGxlOiB0cnVlLFxuICBtdXRlZDogdHJ1ZSxcbiAgb3BlbjogdHJ1ZSxcbiAgcmVhZG9ubHk6IHRydWUsXG4gIHJlcXVpcmVkOiB0cnVlLFxuICByZXZlcnNlZDogdHJ1ZSxcbiAgc2NvcGVkOiB0cnVlLFxuICBzZWFtbGVzczogdHJ1ZSxcbiAgc2VsZWN0ZWQ6IHRydWUsXG4gIHR5cGVtdXN0bWF0Y2g6IHRydWVcbn07XG5cbnZhciB1bmVuY29kZWRFbGVtZW50cyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBzdHlsZTogdHJ1ZSxcbiAgc2NyaXB0OiB0cnVlLFxuICB4bXA6IHRydWUsXG4gIGlmcmFtZTogdHJ1ZSxcbiAgbm9lbWJlZDogdHJ1ZSxcbiAgbm9mcmFtZXM6IHRydWUsXG4gIHBsYWludGV4dDogdHJ1ZSxcbiAgbm9zY3JpcHQ6IHRydWVcbn07XG5cbi8qXG4gIEZvcm1hdCBhdHRyaWJ1dGVzXG4qL1xuZnVuY3Rpb24gZm9ybWF0QXR0cnMoYXR0cmlidXRlcywgb3B0cykge1xuICBpZiAoIWF0dHJpYnV0ZXMpIHJldHVybjtcblxuICB2YXIgb3V0cHV0ID0gJycsXG4gICAgICB2YWx1ZTtcblxuICAvLyBMb29wIHRocm91Z2ggdGhlIGF0dHJpYnV0ZXNcbiAgZm9yICh2YXIga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICB2YWx1ZSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICBpZiAob3V0cHV0KSB7XG4gICAgICBvdXRwdXQgKz0gJyAnO1xuICAgIH1cblxuICAgIGlmICghdmFsdWUgJiYgYm9vbGVhbkF0dHJpYnV0ZXNba2V5XSkge1xuICAgICAgb3V0cHV0ICs9IGtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ICs9IGtleSArICc9XCInICsgKG9wdHMuZGVjb2RlRW50aXRpZXMgPyBlbnRpdGllcy5lbmNvZGVYTUwodmFsdWUpIDogdmFsdWUpICsgJ1wiJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICBTZWxmLWVuY2xvc2luZyB0YWdzIChzdG9sZW4gZnJvbSBub2RlLWh0bWxwYXJzZXIpXG4qL1xudmFyIHNpbmdsZVRhZyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhcmVhOiB0cnVlLFxuICBiYXNlOiB0cnVlLFxuICBiYXNlZm9udDogdHJ1ZSxcbiAgYnI6IHRydWUsXG4gIGNvbDogdHJ1ZSxcbiAgY29tbWFuZDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsXG4gIGZyYW1lOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAgaXNpbmRleDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlLFxufTtcblxuXG52YXIgcmVuZGVyID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb20sIG9wdHMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGRvbSkgJiYgIWRvbS5jaGVlcmlvKSBkb20gPSBbZG9tXTtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIG91dHB1dCA9ICcnO1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBkb20ubGVuZ3RoOyBpKyspe1xuICAgIHZhciBlbGVtID0gZG9tW2ldO1xuXG4gICAgaWYgKGVsZW0udHlwZSA9PT0gJ3Jvb3QnKVxuICAgICAgb3V0cHV0ICs9IHJlbmRlcihlbGVtLmNoaWxkcmVuLCBvcHRzKTtcbiAgICBlbHNlIGlmIChFbGVtZW50VHlwZS5pc1RhZyhlbGVtKSlcbiAgICAgIG91dHB1dCArPSByZW5kZXJUYWcoZWxlbSwgb3B0cyk7XG4gICAgZWxzZSBpZiAoZWxlbS50eXBlID09PSBFbGVtZW50VHlwZS5EaXJlY3RpdmUpXG4gICAgICBvdXRwdXQgKz0gcmVuZGVyRGlyZWN0aXZlKGVsZW0pO1xuICAgIGVsc2UgaWYgKGVsZW0udHlwZSA9PT0gRWxlbWVudFR5cGUuQ29tbWVudClcbiAgICAgIG91dHB1dCArPSByZW5kZXJDb21tZW50KGVsZW0pO1xuICAgIGVsc2UgaWYgKGVsZW0udHlwZSA9PT0gRWxlbWVudFR5cGUuQ0RBVEEpXG4gICAgICBvdXRwdXQgKz0gcmVuZGVyQ2RhdGEoZWxlbSk7XG4gICAgZWxzZVxuICAgICAgb3V0cHV0ICs9IHJlbmRlclRleHQoZWxlbSwgb3B0cyk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuZnVuY3Rpb24gcmVuZGVyVGFnKGVsZW0sIG9wdHMpIHtcbiAgLy8gSGFuZGxlIFNWR1xuICBpZiAoZWxlbS5uYW1lID09PSBcInN2Z1wiKSBvcHRzID0ge2RlY29kZUVudGl0aWVzOiBvcHRzLmRlY29kZUVudGl0aWVzLCB4bWxNb2RlOiB0cnVlfTtcblxuICB2YXIgdGFnID0gJzwnICsgZWxlbS5uYW1lLFxuICAgICAgYXR0cmlicyA9IGZvcm1hdEF0dHJzKGVsZW0uYXR0cmlicywgb3B0cyk7XG5cbiAgaWYgKGF0dHJpYnMpIHtcbiAgICB0YWcgKz0gJyAnICsgYXR0cmlicztcbiAgfVxuXG4gIGlmIChcbiAgICBvcHRzLnhtbE1vZGVcbiAgICAmJiAoIWVsZW0uY2hpbGRyZW4gfHwgZWxlbS5jaGlsZHJlbi5sZW5ndGggPT09IDApXG4gICkge1xuICAgIHRhZyArPSAnLz4nO1xuICB9IGVsc2Uge1xuICAgIHRhZyArPSAnPic7XG4gICAgaWYgKGVsZW0uY2hpbGRyZW4pIHtcbiAgICAgIHRhZyArPSByZW5kZXIoZWxlbS5jaGlsZHJlbiwgb3B0cyk7XG4gICAgfVxuXG4gICAgaWYgKCFzaW5nbGVUYWdbZWxlbS5uYW1lXSB8fCBvcHRzLnhtbE1vZGUpIHtcbiAgICAgIHRhZyArPSAnPC8nICsgZWxlbS5uYW1lICsgJz4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YWc7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckRpcmVjdGl2ZShlbGVtKSB7XG4gIHJldHVybiAnPCcgKyBlbGVtLmRhdGEgKyAnPic7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclRleHQoZWxlbSwgb3B0cykge1xuICB2YXIgZGF0YSA9IGVsZW0uZGF0YSB8fCAnJztcblxuICAvLyBpZiBlbnRpdGllcyB3ZXJlbid0IGRlY29kZWQsIG5vIG5lZWQgdG8gZW5jb2RlIHRoZW0gYmFja1xuICBpZiAob3B0cy5kZWNvZGVFbnRpdGllcyAmJiAhKGVsZW0ucGFyZW50ICYmIGVsZW0ucGFyZW50Lm5hbWUgaW4gdW5lbmNvZGVkRWxlbWVudHMpKSB7XG4gICAgZGF0YSA9IGVudGl0aWVzLmVuY29kZVhNTChkYXRhKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiByZW5kZXJDZGF0YShlbGVtKSB7XG4gIHJldHVybiAnPCFbQ0RBVEFbJyArIGVsZW0uY2hpbGRyZW5bMF0uZGF0YSArICddXT4nO1xufVxuXG5mdW5jdGlvbiByZW5kZXJDb21tZW50KGVsZW0pIHtcbiAgcmV0dXJuICc8IS0tJyArIGVsZW0uZGF0YSArICctLT4nO1xufVxuIiwiLy9UeXBlcyBvZiBlbGVtZW50cyBmb3VuZCBpbiB0aGUgRE9NXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0VGV4dDogXCJ0ZXh0XCIsIC8vVGV4dFxuXHREaXJlY3RpdmU6IFwiZGlyZWN0aXZlXCIsIC8vPD8gLi4uID8+XG5cdENvbW1lbnQ6IFwiY29tbWVudFwiLCAvLzwhLS0gLi4uIC0tPlxuXHRTY3JpcHQ6IFwic2NyaXB0XCIsIC8vPHNjcmlwdD4gdGFnc1xuXHRTdHlsZTogXCJzdHlsZVwiLCAvLzxzdHlsZT4gdGFnc1xuXHRUYWc6IFwidGFnXCIsIC8vQW55IHRhZ1xuXHRDREFUQTogXCJjZGF0YVwiLCAvLzwhW0NEQVRBWyAuLi4gXV0+XG5cblx0aXNUYWc6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdHJldHVybiBlbGVtLnR5cGUgPT09IFwidGFnXCIgfHwgZWxlbS50eXBlID09PSBcInNjcmlwdFwiIHx8IGVsZW0udHlwZSA9PT0gXCJzdHlsZVwiO1xuXHR9XG59OyIsIi8vVHlwZXMgb2YgZWxlbWVudHMgZm91bmQgaW4gdGhlIERPTVxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdFRleHQ6IFwidGV4dFwiLCAvL1RleHRcblx0RGlyZWN0aXZlOiBcImRpcmVjdGl2ZVwiLCAvLzw/IC4uLiA/PlxuXHRDb21tZW50OiBcImNvbW1lbnRcIiwgLy88IS0tIC4uLiAtLT5cblx0U2NyaXB0OiBcInNjcmlwdFwiLCAvLzxzY3JpcHQ+IHRhZ3Ncblx0U3R5bGU6IFwic3R5bGVcIiwgLy88c3R5bGU+IHRhZ3Ncblx0VGFnOiBcInRhZ1wiLCAvL0FueSB0YWdcblx0Q0RBVEE6IFwiY2RhdGFcIiwgLy88IVtDREFUQVsgLi4uIF1dPlxuXHREb2N0eXBlOiBcImRvY3R5cGVcIixcblxuXHRpc1RhZzogZnVuY3Rpb24oZWxlbSl7XG5cdFx0cmV0dXJuIGVsZW0udHlwZSA9PT0gXCJ0YWdcIiB8fCBlbGVtLnR5cGUgPT09IFwic2NyaXB0XCIgfHwgZWxlbS50eXBlID09PSBcInN0eWxlXCI7XG5cdH1cbn07XG4iLCJ2YXIgRWxlbWVudFR5cGUgPSByZXF1aXJlKFwiZG9tZWxlbWVudHR5cGVcIik7XG5cbnZhciByZV93aGl0ZXNwYWNlID0gL1xccysvZztcbnZhciBOb2RlUHJvdG90eXBlID0gcmVxdWlyZShcIi4vbGliL25vZGVcIik7XG52YXIgRWxlbWVudFByb3RvdHlwZSA9IHJlcXVpcmUoXCIuL2xpYi9lbGVtZW50XCIpO1xuXG5mdW5jdGlvbiBEb21IYW5kbGVyKGNhbGxiYWNrLCBvcHRpb25zLCBlbGVtZW50Q0Ipe1xuXHRpZih0eXBlb2YgY2FsbGJhY2sgPT09IFwib2JqZWN0XCIpe1xuXHRcdGVsZW1lbnRDQiA9IG9wdGlvbnM7XG5cdFx0b3B0aW9ucyA9IGNhbGxiYWNrO1xuXHRcdGNhbGxiYWNrID0gbnVsbDtcblx0fSBlbHNlIGlmKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpe1xuXHRcdGVsZW1lbnRDQiA9IG9wdGlvbnM7XG5cdFx0b3B0aW9ucyA9IGRlZmF1bHRPcHRzO1xuXHR9XG5cdHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG5cdHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRPcHRzO1xuXHR0aGlzLl9lbGVtZW50Q0IgPSBlbGVtZW50Q0I7XG5cdHRoaXMuZG9tID0gW107XG5cdHRoaXMuX2RvbmUgPSBmYWxzZTtcblx0dGhpcy5fdGFnU3RhY2sgPSBbXTtcblx0dGhpcy5fcGFyc2VyID0gdGhpcy5fcGFyc2VyIHx8IG51bGw7XG59XG5cbi8vZGVmYXVsdCBvcHRpb25zXG52YXIgZGVmYXVsdE9wdHMgPSB7XG5cdG5vcm1hbGl6ZVdoaXRlc3BhY2U6IGZhbHNlLCAvL1JlcGxhY2UgYWxsIHdoaXRlc3BhY2Ugd2l0aCBzaW5nbGUgc3BhY2VzXG5cdHdpdGhTdGFydEluZGljZXM6IGZhbHNlLCAvL0FkZCBzdGFydEluZGV4IHByb3BlcnRpZXMgdG8gbm9kZXNcbn07XG5cbkRvbUhhbmRsZXIucHJvdG90eXBlLm9ucGFyc2VyaW5pdCA9IGZ1bmN0aW9uKHBhcnNlcil7XG5cdHRoaXMuX3BhcnNlciA9IHBhcnNlcjtcbn07XG5cbi8vUmVzZXRzIHRoZSBoYW5kbGVyIGJhY2sgdG8gc3RhcnRpbmcgc3RhdGVcbkRvbUhhbmRsZXIucHJvdG90eXBlLm9ucmVzZXQgPSBmdW5jdGlvbigpe1xuXHREb21IYW5kbGVyLmNhbGwodGhpcywgdGhpcy5fY2FsbGJhY2ssIHRoaXMuX29wdGlvbnMsIHRoaXMuX2VsZW1lbnRDQik7XG59O1xuXG4vL1NpZ25hbHMgdGhlIGhhbmRsZXIgdGhhdCBwYXJzaW5nIGlzIGRvbmVcbkRvbUhhbmRsZXIucHJvdG90eXBlLm9uZW5kID0gZnVuY3Rpb24oKXtcblx0aWYodGhpcy5fZG9uZSkgcmV0dXJuO1xuXHR0aGlzLl9kb25lID0gdHJ1ZTtcblx0dGhpcy5fcGFyc2VyID0gbnVsbDtcblx0dGhpcy5faGFuZGxlQ2FsbGJhY2sobnVsbCk7XG59O1xuXG5Eb21IYW5kbGVyLnByb3RvdHlwZS5faGFuZGxlQ2FsbGJhY2sgPVxuRG9tSGFuZGxlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uKGVycm9yKXtcblx0aWYodHlwZW9mIHRoaXMuX2NhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpe1xuXHRcdHRoaXMuX2NhbGxiYWNrKGVycm9yLCB0aGlzLmRvbSk7XG5cdH0gZWxzZSB7XG5cdFx0aWYoZXJyb3IpIHRocm93IGVycm9yO1xuXHR9XG59O1xuXG5Eb21IYW5kbGVyLnByb3RvdHlwZS5vbmNsb3NldGFnID0gZnVuY3Rpb24oKXtcblx0Ly9pZih0aGlzLl90YWdTdGFjay5wb3AoKS5uYW1lICE9PSBuYW1lKSB0aGlzLl9oYW5kbGVDYWxsYmFjayhFcnJvcihcIlRhZ25hbWUgZGlkbid0IG1hdGNoIVwiKSk7XG5cdHZhciBlbGVtID0gdGhpcy5fdGFnU3RhY2sucG9wKCk7XG5cdGlmKHRoaXMuX2VsZW1lbnRDQikgdGhpcy5fZWxlbWVudENCKGVsZW0pO1xufTtcblxuRG9tSGFuZGxlci5wcm90b3R5cGUuX2FkZERvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50KXtcblx0dmFyIHBhcmVudCA9IHRoaXMuX3RhZ1N0YWNrW3RoaXMuX3RhZ1N0YWNrLmxlbmd0aCAtIDFdO1xuXHR2YXIgc2libGluZ3MgPSBwYXJlbnQgPyBwYXJlbnQuY2hpbGRyZW4gOiB0aGlzLmRvbTtcblx0dmFyIHByZXZpb3VzU2libGluZyA9IHNpYmxpbmdzW3NpYmxpbmdzLmxlbmd0aCAtIDFdO1xuXG5cdGVsZW1lbnQubmV4dCA9IG51bGw7XG5cblx0aWYodGhpcy5fb3B0aW9ucy53aXRoU3RhcnRJbmRpY2VzKXtcblx0XHRlbGVtZW50LnN0YXJ0SW5kZXggPSB0aGlzLl9wYXJzZXIuc3RhcnRJbmRleDtcblx0fVxuXG5cdGlmICh0aGlzLl9vcHRpb25zLndpdGhEb21MdmwxKSB7XG5cdFx0ZWxlbWVudC5fX3Byb3RvX18gPSBlbGVtZW50LnR5cGUgPT09IFwidGFnXCIgPyBFbGVtZW50UHJvdG90eXBlIDogTm9kZVByb3RvdHlwZTtcblx0fVxuXG5cdGlmKHByZXZpb3VzU2libGluZyl7XG5cdFx0ZWxlbWVudC5wcmV2ID0gcHJldmlvdXNTaWJsaW5nO1xuXHRcdHByZXZpb3VzU2libGluZy5uZXh0ID0gZWxlbWVudDtcblx0fSBlbHNlIHtcblx0XHRlbGVtZW50LnByZXYgPSBudWxsO1xuXHR9XG5cblx0c2libGluZ3MucHVzaChlbGVtZW50KTtcblx0ZWxlbWVudC5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcbn07XG5cbkRvbUhhbmRsZXIucHJvdG90eXBlLm9ub3BlbnRhZyA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnMpe1xuXHR2YXIgZWxlbWVudCA9IHtcblx0XHR0eXBlOiBuYW1lID09PSBcInNjcmlwdFwiID8gRWxlbWVudFR5cGUuU2NyaXB0IDogbmFtZSA9PT0gXCJzdHlsZVwiID8gRWxlbWVudFR5cGUuU3R5bGUgOiBFbGVtZW50VHlwZS5UYWcsXG5cdFx0bmFtZTogbmFtZSxcblx0XHRhdHRyaWJzOiBhdHRyaWJzLFxuXHRcdGNoaWxkcmVuOiBbXVxuXHR9O1xuXG5cdHRoaXMuX2FkZERvbUVsZW1lbnQoZWxlbWVudCk7XG5cblx0dGhpcy5fdGFnU3RhY2sucHVzaChlbGVtZW50KTtcbn07XG5cbkRvbUhhbmRsZXIucHJvdG90eXBlLm9udGV4dCA9IGZ1bmN0aW9uKGRhdGEpe1xuXHQvL3RoZSBpZ25vcmVXaGl0ZXNwYWNlIGlzIG9mZmljaWFsbHkgZHJvcHBlZCwgYnV0IGZvciBub3csXG5cdC8vaXQncyBhbiBhbGlhcyBmb3Igbm9ybWFsaXplV2hpdGVzcGFjZVxuXHR2YXIgbm9ybWFsaXplID0gdGhpcy5fb3B0aW9ucy5ub3JtYWxpemVXaGl0ZXNwYWNlIHx8IHRoaXMuX29wdGlvbnMuaWdub3JlV2hpdGVzcGFjZTtcblxuXHR2YXIgbGFzdFRhZztcblxuXHRpZighdGhpcy5fdGFnU3RhY2subGVuZ3RoICYmIHRoaXMuZG9tLmxlbmd0aCAmJiAobGFzdFRhZyA9IHRoaXMuZG9tW3RoaXMuZG9tLmxlbmd0aC0xXSkudHlwZSA9PT0gRWxlbWVudFR5cGUuVGV4dCl7XG5cdFx0aWYobm9ybWFsaXplKXtcblx0XHRcdGxhc3RUYWcuZGF0YSA9IChsYXN0VGFnLmRhdGEgKyBkYXRhKS5yZXBsYWNlKHJlX3doaXRlc3BhY2UsIFwiIFwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGFzdFRhZy5kYXRhICs9IGRhdGE7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmKFxuXHRcdFx0dGhpcy5fdGFnU3RhY2subGVuZ3RoICYmXG5cdFx0XHQobGFzdFRhZyA9IHRoaXMuX3RhZ1N0YWNrW3RoaXMuX3RhZ1N0YWNrLmxlbmd0aCAtIDFdKSAmJlxuXHRcdFx0KGxhc3RUYWcgPSBsYXN0VGFnLmNoaWxkcmVuW2xhc3RUYWcuY2hpbGRyZW4ubGVuZ3RoIC0gMV0pICYmXG5cdFx0XHRsYXN0VGFnLnR5cGUgPT09IEVsZW1lbnRUeXBlLlRleHRcblx0XHQpe1xuXHRcdFx0aWYobm9ybWFsaXplKXtcblx0XHRcdFx0bGFzdFRhZy5kYXRhID0gKGxhc3RUYWcuZGF0YSArIGRhdGEpLnJlcGxhY2UocmVfd2hpdGVzcGFjZSwgXCIgXCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGFzdFRhZy5kYXRhICs9IGRhdGE7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmKG5vcm1hbGl6ZSl7XG5cdFx0XHRcdGRhdGEgPSBkYXRhLnJlcGxhY2UocmVfd2hpdGVzcGFjZSwgXCIgXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9hZGREb21FbGVtZW50KHtcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0dHlwZTogRWxlbWVudFR5cGUuVGV4dFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59O1xuXG5Eb21IYW5kbGVyLnByb3RvdHlwZS5vbmNvbW1lbnQgPSBmdW5jdGlvbihkYXRhKXtcblx0dmFyIGxhc3RUYWcgPSB0aGlzLl90YWdTdGFja1t0aGlzLl90YWdTdGFjay5sZW5ndGggLSAxXTtcblxuXHRpZihsYXN0VGFnICYmIGxhc3RUYWcudHlwZSA9PT0gRWxlbWVudFR5cGUuQ29tbWVudCl7XG5cdFx0bGFzdFRhZy5kYXRhICs9IGRhdGE7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIGVsZW1lbnQgPSB7XG5cdFx0ZGF0YTogZGF0YSxcblx0XHR0eXBlOiBFbGVtZW50VHlwZS5Db21tZW50XG5cdH07XG5cblx0dGhpcy5fYWRkRG9tRWxlbWVudChlbGVtZW50KTtcblx0dGhpcy5fdGFnU3RhY2sucHVzaChlbGVtZW50KTtcbn07XG5cbkRvbUhhbmRsZXIucHJvdG90eXBlLm9uY2RhdGFzdGFydCA9IGZ1bmN0aW9uKCl7XG5cdHZhciBlbGVtZW50ID0ge1xuXHRcdGNoaWxkcmVuOiBbe1xuXHRcdFx0ZGF0YTogXCJcIixcblx0XHRcdHR5cGU6IEVsZW1lbnRUeXBlLlRleHRcblx0XHR9XSxcblx0XHR0eXBlOiBFbGVtZW50VHlwZS5DREFUQVxuXHR9O1xuXG5cdHRoaXMuX2FkZERvbUVsZW1lbnQoZWxlbWVudCk7XG5cdHRoaXMuX3RhZ1N0YWNrLnB1c2goZWxlbWVudCk7XG59O1xuXG5Eb21IYW5kbGVyLnByb3RvdHlwZS5vbmNvbW1lbnRlbmQgPSBEb21IYW5kbGVyLnByb3RvdHlwZS5vbmNkYXRhZW5kID0gZnVuY3Rpb24oKXtcblx0dGhpcy5fdGFnU3RhY2sucG9wKCk7XG59O1xuXG5Eb21IYW5kbGVyLnByb3RvdHlwZS5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEpe1xuXHR0aGlzLl9hZGREb21FbGVtZW50KHtcblx0XHRuYW1lOiBuYW1lLFxuXHRcdGRhdGE6IGRhdGEsXG5cdFx0dHlwZTogRWxlbWVudFR5cGUuRGlyZWN0aXZlXG5cdH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEb21IYW5kbGVyO1xuIiwiLy8gRE9NLUxldmVsLTEtY29tcGxpYW50IHN0cnVjdHVyZVxudmFyIE5vZGVQcm90b3R5cGUgPSByZXF1aXJlKCcuL25vZGUnKTtcbnZhciBFbGVtZW50UHJvdG90eXBlID0gbW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlKE5vZGVQcm90b3R5cGUpO1xuXG52YXIgZG9tTHZsMSA9IHtcblx0dGFnTmFtZTogXCJuYW1lXCJcbn07XG5cbk9iamVjdC5rZXlzKGRvbUx2bDEpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdHZhciBzaG9ydGhhbmQgPSBkb21MdmwxW2tleV07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbGVtZW50UHJvdG90eXBlLCBrZXksIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXNbc2hvcnRoYW5kXSB8fCBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbih2YWwpIHtcblx0XHRcdHRoaXNbc2hvcnRoYW5kXSA9IHZhbDtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHR9KTtcbn0pO1xuIiwiLy8gVGhpcyBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIHRoZSBwcm90b3R5cGUgZm9yIE5vZGVzIHdoZW4gY3JlYXRpbmcgYVxuLy8gRE9NLUxldmVsLTEtY29tcGxpYW50IHN0cnVjdHVyZS5cbnZhciBOb2RlUHJvdG90eXBlID0gbW9kdWxlLmV4cG9ydHMgPSB7XG5cdGdldCBmaXJzdENoaWxkKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cdFx0cmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuWzBdIHx8IG51bGw7XG5cdH0sXG5cdGdldCBsYXN0Q2hpbGQoKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblx0XHRyZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0gfHwgbnVsbDtcblx0fSxcblx0Z2V0IG5vZGVUeXBlKCkge1xuXHRcdHJldHVybiBub2RlVHlwZXNbdGhpcy50eXBlXSB8fCBub2RlVHlwZXMuZWxlbWVudDtcblx0fVxufTtcblxudmFyIGRvbUx2bDEgPSB7XG5cdHRhZ05hbWU6IFwibmFtZVwiLFxuXHRjaGlsZE5vZGVzOiBcImNoaWxkcmVuXCIsXG5cdHBhcmVudE5vZGU6IFwicGFyZW50XCIsXG5cdHByZXZpb3VzU2libGluZzogXCJwcmV2XCIsXG5cdG5leHRTaWJsaW5nOiBcIm5leHRcIixcblx0bm9kZVZhbHVlOiBcImRhdGFcIlxufTtcblxudmFyIG5vZGVUeXBlcyA9IHtcblx0ZWxlbWVudDogMSxcblx0dGV4dDogMyxcblx0Y2RhdGE6IDQsXG5cdGNvbW1lbnQ6IDhcbn07XG5cbk9iamVjdC5rZXlzKGRvbUx2bDEpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdHZhciBzaG9ydGhhbmQgPSBkb21MdmwxW2tleV07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlUHJvdG90eXBlLCBrZXksIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXNbc2hvcnRoYW5kXSB8fCBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbih2YWwpIHtcblx0XHRcdHRoaXNbc2hvcnRoYW5kXSA9IHZhbDtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHR9KTtcbn0pO1xuIiwidmFyIERvbVV0aWxzID0gbW9kdWxlLmV4cG9ydHM7XG5cbltcblx0cmVxdWlyZShcIi4vbGliL3N0cmluZ2lmeVwiKSxcblx0cmVxdWlyZShcIi4vbGliL3RyYXZlcnNhbFwiKSxcblx0cmVxdWlyZShcIi4vbGliL21hbmlwdWxhdGlvblwiKSxcblx0cmVxdWlyZShcIi4vbGliL3F1ZXJ5aW5nXCIpLFxuXHRyZXF1aXJlKFwiLi9saWIvbGVnYWN5XCIpLFxuXHRyZXF1aXJlKFwiLi9saWIvaGVscGVyc1wiKVxuXS5mb3JFYWNoKGZ1bmN0aW9uKGV4dCl7XG5cdE9iamVjdC5rZXlzKGV4dCkuZm9yRWFjaChmdW5jdGlvbihrZXkpe1xuXHRcdERvbVV0aWxzW2tleV0gPSBleHRba2V5XS5iaW5kKERvbVV0aWxzKTtcblx0fSk7XG59KTtcbiIsIi8vIHJlbW92ZVN1YnNldHNcbi8vIEdpdmVuIGFuIGFycmF5IG9mIG5vZGVzLCByZW1vdmUgYW55IG1lbWJlciB0aGF0IGlzIGNvbnRhaW5lZCBieSBhbm90aGVyLlxuZXhwb3J0cy5yZW1vdmVTdWJzZXRzID0gZnVuY3Rpb24obm9kZXMpIHtcblx0dmFyIGlkeCA9IG5vZGVzLmxlbmd0aCwgbm9kZSwgYW5jZXN0b3IsIHJlcGxhY2U7XG5cblx0Ly8gQ2hlY2sgaWYgZWFjaCBub2RlIChvciBvbmUgb2YgaXRzIGFuY2VzdG9ycykgaXMgYWxyZWFkeSBjb250YWluZWQgaW4gdGhlXG5cdC8vIGFycmF5LlxuXHR3aGlsZSAoLS1pZHggPiAtMSkge1xuXHRcdG5vZGUgPSBhbmNlc3RvciA9IG5vZGVzW2lkeF07XG5cblx0XHQvLyBUZW1wb3JhcmlseSByZW1vdmUgdGhlIG5vZGUgdW5kZXIgY29uc2lkZXJhdGlvblxuXHRcdG5vZGVzW2lkeF0gPSBudWxsO1xuXHRcdHJlcGxhY2UgPSB0cnVlO1xuXG5cdFx0d2hpbGUgKGFuY2VzdG9yKSB7XG5cdFx0XHRpZiAobm9kZXMuaW5kZXhPZihhbmNlc3RvcikgPiAtMSkge1xuXHRcdFx0XHRyZXBsYWNlID0gZmFsc2U7XG5cdFx0XHRcdG5vZGVzLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBub2RlIGhhcyBiZWVuIGZvdW5kIHRvIGJlIHVuaXF1ZSwgcmUtaW5zZXJ0IGl0LlxuXHRcdGlmIChyZXBsYWNlKSB7XG5cdFx0XHRub2Rlc1tpZHhdID0gbm9kZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbm9kZXM7XG59O1xuXG4vLyBTb3VyY2U6IGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tbm9kZS1jb21wYXJlZG9jdW1lbnRwb3NpdGlvblxudmFyIFBPU0lUSU9OID0ge1xuXHRESVNDT05ORUNURUQ6IDEsXG5cdFBSRUNFRElORzogMixcblx0Rk9MTE9XSU5HOiA0LFxuXHRDT05UQUlOUzogOCxcblx0Q09OVEFJTkVEX0JZOiAxNlxufTtcblxuLy8gQ29tcGFyZSB0aGUgcG9zaXRpb24gb2Ygb25lIG5vZGUgYWdhaW5zdCBhbm90aGVyIG5vZGUgaW4gYW55IG90aGVyIGRvY3VtZW50LlxuLy8gVGhlIHJldHVybiB2YWx1ZSBpcyBhIGJpdG1hc2sgd2l0aCB0aGUgZm9sbG93aW5nIHZhbHVlczpcbi8vXG4vLyBkb2N1bWVudCBvcmRlcjpcbi8vID4gVGhlcmUgaXMgYW4gb3JkZXJpbmcsIGRvY3VtZW50IG9yZGVyLCBkZWZpbmVkIG9uIGFsbCB0aGUgbm9kZXMgaW4gdGhlXG4vLyA+IGRvY3VtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9yZGVyIGluIHdoaWNoIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlXG4vLyA+IFhNTCByZXByZXNlbnRhdGlvbiBvZiBlYWNoIG5vZGUgb2NjdXJzIGluIHRoZSBYTUwgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4vLyA+IGRvY3VtZW50IGFmdGVyIGV4cGFuc2lvbiBvZiBnZW5lcmFsIGVudGl0aWVzLiBUaHVzLCB0aGUgZG9jdW1lbnQgZWxlbWVudFxuLy8gPiBub2RlIHdpbGwgYmUgdGhlIGZpcnN0IG5vZGUuIEVsZW1lbnQgbm9kZXMgb2NjdXIgYmVmb3JlIHRoZWlyIGNoaWxkcmVuLlxuLy8gPiBUaHVzLCBkb2N1bWVudCBvcmRlciBvcmRlcnMgZWxlbWVudCBub2RlcyBpbiBvcmRlciBvZiB0aGUgb2NjdXJyZW5jZSBvZlxuLy8gPiB0aGVpciBzdGFydC10YWcgaW4gdGhlIFhNTCAoYWZ0ZXIgZXhwYW5zaW9uIG9mIGVudGl0aWVzKS4gVGhlIGF0dHJpYnV0ZVxuLy8gPiBub2RlcyBvZiBhbiBlbGVtZW50IG9jY3VyIGFmdGVyIHRoZSBlbGVtZW50IGFuZCBiZWZvcmUgaXRzIGNoaWxkcmVuLiBUaGVcbi8vID4gcmVsYXRpdmUgb3JkZXIgb2YgYXR0cmlidXRlIG5vZGVzIGlzIGltcGxlbWVudGF0aW9uLWRlcGVuZGVudC4vXG4vLyBTb3VyY2U6XG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1Db3JlL2dsb3NzYXJ5Lmh0bWwjZHQtZG9jdW1lbnQtb3JkZXJcbi8vXG4vLyBAYXJndW1lbnQge05vZGV9IG5vZGFBIFRoZSBmaXJzdCBub2RlIHRvIHVzZSBpbiB0aGUgY29tcGFyaXNvblxuLy8gQGFyZ3VtZW50IHtOb2RlfSBub2RlQiBUaGUgc2Vjb25kIG5vZGUgdG8gdXNlIGluIHRoZSBjb21wYXJpc29uXG4vL1xuLy8gQHJldHVybiB7TnVtYmVyfSBBIGJpdG1hc2sgZGVzY3JpYmluZyB0aGUgaW5wdXQgbm9kZXMnIHJlbGF0aXZlIHBvc2l0aW9uLlxuLy8gICAgICAgICBTZWUgaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ub2RlLWNvbXBhcmVkb2N1bWVudHBvc2l0aW9uIGZvclxuLy8gICAgICAgICBhIGRlc2NyaXB0aW9uIG9mIHRoZXNlIHZhbHVlcy5cbnZhciBjb21wYXJlUG9zID0gZXhwb3J0cy5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA9IGZ1bmN0aW9uKG5vZGVBLCBub2RlQikge1xuXHR2YXIgYVBhcmVudHMgPSBbXTtcblx0dmFyIGJQYXJlbnRzID0gW107XG5cdHZhciBjdXJyZW50LCBzaGFyZWRQYXJlbnQsIHNpYmxpbmdzLCBhU2libGluZywgYlNpYmxpbmcsIGlkeDtcblxuXHRpZiAobm9kZUEgPT09IG5vZGVCKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRjdXJyZW50ID0gbm9kZUE7XG5cdHdoaWxlIChjdXJyZW50KSB7XG5cdFx0YVBhcmVudHMudW5zaGlmdChjdXJyZW50KTtcblx0XHRjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG5cdH1cblx0Y3VycmVudCA9IG5vZGVCO1xuXHR3aGlsZSAoY3VycmVudCkge1xuXHRcdGJQYXJlbnRzLnVuc2hpZnQoY3VycmVudCk7XG5cdFx0Y3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuXHR9XG5cblx0aWR4ID0gMDtcblx0d2hpbGUgKGFQYXJlbnRzW2lkeF0gPT09IGJQYXJlbnRzW2lkeF0pIHtcblx0XHRpZHgrKztcblx0fVxuXG5cdGlmIChpZHggPT09IDApIHtcblx0XHRyZXR1cm4gUE9TSVRJT04uRElTQ09OTkVDVEVEO1xuXHR9XG5cblx0c2hhcmVkUGFyZW50ID0gYVBhcmVudHNbaWR4IC0gMV07XG5cdHNpYmxpbmdzID0gc2hhcmVkUGFyZW50LmNoaWxkcmVuO1xuXHRhU2libGluZyA9IGFQYXJlbnRzW2lkeF07XG5cdGJTaWJsaW5nID0gYlBhcmVudHNbaWR4XTtcblxuXHRpZiAoc2libGluZ3MuaW5kZXhPZihhU2libGluZykgPiBzaWJsaW5ncy5pbmRleE9mKGJTaWJsaW5nKSkge1xuXHRcdGlmIChzaGFyZWRQYXJlbnQgPT09IG5vZGVCKSB7XG5cdFx0XHRyZXR1cm4gUE9TSVRJT04uRk9MTE9XSU5HIHwgUE9TSVRJT04uQ09OVEFJTkVEX0JZO1xuXHRcdH1cblx0XHRyZXR1cm4gUE9TSVRJT04uRk9MTE9XSU5HO1xuXHR9IGVsc2Uge1xuXHRcdGlmIChzaGFyZWRQYXJlbnQgPT09IG5vZGVBKSB7XG5cdFx0XHRyZXR1cm4gUE9TSVRJT04uUFJFQ0VESU5HIHwgUE9TSVRJT04uQ09OVEFJTlM7XG5cdFx0fVxuXHRcdHJldHVybiBQT1NJVElPTi5QUkVDRURJTkc7XG5cdH1cbn07XG5cbi8vIFNvcnQgYW4gYXJyYXkgb2Ygbm9kZXMgYmFzZWQgb24gdGhlaXIgcmVsYXRpdmUgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50IGFuZFxuLy8gcmVtb3ZlIGFueSBkdXBsaWNhdGUgbm9kZXMuIElmIHRoZSBhcnJheSBjb250YWlucyBub2RlcyB0aGF0IGRvIG5vdCBiZWxvbmdcbi8vIHRvIHRoZSBzYW1lIGRvY3VtZW50LCBzb3J0IG9yZGVyIGlzIHVuc3BlY2lmaWVkLlxuLy9cbi8vIEBhcmd1bWVudCB7QXJyYXl9IG5vZGVzIEFycmF5IG9mIERPTSBub2Rlc1xuLy9cbi8vIEByZXR1cm5zIHtBcnJheX0gY29sbGVjdGlvbiBvZiB1bmlxdWUgbm9kZXMsIHNvcnRlZCBpbiBkb2N1bWVudCBvcmRlclxuZXhwb3J0cy51bmlxdWVTb3J0ID0gZnVuY3Rpb24obm9kZXMpIHtcblx0dmFyIGlkeCA9IG5vZGVzLmxlbmd0aCwgbm9kZSwgcG9zaXRpb247XG5cblx0bm9kZXMgPSBub2Rlcy5zbGljZSgpO1xuXG5cdHdoaWxlICgtLWlkeCA+IC0xKSB7XG5cdFx0bm9kZSA9IG5vZGVzW2lkeF07XG5cdFx0cG9zaXRpb24gPSBub2Rlcy5pbmRleE9mKG5vZGUpO1xuXHRcdGlmIChwb3NpdGlvbiA+IC0xICYmIHBvc2l0aW9uIDwgaWR4KSB7XG5cdFx0XHRub2Rlcy5zcGxpY2UoaWR4LCAxKTtcblx0XHR9XG5cdH1cblx0bm9kZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0dmFyIHJlbGF0aXZlID0gY29tcGFyZVBvcyhhLCBiKTtcblx0XHRpZiAocmVsYXRpdmUgJiBQT1NJVElPTi5QUkVDRURJTkcpIHtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9IGVsc2UgaWYgKHJlbGF0aXZlICYgUE9TSVRJT04uRk9MTE9XSU5HKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0pO1xuXG5cdHJldHVybiBub2Rlcztcbn07XG4iLCJ2YXIgRWxlbWVudFR5cGUgPSByZXF1aXJlKFwiZG9tZWxlbWVudHR5cGVcIik7XG52YXIgaXNUYWcgPSBleHBvcnRzLmlzVGFnID0gRWxlbWVudFR5cGUuaXNUYWc7XG5cbmV4cG9ydHMudGVzdEVsZW1lbnQgPSBmdW5jdGlvbihvcHRpb25zLCBlbGVtZW50KXtcblx0Zm9yKHZhciBrZXkgaW4gb3B0aW9ucyl7XG5cdFx0aWYoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSk7XG5cdFx0ZWxzZSBpZihrZXkgPT09IFwidGFnX25hbWVcIil7XG5cdFx0XHRpZighaXNUYWcoZWxlbWVudCkgfHwgIW9wdGlvbnMudGFnX25hbWUoZWxlbWVudC5uYW1lKSl7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYoa2V5ID09PSBcInRhZ190eXBlXCIpe1xuXHRcdFx0aWYoIW9wdGlvbnMudGFnX3R5cGUoZWxlbWVudC50eXBlKSkgcmV0dXJuIGZhbHNlO1xuXHRcdH0gZWxzZSBpZihrZXkgPT09IFwidGFnX2NvbnRhaW5zXCIpe1xuXHRcdFx0aWYoaXNUYWcoZWxlbWVudCkgfHwgIW9wdGlvbnMudGFnX2NvbnRhaW5zKGVsZW1lbnQuZGF0YSkpe1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmKCFlbGVtZW50LmF0dHJpYnMgfHwgIW9wdGlvbnNba2V5XShlbGVtZW50LmF0dHJpYnNba2V5XSkpe1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBDaGVja3MgPSB7XG5cdHRhZ19uYW1lOiBmdW5jdGlvbihuYW1lKXtcblx0XHRpZih0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiKXtcblx0XHRcdHJldHVybiBmdW5jdGlvbihlbGVtKXsgcmV0dXJuIGlzVGFnKGVsZW0pICYmIG5hbWUoZWxlbS5uYW1lKTsgfTtcblx0XHR9IGVsc2UgaWYobmFtZSA9PT0gXCIqXCIpe1xuXHRcdFx0cmV0dXJuIGlzVGFnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oZWxlbSl7IHJldHVybiBpc1RhZyhlbGVtKSAmJiBlbGVtLm5hbWUgPT09IG5hbWU7IH07XG5cdFx0fVxuXHR9LFxuXHR0YWdfdHlwZTogZnVuY3Rpb24odHlwZSl7XG5cdFx0aWYodHlwZW9mIHR5cGUgPT09IFwiZnVuY3Rpb25cIil7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oZWxlbSl7IHJldHVybiB0eXBlKGVsZW0udHlwZSk7IH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbihlbGVtKXsgcmV0dXJuIGVsZW0udHlwZSA9PT0gdHlwZTsgfTtcblx0XHR9XG5cdH0sXG5cdHRhZ19jb250YWluczogZnVuY3Rpb24oZGF0YSl7XG5cdFx0aWYodHlwZW9mIGRhdGEgPT09IFwiZnVuY3Rpb25cIil7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oZWxlbSl7IHJldHVybiAhaXNUYWcoZWxlbSkgJiYgZGF0YShlbGVtLmRhdGEpOyB9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oZWxlbSl7IHJldHVybiAhaXNUYWcoZWxlbSkgJiYgZWxlbS5kYXRhID09PSBkYXRhOyB9O1xuXHRcdH1cblx0fVxufTtcblxuZnVuY3Rpb24gZ2V0QXR0cmliQ2hlY2soYXR0cmliLCB2YWx1ZSl7XG5cdGlmKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKXtcblx0XHRyZXR1cm4gZnVuY3Rpb24oZWxlbSl7IHJldHVybiBlbGVtLmF0dHJpYnMgJiYgdmFsdWUoZWxlbS5hdHRyaWJzW2F0dHJpYl0pOyB9O1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBmdW5jdGlvbihlbGVtKXsgcmV0dXJuIGVsZW0uYXR0cmlicyAmJiBlbGVtLmF0dHJpYnNbYXR0cmliXSA9PT0gdmFsdWU7IH07XG5cdH1cbn1cblxuZnVuY3Rpb24gY29tYmluZUZ1bmNzKGEsIGIpe1xuXHRyZXR1cm4gZnVuY3Rpb24oZWxlbSl7XG5cdFx0cmV0dXJuIGEoZWxlbSkgfHwgYihlbGVtKTtcblx0fTtcbn1cblxuZXhwb3J0cy5nZXRFbGVtZW50cyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGVsZW1lbnQsIHJlY3Vyc2UsIGxpbWl0KXtcblx0dmFyIGZ1bmNzID0gT2JqZWN0LmtleXMob3B0aW9ucykubWFwKGZ1bmN0aW9uKGtleSl7XG5cdFx0dmFyIHZhbHVlID0gb3B0aW9uc1trZXldO1xuXHRcdHJldHVybiBrZXkgaW4gQ2hlY2tzID8gQ2hlY2tzW2tleV0odmFsdWUpIDogZ2V0QXR0cmliQ2hlY2soa2V5LCB2YWx1ZSk7XG5cdH0pO1xuXG5cdHJldHVybiBmdW5jcy5sZW5ndGggPT09IDAgPyBbXSA6IHRoaXMuZmlsdGVyKFxuXHRcdGZ1bmNzLnJlZHVjZShjb21iaW5lRnVuY3MpLFxuXHRcdGVsZW1lbnQsIHJlY3Vyc2UsIGxpbWl0XG5cdCk7XG59O1xuXG5leHBvcnRzLmdldEVsZW1lbnRCeUlkID0gZnVuY3Rpb24oaWQsIGVsZW1lbnQsIHJlY3Vyc2Upe1xuXHRpZighQXJyYXkuaXNBcnJheShlbGVtZW50KSkgZWxlbWVudCA9IFtlbGVtZW50XTtcblx0cmV0dXJuIHRoaXMuZmluZE9uZShnZXRBdHRyaWJDaGVjayhcImlkXCIsIGlkKSwgZWxlbWVudCwgcmVjdXJzZSAhPT0gZmFsc2UpO1xufTtcblxuZXhwb3J0cy5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGZ1bmN0aW9uKG5hbWUsIGVsZW1lbnQsIHJlY3Vyc2UsIGxpbWl0KXtcblx0cmV0dXJuIHRoaXMuZmlsdGVyKENoZWNrcy50YWdfbmFtZShuYW1lKSwgZWxlbWVudCwgcmVjdXJzZSwgbGltaXQpO1xufTtcblxuZXhwb3J0cy5nZXRFbGVtZW50c0J5VGFnVHlwZSA9IGZ1bmN0aW9uKHR5cGUsIGVsZW1lbnQsIHJlY3Vyc2UsIGxpbWl0KXtcblx0cmV0dXJuIHRoaXMuZmlsdGVyKENoZWNrcy50YWdfdHlwZSh0eXBlKSwgZWxlbWVudCwgcmVjdXJzZSwgbGltaXQpO1xufTtcbiIsImV4cG9ydHMucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW0pe1xuXHRpZihlbGVtLnByZXYpIGVsZW0ucHJldi5uZXh0ID0gZWxlbS5uZXh0O1xuXHRpZihlbGVtLm5leHQpIGVsZW0ubmV4dC5wcmV2ID0gZWxlbS5wcmV2O1xuXG5cdGlmKGVsZW0ucGFyZW50KXtcblx0XHR2YXIgY2hpbGRzID0gZWxlbS5wYXJlbnQuY2hpbGRyZW47XG5cdFx0Y2hpbGRzLnNwbGljZShjaGlsZHMubGFzdEluZGV4T2YoZWxlbSksIDEpO1xuXHR9XG59O1xuXG5leHBvcnRzLnJlcGxhY2VFbGVtZW50ID0gZnVuY3Rpb24oZWxlbSwgcmVwbGFjZW1lbnQpe1xuXHR2YXIgcHJldiA9IHJlcGxhY2VtZW50LnByZXYgPSBlbGVtLnByZXY7XG5cdGlmKHByZXYpe1xuXHRcdHByZXYubmV4dCA9IHJlcGxhY2VtZW50O1xuXHR9XG5cblx0dmFyIG5leHQgPSByZXBsYWNlbWVudC5uZXh0ID0gZWxlbS5uZXh0O1xuXHRpZihuZXh0KXtcblx0XHRuZXh0LnByZXYgPSByZXBsYWNlbWVudDtcblx0fVxuXG5cdHZhciBwYXJlbnQgPSByZXBsYWNlbWVudC5wYXJlbnQgPSBlbGVtLnBhcmVudDtcblx0aWYocGFyZW50KXtcblx0XHR2YXIgY2hpbGRzID0gcGFyZW50LmNoaWxkcmVuO1xuXHRcdGNoaWxkc1tjaGlsZHMubGFzdEluZGV4T2YoZWxlbSldID0gcmVwbGFjZW1lbnQ7XG5cdH1cbn07XG5cbmV4cG9ydHMuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbihlbGVtLCBjaGlsZCl7XG5cdGNoaWxkLnBhcmVudCA9IGVsZW07XG5cblx0aWYoZWxlbS5jaGlsZHJlbi5wdXNoKGNoaWxkKSAhPT0gMSl7XG5cdFx0dmFyIHNpYmxpbmcgPSBlbGVtLmNoaWxkcmVuW2VsZW0uY2hpbGRyZW4ubGVuZ3RoIC0gMl07XG5cdFx0c2libGluZy5uZXh0ID0gY2hpbGQ7XG5cdFx0Y2hpbGQucHJldiA9IHNpYmxpbmc7XG5cdFx0Y2hpbGQubmV4dCA9IG51bGw7XG5cdH1cbn07XG5cbmV4cG9ydHMuYXBwZW5kID0gZnVuY3Rpb24oZWxlbSwgbmV4dCl7XG5cdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudCxcblx0XHRjdXJyTmV4dCA9IGVsZW0ubmV4dDtcblxuXHRuZXh0Lm5leHQgPSBjdXJyTmV4dDtcblx0bmV4dC5wcmV2ID0gZWxlbTtcblx0ZWxlbS5uZXh0ID0gbmV4dDtcblx0bmV4dC5wYXJlbnQgPSBwYXJlbnQ7XG5cblx0aWYoY3Vyck5leHQpe1xuXHRcdGN1cnJOZXh0LnByZXYgPSBuZXh0O1xuXHRcdGlmKHBhcmVudCl7XG5cdFx0XHR2YXIgY2hpbGRzID0gcGFyZW50LmNoaWxkcmVuO1xuXHRcdFx0Y2hpbGRzLnNwbGljZShjaGlsZHMubGFzdEluZGV4T2YoY3Vyck5leHQpLCAwLCBuZXh0KTtcblx0XHR9XG5cdH0gZWxzZSBpZihwYXJlbnQpe1xuXHRcdHBhcmVudC5jaGlsZHJlbi5wdXNoKG5leHQpO1xuXHR9XG59O1xuXG5leHBvcnRzLnByZXBlbmQgPSBmdW5jdGlvbihlbGVtLCBwcmV2KXtcblx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50O1xuXHRpZihwYXJlbnQpe1xuXHRcdHZhciBjaGlsZHMgPSBwYXJlbnQuY2hpbGRyZW47XG5cdFx0Y2hpbGRzLnNwbGljZShjaGlsZHMubGFzdEluZGV4T2YoZWxlbSksIDAsIHByZXYpO1xuXHR9XG5cblx0aWYoZWxlbS5wcmV2KXtcblx0XHRlbGVtLnByZXYubmV4dCA9IHByZXY7XG5cdH1cblx0XG5cdHByZXYucGFyZW50ID0gcGFyZW50O1xuXHRwcmV2LnByZXYgPSBlbGVtLnByZXY7XG5cdHByZXYubmV4dCA9IGVsZW07XG5cdGVsZW0ucHJldiA9IHByZXY7XG59O1xuXG5cbiIsInZhciBpc1RhZyA9IHJlcXVpcmUoXCJkb21lbGVtZW50dHlwZVwiKS5pc1RhZztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGZpbHRlcjogZmlsdGVyLFxuXHRmaW5kOiBmaW5kLFxuXHRmaW5kT25lQ2hpbGQ6IGZpbmRPbmVDaGlsZCxcblx0ZmluZE9uZTogZmluZE9uZSxcblx0ZXhpc3RzT25lOiBleGlzdHNPbmUsXG5cdGZpbmRBbGw6IGZpbmRBbGxcbn07XG5cbmZ1bmN0aW9uIGZpbHRlcih0ZXN0LCBlbGVtZW50LCByZWN1cnNlLCBsaW1pdCl7XG5cdGlmKCFBcnJheS5pc0FycmF5KGVsZW1lbnQpKSBlbGVtZW50ID0gW2VsZW1lbnRdO1xuXG5cdGlmKHR5cGVvZiBsaW1pdCAhPT0gXCJudW1iZXJcIiB8fCAhaXNGaW5pdGUobGltaXQpKXtcblx0XHRsaW1pdCA9IEluZmluaXR5O1xuXHR9XG5cdHJldHVybiBmaW5kKHRlc3QsIGVsZW1lbnQsIHJlY3Vyc2UgIT09IGZhbHNlLCBsaW1pdCk7XG59XG5cbmZ1bmN0aW9uIGZpbmQodGVzdCwgZWxlbXMsIHJlY3Vyc2UsIGxpbWl0KXtcblx0dmFyIHJlc3VsdCA9IFtdLCBjaGlsZHM7XG5cblx0Zm9yKHZhciBpID0gMCwgaiA9IGVsZW1zLmxlbmd0aDsgaSA8IGo7IGkrKyl7XG5cdFx0aWYodGVzdChlbGVtc1tpXSkpe1xuXHRcdFx0cmVzdWx0LnB1c2goZWxlbXNbaV0pO1xuXHRcdFx0aWYoLS1saW1pdCA8PSAwKSBicmVhaztcblx0XHR9XG5cblx0XHRjaGlsZHMgPSBlbGVtc1tpXS5jaGlsZHJlbjtcblx0XHRpZihyZWN1cnNlICYmIGNoaWxkcyAmJiBjaGlsZHMubGVuZ3RoID4gMCl7XG5cdFx0XHRjaGlsZHMgPSBmaW5kKHRlc3QsIGNoaWxkcywgcmVjdXJzZSwgbGltaXQpO1xuXHRcdFx0cmVzdWx0ID0gcmVzdWx0LmNvbmNhdChjaGlsZHMpO1xuXHRcdFx0bGltaXQgLT0gY2hpbGRzLmxlbmd0aDtcblx0XHRcdGlmKGxpbWl0IDw9IDApIGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRPbmVDaGlsZCh0ZXN0LCBlbGVtcyl7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBlbGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspe1xuXHRcdGlmKHRlc3QoZWxlbXNbaV0pKSByZXR1cm4gZWxlbXNbaV07XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZE9uZSh0ZXN0LCBlbGVtcyl7XG5cdHZhciBlbGVtID0gbnVsbDtcblxuXHRmb3IodmFyIGkgPSAwLCBsID0gZWxlbXMubGVuZ3RoOyBpIDwgbCAmJiAhZWxlbTsgaSsrKXtcblx0XHRpZighaXNUYWcoZWxlbXNbaV0pKXtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH0gZWxzZSBpZih0ZXN0KGVsZW1zW2ldKSl7XG5cdFx0XHRlbGVtID0gZWxlbXNbaV07XG5cdFx0fSBlbHNlIGlmKGVsZW1zW2ldLmNoaWxkcmVuLmxlbmd0aCA+IDApe1xuXHRcdFx0ZWxlbSA9IGZpbmRPbmUodGVzdCwgZWxlbXNbaV0uY2hpbGRyZW4pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBleGlzdHNPbmUodGVzdCwgZWxlbXMpe1xuXHRmb3IodmFyIGkgPSAwLCBsID0gZWxlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKXtcblx0XHRpZihcblx0XHRcdGlzVGFnKGVsZW1zW2ldKSAmJiAoXG5cdFx0XHRcdHRlc3QoZWxlbXNbaV0pIHx8IChcblx0XHRcdFx0XHRlbGVtc1tpXS5jaGlsZHJlbi5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0ZXhpc3RzT25lKHRlc3QsIGVsZW1zW2ldLmNoaWxkcmVuKVxuXHRcdFx0XHQpXG5cdFx0XHQpXG5cdFx0KXtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZmluZEFsbCh0ZXN0LCBlbGVtcyl7XG5cdHZhciByZXN1bHQgPSBbXTtcblx0Zm9yKHZhciBpID0gMCwgaiA9IGVsZW1zLmxlbmd0aDsgaSA8IGo7IGkrKyl7XG5cdFx0aWYoIWlzVGFnKGVsZW1zW2ldKSkgY29udGludWU7XG5cdFx0aWYodGVzdChlbGVtc1tpXSkpIHJlc3VsdC5wdXNoKGVsZW1zW2ldKTtcblxuXHRcdGlmKGVsZW1zW2ldLmNoaWxkcmVuLmxlbmd0aCA+IDApe1xuXHRcdFx0cmVzdWx0ID0gcmVzdWx0LmNvbmNhdChmaW5kQWxsKHRlc3QsIGVsZW1zW2ldLmNoaWxkcmVuKSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG4iLCJ2YXIgRWxlbWVudFR5cGUgPSByZXF1aXJlKFwiZG9tZWxlbWVudHR5cGVcIiksXG4gICAgZ2V0T3V0ZXJIVE1MID0gcmVxdWlyZShcImRvbS1zZXJpYWxpemVyXCIpLFxuICAgIGlzVGFnID0gRWxlbWVudFR5cGUuaXNUYWc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRnZXRJbm5lckhUTUw6IGdldElubmVySFRNTCxcblx0Z2V0T3V0ZXJIVE1MOiBnZXRPdXRlckhUTUwsXG5cdGdldFRleHQ6IGdldFRleHRcbn07XG5cbmZ1bmN0aW9uIGdldElubmVySFRNTChlbGVtLCBvcHRzKXtcblx0cmV0dXJuIGVsZW0uY2hpbGRyZW4gPyBlbGVtLmNoaWxkcmVuLm1hcChmdW5jdGlvbihlbGVtKXtcblx0XHRyZXR1cm4gZ2V0T3V0ZXJIVE1MKGVsZW0sIG9wdHMpO1xuXHR9KS5qb2luKFwiXCIpIDogXCJcIjtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dChlbGVtKXtcblx0aWYoQXJyYXkuaXNBcnJheShlbGVtKSkgcmV0dXJuIGVsZW0ubWFwKGdldFRleHQpLmpvaW4oXCJcIik7XG5cdGlmKGlzVGFnKGVsZW0pIHx8IGVsZW0udHlwZSA9PT0gRWxlbWVudFR5cGUuQ0RBVEEpIHJldHVybiBnZXRUZXh0KGVsZW0uY2hpbGRyZW4pO1xuXHRpZihlbGVtLnR5cGUgPT09IEVsZW1lbnRUeXBlLlRleHQpIHJldHVybiBlbGVtLmRhdGE7XG5cdHJldHVybiBcIlwiO1xufVxuIiwidmFyIGdldENoaWxkcmVuID0gZXhwb3J0cy5nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uKGVsZW0pe1xuXHRyZXR1cm4gZWxlbS5jaGlsZHJlbjtcbn07XG5cbnZhciBnZXRQYXJlbnQgPSBleHBvcnRzLmdldFBhcmVudCA9IGZ1bmN0aW9uKGVsZW0pe1xuXHRyZXR1cm4gZWxlbS5wYXJlbnQ7XG59O1xuXG5leHBvcnRzLmdldFNpYmxpbmdzID0gZnVuY3Rpb24oZWxlbSl7XG5cdHZhciBwYXJlbnQgPSBnZXRQYXJlbnQoZWxlbSk7XG5cdHJldHVybiBwYXJlbnQgPyBnZXRDaGlsZHJlbihwYXJlbnQpIDogW2VsZW1dO1xufTtcblxuZXhwb3J0cy5nZXRBdHRyaWJ1dGVWYWx1ZSA9IGZ1bmN0aW9uKGVsZW0sIG5hbWUpe1xuXHRyZXR1cm4gZWxlbS5hdHRyaWJzICYmIGVsZW0uYXR0cmlic1tuYW1lXTtcbn07XG5cbmV4cG9ydHMuaGFzQXR0cmliID0gZnVuY3Rpb24oZWxlbSwgbmFtZSl7XG5cdHJldHVybiAhIWVsZW0uYXR0cmlicyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGVsZW0uYXR0cmlicywgbmFtZSk7XG59O1xuXG5leHBvcnRzLmdldE5hbWUgPSBmdW5jdGlvbihlbGVtKXtcblx0cmV0dXJuIGVsZW0ubmFtZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjYWNoZSA9IHt9O1xudmFyIHN0YXJ0ID0gJyg/Ol58XFxcXHMpJztcbnZhciBlbmQgPSAnKD86XFxcXHN8JCknO1xuXG5mdW5jdGlvbiBsb29rdXBDbGFzcyAoY2xhc3NOYW1lKSB7XG4gIHZhciBjYWNoZWQgPSBjYWNoZVtjbGFzc05hbWVdO1xuICBpZiAoY2FjaGVkKSB7XG4gICAgY2FjaGVkLmxhc3RJbmRleCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgY2FjaGVbY2xhc3NOYW1lXSA9IGNhY2hlZCA9IG5ldyBSZWdFeHAoc3RhcnQgKyBjbGFzc05hbWUgKyBlbmQsICdnJyk7XG4gIH1cbiAgcmV0dXJuIGNhY2hlZDtcbn1cblxuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbGFzc05hbWUpIHtcbiAgdmFyIGN1cnJlbnQgPSBlbC5jbGFzc05hbWU7XG4gIGlmICghY3VycmVudC5sZW5ndGgpIHtcbiAgICBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gIH0gZWxzZSBpZiAoIWxvb2t1cENsYXNzKGNsYXNzTmFtZSkudGVzdChjdXJyZW50KSkge1xuICAgIGVsLmNsYXNzTmFtZSArPSAnICcgKyBjbGFzc05hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcm1DbGFzcyAoZWwsIGNsYXNzTmFtZSkge1xuICBlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUucmVwbGFjZShsb29rdXBDbGFzcyhjbGFzc05hbWUpLCAnICcpLnRyaW0oKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFkZDogYWRkQ2xhc3MsXG4gIHJtOiBybUNsYXNzXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1pdHRlciA9IHJlcXVpcmUoJ2NvbnRyYS9lbWl0dGVyJyk7XG52YXIgY3Jvc3N2ZW50ID0gcmVxdWlyZSgnY3Jvc3N2ZW50Jyk7XG52YXIgY2xhc3NlcyA9IHJlcXVpcmUoJy4vY2xhc3NlcycpO1xudmFyIGRvYyA9IGRvY3VtZW50O1xudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cbmZ1bmN0aW9uIGRyYWd1bGEgKGluaXRpYWxDb250YWluZXJzLCBvcHRpb25zKSB7XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICBpZiAobGVuID09PSAxICYmIEFycmF5LmlzQXJyYXkoaW5pdGlhbENvbnRhaW5lcnMpID09PSBmYWxzZSkge1xuICAgIG9wdGlvbnMgPSBpbml0aWFsQ29udGFpbmVycztcbiAgICBpbml0aWFsQ29udGFpbmVycyA9IFtdO1xuICB9XG4gIHZhciBfbWlycm9yOyAvLyBtaXJyb3IgaW1hZ2VcbiAgdmFyIF9zb3VyY2U7IC8vIHNvdXJjZSBjb250YWluZXJcbiAgdmFyIF9pdGVtOyAvLyBpdGVtIGJlaW5nIGRyYWdnZWRcbiAgdmFyIF9vZmZzZXRYOyAvLyByZWZlcmVuY2UgeFxuICB2YXIgX29mZnNldFk7IC8vIHJlZmVyZW5jZSB5XG4gIHZhciBfbW92ZVg7IC8vIHJlZmVyZW5jZSBtb3ZlIHhcbiAgdmFyIF9tb3ZlWTsgLy8gcmVmZXJlbmNlIG1vdmUgeVxuICB2YXIgX2luaXRpYWxTaWJsaW5nOyAvLyByZWZlcmVuY2Ugc2libGluZyB3aGVuIGdyYWJiZWRcbiAgdmFyIF9jdXJyZW50U2libGluZzsgLy8gcmVmZXJlbmNlIHNpYmxpbmcgbm93XG4gIHZhciBfY29weTsgLy8gaXRlbSB1c2VkIGZvciBjb3B5aW5nXG4gIHZhciBfcmVuZGVyVGltZXI7IC8vIHRpbWVyIGZvciBzZXRUaW1lb3V0IHJlbmRlck1pcnJvckltYWdlXG4gIHZhciBfbGFzdERyb3BUYXJnZXQgPSBudWxsOyAvLyBsYXN0IGNvbnRhaW5lciBpdGVtIHdhcyBvdmVyXG4gIHZhciBfZ3JhYmJlZDsgLy8gaG9sZHMgbW91c2Vkb3duIGNvbnRleHQgdW50aWwgZmlyc3QgbW91c2Vtb3ZlXG5cbiAgdmFyIG8gPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoby5tb3ZlcyA9PT0gdm9pZCAwKSB7IG8ubW92ZXMgPSBhbHdheXM7IH1cbiAgaWYgKG8uYWNjZXB0cyA9PT0gdm9pZCAwKSB7IG8uYWNjZXB0cyA9IGFsd2F5czsgfVxuICBpZiAoby5pbnZhbGlkID09PSB2b2lkIDApIHsgby5pbnZhbGlkID0gaW52YWxpZFRhcmdldDsgfVxuICBpZiAoby5jb250YWluZXJzID09PSB2b2lkIDApIHsgby5jb250YWluZXJzID0gaW5pdGlhbENvbnRhaW5lcnMgfHwgW107IH1cbiAgaWYgKG8uaXNDb250YWluZXIgPT09IHZvaWQgMCkgeyBvLmlzQ29udGFpbmVyID0gbmV2ZXI7IH1cbiAgaWYgKG8uY29weSA9PT0gdm9pZCAwKSB7IG8uY29weSA9IGZhbHNlOyB9XG4gIGlmIChvLmNvcHlTb3J0U291cmNlID09PSB2b2lkIDApIHsgby5jb3B5U29ydFNvdXJjZSA9IGZhbHNlOyB9XG4gIGlmIChvLnJldmVydE9uU3BpbGwgPT09IHZvaWQgMCkgeyBvLnJldmVydE9uU3BpbGwgPSBmYWxzZTsgfVxuICBpZiAoby5yZW1vdmVPblNwaWxsID09PSB2b2lkIDApIHsgby5yZW1vdmVPblNwaWxsID0gZmFsc2U7IH1cbiAgaWYgKG8uZGlyZWN0aW9uID09PSB2b2lkIDApIHsgby5kaXJlY3Rpb24gPSAndmVydGljYWwnOyB9XG4gIGlmIChvLmlnbm9yZUlucHV0VGV4dFNlbGVjdGlvbiA9PT0gdm9pZCAwKSB7IG8uaWdub3JlSW5wdXRUZXh0U2VsZWN0aW9uID0gdHJ1ZTsgfVxuICBpZiAoby5taXJyb3JDb250YWluZXIgPT09IHZvaWQgMCkgeyBvLm1pcnJvckNvbnRhaW5lciA9IGRvYy5ib2R5OyB9XG5cbiAgdmFyIGRyYWtlID0gZW1pdHRlcih7XG4gICAgY29udGFpbmVyczogby5jb250YWluZXJzLFxuICAgIHN0YXJ0OiBtYW51YWxTdGFydCxcbiAgICBlbmQ6IGVuZCxcbiAgICBjYW5jZWw6IGNhbmNlbCxcbiAgICByZW1vdmU6IHJlbW92ZSxcbiAgICBkZXN0cm95OiBkZXN0cm95LFxuICAgIGNhbk1vdmU6IGNhbk1vdmUsXG4gICAgZHJhZ2dpbmc6IGZhbHNlXG4gIH0pO1xuXG4gIGlmIChvLnJlbW92ZU9uU3BpbGwgPT09IHRydWUpIHtcbiAgICBkcmFrZS5vbignb3ZlcicsIHNwaWxsT3Zlcikub24oJ291dCcsIHNwaWxsT3V0KTtcbiAgfVxuXG4gIGV2ZW50cygpO1xuXG4gIHJldHVybiBkcmFrZTtcblxuICBmdW5jdGlvbiBpc0NvbnRhaW5lciAoZWwpIHtcbiAgICByZXR1cm4gZHJha2UuY29udGFpbmVycy5pbmRleE9mKGVsKSAhPT0gLTEgfHwgby5pc0NvbnRhaW5lcihlbCk7XG4gIH1cblxuICBmdW5jdGlvbiBldmVudHMgKHJlbW92ZSkge1xuICAgIHZhciBvcCA9IHJlbW92ZSA/ICdyZW1vdmUnIDogJ2FkZCc7XG4gICAgdG91Y2h5KGRvY3VtZW50RWxlbWVudCwgb3AsICdtb3VzZWRvd24nLCBncmFiKTtcbiAgICB0b3VjaHkoZG9jdW1lbnRFbGVtZW50LCBvcCwgJ21vdXNldXAnLCByZWxlYXNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV2ZW50dWFsTW92ZW1lbnRzIChyZW1vdmUpIHtcbiAgICB2YXIgb3AgPSByZW1vdmUgPyAncmVtb3ZlJyA6ICdhZGQnO1xuICAgIHRvdWNoeShkb2N1bWVudEVsZW1lbnQsIG9wLCAnbW91c2Vtb3ZlJywgc3RhcnRCZWNhdXNlTW91c2VNb3ZlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlbWVudHMgKHJlbW92ZSkge1xuICAgIHZhciBvcCA9IHJlbW92ZSA/ICdyZW1vdmUnIDogJ2FkZCc7XG4gICAgY3Jvc3N2ZW50W29wXShkb2N1bWVudEVsZW1lbnQsICdzZWxlY3RzdGFydCcsIHByZXZlbnRHcmFiYmVkKTsgLy8gSUU4XG4gICAgY3Jvc3N2ZW50W29wXShkb2N1bWVudEVsZW1lbnQsICdjbGljaycsIHByZXZlbnRHcmFiYmVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xuICAgIGV2ZW50cyh0cnVlKTtcbiAgICByZWxlYXNlKHt9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXZlbnRHcmFiYmVkIChlKSB7XG4gICAgaWYgKF9ncmFiYmVkKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ3JhYiAoZSkge1xuICAgIF9tb3ZlWCA9IGUuY2xpZW50WDtcbiAgICBfbW92ZVkgPSBlLmNsaWVudFk7XG5cbiAgICB2YXIgaWdub3JlID0gd2hpY2hNb3VzZUJ1dHRvbihlKSAhPT0gMSB8fCBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5O1xuICAgIGlmIChpZ25vcmUpIHtcbiAgICAgIHJldHVybjsgLy8gd2Ugb25seSBjYXJlIGFib3V0IGhvbmVzdC10by1nb2QgbGVmdCBjbGlja3MgYW5kIHRvdWNoIGV2ZW50c1xuICAgIH1cbiAgICB2YXIgaXRlbSA9IGUudGFyZ2V0O1xuICAgIHZhciBjb250ZXh0ID0gY2FuU3RhcnQoaXRlbSk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9ncmFiYmVkID0gY29udGV4dDtcbiAgICBldmVudHVhbE1vdmVtZW50cygpO1xuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICBpZiAoaXNJbnB1dChpdGVtKSkgeyAvLyBzZWUgYWxzbzogaHR0cHM6Ly9naXRodWIuY29tL2JldmFjcXVhL2RyYWd1bGEvaXNzdWVzLzIwOFxuICAgICAgICBpdGVtLmZvY3VzKCk7IC8vIGZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXZhY3F1YS9kcmFndWxhL2lzc3Vlcy8xNzZcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gZml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL2JldmFjcXVhL2RyYWd1bGEvaXNzdWVzLzE1NVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0QmVjYXVzZU1vdXNlTW92ZWQgKGUpIHtcbiAgICBpZiAoIV9ncmFiYmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh3aGljaE1vdXNlQnV0dG9uKGUpID09PSAwKSB7XG4gICAgICByZWxlYXNlKHt9KTtcbiAgICAgIHJldHVybjsgLy8gd2hlbiB0ZXh0IGlzIHNlbGVjdGVkIG9uIGFuIGlucHV0IGFuZCB0aGVuIGRyYWdnZWQsIG1vdXNldXAgZG9lc24ndCBmaXJlLiB0aGlzIGlzIG91ciBvbmx5IGhvcGVcbiAgICB9XG4gICAgLy8gdHJ1dGh5IGNoZWNrIGZpeGVzICMyMzksIGVxdWFsaXR5IGZpeGVzICMyMDdcbiAgICBpZiAoZS5jbGllbnRYICE9PSB2b2lkIDAgJiYgZS5jbGllbnRYID09PSBfbW92ZVggJiYgZS5jbGllbnRZICE9PSB2b2lkIDAgJiYgZS5jbGllbnRZID09PSBfbW92ZVkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG8uaWdub3JlSW5wdXRUZXh0U2VsZWN0aW9uKSB7XG4gICAgICB2YXIgY2xpZW50WCA9IGdldENvb3JkKCdjbGllbnRYJywgZSk7XG4gICAgICB2YXIgY2xpZW50WSA9IGdldENvb3JkKCdjbGllbnRZJywgZSk7XG4gICAgICB2YXIgZWxlbWVudEJlaGluZEN1cnNvciA9IGRvYy5lbGVtZW50RnJvbVBvaW50KGNsaWVudFgsIGNsaWVudFkpO1xuICAgICAgaWYgKGlzSW5wdXQoZWxlbWVudEJlaGluZEN1cnNvcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBncmFiYmVkID0gX2dyYWJiZWQ7IC8vIGNhbGwgdG8gZW5kKCkgdW5zZXRzIF9ncmFiYmVkXG4gICAgZXZlbnR1YWxNb3ZlbWVudHModHJ1ZSk7XG4gICAgbW92ZW1lbnRzKCk7XG4gICAgZW5kKCk7XG4gICAgc3RhcnQoZ3JhYmJlZCk7XG5cbiAgICB2YXIgb2Zmc2V0ID0gZ2V0T2Zmc2V0KF9pdGVtKTtcbiAgICBfb2Zmc2V0WCA9IGdldENvb3JkKCdwYWdlWCcsIGUpIC0gb2Zmc2V0LmxlZnQ7XG4gICAgX29mZnNldFkgPSBnZXRDb29yZCgncGFnZVknLCBlKSAtIG9mZnNldC50b3A7XG5cbiAgICBjbGFzc2VzLmFkZChfY29weSB8fCBfaXRlbSwgJ2d1LXRyYW5zaXQnKTtcbiAgICByZW5kZXJNaXJyb3JJbWFnZSgpO1xuICAgIGRyYWcoZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5TdGFydCAoaXRlbSkge1xuICAgIGlmIChkcmFrZS5kcmFnZ2luZyAmJiBfbWlycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0NvbnRhaW5lcihpdGVtKSkge1xuICAgICAgcmV0dXJuOyAvLyBkb24ndCBkcmFnIGNvbnRhaW5lciBpdHNlbGZcbiAgICB9XG4gICAgdmFyIGhhbmRsZSA9IGl0ZW07XG4gICAgd2hpbGUgKGdldFBhcmVudChpdGVtKSAmJiBpc0NvbnRhaW5lcihnZXRQYXJlbnQoaXRlbSkpID09PSBmYWxzZSkge1xuICAgICAgaWYgKG8uaW52YWxpZChpdGVtLCBoYW5kbGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGl0ZW0gPSBnZXRQYXJlbnQoaXRlbSk7IC8vIGRyYWcgdGFyZ2V0IHNob3VsZCBiZSBhIHRvcCBlbGVtZW50XG4gICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgc291cmNlID0gZ2V0UGFyZW50KGl0ZW0pO1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvLmludmFsaWQoaXRlbSwgaGFuZGxlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtb3ZhYmxlID0gby5tb3ZlcyhpdGVtLCBzb3VyY2UsIGhhbmRsZSwgbmV4dEVsKGl0ZW0pKTtcbiAgICBpZiAoIW1vdmFibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXRlbTogaXRlbSxcbiAgICAgIHNvdXJjZTogc291cmNlXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbk1vdmUgKGl0ZW0pIHtcbiAgICByZXR1cm4gISFjYW5TdGFydChpdGVtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hbnVhbFN0YXJ0IChpdGVtKSB7XG4gICAgdmFyIGNvbnRleHQgPSBjYW5TdGFydChpdGVtKTtcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgc3RhcnQoY29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnQgKGNvbnRleHQpIHtcbiAgICBpZiAoaXNDb3B5KGNvbnRleHQuaXRlbSwgY29udGV4dC5zb3VyY2UpKSB7XG4gICAgICBfY29weSA9IGNvbnRleHQuaXRlbS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICBkcmFrZS5lbWl0KCdjbG9uZWQnLCBfY29weSwgY29udGV4dC5pdGVtLCAnY29weScpO1xuICAgIH1cblxuICAgIF9zb3VyY2UgPSBjb250ZXh0LnNvdXJjZTtcbiAgICBfaXRlbSA9IGNvbnRleHQuaXRlbTtcbiAgICBfaW5pdGlhbFNpYmxpbmcgPSBfY3VycmVudFNpYmxpbmcgPSBuZXh0RWwoY29udGV4dC5pdGVtKTtcblxuICAgIGRyYWtlLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICBkcmFrZS5lbWl0KCdkcmFnJywgX2l0ZW0sIF9zb3VyY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52YWxpZFRhcmdldCAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5kICgpIHtcbiAgICBpZiAoIWRyYWtlLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpdGVtID0gX2NvcHkgfHwgX2l0ZW07XG4gICAgZHJvcChpdGVtLCBnZXRQYXJlbnQoaXRlbSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5ncmFiICgpIHtcbiAgICBfZ3JhYmJlZCA9IGZhbHNlO1xuICAgIGV2ZW50dWFsTW92ZW1lbnRzKHRydWUpO1xuICAgIG1vdmVtZW50cyh0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbGVhc2UgKGUpIHtcbiAgICB1bmdyYWIoKTtcblxuICAgIGlmICghZHJha2UuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGl0ZW0gPSBfY29weSB8fCBfaXRlbTtcbiAgICB2YXIgY2xpZW50WCA9IGdldENvb3JkKCdjbGllbnRYJywgZSk7XG4gICAgdmFyIGNsaWVudFkgPSBnZXRDb29yZCgnY2xpZW50WScsIGUpO1xuICAgIHZhciBlbGVtZW50QmVoaW5kQ3Vyc29yID0gZ2V0RWxlbWVudEJlaGluZFBvaW50KF9taXJyb3IsIGNsaWVudFgsIGNsaWVudFkpO1xuICAgIHZhciBkcm9wVGFyZ2V0ID0gZmluZERyb3BUYXJnZXQoZWxlbWVudEJlaGluZEN1cnNvciwgY2xpZW50WCwgY2xpZW50WSk7XG4gICAgaWYgKGRyb3BUYXJnZXQgJiYgKChfY29weSAmJiBvLmNvcHlTb3J0U291cmNlKSB8fCAoIV9jb3B5IHx8IGRyb3BUYXJnZXQgIT09IF9zb3VyY2UpKSkge1xuICAgICAgZHJvcChpdGVtLCBkcm9wVGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKG8ucmVtb3ZlT25TcGlsbCkge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbmNlbCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRyb3AgKGl0ZW0sIHRhcmdldCkge1xuICAgIHZhciBwYXJlbnQgPSBnZXRQYXJlbnQoaXRlbSk7XG4gICAgaWYgKF9jb3B5ICYmIG8uY29weVNvcnRTb3VyY2UgJiYgdGFyZ2V0ID09PSBfc291cmNlKSB7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoX2l0ZW0pO1xuICAgIH1cbiAgICBpZiAoaXNJbml0aWFsUGxhY2VtZW50KHRhcmdldCkpIHtcbiAgICAgIGRyYWtlLmVtaXQoJ2NhbmNlbCcsIGl0ZW0sIF9zb3VyY2UsIF9zb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkcmFrZS5lbWl0KCdkcm9wJywgaXRlbSwgdGFyZ2V0LCBfc291cmNlLCBfY3VycmVudFNpYmxpbmcpO1xuICAgIH1cbiAgICBjbGVhbnVwKCk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmUgKCkge1xuICAgIGlmICghZHJha2UuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGl0ZW0gPSBfY29weSB8fCBfaXRlbTtcbiAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50KGl0ZW0pO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChpdGVtKTtcbiAgICB9XG4gICAgZHJha2UuZW1pdChfY29weSA/ICdjYW5jZWwnIDogJ3JlbW92ZScsIGl0ZW0sIHBhcmVudCwgX3NvdXJjZSk7XG4gICAgY2xlYW51cCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsIChyZXZlcnQpIHtcbiAgICBpZiAoIWRyYWtlLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZXZlcnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgPyByZXZlcnQgOiBvLnJldmVydE9uU3BpbGw7XG4gICAgdmFyIGl0ZW0gPSBfY29weSB8fCBfaXRlbTtcbiAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50KGl0ZW0pO1xuICAgIHZhciBpbml0aWFsID0gaXNJbml0aWFsUGxhY2VtZW50KHBhcmVudCk7XG4gICAgaWYgKGluaXRpYWwgPT09IGZhbHNlICYmIHJldmVydHMpIHtcbiAgICAgIGlmIChfY29weSkge1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKF9jb3B5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3NvdXJjZS5pbnNlcnRCZWZvcmUoaXRlbSwgX2luaXRpYWxTaWJsaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluaXRpYWwgfHwgcmV2ZXJ0cykge1xuICAgICAgZHJha2UuZW1pdCgnY2FuY2VsJywgaXRlbSwgX3NvdXJjZSwgX3NvdXJjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYWtlLmVtaXQoJ2Ryb3AnLCBpdGVtLCBwYXJlbnQsIF9zb3VyY2UsIF9jdXJyZW50U2libGluZyk7XG4gICAgfVxuICAgIGNsZWFudXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXAgKCkge1xuICAgIHZhciBpdGVtID0gX2NvcHkgfHwgX2l0ZW07XG4gICAgdW5ncmFiKCk7XG4gICAgcmVtb3ZlTWlycm9ySW1hZ2UoKTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgY2xhc3Nlcy5ybShpdGVtLCAnZ3UtdHJhbnNpdCcpO1xuICAgIH1cbiAgICBpZiAoX3JlbmRlclRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoX3JlbmRlclRpbWVyKTtcbiAgICB9XG4gICAgZHJha2UuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICBpZiAoX2xhc3REcm9wVGFyZ2V0KSB7XG4gICAgICBkcmFrZS5lbWl0KCdvdXQnLCBpdGVtLCBfbGFzdERyb3BUYXJnZXQsIF9zb3VyY2UpO1xuICAgIH1cbiAgICBkcmFrZS5lbWl0KCdkcmFnZW5kJywgaXRlbSk7XG4gICAgX3NvdXJjZSA9IF9pdGVtID0gX2NvcHkgPSBfaW5pdGlhbFNpYmxpbmcgPSBfY3VycmVudFNpYmxpbmcgPSBfcmVuZGVyVGltZXIgPSBfbGFzdERyb3BUYXJnZXQgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJbml0aWFsUGxhY2VtZW50ICh0YXJnZXQsIHMpIHtcbiAgICB2YXIgc2libGluZztcbiAgICBpZiAocyAhPT0gdm9pZCAwKSB7XG4gICAgICBzaWJsaW5nID0gcztcbiAgICB9IGVsc2UgaWYgKF9taXJyb3IpIHtcbiAgICAgIHNpYmxpbmcgPSBfY3VycmVudFNpYmxpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpYmxpbmcgPSBuZXh0RWwoX2NvcHkgfHwgX2l0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0ID09PSBfc291cmNlICYmIHNpYmxpbmcgPT09IF9pbml0aWFsU2libGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmREcm9wVGFyZ2V0IChlbGVtZW50QmVoaW5kQ3Vyc29yLCBjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgdmFyIHRhcmdldCA9IGVsZW1lbnRCZWhpbmRDdXJzb3I7XG4gICAgd2hpbGUgKHRhcmdldCAmJiAhYWNjZXB0ZWQoKSkge1xuICAgICAgdGFyZ2V0ID0gZ2V0UGFyZW50KHRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG5cbiAgICBmdW5jdGlvbiBhY2NlcHRlZCAoKSB7XG4gICAgICB2YXIgZHJvcHBhYmxlID0gaXNDb250YWluZXIodGFyZ2V0KTtcbiAgICAgIGlmIChkcm9wcGFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGltbWVkaWF0ZSA9IGdldEltbWVkaWF0ZUNoaWxkKHRhcmdldCwgZWxlbWVudEJlaGluZEN1cnNvcik7XG4gICAgICB2YXIgcmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlKHRhcmdldCwgaW1tZWRpYXRlLCBjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgIHZhciBpbml0aWFsID0gaXNJbml0aWFsUGxhY2VtZW50KHRhcmdldCwgcmVmZXJlbmNlKTtcbiAgICAgIGlmIChpbml0aWFsKSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBzaG91bGQgYWx3YXlzIGJlIGFibGUgdG8gZHJvcCBpdCByaWdodCBiYWNrIHdoZXJlIGl0IHdhc1xuICAgICAgfVxuICAgICAgcmV0dXJuIG8uYWNjZXB0cyhfaXRlbSwgdGFyZ2V0LCBfc291cmNlLCByZWZlcmVuY2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYWcgKGUpIHtcbiAgICBpZiAoIV9taXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdmFyIGNsaWVudFggPSBnZXRDb29yZCgnY2xpZW50WCcsIGUpO1xuICAgIHZhciBjbGllbnRZID0gZ2V0Q29vcmQoJ2NsaWVudFknLCBlKTtcbiAgICB2YXIgeCA9IGNsaWVudFggLSBfb2Zmc2V0WDtcbiAgICB2YXIgeSA9IGNsaWVudFkgLSBfb2Zmc2V0WTtcblxuICAgIF9taXJyb3Iuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgIF9taXJyb3Iuc3R5bGUudG9wID0geSArICdweCc7XG5cbiAgICB2YXIgaXRlbSA9IF9jb3B5IHx8IF9pdGVtO1xuICAgIHZhciBlbGVtZW50QmVoaW5kQ3Vyc29yID0gZ2V0RWxlbWVudEJlaGluZFBvaW50KF9taXJyb3IsIGNsaWVudFgsIGNsaWVudFkpO1xuICAgIHZhciBkcm9wVGFyZ2V0ID0gZmluZERyb3BUYXJnZXQoZWxlbWVudEJlaGluZEN1cnNvciwgY2xpZW50WCwgY2xpZW50WSk7XG4gICAgdmFyIGNoYW5nZWQgPSBkcm9wVGFyZ2V0ICE9PSBudWxsICYmIGRyb3BUYXJnZXQgIT09IF9sYXN0RHJvcFRhcmdldDtcbiAgICBpZiAoY2hhbmdlZCB8fCBkcm9wVGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICBvdXQoKTtcbiAgICAgIF9sYXN0RHJvcFRhcmdldCA9IGRyb3BUYXJnZXQ7XG4gICAgICBvdmVyKCk7XG4gICAgfVxuICAgIHZhciBwYXJlbnQgPSBnZXRQYXJlbnQoaXRlbSk7XG4gICAgaWYgKGRyb3BUYXJnZXQgPT09IF9zb3VyY2UgJiYgX2NvcHkgJiYgIW8uY29weVNvcnRTb3VyY2UpIHtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGl0ZW0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmVmZXJlbmNlO1xuICAgIHZhciBpbW1lZGlhdGUgPSBnZXRJbW1lZGlhdGVDaGlsZChkcm9wVGFyZ2V0LCBlbGVtZW50QmVoaW5kQ3Vyc29yKTtcbiAgICBpZiAoaW1tZWRpYXRlICE9PSBudWxsKSB7XG4gICAgICByZWZlcmVuY2UgPSBnZXRSZWZlcmVuY2UoZHJvcFRhcmdldCwgaW1tZWRpYXRlLCBjbGllbnRYLCBjbGllbnRZKTtcbiAgICB9IGVsc2UgaWYgKG8ucmV2ZXJ0T25TcGlsbCA9PT0gdHJ1ZSAmJiAhX2NvcHkpIHtcbiAgICAgIHJlZmVyZW5jZSA9IF9pbml0aWFsU2libGluZztcbiAgICAgIGRyb3BUYXJnZXQgPSBfc291cmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoX2NvcHkgJiYgcGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChpdGVtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgKHJlZmVyZW5jZSA9PT0gbnVsbCAmJiBjaGFuZ2VkKSB8fFxuICAgICAgcmVmZXJlbmNlICE9PSBpdGVtICYmXG4gICAgICByZWZlcmVuY2UgIT09IG5leHRFbChpdGVtKVxuICAgICkge1xuICAgICAgX2N1cnJlbnRTaWJsaW5nID0gcmVmZXJlbmNlO1xuICAgICAgZHJvcFRhcmdldC5pbnNlcnRCZWZvcmUoaXRlbSwgcmVmZXJlbmNlKTtcbiAgICAgIGRyYWtlLmVtaXQoJ3NoYWRvdycsIGl0ZW0sIGRyb3BUYXJnZXQsIF9zb3VyY2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3ZlZCAodHlwZSkgeyBkcmFrZS5lbWl0KHR5cGUsIGl0ZW0sIF9sYXN0RHJvcFRhcmdldCwgX3NvdXJjZSk7IH1cbiAgICBmdW5jdGlvbiBvdmVyICgpIHsgaWYgKGNoYW5nZWQpIHsgbW92ZWQoJ292ZXInKTsgfSB9XG4gICAgZnVuY3Rpb24gb3V0ICgpIHsgaWYgKF9sYXN0RHJvcFRhcmdldCkgeyBtb3ZlZCgnb3V0Jyk7IH0gfVxuICB9XG5cbiAgZnVuY3Rpb24gc3BpbGxPdmVyIChlbCkge1xuICAgIGNsYXNzZXMucm0oZWwsICdndS1oaWRlJyk7XG4gIH1cblxuICBmdW5jdGlvbiBzcGlsbE91dCAoZWwpIHtcbiAgICBpZiAoZHJha2UuZHJhZ2dpbmcpIHsgY2xhc3Nlcy5hZGQoZWwsICdndS1oaWRlJyk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlck1pcnJvckltYWdlICgpIHtcbiAgICBpZiAoX21pcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmVjdCA9IF9pdGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIF9taXJyb3IgPSBfaXRlbS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgX21pcnJvci5zdHlsZS53aWR0aCA9IGdldFJlY3RXaWR0aChyZWN0KSArICdweCc7XG4gICAgX21pcnJvci5zdHlsZS5oZWlnaHQgPSBnZXRSZWN0SGVpZ2h0KHJlY3QpICsgJ3B4JztcbiAgICBjbGFzc2VzLnJtKF9taXJyb3IsICdndS10cmFuc2l0Jyk7XG4gICAgY2xhc3Nlcy5hZGQoX21pcnJvciwgJ2d1LW1pcnJvcicpO1xuICAgIG8ubWlycm9yQ29udGFpbmVyLmFwcGVuZENoaWxkKF9taXJyb3IpO1xuICAgIHRvdWNoeShkb2N1bWVudEVsZW1lbnQsICdhZGQnLCAnbW91c2Vtb3ZlJywgZHJhZyk7XG4gICAgY2xhc3Nlcy5hZGQoby5taXJyb3JDb250YWluZXIsICdndS11bnNlbGVjdGFibGUnKTtcbiAgICBkcmFrZS5lbWl0KCdjbG9uZWQnLCBfbWlycm9yLCBfaXRlbSwgJ21pcnJvcicpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTWlycm9ySW1hZ2UgKCkge1xuICAgIGlmIChfbWlycm9yKSB7XG4gICAgICBjbGFzc2VzLnJtKG8ubWlycm9yQ29udGFpbmVyLCAnZ3UtdW5zZWxlY3RhYmxlJyk7XG4gICAgICB0b3VjaHkoZG9jdW1lbnRFbGVtZW50LCAncmVtb3ZlJywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgICAgZ2V0UGFyZW50KF9taXJyb3IpLnJlbW92ZUNoaWxkKF9taXJyb3IpO1xuICAgICAgX21pcnJvciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW1tZWRpYXRlQ2hpbGQgKGRyb3BUYXJnZXQsIHRhcmdldCkge1xuICAgIHZhciBpbW1lZGlhdGUgPSB0YXJnZXQ7XG4gICAgd2hpbGUgKGltbWVkaWF0ZSAhPT0gZHJvcFRhcmdldCAmJiBnZXRQYXJlbnQoaW1tZWRpYXRlKSAhPT0gZHJvcFRhcmdldCkge1xuICAgICAgaW1tZWRpYXRlID0gZ2V0UGFyZW50KGltbWVkaWF0ZSk7XG4gICAgfVxuICAgIGlmIChpbW1lZGlhdGUgPT09IGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpbW1lZGlhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSZWZlcmVuY2UgKGRyb3BUYXJnZXQsIHRhcmdldCwgeCwgeSkge1xuICAgIHZhciBob3Jpem9udGFsID0gby5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJztcbiAgICB2YXIgcmVmZXJlbmNlID0gdGFyZ2V0ICE9PSBkcm9wVGFyZ2V0ID8gaW5zaWRlKCkgOiBvdXRzaWRlKCk7XG4gICAgcmV0dXJuIHJlZmVyZW5jZTtcblxuICAgIGZ1bmN0aW9uIG91dHNpZGUgKCkgeyAvLyBzbG93ZXIsIGJ1dCBhYmxlIHRvIGZpZ3VyZSBvdXQgYW55IHBvc2l0aW9uXG4gICAgICB2YXIgbGVuID0gZHJvcFRhcmdldC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBlbDtcbiAgICAgIHZhciByZWN0O1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGVsID0gZHJvcFRhcmdldC5jaGlsZHJlbltpXTtcbiAgICAgICAgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoaG9yaXpvbnRhbCAmJiAocmVjdC5sZWZ0ICsgcmVjdC53aWR0aCAvIDIpID4geCkgeyByZXR1cm4gZWw7IH1cbiAgICAgICAgaWYgKCFob3Jpem9udGFsICYmIChyZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC8gMikgPiB5KSB7IHJldHVybiBlbDsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zaWRlICgpIHsgLy8gZmFzdGVyLCBidXQgb25seSBhdmFpbGFibGUgaWYgZHJvcHBlZCBpbnNpZGUgYSBjaGlsZCBlbGVtZW50XG4gICAgICB2YXIgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHggPiByZWN0LmxlZnQgKyBnZXRSZWN0V2lkdGgocmVjdCkgLyAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNvbHZlKHkgPiByZWN0LnRvcCArIGdldFJlY3RIZWlnaHQocmVjdCkgLyAyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlIChhZnRlcikge1xuICAgICAgcmV0dXJuIGFmdGVyID8gbmV4dEVsKHRhcmdldCkgOiB0YXJnZXQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNDb3B5IChpdGVtLCBjb250YWluZXIpIHtcbiAgICByZXR1cm4gdHlwZW9mIG8uY29weSA9PT0gJ2Jvb2xlYW4nID8gby5jb3B5IDogby5jb3B5KGl0ZW0sIGNvbnRhaW5lcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gdG91Y2h5IChlbCwgb3AsIHR5cGUsIGZuKSB7XG4gIHZhciB0b3VjaCA9IHtcbiAgICBtb3VzZXVwOiAndG91Y2hlbmQnLFxuICAgIG1vdXNlZG93bjogJ3RvdWNoc3RhcnQnLFxuICAgIG1vdXNlbW92ZTogJ3RvdWNobW92ZSdcbiAgfTtcbiAgdmFyIHBvaW50ZXJzID0ge1xuICAgIG1vdXNldXA6ICdwb2ludGVydXAnLFxuICAgIG1vdXNlZG93bjogJ3BvaW50ZXJkb3duJyxcbiAgICBtb3VzZW1vdmU6ICdwb2ludGVybW92ZSdcbiAgfTtcbiAgdmFyIG1pY3Jvc29mdCA9IHtcbiAgICBtb3VzZXVwOiAnTVNQb2ludGVyVXAnLFxuICAgIG1vdXNlZG93bjogJ01TUG9pbnRlckRvd24nLFxuICAgIG1vdXNlbW92ZTogJ01TUG9pbnRlck1vdmUnXG4gIH07XG4gIGlmIChnbG9iYWwubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkKSB7XG4gICAgY3Jvc3N2ZW50W29wXShlbCwgcG9pbnRlcnNbdHlwZV0sIGZuKTtcbiAgfSBlbHNlIGlmIChnbG9iYWwubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQpIHtcbiAgICBjcm9zc3ZlbnRbb3BdKGVsLCBtaWNyb3NvZnRbdHlwZV0sIGZuKTtcbiAgfSBlbHNlIHtcbiAgICBjcm9zc3ZlbnRbb3BdKGVsLCB0b3VjaFt0eXBlXSwgZm4pO1xuICAgIGNyb3NzdmVudFtvcF0oZWwsIHR5cGUsIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3aGljaE1vdXNlQnV0dG9uIChlKSB7XG4gIGlmIChlLnRvdWNoZXMgIT09IHZvaWQgMCkgeyByZXR1cm4gZS50b3VjaGVzLmxlbmd0aDsgfVxuICBpZiAoZS53aGljaCAhPT0gdm9pZCAwICYmIGUud2hpY2ggIT09IDApIHsgcmV0dXJuIGUud2hpY2g7IH0gLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXZhY3F1YS9kcmFndWxhL2lzc3Vlcy8yNjFcbiAgaWYgKGUuYnV0dG9ucyAhPT0gdm9pZCAwKSB7IHJldHVybiBlLmJ1dHRvbnM7IH1cbiAgdmFyIGJ1dHRvbiA9IGUuYnV0dG9uO1xuICBpZiAoYnV0dG9uICE9PSB2b2lkIDApIHsgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvOTllOGZmMWJhYTdhZTM0MWU5NGJiODljM2U4NDU3MGM3YzNhZDllYS9zcmMvZXZlbnQuanMjTDU3My1MNTc1XG4gICAgcmV0dXJuIGJ1dHRvbiAmIDEgPyAxIDogYnV0dG9uICYgMiA/IDMgOiAoYnV0dG9uICYgNCA/IDIgOiAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXQgKGVsKSB7XG4gIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgbGVmdDogcmVjdC5sZWZ0ICsgZ2V0U2Nyb2xsKCdzY3JvbGxMZWZ0JywgJ3BhZ2VYT2Zmc2V0JyksXG4gICAgdG9wOiByZWN0LnRvcCArIGdldFNjcm9sbCgnc2Nyb2xsVG9wJywgJ3BhZ2VZT2Zmc2V0JylcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsIChzY3JvbGxQcm9wLCBvZmZzZXRQcm9wKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsW29mZnNldFByb3BdICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBnbG9iYWxbb2Zmc2V0UHJvcF07XG4gIH1cbiAgaWYgKGRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnRFbGVtZW50W3Njcm9sbFByb3BdO1xuICB9XG4gIHJldHVybiBkb2MuYm9keVtzY3JvbGxQcm9wXTtcbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudEJlaGluZFBvaW50IChwb2ludCwgeCwgeSkge1xuICB2YXIgcCA9IHBvaW50IHx8IHt9O1xuICB2YXIgc3RhdGUgPSBwLmNsYXNzTmFtZTtcbiAgdmFyIGVsO1xuICBwLmNsYXNzTmFtZSArPSAnIGd1LWhpZGUnO1xuICBlbCA9IGRvYy5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICBwLmNsYXNzTmFtZSA9IHN0YXRlO1xuICByZXR1cm4gZWw7XG59XG5cbmZ1bmN0aW9uIG5ldmVyICgpIHsgcmV0dXJuIGZhbHNlOyB9XG5mdW5jdGlvbiBhbHdheXMgKCkgeyByZXR1cm4gdHJ1ZTsgfVxuZnVuY3Rpb24gZ2V0UmVjdFdpZHRoIChyZWN0KSB7IHJldHVybiByZWN0LndpZHRoIHx8IChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KTsgfVxuZnVuY3Rpb24gZ2V0UmVjdEhlaWdodCAocmVjdCkgeyByZXR1cm4gcmVjdC5oZWlnaHQgfHwgKHJlY3QuYm90dG9tIC0gcmVjdC50b3ApOyB9XG5mdW5jdGlvbiBnZXRQYXJlbnQgKGVsKSB7IHJldHVybiBlbC5wYXJlbnROb2RlID09PSBkb2MgPyBudWxsIDogZWwucGFyZW50Tm9kZTsgfVxuZnVuY3Rpb24gaXNJbnB1dCAoZWwpIHsgcmV0dXJuIGVsLnRhZ05hbWUgPT09ICdJTlBVVCcgfHwgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyB8fCBlbC50YWdOYW1lID09PSAnU0VMRUNUJyB8fCBpc0VkaXRhYmxlKGVsKTsgfVxuZnVuY3Rpb24gaXNFZGl0YWJsZSAoZWwpIHtcbiAgaWYgKCFlbCkgeyByZXR1cm4gZmFsc2U7IH0gLy8gbm8gcGFyZW50cyB3ZXJlIGVkaXRhYmxlXG4gIGlmIChlbC5jb250ZW50RWRpdGFibGUgPT09ICdmYWxzZScpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIHN0b3AgdGhlIGxvb2t1cFxuICBpZiAoZWwuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHsgcmV0dXJuIHRydWU7IH0gLy8gZm91bmQgYSBjb250ZW50RWRpdGFibGUgZWxlbWVudCBpbiB0aGUgY2hhaW5cbiAgcmV0dXJuIGlzRWRpdGFibGUoZ2V0UGFyZW50KGVsKSk7IC8vIGNvbnRlbnRFZGl0YWJsZSBpcyBzZXQgdG8gJ2luaGVyaXQnXG59XG5cbmZ1bmN0aW9uIG5leHRFbCAoZWwpIHtcbiAgcmV0dXJuIGVsLm5leHRFbGVtZW50U2libGluZyB8fCBtYW51YWxseSgpO1xuICBmdW5jdGlvbiBtYW51YWxseSAoKSB7XG4gICAgdmFyIHNpYmxpbmcgPSBlbDtcbiAgICBkbyB7XG4gICAgICBzaWJsaW5nID0gc2libGluZy5uZXh0U2libGluZztcbiAgICB9IHdoaWxlIChzaWJsaW5nICYmIHNpYmxpbmcubm9kZVR5cGUgIT09IDEpO1xuICAgIHJldHVybiBzaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50SG9zdCAoZSkge1xuICAvLyBvbiB0b3VjaGVuZCBldmVudCwgd2UgaGF2ZSB0byB1c2UgYGUuY2hhbmdlZFRvdWNoZXNgXG4gIC8vIHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzcxOTI1NjMvdG91Y2hlbmQtZXZlbnQtcHJvcGVydGllc1xuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2JldmFjcXVhL2RyYWd1bGEvaXNzdWVzLzM0XG4gIGlmIChlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBlLnRhcmdldFRvdWNoZXNbMF07XG4gIH1cbiAgaWYgKGUuY2hhbmdlZFRvdWNoZXMgJiYgZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29vcmQgKGNvb3JkLCBlKSB7XG4gIHZhciBob3N0ID0gZ2V0RXZlbnRIb3N0KGUpO1xuICB2YXIgbWlzc01hcCA9IHtcbiAgICBwYWdlWDogJ2NsaWVudFgnLCAvLyBJRThcbiAgICBwYWdlWTogJ2NsaWVudFknIC8vIElFOFxuICB9O1xuICBpZiAoY29vcmQgaW4gbWlzc01hcCAmJiAhKGNvb3JkIGluIGhvc3QpICYmIG1pc3NNYXBbY29vcmRdIGluIGhvc3QpIHtcbiAgICBjb29yZCA9IG1pc3NNYXBbY29vcmRdO1xuICB9XG4gIHJldHVybiBob3N0W2Nvb3JkXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkcmFndWxhO1xuIiwidmFyIGVuY29kZSA9IHJlcXVpcmUoXCIuL2xpYi9lbmNvZGUuanNcIiksXG4gICAgZGVjb2RlID0gcmVxdWlyZShcIi4vbGliL2RlY29kZS5qc1wiKTtcblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihkYXRhLCBsZXZlbCl7XG5cdHJldHVybiAoIWxldmVsIHx8IGxldmVsIDw9IDAgPyBkZWNvZGUuWE1MIDogZGVjb2RlLkhUTUwpKGRhdGEpO1xufTtcblxuZXhwb3J0cy5kZWNvZGVTdHJpY3QgPSBmdW5jdGlvbihkYXRhLCBsZXZlbCl7XG5cdHJldHVybiAoIWxldmVsIHx8IGxldmVsIDw9IDAgPyBkZWNvZGUuWE1MIDogZGVjb2RlLkhUTUxTdHJpY3QpKGRhdGEpO1xufTtcblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihkYXRhLCBsZXZlbCl7XG5cdHJldHVybiAoIWxldmVsIHx8IGxldmVsIDw9IDAgPyBlbmNvZGUuWE1MIDogZW5jb2RlLkhUTUwpKGRhdGEpO1xufTtcblxuZXhwb3J0cy5lbmNvZGVYTUwgPSBlbmNvZGUuWE1MO1xuXG5leHBvcnRzLmVuY29kZUhUTUw0ID1cbmV4cG9ydHMuZW5jb2RlSFRNTDUgPVxuZXhwb3J0cy5lbmNvZGVIVE1MICA9IGVuY29kZS5IVE1MO1xuXG5leHBvcnRzLmRlY29kZVhNTCA9XG5leHBvcnRzLmRlY29kZVhNTFN0cmljdCA9IGRlY29kZS5YTUw7XG5cbmV4cG9ydHMuZGVjb2RlSFRNTDQgPVxuZXhwb3J0cy5kZWNvZGVIVE1MNSA9XG5leHBvcnRzLmRlY29kZUhUTUwgPSBkZWNvZGUuSFRNTDtcblxuZXhwb3J0cy5kZWNvZGVIVE1MNFN0cmljdCA9XG5leHBvcnRzLmRlY29kZUhUTUw1U3RyaWN0ID1cbmV4cG9ydHMuZGVjb2RlSFRNTFN0cmljdCA9IGRlY29kZS5IVE1MU3RyaWN0O1xuXG5leHBvcnRzLmVzY2FwZSA9IGVuY29kZS5lc2NhcGU7XG4iLCJ2YXIgZW50aXR5TWFwID0gcmVxdWlyZShcIi4uL21hcHMvZW50aXRpZXMuanNvblwiKSxcbiAgICBsZWdhY3lNYXAgPSByZXF1aXJlKFwiLi4vbWFwcy9sZWdhY3kuanNvblwiKSxcbiAgICB4bWxNYXAgICAgPSByZXF1aXJlKFwiLi4vbWFwcy94bWwuanNvblwiKSxcbiAgICBkZWNvZGVDb2RlUG9pbnQgPSByZXF1aXJlKFwiLi9kZWNvZGVfY29kZXBvaW50LmpzXCIpO1xuXG52YXIgZGVjb2RlWE1MU3RyaWN0ICA9IGdldFN0cmljdERlY29kZXIoeG1sTWFwKSxcbiAgICBkZWNvZGVIVE1MU3RyaWN0ID0gZ2V0U3RyaWN0RGVjb2RlcihlbnRpdHlNYXApO1xuXG5mdW5jdGlvbiBnZXRTdHJpY3REZWNvZGVyKG1hcCl7XG5cdHZhciBrZXlzID0gT2JqZWN0LmtleXMobWFwKS5qb2luKFwifFwiKSxcblx0ICAgIHJlcGxhY2UgPSBnZXRSZXBsYWNlcihtYXApO1xuXG5cdGtleXMgKz0gXCJ8I1t4WF1bXFxcXGRhLWZBLUZdK3wjXFxcXGQrXCI7XG5cblx0dmFyIHJlID0gbmV3IFJlZ0V4cChcIiYoPzpcIiArIGtleXMgKyBcIik7XCIsIFwiZ1wiKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oc3RyKXtcblx0XHRyZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZShyZSwgcmVwbGFjZSk7XG5cdH07XG59XG5cbnZhciBkZWNvZGVIVE1MID0gKGZ1bmN0aW9uKCl7XG5cdHZhciBsZWdhY3kgPSBPYmplY3Qua2V5cyhsZWdhY3lNYXApXG5cdFx0LnNvcnQoc29ydGVyKTtcblxuXHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKGVudGl0eU1hcClcblx0XHQuc29ydChzb3J0ZXIpO1xuXG5cdGZvcih2YXIgaSA9IDAsIGogPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKyl7XG5cdFx0aWYobGVnYWN5W2pdID09PSBrZXlzW2ldKXtcblx0XHRcdGtleXNbaV0gKz0gXCI7P1wiO1xuXHRcdFx0aisrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRrZXlzW2ldICs9IFwiO1wiO1xuXHRcdH1cblx0fVxuXG5cdHZhciByZSA9IG5ldyBSZWdFeHAoXCImKD86XCIgKyBrZXlzLmpvaW4oXCJ8XCIpICsgXCJ8I1t4WF1bXFxcXGRhLWZBLUZdKzs/fCNcXFxcZCs7PylcIiwgXCJnXCIpLFxuXHQgICAgcmVwbGFjZSA9IGdldFJlcGxhY2VyKGVudGl0eU1hcCk7XG5cblx0ZnVuY3Rpb24gcmVwbGFjZXIoc3RyKXtcblx0XHRpZihzdHIuc3Vic3RyKC0xKSAhPT0gXCI7XCIpIHN0ciArPSBcIjtcIjtcblx0XHRyZXR1cm4gcmVwbGFjZShzdHIpO1xuXHR9XG5cblx0Ly9UT0RPIGNvbnNpZGVyIGNyZWF0aW5nIGEgbWVyZ2VkIG1hcFxuXHRyZXR1cm4gZnVuY3Rpb24oc3RyKXtcblx0XHRyZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZShyZSwgcmVwbGFjZXIpO1xuXHR9O1xufSgpKTtcblxuZnVuY3Rpb24gc29ydGVyKGEsIGIpe1xuXHRyZXR1cm4gYSA8IGIgPyAxIDogLTE7XG59XG5cbmZ1bmN0aW9uIGdldFJlcGxhY2VyKG1hcCl7XG5cdHJldHVybiBmdW5jdGlvbiByZXBsYWNlKHN0cil7XG5cdFx0aWYoc3RyLmNoYXJBdCgxKSA9PT0gXCIjXCIpe1xuXHRcdFx0aWYoc3RyLmNoYXJBdCgyKSA9PT0gXCJYXCIgfHwgc3RyLmNoYXJBdCgyKSA9PT0gXCJ4XCIpe1xuXHRcdFx0XHRyZXR1cm4gZGVjb2RlQ29kZVBvaW50KHBhcnNlSW50KHN0ci5zdWJzdHIoMyksIDE2KSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGVjb2RlQ29kZVBvaW50KHBhcnNlSW50KHN0ci5zdWJzdHIoMiksIDEwKSk7XG5cdFx0fVxuXHRcdHJldHVybiBtYXBbc3RyLnNsaWNlKDEsIC0xKV07XG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRYTUw6IGRlY29kZVhNTFN0cmljdCxcblx0SFRNTDogZGVjb2RlSFRNTCxcblx0SFRNTFN0cmljdDogZGVjb2RlSFRNTFN0cmljdFxufTsiLCJ2YXIgZGVjb2RlTWFwID0gcmVxdWlyZShcIi4uL21hcHMvZGVjb2RlLmpzb25cIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlQ29kZVBvaW50O1xuXG4vLyBtb2RpZmllZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL2hlL2Jsb2IvbWFzdGVyL3NyYy9oZS5qcyNMOTQtTDExOVxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50KGNvZGVQb2ludCl7XG5cblx0aWYoKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikgfHwgY29kZVBvaW50ID4gMHgxMEZGRkYpe1xuXHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0fVxuXG5cdGlmKGNvZGVQb2ludCBpbiBkZWNvZGVNYXApe1xuXHRcdGNvZGVQb2ludCA9IGRlY29kZU1hcFtjb2RlUG9pbnRdO1xuXHR9XG5cblx0dmFyIG91dHB1dCA9IFwiXCI7XG5cblx0aWYoY29kZVBvaW50ID4gMHhGRkZGKXtcblx0XHRjb2RlUG9pbnQgLT0gMHgxMDAwMDtcblx0XHRvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGO1xuXHR9XG5cblx0b3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcblx0cmV0dXJuIG91dHB1dDtcbn1cbiIsInZhciBpbnZlcnNlWE1MID0gZ2V0SW52ZXJzZU9iaihyZXF1aXJlKFwiLi4vbWFwcy94bWwuanNvblwiKSksXG4gICAgeG1sUmVwbGFjZXIgPSBnZXRJbnZlcnNlUmVwbGFjZXIoaW52ZXJzZVhNTCk7XG5cbmV4cG9ydHMuWE1MID0gZ2V0SW52ZXJzZShpbnZlcnNlWE1MLCB4bWxSZXBsYWNlcik7XG5cbnZhciBpbnZlcnNlSFRNTCA9IGdldEludmVyc2VPYmoocmVxdWlyZShcIi4uL21hcHMvZW50aXRpZXMuanNvblwiKSksXG4gICAgaHRtbFJlcGxhY2VyID0gZ2V0SW52ZXJzZVJlcGxhY2VyKGludmVyc2VIVE1MKTtcblxuZXhwb3J0cy5IVE1MID0gZ2V0SW52ZXJzZShpbnZlcnNlSFRNTCwgaHRtbFJlcGxhY2VyKTtcblxuZnVuY3Rpb24gZ2V0SW52ZXJzZU9iaihvYmope1xuXHRyZXR1cm4gT2JqZWN0LmtleXMob2JqKS5zb3J0KCkucmVkdWNlKGZ1bmN0aW9uKGludmVyc2UsIG5hbWUpe1xuXHRcdGludmVyc2Vbb2JqW25hbWVdXSA9IFwiJlwiICsgbmFtZSArIFwiO1wiO1xuXHRcdHJldHVybiBpbnZlcnNlO1xuXHR9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGdldEludmVyc2VSZXBsYWNlcihpbnZlcnNlKXtcblx0dmFyIHNpbmdsZSA9IFtdLFxuXHQgICAgbXVsdGlwbGUgPSBbXTtcblxuXHRPYmplY3Qua2V5cyhpbnZlcnNlKS5mb3JFYWNoKGZ1bmN0aW9uKGspe1xuXHRcdGlmKGsubGVuZ3RoID09PSAxKXtcblx0XHRcdHNpbmdsZS5wdXNoKFwiXFxcXFwiICsgayk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG11bHRpcGxlLnB1c2goayk7XG5cdFx0fVxuXHR9KTtcblxuXHQvL1RPRE8gYWRkIHJhbmdlc1xuXHRtdWx0aXBsZS51bnNoaWZ0KFwiW1wiICsgc2luZ2xlLmpvaW4oXCJcIikgKyBcIl1cIik7XG5cblx0cmV0dXJuIG5ldyBSZWdFeHAobXVsdGlwbGUuam9pbihcInxcIiksIFwiZ1wiKTtcbn1cblxudmFyIHJlX25vbkFTQ0lJID0gL1teXFwwLVxceDdGXS9nLFxuICAgIHJlX2FzdHJhbFN5bWJvbHMgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nO1xuXG5mdW5jdGlvbiBzaW5nbGVDaGFyUmVwbGFjZXIoYyl7XG5cdHJldHVybiBcIiYjeFwiICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCI7XCI7XG59XG5cbmZ1bmN0aW9uIGFzdHJhbFJlcGxhY2VyKGMpe1xuXHQvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuXHR2YXIgaGlnaCA9IGMuY2hhckNvZGVBdCgwKTtcblx0dmFyIGxvdyAgPSBjLmNoYXJDb2RlQXQoMSk7XG5cdHZhciBjb2RlUG9pbnQgPSAoaGlnaCAtIDB4RDgwMCkgKiAweDQwMCArIGxvdyAtIDB4REMwMCArIDB4MTAwMDA7XG5cdHJldHVybiBcIiYjeFwiICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCI7XCI7XG59XG5cbmZ1bmN0aW9uIGdldEludmVyc2UoaW52ZXJzZSwgcmUpe1xuXHRmdW5jdGlvbiBmdW5jKG5hbWUpe1xuXHRcdHJldHVybiBpbnZlcnNlW25hbWVdO1xuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uKGRhdGEpe1xuXHRcdHJldHVybiBkYXRhXG5cdFx0XHRcdC5yZXBsYWNlKHJlLCBmdW5jKVxuXHRcdFx0XHQucmVwbGFjZShyZV9hc3RyYWxTeW1ib2xzLCBhc3RyYWxSZXBsYWNlcilcblx0XHRcdFx0LnJlcGxhY2UocmVfbm9uQVNDSUksIHNpbmdsZUNoYXJSZXBsYWNlcik7XG5cdH07XG59XG5cbnZhciByZV94bWxDaGFycyA9IGdldEludmVyc2VSZXBsYWNlcihpbnZlcnNlWE1MKTtcblxuZnVuY3Rpb24gZXNjYXBlWE1MKGRhdGEpe1xuXHRyZXR1cm4gZGF0YVxuXHRcdFx0LnJlcGxhY2UocmVfeG1sQ2hhcnMsIHNpbmdsZUNoYXJSZXBsYWNlcilcblx0XHRcdC5yZXBsYWNlKHJlX2FzdHJhbFN5bWJvbHMsIGFzdHJhbFJlcGxhY2VyKVxuXHRcdFx0LnJlcGxhY2UocmVfbm9uQVNDSUksIHNpbmdsZUNoYXJSZXBsYWNlcik7XG59XG5cbmV4cG9ydHMuZXNjYXBlID0gZXNjYXBlWE1MO1xuIiwibW9kdWxlLmV4cG9ydHM9e1wiMFwiOjY1NTMzLFwiMTI4XCI6ODM2NCxcIjEzMFwiOjgyMTgsXCIxMzFcIjo0MDIsXCIxMzJcIjo4MjIyLFwiMTMzXCI6ODIzMCxcIjEzNFwiOjgyMjQsXCIxMzVcIjo4MjI1LFwiMTM2XCI6NzEwLFwiMTM3XCI6ODI0MCxcIjEzOFwiOjM1MixcIjEzOVwiOjgyNDksXCIxNDBcIjozMzgsXCIxNDJcIjozODEsXCIxNDVcIjo4MjE2LFwiMTQ2XCI6ODIxNyxcIjE0N1wiOjgyMjAsXCIxNDhcIjo4MjIxLFwiMTQ5XCI6ODIyNixcIjE1MFwiOjgyMTEsXCIxNTFcIjo4MjEyLFwiMTUyXCI6NzMyLFwiMTUzXCI6ODQ4MixcIjE1NFwiOjM1MyxcIjE1NVwiOjgyNTAsXCIxNTZcIjozMzksXCIxNThcIjozODIsXCIxNTlcIjozNzZ9IiwibW9kdWxlLmV4cG9ydHM9e1wiQWFjdXRlXCI6XCJcXHUwMEMxXCIsXCJhYWN1dGVcIjpcIlxcdTAwRTFcIixcIkFicmV2ZVwiOlwiXFx1MDEwMlwiLFwiYWJyZXZlXCI6XCJcXHUwMTAzXCIsXCJhY1wiOlwiXFx1MjIzRVwiLFwiYWNkXCI6XCJcXHUyMjNGXCIsXCJhY0VcIjpcIlxcdTIyM0VcXHUwMzMzXCIsXCJBY2lyY1wiOlwiXFx1MDBDMlwiLFwiYWNpcmNcIjpcIlxcdTAwRTJcIixcImFjdXRlXCI6XCJcXHUwMEI0XCIsXCJBY3lcIjpcIlxcdTA0MTBcIixcImFjeVwiOlwiXFx1MDQzMFwiLFwiQUVsaWdcIjpcIlxcdTAwQzZcIixcImFlbGlnXCI6XCJcXHUwMEU2XCIsXCJhZlwiOlwiXFx1MjA2MVwiLFwiQWZyXCI6XCJcXHVEODM1XFx1REQwNFwiLFwiYWZyXCI6XCJcXHVEODM1XFx1REQxRVwiLFwiQWdyYXZlXCI6XCJcXHUwMEMwXCIsXCJhZ3JhdmVcIjpcIlxcdTAwRTBcIixcImFsZWZzeW1cIjpcIlxcdTIxMzVcIixcImFsZXBoXCI6XCJcXHUyMTM1XCIsXCJBbHBoYVwiOlwiXFx1MDM5MVwiLFwiYWxwaGFcIjpcIlxcdTAzQjFcIixcIkFtYWNyXCI6XCJcXHUwMTAwXCIsXCJhbWFjclwiOlwiXFx1MDEwMVwiLFwiYW1hbGdcIjpcIlxcdTJBM0ZcIixcImFtcFwiOlwiJlwiLFwiQU1QXCI6XCImXCIsXCJhbmRhbmRcIjpcIlxcdTJBNTVcIixcIkFuZFwiOlwiXFx1MkE1M1wiLFwiYW5kXCI6XCJcXHUyMjI3XCIsXCJhbmRkXCI6XCJcXHUyQTVDXCIsXCJhbmRzbG9wZVwiOlwiXFx1MkE1OFwiLFwiYW5kdlwiOlwiXFx1MkE1QVwiLFwiYW5nXCI6XCJcXHUyMjIwXCIsXCJhbmdlXCI6XCJcXHUyOUE0XCIsXCJhbmdsZVwiOlwiXFx1MjIyMFwiLFwiYW5nbXNkYWFcIjpcIlxcdTI5QThcIixcImFuZ21zZGFiXCI6XCJcXHUyOUE5XCIsXCJhbmdtc2RhY1wiOlwiXFx1MjlBQVwiLFwiYW5nbXNkYWRcIjpcIlxcdTI5QUJcIixcImFuZ21zZGFlXCI6XCJcXHUyOUFDXCIsXCJhbmdtc2RhZlwiOlwiXFx1MjlBRFwiLFwiYW5nbXNkYWdcIjpcIlxcdTI5QUVcIixcImFuZ21zZGFoXCI6XCJcXHUyOUFGXCIsXCJhbmdtc2RcIjpcIlxcdTIyMjFcIixcImFuZ3J0XCI6XCJcXHUyMjFGXCIsXCJhbmdydHZiXCI6XCJcXHUyMkJFXCIsXCJhbmdydHZiZFwiOlwiXFx1Mjk5RFwiLFwiYW5nc3BoXCI6XCJcXHUyMjIyXCIsXCJhbmdzdFwiOlwiXFx1MDBDNVwiLFwiYW5nemFyclwiOlwiXFx1MjM3Q1wiLFwiQW9nb25cIjpcIlxcdTAxMDRcIixcImFvZ29uXCI6XCJcXHUwMTA1XCIsXCJBb3BmXCI6XCJcXHVEODM1XFx1REQzOFwiLFwiYW9wZlwiOlwiXFx1RDgzNVxcdURENTJcIixcImFwYWNpclwiOlwiXFx1MkE2RlwiLFwiYXBcIjpcIlxcdTIyNDhcIixcImFwRVwiOlwiXFx1MkE3MFwiLFwiYXBlXCI6XCJcXHUyMjRBXCIsXCJhcGlkXCI6XCJcXHUyMjRCXCIsXCJhcG9zXCI6XCInXCIsXCJBcHBseUZ1bmN0aW9uXCI6XCJcXHUyMDYxXCIsXCJhcHByb3hcIjpcIlxcdTIyNDhcIixcImFwcHJveGVxXCI6XCJcXHUyMjRBXCIsXCJBcmluZ1wiOlwiXFx1MDBDNVwiLFwiYXJpbmdcIjpcIlxcdTAwRTVcIixcIkFzY3JcIjpcIlxcdUQ4MzVcXHVEQzlDXCIsXCJhc2NyXCI6XCJcXHVEODM1XFx1RENCNlwiLFwiQXNzaWduXCI6XCJcXHUyMjU0XCIsXCJhc3RcIjpcIipcIixcImFzeW1wXCI6XCJcXHUyMjQ4XCIsXCJhc3ltcGVxXCI6XCJcXHUyMjREXCIsXCJBdGlsZGVcIjpcIlxcdTAwQzNcIixcImF0aWxkZVwiOlwiXFx1MDBFM1wiLFwiQXVtbFwiOlwiXFx1MDBDNFwiLFwiYXVtbFwiOlwiXFx1MDBFNFwiLFwiYXdjb25pbnRcIjpcIlxcdTIyMzNcIixcImF3aW50XCI6XCJcXHUyQTExXCIsXCJiYWNrY29uZ1wiOlwiXFx1MjI0Q1wiLFwiYmFja2Vwc2lsb25cIjpcIlxcdTAzRjZcIixcImJhY2twcmltZVwiOlwiXFx1MjAzNVwiLFwiYmFja3NpbVwiOlwiXFx1MjIzRFwiLFwiYmFja3NpbWVxXCI6XCJcXHUyMkNEXCIsXCJCYWNrc2xhc2hcIjpcIlxcdTIyMTZcIixcIkJhcnZcIjpcIlxcdTJBRTdcIixcImJhcnZlZVwiOlwiXFx1MjJCRFwiLFwiYmFyd2VkXCI6XCJcXHUyMzA1XCIsXCJCYXJ3ZWRcIjpcIlxcdTIzMDZcIixcImJhcndlZGdlXCI6XCJcXHUyMzA1XCIsXCJiYnJrXCI6XCJcXHUyM0I1XCIsXCJiYnJrdGJya1wiOlwiXFx1MjNCNlwiLFwiYmNvbmdcIjpcIlxcdTIyNENcIixcIkJjeVwiOlwiXFx1MDQxMVwiLFwiYmN5XCI6XCJcXHUwNDMxXCIsXCJiZHF1b1wiOlwiXFx1MjAxRVwiLFwiYmVjYXVzXCI6XCJcXHUyMjM1XCIsXCJiZWNhdXNlXCI6XCJcXHUyMjM1XCIsXCJCZWNhdXNlXCI6XCJcXHUyMjM1XCIsXCJiZW1wdHl2XCI6XCJcXHUyOUIwXCIsXCJiZXBzaVwiOlwiXFx1MDNGNlwiLFwiYmVybm91XCI6XCJcXHUyMTJDXCIsXCJCZXJub3VsbGlzXCI6XCJcXHUyMTJDXCIsXCJCZXRhXCI6XCJcXHUwMzkyXCIsXCJiZXRhXCI6XCJcXHUwM0IyXCIsXCJiZXRoXCI6XCJcXHUyMTM2XCIsXCJiZXR3ZWVuXCI6XCJcXHUyMjZDXCIsXCJCZnJcIjpcIlxcdUQ4MzVcXHVERDA1XCIsXCJiZnJcIjpcIlxcdUQ4MzVcXHVERDFGXCIsXCJiaWdjYXBcIjpcIlxcdTIyQzJcIixcImJpZ2NpcmNcIjpcIlxcdTI1RUZcIixcImJpZ2N1cFwiOlwiXFx1MjJDM1wiLFwiYmlnb2RvdFwiOlwiXFx1MkEwMFwiLFwiYmlnb3BsdXNcIjpcIlxcdTJBMDFcIixcImJpZ290aW1lc1wiOlwiXFx1MkEwMlwiLFwiYmlnc3FjdXBcIjpcIlxcdTJBMDZcIixcImJpZ3N0YXJcIjpcIlxcdTI2MDVcIixcImJpZ3RyaWFuZ2xlZG93blwiOlwiXFx1MjVCRFwiLFwiYmlndHJpYW5nbGV1cFwiOlwiXFx1MjVCM1wiLFwiYmlndXBsdXNcIjpcIlxcdTJBMDRcIixcImJpZ3ZlZVwiOlwiXFx1MjJDMVwiLFwiYmlnd2VkZ2VcIjpcIlxcdTIyQzBcIixcImJrYXJvd1wiOlwiXFx1MjkwRFwiLFwiYmxhY2tsb3plbmdlXCI6XCJcXHUyOUVCXCIsXCJibGFja3NxdWFyZVwiOlwiXFx1MjVBQVwiLFwiYmxhY2t0cmlhbmdsZVwiOlwiXFx1MjVCNFwiLFwiYmxhY2t0cmlhbmdsZWRvd25cIjpcIlxcdTI1QkVcIixcImJsYWNrdHJpYW5nbGVsZWZ0XCI6XCJcXHUyNUMyXCIsXCJibGFja3RyaWFuZ2xlcmlnaHRcIjpcIlxcdTI1QjhcIixcImJsYW5rXCI6XCJcXHUyNDIzXCIsXCJibGsxMlwiOlwiXFx1MjU5MlwiLFwiYmxrMTRcIjpcIlxcdTI1OTFcIixcImJsazM0XCI6XCJcXHUyNTkzXCIsXCJibG9ja1wiOlwiXFx1MjU4OFwiLFwiYm5lXCI6XCI9XFx1MjBFNVwiLFwiYm5lcXVpdlwiOlwiXFx1MjI2MVxcdTIwRTVcIixcImJOb3RcIjpcIlxcdTJBRURcIixcImJub3RcIjpcIlxcdTIzMTBcIixcIkJvcGZcIjpcIlxcdUQ4MzVcXHVERDM5XCIsXCJib3BmXCI6XCJcXHVEODM1XFx1REQ1M1wiLFwiYm90XCI6XCJcXHUyMkE1XCIsXCJib3R0b21cIjpcIlxcdTIyQTVcIixcImJvd3RpZVwiOlwiXFx1MjJDOFwiLFwiYm94Ym94XCI6XCJcXHUyOUM5XCIsXCJib3hkbFwiOlwiXFx1MjUxMFwiLFwiYm94ZExcIjpcIlxcdTI1NTVcIixcImJveERsXCI6XCJcXHUyNTU2XCIsXCJib3hETFwiOlwiXFx1MjU1N1wiLFwiYm94ZHJcIjpcIlxcdTI1MENcIixcImJveGRSXCI6XCJcXHUyNTUyXCIsXCJib3hEclwiOlwiXFx1MjU1M1wiLFwiYm94RFJcIjpcIlxcdTI1NTRcIixcImJveGhcIjpcIlxcdTI1MDBcIixcImJveEhcIjpcIlxcdTI1NTBcIixcImJveGhkXCI6XCJcXHUyNTJDXCIsXCJib3hIZFwiOlwiXFx1MjU2NFwiLFwiYm94aERcIjpcIlxcdTI1NjVcIixcImJveEhEXCI6XCJcXHUyNTY2XCIsXCJib3hodVwiOlwiXFx1MjUzNFwiLFwiYm94SHVcIjpcIlxcdTI1NjdcIixcImJveGhVXCI6XCJcXHUyNTY4XCIsXCJib3hIVVwiOlwiXFx1MjU2OVwiLFwiYm94bWludXNcIjpcIlxcdTIyOUZcIixcImJveHBsdXNcIjpcIlxcdTIyOUVcIixcImJveHRpbWVzXCI6XCJcXHUyMkEwXCIsXCJib3h1bFwiOlwiXFx1MjUxOFwiLFwiYm94dUxcIjpcIlxcdTI1NUJcIixcImJveFVsXCI6XCJcXHUyNTVDXCIsXCJib3hVTFwiOlwiXFx1MjU1RFwiLFwiYm94dXJcIjpcIlxcdTI1MTRcIixcImJveHVSXCI6XCJcXHUyNTU4XCIsXCJib3hVclwiOlwiXFx1MjU1OVwiLFwiYm94VVJcIjpcIlxcdTI1NUFcIixcImJveHZcIjpcIlxcdTI1MDJcIixcImJveFZcIjpcIlxcdTI1NTFcIixcImJveHZoXCI6XCJcXHUyNTNDXCIsXCJib3h2SFwiOlwiXFx1MjU2QVwiLFwiYm94VmhcIjpcIlxcdTI1NkJcIixcImJveFZIXCI6XCJcXHUyNTZDXCIsXCJib3h2bFwiOlwiXFx1MjUyNFwiLFwiYm94dkxcIjpcIlxcdTI1NjFcIixcImJveFZsXCI6XCJcXHUyNTYyXCIsXCJib3hWTFwiOlwiXFx1MjU2M1wiLFwiYm94dnJcIjpcIlxcdTI1MUNcIixcImJveHZSXCI6XCJcXHUyNTVFXCIsXCJib3hWclwiOlwiXFx1MjU1RlwiLFwiYm94VlJcIjpcIlxcdTI1NjBcIixcImJwcmltZVwiOlwiXFx1MjAzNVwiLFwiYnJldmVcIjpcIlxcdTAyRDhcIixcIkJyZXZlXCI6XCJcXHUwMkQ4XCIsXCJicnZiYXJcIjpcIlxcdTAwQTZcIixcImJzY3JcIjpcIlxcdUQ4MzVcXHVEQ0I3XCIsXCJCc2NyXCI6XCJcXHUyMTJDXCIsXCJic2VtaVwiOlwiXFx1MjA0RlwiLFwiYnNpbVwiOlwiXFx1MjIzRFwiLFwiYnNpbWVcIjpcIlxcdTIyQ0RcIixcImJzb2xiXCI6XCJcXHUyOUM1XCIsXCJic29sXCI6XCJcXFxcXCIsXCJic29saHN1YlwiOlwiXFx1MjdDOFwiLFwiYnVsbFwiOlwiXFx1MjAyMlwiLFwiYnVsbGV0XCI6XCJcXHUyMDIyXCIsXCJidW1wXCI6XCJcXHUyMjRFXCIsXCJidW1wRVwiOlwiXFx1MkFBRVwiLFwiYnVtcGVcIjpcIlxcdTIyNEZcIixcIkJ1bXBlcVwiOlwiXFx1MjI0RVwiLFwiYnVtcGVxXCI6XCJcXHUyMjRGXCIsXCJDYWN1dGVcIjpcIlxcdTAxMDZcIixcImNhY3V0ZVwiOlwiXFx1MDEwN1wiLFwiY2FwYW5kXCI6XCJcXHUyQTQ0XCIsXCJjYXBicmN1cFwiOlwiXFx1MkE0OVwiLFwiY2FwY2FwXCI6XCJcXHUyQTRCXCIsXCJjYXBcIjpcIlxcdTIyMjlcIixcIkNhcFwiOlwiXFx1MjJEMlwiLFwiY2FwY3VwXCI6XCJcXHUyQTQ3XCIsXCJjYXBkb3RcIjpcIlxcdTJBNDBcIixcIkNhcGl0YWxEaWZmZXJlbnRpYWxEXCI6XCJcXHUyMTQ1XCIsXCJjYXBzXCI6XCJcXHUyMjI5XFx1RkUwMFwiLFwiY2FyZXRcIjpcIlxcdTIwNDFcIixcImNhcm9uXCI6XCJcXHUwMkM3XCIsXCJDYXlsZXlzXCI6XCJcXHUyMTJEXCIsXCJjY2Fwc1wiOlwiXFx1MkE0RFwiLFwiQ2Nhcm9uXCI6XCJcXHUwMTBDXCIsXCJjY2Fyb25cIjpcIlxcdTAxMERcIixcIkNjZWRpbFwiOlwiXFx1MDBDN1wiLFwiY2NlZGlsXCI6XCJcXHUwMEU3XCIsXCJDY2lyY1wiOlwiXFx1MDEwOFwiLFwiY2NpcmNcIjpcIlxcdTAxMDlcIixcIkNjb25pbnRcIjpcIlxcdTIyMzBcIixcImNjdXBzXCI6XCJcXHUyQTRDXCIsXCJjY3Vwc3NtXCI6XCJcXHUyQTUwXCIsXCJDZG90XCI6XCJcXHUwMTBBXCIsXCJjZG90XCI6XCJcXHUwMTBCXCIsXCJjZWRpbFwiOlwiXFx1MDBCOFwiLFwiQ2VkaWxsYVwiOlwiXFx1MDBCOFwiLFwiY2VtcHR5dlwiOlwiXFx1MjlCMlwiLFwiY2VudFwiOlwiXFx1MDBBMlwiLFwiY2VudGVyZG90XCI6XCJcXHUwMEI3XCIsXCJDZW50ZXJEb3RcIjpcIlxcdTAwQjdcIixcImNmclwiOlwiXFx1RDgzNVxcdUREMjBcIixcIkNmclwiOlwiXFx1MjEyRFwiLFwiQ0hjeVwiOlwiXFx1MDQyN1wiLFwiY2hjeVwiOlwiXFx1MDQ0N1wiLFwiY2hlY2tcIjpcIlxcdTI3MTNcIixcImNoZWNrbWFya1wiOlwiXFx1MjcxM1wiLFwiQ2hpXCI6XCJcXHUwM0E3XCIsXCJjaGlcIjpcIlxcdTAzQzdcIixcImNpcmNcIjpcIlxcdTAyQzZcIixcImNpcmNlcVwiOlwiXFx1MjI1N1wiLFwiY2lyY2xlYXJyb3dsZWZ0XCI6XCJcXHUyMUJBXCIsXCJjaXJjbGVhcnJvd3JpZ2h0XCI6XCJcXHUyMUJCXCIsXCJjaXJjbGVkYXN0XCI6XCJcXHUyMjlCXCIsXCJjaXJjbGVkY2lyY1wiOlwiXFx1MjI5QVwiLFwiY2lyY2xlZGRhc2hcIjpcIlxcdTIyOURcIixcIkNpcmNsZURvdFwiOlwiXFx1MjI5OVwiLFwiY2lyY2xlZFJcIjpcIlxcdTAwQUVcIixcImNpcmNsZWRTXCI6XCJcXHUyNEM4XCIsXCJDaXJjbGVNaW51c1wiOlwiXFx1MjI5NlwiLFwiQ2lyY2xlUGx1c1wiOlwiXFx1MjI5NVwiLFwiQ2lyY2xlVGltZXNcIjpcIlxcdTIyOTdcIixcImNpclwiOlwiXFx1MjVDQlwiLFwiY2lyRVwiOlwiXFx1MjlDM1wiLFwiY2lyZVwiOlwiXFx1MjI1N1wiLFwiY2lyZm5pbnRcIjpcIlxcdTJBMTBcIixcImNpcm1pZFwiOlwiXFx1MkFFRlwiLFwiY2lyc2NpclwiOlwiXFx1MjlDMlwiLFwiQ2xvY2t3aXNlQ29udG91ckludGVncmFsXCI6XCJcXHUyMjMyXCIsXCJDbG9zZUN1cmx5RG91YmxlUXVvdGVcIjpcIlxcdTIwMURcIixcIkNsb3NlQ3VybHlRdW90ZVwiOlwiXFx1MjAxOVwiLFwiY2x1YnNcIjpcIlxcdTI2NjNcIixcImNsdWJzdWl0XCI6XCJcXHUyNjYzXCIsXCJjb2xvblwiOlwiOlwiLFwiQ29sb25cIjpcIlxcdTIyMzdcIixcIkNvbG9uZVwiOlwiXFx1MkE3NFwiLFwiY29sb25lXCI6XCJcXHUyMjU0XCIsXCJjb2xvbmVxXCI6XCJcXHUyMjU0XCIsXCJjb21tYVwiOlwiLFwiLFwiY29tbWF0XCI6XCJAXCIsXCJjb21wXCI6XCJcXHUyMjAxXCIsXCJjb21wZm5cIjpcIlxcdTIyMThcIixcImNvbXBsZW1lbnRcIjpcIlxcdTIyMDFcIixcImNvbXBsZXhlc1wiOlwiXFx1MjEwMlwiLFwiY29uZ1wiOlwiXFx1MjI0NVwiLFwiY29uZ2RvdFwiOlwiXFx1MkE2RFwiLFwiQ29uZ3J1ZW50XCI6XCJcXHUyMjYxXCIsXCJjb25pbnRcIjpcIlxcdTIyMkVcIixcIkNvbmludFwiOlwiXFx1MjIyRlwiLFwiQ29udG91ckludGVncmFsXCI6XCJcXHUyMjJFXCIsXCJjb3BmXCI6XCJcXHVEODM1XFx1REQ1NFwiLFwiQ29wZlwiOlwiXFx1MjEwMlwiLFwiY29wcm9kXCI6XCJcXHUyMjEwXCIsXCJDb3Byb2R1Y3RcIjpcIlxcdTIyMTBcIixcImNvcHlcIjpcIlxcdTAwQTlcIixcIkNPUFlcIjpcIlxcdTAwQTlcIixcImNvcHlzclwiOlwiXFx1MjExN1wiLFwiQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbFwiOlwiXFx1MjIzM1wiLFwiY3JhcnJcIjpcIlxcdTIxQjVcIixcImNyb3NzXCI6XCJcXHUyNzE3XCIsXCJDcm9zc1wiOlwiXFx1MkEyRlwiLFwiQ3NjclwiOlwiXFx1RDgzNVxcdURDOUVcIixcImNzY3JcIjpcIlxcdUQ4MzVcXHVEQ0I4XCIsXCJjc3ViXCI6XCJcXHUyQUNGXCIsXCJjc3ViZVwiOlwiXFx1MkFEMVwiLFwiY3N1cFwiOlwiXFx1MkFEMFwiLFwiY3N1cGVcIjpcIlxcdTJBRDJcIixcImN0ZG90XCI6XCJcXHUyMkVGXCIsXCJjdWRhcnJsXCI6XCJcXHUyOTM4XCIsXCJjdWRhcnJyXCI6XCJcXHUyOTM1XCIsXCJjdWVwclwiOlwiXFx1MjJERVwiLFwiY3Vlc2NcIjpcIlxcdTIyREZcIixcImN1bGFyclwiOlwiXFx1MjFCNlwiLFwiY3VsYXJycFwiOlwiXFx1MjkzRFwiLFwiY3VwYnJjYXBcIjpcIlxcdTJBNDhcIixcImN1cGNhcFwiOlwiXFx1MkE0NlwiLFwiQ3VwQ2FwXCI6XCJcXHUyMjREXCIsXCJjdXBcIjpcIlxcdTIyMkFcIixcIkN1cFwiOlwiXFx1MjJEM1wiLFwiY3VwY3VwXCI6XCJcXHUyQTRBXCIsXCJjdXBkb3RcIjpcIlxcdTIyOERcIixcImN1cG9yXCI6XCJcXHUyQTQ1XCIsXCJjdXBzXCI6XCJcXHUyMjJBXFx1RkUwMFwiLFwiY3VyYXJyXCI6XCJcXHUyMUI3XCIsXCJjdXJhcnJtXCI6XCJcXHUyOTNDXCIsXCJjdXJseWVxcHJlY1wiOlwiXFx1MjJERVwiLFwiY3VybHllcXN1Y2NcIjpcIlxcdTIyREZcIixcImN1cmx5dmVlXCI6XCJcXHUyMkNFXCIsXCJjdXJseXdlZGdlXCI6XCJcXHUyMkNGXCIsXCJjdXJyZW5cIjpcIlxcdTAwQTRcIixcImN1cnZlYXJyb3dsZWZ0XCI6XCJcXHUyMUI2XCIsXCJjdXJ2ZWFycm93cmlnaHRcIjpcIlxcdTIxQjdcIixcImN1dmVlXCI6XCJcXHUyMkNFXCIsXCJjdXdlZFwiOlwiXFx1MjJDRlwiLFwiY3djb25pbnRcIjpcIlxcdTIyMzJcIixcImN3aW50XCI6XCJcXHUyMjMxXCIsXCJjeWxjdHlcIjpcIlxcdTIzMkRcIixcImRhZ2dlclwiOlwiXFx1MjAyMFwiLFwiRGFnZ2VyXCI6XCJcXHUyMDIxXCIsXCJkYWxldGhcIjpcIlxcdTIxMzhcIixcImRhcnJcIjpcIlxcdTIxOTNcIixcIkRhcnJcIjpcIlxcdTIxQTFcIixcImRBcnJcIjpcIlxcdTIxRDNcIixcImRhc2hcIjpcIlxcdTIwMTBcIixcIkRhc2h2XCI6XCJcXHUyQUU0XCIsXCJkYXNodlwiOlwiXFx1MjJBM1wiLFwiZGJrYXJvd1wiOlwiXFx1MjkwRlwiLFwiZGJsYWNcIjpcIlxcdTAyRERcIixcIkRjYXJvblwiOlwiXFx1MDEwRVwiLFwiZGNhcm9uXCI6XCJcXHUwMTBGXCIsXCJEY3lcIjpcIlxcdTA0MTRcIixcImRjeVwiOlwiXFx1MDQzNFwiLFwiZGRhZ2dlclwiOlwiXFx1MjAyMVwiLFwiZGRhcnJcIjpcIlxcdTIxQ0FcIixcIkREXCI6XCJcXHUyMTQ1XCIsXCJkZFwiOlwiXFx1MjE0NlwiLFwiRERvdHJhaGRcIjpcIlxcdTI5MTFcIixcImRkb3RzZXFcIjpcIlxcdTJBNzdcIixcImRlZ1wiOlwiXFx1MDBCMFwiLFwiRGVsXCI6XCJcXHUyMjA3XCIsXCJEZWx0YVwiOlwiXFx1MDM5NFwiLFwiZGVsdGFcIjpcIlxcdTAzQjRcIixcImRlbXB0eXZcIjpcIlxcdTI5QjFcIixcImRmaXNodFwiOlwiXFx1Mjk3RlwiLFwiRGZyXCI6XCJcXHVEODM1XFx1REQwN1wiLFwiZGZyXCI6XCJcXHVEODM1XFx1REQyMVwiLFwiZEhhclwiOlwiXFx1Mjk2NVwiLFwiZGhhcmxcIjpcIlxcdTIxQzNcIixcImRoYXJyXCI6XCJcXHUyMUMyXCIsXCJEaWFjcml0aWNhbEFjdXRlXCI6XCJcXHUwMEI0XCIsXCJEaWFjcml0aWNhbERvdFwiOlwiXFx1MDJEOVwiLFwiRGlhY3JpdGljYWxEb3VibGVBY3V0ZVwiOlwiXFx1MDJERFwiLFwiRGlhY3JpdGljYWxHcmF2ZVwiOlwiYFwiLFwiRGlhY3JpdGljYWxUaWxkZVwiOlwiXFx1MDJEQ1wiLFwiZGlhbVwiOlwiXFx1MjJDNFwiLFwiZGlhbW9uZFwiOlwiXFx1MjJDNFwiLFwiRGlhbW9uZFwiOlwiXFx1MjJDNFwiLFwiZGlhbW9uZHN1aXRcIjpcIlxcdTI2NjZcIixcImRpYW1zXCI6XCJcXHUyNjY2XCIsXCJkaWVcIjpcIlxcdTAwQThcIixcIkRpZmZlcmVudGlhbERcIjpcIlxcdTIxNDZcIixcImRpZ2FtbWFcIjpcIlxcdTAzRERcIixcImRpc2luXCI6XCJcXHUyMkYyXCIsXCJkaXZcIjpcIlxcdTAwRjdcIixcImRpdmlkZVwiOlwiXFx1MDBGN1wiLFwiZGl2aWRlb250aW1lc1wiOlwiXFx1MjJDN1wiLFwiZGl2b254XCI6XCJcXHUyMkM3XCIsXCJESmN5XCI6XCJcXHUwNDAyXCIsXCJkamN5XCI6XCJcXHUwNDUyXCIsXCJkbGNvcm5cIjpcIlxcdTIzMUVcIixcImRsY3JvcFwiOlwiXFx1MjMwRFwiLFwiZG9sbGFyXCI6XCIkXCIsXCJEb3BmXCI6XCJcXHVEODM1XFx1REQzQlwiLFwiZG9wZlwiOlwiXFx1RDgzNVxcdURENTVcIixcIkRvdFwiOlwiXFx1MDBBOFwiLFwiZG90XCI6XCJcXHUwMkQ5XCIsXCJEb3REb3RcIjpcIlxcdTIwRENcIixcImRvdGVxXCI6XCJcXHUyMjUwXCIsXCJkb3RlcWRvdFwiOlwiXFx1MjI1MVwiLFwiRG90RXF1YWxcIjpcIlxcdTIyNTBcIixcImRvdG1pbnVzXCI6XCJcXHUyMjM4XCIsXCJkb3RwbHVzXCI6XCJcXHUyMjE0XCIsXCJkb3RzcXVhcmVcIjpcIlxcdTIyQTFcIixcImRvdWJsZWJhcndlZGdlXCI6XCJcXHUyMzA2XCIsXCJEb3VibGVDb250b3VySW50ZWdyYWxcIjpcIlxcdTIyMkZcIixcIkRvdWJsZURvdFwiOlwiXFx1MDBBOFwiLFwiRG91YmxlRG93bkFycm93XCI6XCJcXHUyMUQzXCIsXCJEb3VibGVMZWZ0QXJyb3dcIjpcIlxcdTIxRDBcIixcIkRvdWJsZUxlZnRSaWdodEFycm93XCI6XCJcXHUyMUQ0XCIsXCJEb3VibGVMZWZ0VGVlXCI6XCJcXHUyQUU0XCIsXCJEb3VibGVMb25nTGVmdEFycm93XCI6XCJcXHUyN0Y4XCIsXCJEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3dcIjpcIlxcdTI3RkFcIixcIkRvdWJsZUxvbmdSaWdodEFycm93XCI6XCJcXHUyN0Y5XCIsXCJEb3VibGVSaWdodEFycm93XCI6XCJcXHUyMUQyXCIsXCJEb3VibGVSaWdodFRlZVwiOlwiXFx1MjJBOFwiLFwiRG91YmxlVXBBcnJvd1wiOlwiXFx1MjFEMVwiLFwiRG91YmxlVXBEb3duQXJyb3dcIjpcIlxcdTIxRDVcIixcIkRvdWJsZVZlcnRpY2FsQmFyXCI6XCJcXHUyMjI1XCIsXCJEb3duQXJyb3dCYXJcIjpcIlxcdTI5MTNcIixcImRvd25hcnJvd1wiOlwiXFx1MjE5M1wiLFwiRG93bkFycm93XCI6XCJcXHUyMTkzXCIsXCJEb3duYXJyb3dcIjpcIlxcdTIxRDNcIixcIkRvd25BcnJvd1VwQXJyb3dcIjpcIlxcdTIxRjVcIixcIkRvd25CcmV2ZVwiOlwiXFx1MDMxMVwiLFwiZG93bmRvd25hcnJvd3NcIjpcIlxcdTIxQ0FcIixcImRvd25oYXJwb29ubGVmdFwiOlwiXFx1MjFDM1wiLFwiZG93bmhhcnBvb25yaWdodFwiOlwiXFx1MjFDMlwiLFwiRG93bkxlZnRSaWdodFZlY3RvclwiOlwiXFx1Mjk1MFwiLFwiRG93bkxlZnRUZWVWZWN0b3JcIjpcIlxcdTI5NUVcIixcIkRvd25MZWZ0VmVjdG9yQmFyXCI6XCJcXHUyOTU2XCIsXCJEb3duTGVmdFZlY3RvclwiOlwiXFx1MjFCRFwiLFwiRG93blJpZ2h0VGVlVmVjdG9yXCI6XCJcXHUyOTVGXCIsXCJEb3duUmlnaHRWZWN0b3JCYXJcIjpcIlxcdTI5NTdcIixcIkRvd25SaWdodFZlY3RvclwiOlwiXFx1MjFDMVwiLFwiRG93blRlZUFycm93XCI6XCJcXHUyMUE3XCIsXCJEb3duVGVlXCI6XCJcXHUyMkE0XCIsXCJkcmJrYXJvd1wiOlwiXFx1MjkxMFwiLFwiZHJjb3JuXCI6XCJcXHUyMzFGXCIsXCJkcmNyb3BcIjpcIlxcdTIzMENcIixcIkRzY3JcIjpcIlxcdUQ4MzVcXHVEQzlGXCIsXCJkc2NyXCI6XCJcXHVEODM1XFx1RENCOVwiLFwiRFNjeVwiOlwiXFx1MDQwNVwiLFwiZHNjeVwiOlwiXFx1MDQ1NVwiLFwiZHNvbFwiOlwiXFx1MjlGNlwiLFwiRHN0cm9rXCI6XCJcXHUwMTEwXCIsXCJkc3Ryb2tcIjpcIlxcdTAxMTFcIixcImR0ZG90XCI6XCJcXHUyMkYxXCIsXCJkdHJpXCI6XCJcXHUyNUJGXCIsXCJkdHJpZlwiOlwiXFx1MjVCRVwiLFwiZHVhcnJcIjpcIlxcdTIxRjVcIixcImR1aGFyXCI6XCJcXHUyOTZGXCIsXCJkd2FuZ2xlXCI6XCJcXHUyOUE2XCIsXCJEWmN5XCI6XCJcXHUwNDBGXCIsXCJkemN5XCI6XCJcXHUwNDVGXCIsXCJkemlncmFyclwiOlwiXFx1MjdGRlwiLFwiRWFjdXRlXCI6XCJcXHUwMEM5XCIsXCJlYWN1dGVcIjpcIlxcdTAwRTlcIixcImVhc3RlclwiOlwiXFx1MkE2RVwiLFwiRWNhcm9uXCI6XCJcXHUwMTFBXCIsXCJlY2Fyb25cIjpcIlxcdTAxMUJcIixcIkVjaXJjXCI6XCJcXHUwMENBXCIsXCJlY2lyY1wiOlwiXFx1MDBFQVwiLFwiZWNpclwiOlwiXFx1MjI1NlwiLFwiZWNvbG9uXCI6XCJcXHUyMjU1XCIsXCJFY3lcIjpcIlxcdTA0MkRcIixcImVjeVwiOlwiXFx1MDQ0RFwiLFwiZUREb3RcIjpcIlxcdTJBNzdcIixcIkVkb3RcIjpcIlxcdTAxMTZcIixcImVkb3RcIjpcIlxcdTAxMTdcIixcImVEb3RcIjpcIlxcdTIyNTFcIixcImVlXCI6XCJcXHUyMTQ3XCIsXCJlZkRvdFwiOlwiXFx1MjI1MlwiLFwiRWZyXCI6XCJcXHVEODM1XFx1REQwOFwiLFwiZWZyXCI6XCJcXHVEODM1XFx1REQyMlwiLFwiZWdcIjpcIlxcdTJBOUFcIixcIkVncmF2ZVwiOlwiXFx1MDBDOFwiLFwiZWdyYXZlXCI6XCJcXHUwMEU4XCIsXCJlZ3NcIjpcIlxcdTJBOTZcIixcImVnc2RvdFwiOlwiXFx1MkE5OFwiLFwiZWxcIjpcIlxcdTJBOTlcIixcIkVsZW1lbnRcIjpcIlxcdTIyMDhcIixcImVsaW50ZXJzXCI6XCJcXHUyM0U3XCIsXCJlbGxcIjpcIlxcdTIxMTNcIixcImVsc1wiOlwiXFx1MkE5NVwiLFwiZWxzZG90XCI6XCJcXHUyQTk3XCIsXCJFbWFjclwiOlwiXFx1MDExMlwiLFwiZW1hY3JcIjpcIlxcdTAxMTNcIixcImVtcHR5XCI6XCJcXHUyMjA1XCIsXCJlbXB0eXNldFwiOlwiXFx1MjIwNVwiLFwiRW1wdHlTbWFsbFNxdWFyZVwiOlwiXFx1MjVGQlwiLFwiZW1wdHl2XCI6XCJcXHUyMjA1XCIsXCJFbXB0eVZlcnlTbWFsbFNxdWFyZVwiOlwiXFx1MjVBQlwiLFwiZW1zcDEzXCI6XCJcXHUyMDA0XCIsXCJlbXNwMTRcIjpcIlxcdTIwMDVcIixcImVtc3BcIjpcIlxcdTIwMDNcIixcIkVOR1wiOlwiXFx1MDE0QVwiLFwiZW5nXCI6XCJcXHUwMTRCXCIsXCJlbnNwXCI6XCJcXHUyMDAyXCIsXCJFb2dvblwiOlwiXFx1MDExOFwiLFwiZW9nb25cIjpcIlxcdTAxMTlcIixcIkVvcGZcIjpcIlxcdUQ4MzVcXHVERDNDXCIsXCJlb3BmXCI6XCJcXHVEODM1XFx1REQ1NlwiLFwiZXBhclwiOlwiXFx1MjJENVwiLFwiZXBhcnNsXCI6XCJcXHUyOUUzXCIsXCJlcGx1c1wiOlwiXFx1MkE3MVwiLFwiZXBzaVwiOlwiXFx1MDNCNVwiLFwiRXBzaWxvblwiOlwiXFx1MDM5NVwiLFwiZXBzaWxvblwiOlwiXFx1MDNCNVwiLFwiZXBzaXZcIjpcIlxcdTAzRjVcIixcImVxY2lyY1wiOlwiXFx1MjI1NlwiLFwiZXFjb2xvblwiOlwiXFx1MjI1NVwiLFwiZXFzaW1cIjpcIlxcdTIyNDJcIixcImVxc2xhbnRndHJcIjpcIlxcdTJBOTZcIixcImVxc2xhbnRsZXNzXCI6XCJcXHUyQTk1XCIsXCJFcXVhbFwiOlwiXFx1MkE3NVwiLFwiZXF1YWxzXCI6XCI9XCIsXCJFcXVhbFRpbGRlXCI6XCJcXHUyMjQyXCIsXCJlcXVlc3RcIjpcIlxcdTIyNUZcIixcIkVxdWlsaWJyaXVtXCI6XCJcXHUyMUNDXCIsXCJlcXVpdlwiOlwiXFx1MjI2MVwiLFwiZXF1aXZERFwiOlwiXFx1MkE3OFwiLFwiZXF2cGFyc2xcIjpcIlxcdTI5RTVcIixcImVyYXJyXCI6XCJcXHUyOTcxXCIsXCJlckRvdFwiOlwiXFx1MjI1M1wiLFwiZXNjclwiOlwiXFx1MjEyRlwiLFwiRXNjclwiOlwiXFx1MjEzMFwiLFwiZXNkb3RcIjpcIlxcdTIyNTBcIixcIkVzaW1cIjpcIlxcdTJBNzNcIixcImVzaW1cIjpcIlxcdTIyNDJcIixcIkV0YVwiOlwiXFx1MDM5N1wiLFwiZXRhXCI6XCJcXHUwM0I3XCIsXCJFVEhcIjpcIlxcdTAwRDBcIixcImV0aFwiOlwiXFx1MDBGMFwiLFwiRXVtbFwiOlwiXFx1MDBDQlwiLFwiZXVtbFwiOlwiXFx1MDBFQlwiLFwiZXVyb1wiOlwiXFx1MjBBQ1wiLFwiZXhjbFwiOlwiIVwiLFwiZXhpc3RcIjpcIlxcdTIyMDNcIixcIkV4aXN0c1wiOlwiXFx1MjIwM1wiLFwiZXhwZWN0YXRpb25cIjpcIlxcdTIxMzBcIixcImV4cG9uZW50aWFsZVwiOlwiXFx1MjE0N1wiLFwiRXhwb25lbnRpYWxFXCI6XCJcXHUyMTQ3XCIsXCJmYWxsaW5nZG90c2VxXCI6XCJcXHUyMjUyXCIsXCJGY3lcIjpcIlxcdTA0MjRcIixcImZjeVwiOlwiXFx1MDQ0NFwiLFwiZmVtYWxlXCI6XCJcXHUyNjQwXCIsXCJmZmlsaWdcIjpcIlxcdUZCMDNcIixcImZmbGlnXCI6XCJcXHVGQjAwXCIsXCJmZmxsaWdcIjpcIlxcdUZCMDRcIixcIkZmclwiOlwiXFx1RDgzNVxcdUREMDlcIixcImZmclwiOlwiXFx1RDgzNVxcdUREMjNcIixcImZpbGlnXCI6XCJcXHVGQjAxXCIsXCJGaWxsZWRTbWFsbFNxdWFyZVwiOlwiXFx1MjVGQ1wiLFwiRmlsbGVkVmVyeVNtYWxsU3F1YXJlXCI6XCJcXHUyNUFBXCIsXCJmamxpZ1wiOlwiZmpcIixcImZsYXRcIjpcIlxcdTI2NkRcIixcImZsbGlnXCI6XCJcXHVGQjAyXCIsXCJmbHRuc1wiOlwiXFx1MjVCMVwiLFwiZm5vZlwiOlwiXFx1MDE5MlwiLFwiRm9wZlwiOlwiXFx1RDgzNVxcdUREM0RcIixcImZvcGZcIjpcIlxcdUQ4MzVcXHVERDU3XCIsXCJmb3JhbGxcIjpcIlxcdTIyMDBcIixcIkZvckFsbFwiOlwiXFx1MjIwMFwiLFwiZm9ya1wiOlwiXFx1MjJENFwiLFwiZm9ya3ZcIjpcIlxcdTJBRDlcIixcIkZvdXJpZXJ0cmZcIjpcIlxcdTIxMzFcIixcImZwYXJ0aW50XCI6XCJcXHUyQTBEXCIsXCJmcmFjMTJcIjpcIlxcdTAwQkRcIixcImZyYWMxM1wiOlwiXFx1MjE1M1wiLFwiZnJhYzE0XCI6XCJcXHUwMEJDXCIsXCJmcmFjMTVcIjpcIlxcdTIxNTVcIixcImZyYWMxNlwiOlwiXFx1MjE1OVwiLFwiZnJhYzE4XCI6XCJcXHUyMTVCXCIsXCJmcmFjMjNcIjpcIlxcdTIxNTRcIixcImZyYWMyNVwiOlwiXFx1MjE1NlwiLFwiZnJhYzM0XCI6XCJcXHUwMEJFXCIsXCJmcmFjMzVcIjpcIlxcdTIxNTdcIixcImZyYWMzOFwiOlwiXFx1MjE1Q1wiLFwiZnJhYzQ1XCI6XCJcXHUyMTU4XCIsXCJmcmFjNTZcIjpcIlxcdTIxNUFcIixcImZyYWM1OFwiOlwiXFx1MjE1RFwiLFwiZnJhYzc4XCI6XCJcXHUyMTVFXCIsXCJmcmFzbFwiOlwiXFx1MjA0NFwiLFwiZnJvd25cIjpcIlxcdTIzMjJcIixcImZzY3JcIjpcIlxcdUQ4MzVcXHVEQ0JCXCIsXCJGc2NyXCI6XCJcXHUyMTMxXCIsXCJnYWN1dGVcIjpcIlxcdTAxRjVcIixcIkdhbW1hXCI6XCJcXHUwMzkzXCIsXCJnYW1tYVwiOlwiXFx1MDNCM1wiLFwiR2FtbWFkXCI6XCJcXHUwM0RDXCIsXCJnYW1tYWRcIjpcIlxcdTAzRERcIixcImdhcFwiOlwiXFx1MkE4NlwiLFwiR2JyZXZlXCI6XCJcXHUwMTFFXCIsXCJnYnJldmVcIjpcIlxcdTAxMUZcIixcIkdjZWRpbFwiOlwiXFx1MDEyMlwiLFwiR2NpcmNcIjpcIlxcdTAxMUNcIixcImdjaXJjXCI6XCJcXHUwMTFEXCIsXCJHY3lcIjpcIlxcdTA0MTNcIixcImdjeVwiOlwiXFx1MDQzM1wiLFwiR2RvdFwiOlwiXFx1MDEyMFwiLFwiZ2RvdFwiOlwiXFx1MDEyMVwiLFwiZ2VcIjpcIlxcdTIyNjVcIixcImdFXCI6XCJcXHUyMjY3XCIsXCJnRWxcIjpcIlxcdTJBOENcIixcImdlbFwiOlwiXFx1MjJEQlwiLFwiZ2VxXCI6XCJcXHUyMjY1XCIsXCJnZXFxXCI6XCJcXHUyMjY3XCIsXCJnZXFzbGFudFwiOlwiXFx1MkE3RVwiLFwiZ2VzY2NcIjpcIlxcdTJBQTlcIixcImdlc1wiOlwiXFx1MkE3RVwiLFwiZ2VzZG90XCI6XCJcXHUyQTgwXCIsXCJnZXNkb3RvXCI6XCJcXHUyQTgyXCIsXCJnZXNkb3RvbFwiOlwiXFx1MkE4NFwiLFwiZ2VzbFwiOlwiXFx1MjJEQlxcdUZFMDBcIixcImdlc2xlc1wiOlwiXFx1MkE5NFwiLFwiR2ZyXCI6XCJcXHVEODM1XFx1REQwQVwiLFwiZ2ZyXCI6XCJcXHVEODM1XFx1REQyNFwiLFwiZ2dcIjpcIlxcdTIyNkJcIixcIkdnXCI6XCJcXHUyMkQ5XCIsXCJnZ2dcIjpcIlxcdTIyRDlcIixcImdpbWVsXCI6XCJcXHUyMTM3XCIsXCJHSmN5XCI6XCJcXHUwNDAzXCIsXCJnamN5XCI6XCJcXHUwNDUzXCIsXCJnbGFcIjpcIlxcdTJBQTVcIixcImdsXCI6XCJcXHUyMjc3XCIsXCJnbEVcIjpcIlxcdTJBOTJcIixcImdsalwiOlwiXFx1MkFBNFwiLFwiZ25hcFwiOlwiXFx1MkE4QVwiLFwiZ25hcHByb3hcIjpcIlxcdTJBOEFcIixcImduZVwiOlwiXFx1MkE4OFwiLFwiZ25FXCI6XCJcXHUyMjY5XCIsXCJnbmVxXCI6XCJcXHUyQTg4XCIsXCJnbmVxcVwiOlwiXFx1MjI2OVwiLFwiZ25zaW1cIjpcIlxcdTIyRTdcIixcIkdvcGZcIjpcIlxcdUQ4MzVcXHVERDNFXCIsXCJnb3BmXCI6XCJcXHVEODM1XFx1REQ1OFwiLFwiZ3JhdmVcIjpcImBcIixcIkdyZWF0ZXJFcXVhbFwiOlwiXFx1MjI2NVwiLFwiR3JlYXRlckVxdWFsTGVzc1wiOlwiXFx1MjJEQlwiLFwiR3JlYXRlckZ1bGxFcXVhbFwiOlwiXFx1MjI2N1wiLFwiR3JlYXRlckdyZWF0ZXJcIjpcIlxcdTJBQTJcIixcIkdyZWF0ZXJMZXNzXCI6XCJcXHUyMjc3XCIsXCJHcmVhdGVyU2xhbnRFcXVhbFwiOlwiXFx1MkE3RVwiLFwiR3JlYXRlclRpbGRlXCI6XCJcXHUyMjczXCIsXCJHc2NyXCI6XCJcXHVEODM1XFx1RENBMlwiLFwiZ3NjclwiOlwiXFx1MjEwQVwiLFwiZ3NpbVwiOlwiXFx1MjI3M1wiLFwiZ3NpbWVcIjpcIlxcdTJBOEVcIixcImdzaW1sXCI6XCJcXHUyQTkwXCIsXCJndGNjXCI6XCJcXHUyQUE3XCIsXCJndGNpclwiOlwiXFx1MkE3QVwiLFwiZ3RcIjpcIj5cIixcIkdUXCI6XCI+XCIsXCJHdFwiOlwiXFx1MjI2QlwiLFwiZ3Rkb3RcIjpcIlxcdTIyRDdcIixcImd0bFBhclwiOlwiXFx1Mjk5NVwiLFwiZ3RxdWVzdFwiOlwiXFx1MkE3Q1wiLFwiZ3RyYXBwcm94XCI6XCJcXHUyQTg2XCIsXCJndHJhcnJcIjpcIlxcdTI5NzhcIixcImd0cmRvdFwiOlwiXFx1MjJEN1wiLFwiZ3RyZXFsZXNzXCI6XCJcXHUyMkRCXCIsXCJndHJlcXFsZXNzXCI6XCJcXHUyQThDXCIsXCJndHJsZXNzXCI6XCJcXHUyMjc3XCIsXCJndHJzaW1cIjpcIlxcdTIyNzNcIixcImd2ZXJ0bmVxcVwiOlwiXFx1MjI2OVxcdUZFMDBcIixcImd2bkVcIjpcIlxcdTIyNjlcXHVGRTAwXCIsXCJIYWNla1wiOlwiXFx1MDJDN1wiLFwiaGFpcnNwXCI6XCJcXHUyMDBBXCIsXCJoYWxmXCI6XCJcXHUwMEJEXCIsXCJoYW1pbHRcIjpcIlxcdTIxMEJcIixcIkhBUkRjeVwiOlwiXFx1MDQyQVwiLFwiaGFyZGN5XCI6XCJcXHUwNDRBXCIsXCJoYXJyY2lyXCI6XCJcXHUyOTQ4XCIsXCJoYXJyXCI6XCJcXHUyMTk0XCIsXCJoQXJyXCI6XCJcXHUyMUQ0XCIsXCJoYXJyd1wiOlwiXFx1MjFBRFwiLFwiSGF0XCI6XCJeXCIsXCJoYmFyXCI6XCJcXHUyMTBGXCIsXCJIY2lyY1wiOlwiXFx1MDEyNFwiLFwiaGNpcmNcIjpcIlxcdTAxMjVcIixcImhlYXJ0c1wiOlwiXFx1MjY2NVwiLFwiaGVhcnRzdWl0XCI6XCJcXHUyNjY1XCIsXCJoZWxsaXBcIjpcIlxcdTIwMjZcIixcImhlcmNvblwiOlwiXFx1MjJCOVwiLFwiaGZyXCI6XCJcXHVEODM1XFx1REQyNVwiLFwiSGZyXCI6XCJcXHUyMTBDXCIsXCJIaWxiZXJ0U3BhY2VcIjpcIlxcdTIxMEJcIixcImhrc2Vhcm93XCI6XCJcXHUyOTI1XCIsXCJoa3N3YXJvd1wiOlwiXFx1MjkyNlwiLFwiaG9hcnJcIjpcIlxcdTIxRkZcIixcImhvbXRodFwiOlwiXFx1MjIzQlwiLFwiaG9va2xlZnRhcnJvd1wiOlwiXFx1MjFBOVwiLFwiaG9va3JpZ2h0YXJyb3dcIjpcIlxcdTIxQUFcIixcImhvcGZcIjpcIlxcdUQ4MzVcXHVERDU5XCIsXCJIb3BmXCI6XCJcXHUyMTBEXCIsXCJob3JiYXJcIjpcIlxcdTIwMTVcIixcIkhvcml6b250YWxMaW5lXCI6XCJcXHUyNTAwXCIsXCJoc2NyXCI6XCJcXHVEODM1XFx1RENCRFwiLFwiSHNjclwiOlwiXFx1MjEwQlwiLFwiaHNsYXNoXCI6XCJcXHUyMTBGXCIsXCJIc3Ryb2tcIjpcIlxcdTAxMjZcIixcImhzdHJva1wiOlwiXFx1MDEyN1wiLFwiSHVtcERvd25IdW1wXCI6XCJcXHUyMjRFXCIsXCJIdW1wRXF1YWxcIjpcIlxcdTIyNEZcIixcImh5YnVsbFwiOlwiXFx1MjA0M1wiLFwiaHlwaGVuXCI6XCJcXHUyMDEwXCIsXCJJYWN1dGVcIjpcIlxcdTAwQ0RcIixcImlhY3V0ZVwiOlwiXFx1MDBFRFwiLFwiaWNcIjpcIlxcdTIwNjNcIixcIkljaXJjXCI6XCJcXHUwMENFXCIsXCJpY2lyY1wiOlwiXFx1MDBFRVwiLFwiSWN5XCI6XCJcXHUwNDE4XCIsXCJpY3lcIjpcIlxcdTA0MzhcIixcIklkb3RcIjpcIlxcdTAxMzBcIixcIklFY3lcIjpcIlxcdTA0MTVcIixcImllY3lcIjpcIlxcdTA0MzVcIixcImlleGNsXCI6XCJcXHUwMEExXCIsXCJpZmZcIjpcIlxcdTIxRDRcIixcImlmclwiOlwiXFx1RDgzNVxcdUREMjZcIixcIklmclwiOlwiXFx1MjExMVwiLFwiSWdyYXZlXCI6XCJcXHUwMENDXCIsXCJpZ3JhdmVcIjpcIlxcdTAwRUNcIixcImlpXCI6XCJcXHUyMTQ4XCIsXCJpaWlpbnRcIjpcIlxcdTJBMENcIixcImlpaW50XCI6XCJcXHUyMjJEXCIsXCJpaW5maW5cIjpcIlxcdTI5RENcIixcImlpb3RhXCI6XCJcXHUyMTI5XCIsXCJJSmxpZ1wiOlwiXFx1MDEzMlwiLFwiaWpsaWdcIjpcIlxcdTAxMzNcIixcIkltYWNyXCI6XCJcXHUwMTJBXCIsXCJpbWFjclwiOlwiXFx1MDEyQlwiLFwiaW1hZ2VcIjpcIlxcdTIxMTFcIixcIkltYWdpbmFyeUlcIjpcIlxcdTIxNDhcIixcImltYWdsaW5lXCI6XCJcXHUyMTEwXCIsXCJpbWFncGFydFwiOlwiXFx1MjExMVwiLFwiaW1hdGhcIjpcIlxcdTAxMzFcIixcIkltXCI6XCJcXHUyMTExXCIsXCJpbW9mXCI6XCJcXHUyMkI3XCIsXCJpbXBlZFwiOlwiXFx1MDFCNVwiLFwiSW1wbGllc1wiOlwiXFx1MjFEMlwiLFwiaW5jYXJlXCI6XCJcXHUyMTA1XCIsXCJpblwiOlwiXFx1MjIwOFwiLFwiaW5maW5cIjpcIlxcdTIyMUVcIixcImluZmludGllXCI6XCJcXHUyOUREXCIsXCJpbm9kb3RcIjpcIlxcdTAxMzFcIixcImludGNhbFwiOlwiXFx1MjJCQVwiLFwiaW50XCI6XCJcXHUyMjJCXCIsXCJJbnRcIjpcIlxcdTIyMkNcIixcImludGVnZXJzXCI6XCJcXHUyMTI0XCIsXCJJbnRlZ3JhbFwiOlwiXFx1MjIyQlwiLFwiaW50ZXJjYWxcIjpcIlxcdTIyQkFcIixcIkludGVyc2VjdGlvblwiOlwiXFx1MjJDMlwiLFwiaW50bGFyaGtcIjpcIlxcdTJBMTdcIixcImludHByb2RcIjpcIlxcdTJBM0NcIixcIkludmlzaWJsZUNvbW1hXCI6XCJcXHUyMDYzXCIsXCJJbnZpc2libGVUaW1lc1wiOlwiXFx1MjA2MlwiLFwiSU9jeVwiOlwiXFx1MDQwMVwiLFwiaW9jeVwiOlwiXFx1MDQ1MVwiLFwiSW9nb25cIjpcIlxcdTAxMkVcIixcImlvZ29uXCI6XCJcXHUwMTJGXCIsXCJJb3BmXCI6XCJcXHVEODM1XFx1REQ0MFwiLFwiaW9wZlwiOlwiXFx1RDgzNVxcdURENUFcIixcIklvdGFcIjpcIlxcdTAzOTlcIixcImlvdGFcIjpcIlxcdTAzQjlcIixcImlwcm9kXCI6XCJcXHUyQTNDXCIsXCJpcXVlc3RcIjpcIlxcdTAwQkZcIixcImlzY3JcIjpcIlxcdUQ4MzVcXHVEQ0JFXCIsXCJJc2NyXCI6XCJcXHUyMTEwXCIsXCJpc2luXCI6XCJcXHUyMjA4XCIsXCJpc2luZG90XCI6XCJcXHUyMkY1XCIsXCJpc2luRVwiOlwiXFx1MjJGOVwiLFwiaXNpbnNcIjpcIlxcdTIyRjRcIixcImlzaW5zdlwiOlwiXFx1MjJGM1wiLFwiaXNpbnZcIjpcIlxcdTIyMDhcIixcIml0XCI6XCJcXHUyMDYyXCIsXCJJdGlsZGVcIjpcIlxcdTAxMjhcIixcIml0aWxkZVwiOlwiXFx1MDEyOVwiLFwiSXVrY3lcIjpcIlxcdTA0MDZcIixcIml1a2N5XCI6XCJcXHUwNDU2XCIsXCJJdW1sXCI6XCJcXHUwMENGXCIsXCJpdW1sXCI6XCJcXHUwMEVGXCIsXCJKY2lyY1wiOlwiXFx1MDEzNFwiLFwiamNpcmNcIjpcIlxcdTAxMzVcIixcIkpjeVwiOlwiXFx1MDQxOVwiLFwiamN5XCI6XCJcXHUwNDM5XCIsXCJKZnJcIjpcIlxcdUQ4MzVcXHVERDBEXCIsXCJqZnJcIjpcIlxcdUQ4MzVcXHVERDI3XCIsXCJqbWF0aFwiOlwiXFx1MDIzN1wiLFwiSm9wZlwiOlwiXFx1RDgzNVxcdURENDFcIixcImpvcGZcIjpcIlxcdUQ4MzVcXHVERDVCXCIsXCJKc2NyXCI6XCJcXHVEODM1XFx1RENBNVwiLFwianNjclwiOlwiXFx1RDgzNVxcdURDQkZcIixcIkpzZXJjeVwiOlwiXFx1MDQwOFwiLFwianNlcmN5XCI6XCJcXHUwNDU4XCIsXCJKdWtjeVwiOlwiXFx1MDQwNFwiLFwianVrY3lcIjpcIlxcdTA0NTRcIixcIkthcHBhXCI6XCJcXHUwMzlBXCIsXCJrYXBwYVwiOlwiXFx1MDNCQVwiLFwia2FwcGF2XCI6XCJcXHUwM0YwXCIsXCJLY2VkaWxcIjpcIlxcdTAxMzZcIixcImtjZWRpbFwiOlwiXFx1MDEzN1wiLFwiS2N5XCI6XCJcXHUwNDFBXCIsXCJrY3lcIjpcIlxcdTA0M0FcIixcIktmclwiOlwiXFx1RDgzNVxcdUREMEVcIixcImtmclwiOlwiXFx1RDgzNVxcdUREMjhcIixcImtncmVlblwiOlwiXFx1MDEzOFwiLFwiS0hjeVwiOlwiXFx1MDQyNVwiLFwia2hjeVwiOlwiXFx1MDQ0NVwiLFwiS0pjeVwiOlwiXFx1MDQwQ1wiLFwia2pjeVwiOlwiXFx1MDQ1Q1wiLFwiS29wZlwiOlwiXFx1RDgzNVxcdURENDJcIixcImtvcGZcIjpcIlxcdUQ4MzVcXHVERDVDXCIsXCJLc2NyXCI6XCJcXHVEODM1XFx1RENBNlwiLFwia3NjclwiOlwiXFx1RDgzNVxcdURDQzBcIixcImxBYXJyXCI6XCJcXHUyMURBXCIsXCJMYWN1dGVcIjpcIlxcdTAxMzlcIixcImxhY3V0ZVwiOlwiXFx1MDEzQVwiLFwibGFlbXB0eXZcIjpcIlxcdTI5QjRcIixcImxhZ3JhblwiOlwiXFx1MjExMlwiLFwiTGFtYmRhXCI6XCJcXHUwMzlCXCIsXCJsYW1iZGFcIjpcIlxcdTAzQkJcIixcImxhbmdcIjpcIlxcdTI3RThcIixcIkxhbmdcIjpcIlxcdTI3RUFcIixcImxhbmdkXCI6XCJcXHUyOTkxXCIsXCJsYW5nbGVcIjpcIlxcdTI3RThcIixcImxhcFwiOlwiXFx1MkE4NVwiLFwiTGFwbGFjZXRyZlwiOlwiXFx1MjExMlwiLFwibGFxdW9cIjpcIlxcdTAwQUJcIixcImxhcnJiXCI6XCJcXHUyMUU0XCIsXCJsYXJyYmZzXCI6XCJcXHUyOTFGXCIsXCJsYXJyXCI6XCJcXHUyMTkwXCIsXCJMYXJyXCI6XCJcXHUyMTlFXCIsXCJsQXJyXCI6XCJcXHUyMUQwXCIsXCJsYXJyZnNcIjpcIlxcdTI5MURcIixcImxhcnJoa1wiOlwiXFx1MjFBOVwiLFwibGFycmxwXCI6XCJcXHUyMUFCXCIsXCJsYXJycGxcIjpcIlxcdTI5MzlcIixcImxhcnJzaW1cIjpcIlxcdTI5NzNcIixcImxhcnJ0bFwiOlwiXFx1MjFBMlwiLFwibGF0YWlsXCI6XCJcXHUyOTE5XCIsXCJsQXRhaWxcIjpcIlxcdTI5MUJcIixcImxhdFwiOlwiXFx1MkFBQlwiLFwibGF0ZVwiOlwiXFx1MkFBRFwiLFwibGF0ZXNcIjpcIlxcdTJBQURcXHVGRTAwXCIsXCJsYmFyclwiOlwiXFx1MjkwQ1wiLFwibEJhcnJcIjpcIlxcdTI5MEVcIixcImxiYnJrXCI6XCJcXHUyNzcyXCIsXCJsYnJhY2VcIjpcIntcIixcImxicmFja1wiOlwiW1wiLFwibGJya2VcIjpcIlxcdTI5OEJcIixcImxicmtzbGRcIjpcIlxcdTI5OEZcIixcImxicmtzbHVcIjpcIlxcdTI5OERcIixcIkxjYXJvblwiOlwiXFx1MDEzRFwiLFwibGNhcm9uXCI6XCJcXHUwMTNFXCIsXCJMY2VkaWxcIjpcIlxcdTAxM0JcIixcImxjZWRpbFwiOlwiXFx1MDEzQ1wiLFwibGNlaWxcIjpcIlxcdTIzMDhcIixcImxjdWJcIjpcIntcIixcIkxjeVwiOlwiXFx1MDQxQlwiLFwibGN5XCI6XCJcXHUwNDNCXCIsXCJsZGNhXCI6XCJcXHUyOTM2XCIsXCJsZHF1b1wiOlwiXFx1MjAxQ1wiLFwibGRxdW9yXCI6XCJcXHUyMDFFXCIsXCJsZHJkaGFyXCI6XCJcXHUyOTY3XCIsXCJsZHJ1c2hhclwiOlwiXFx1Mjk0QlwiLFwibGRzaFwiOlwiXFx1MjFCMlwiLFwibGVcIjpcIlxcdTIyNjRcIixcImxFXCI6XCJcXHUyMjY2XCIsXCJMZWZ0QW5nbGVCcmFja2V0XCI6XCJcXHUyN0U4XCIsXCJMZWZ0QXJyb3dCYXJcIjpcIlxcdTIxRTRcIixcImxlZnRhcnJvd1wiOlwiXFx1MjE5MFwiLFwiTGVmdEFycm93XCI6XCJcXHUyMTkwXCIsXCJMZWZ0YXJyb3dcIjpcIlxcdTIxRDBcIixcIkxlZnRBcnJvd1JpZ2h0QXJyb3dcIjpcIlxcdTIxQzZcIixcImxlZnRhcnJvd3RhaWxcIjpcIlxcdTIxQTJcIixcIkxlZnRDZWlsaW5nXCI6XCJcXHUyMzA4XCIsXCJMZWZ0RG91YmxlQnJhY2tldFwiOlwiXFx1MjdFNlwiLFwiTGVmdERvd25UZWVWZWN0b3JcIjpcIlxcdTI5NjFcIixcIkxlZnREb3duVmVjdG9yQmFyXCI6XCJcXHUyOTU5XCIsXCJMZWZ0RG93blZlY3RvclwiOlwiXFx1MjFDM1wiLFwiTGVmdEZsb29yXCI6XCJcXHUyMzBBXCIsXCJsZWZ0aGFycG9vbmRvd25cIjpcIlxcdTIxQkRcIixcImxlZnRoYXJwb29udXBcIjpcIlxcdTIxQkNcIixcImxlZnRsZWZ0YXJyb3dzXCI6XCJcXHUyMUM3XCIsXCJsZWZ0cmlnaHRhcnJvd1wiOlwiXFx1MjE5NFwiLFwiTGVmdFJpZ2h0QXJyb3dcIjpcIlxcdTIxOTRcIixcIkxlZnRyaWdodGFycm93XCI6XCJcXHUyMUQ0XCIsXCJsZWZ0cmlnaHRhcnJvd3NcIjpcIlxcdTIxQzZcIixcImxlZnRyaWdodGhhcnBvb25zXCI6XCJcXHUyMUNCXCIsXCJsZWZ0cmlnaHRzcXVpZ2Fycm93XCI6XCJcXHUyMUFEXCIsXCJMZWZ0UmlnaHRWZWN0b3JcIjpcIlxcdTI5NEVcIixcIkxlZnRUZWVBcnJvd1wiOlwiXFx1MjFBNFwiLFwiTGVmdFRlZVwiOlwiXFx1MjJBM1wiLFwiTGVmdFRlZVZlY3RvclwiOlwiXFx1Mjk1QVwiLFwibGVmdHRocmVldGltZXNcIjpcIlxcdTIyQ0JcIixcIkxlZnRUcmlhbmdsZUJhclwiOlwiXFx1MjlDRlwiLFwiTGVmdFRyaWFuZ2xlXCI6XCJcXHUyMkIyXCIsXCJMZWZ0VHJpYW5nbGVFcXVhbFwiOlwiXFx1MjJCNFwiLFwiTGVmdFVwRG93blZlY3RvclwiOlwiXFx1Mjk1MVwiLFwiTGVmdFVwVGVlVmVjdG9yXCI6XCJcXHUyOTYwXCIsXCJMZWZ0VXBWZWN0b3JCYXJcIjpcIlxcdTI5NThcIixcIkxlZnRVcFZlY3RvclwiOlwiXFx1MjFCRlwiLFwiTGVmdFZlY3RvckJhclwiOlwiXFx1Mjk1MlwiLFwiTGVmdFZlY3RvclwiOlwiXFx1MjFCQ1wiLFwibEVnXCI6XCJcXHUyQThCXCIsXCJsZWdcIjpcIlxcdTIyREFcIixcImxlcVwiOlwiXFx1MjI2NFwiLFwibGVxcVwiOlwiXFx1MjI2NlwiLFwibGVxc2xhbnRcIjpcIlxcdTJBN0RcIixcImxlc2NjXCI6XCJcXHUyQUE4XCIsXCJsZXNcIjpcIlxcdTJBN0RcIixcImxlc2RvdFwiOlwiXFx1MkE3RlwiLFwibGVzZG90b1wiOlwiXFx1MkE4MVwiLFwibGVzZG90b3JcIjpcIlxcdTJBODNcIixcImxlc2dcIjpcIlxcdTIyREFcXHVGRTAwXCIsXCJsZXNnZXNcIjpcIlxcdTJBOTNcIixcImxlc3NhcHByb3hcIjpcIlxcdTJBODVcIixcImxlc3Nkb3RcIjpcIlxcdTIyRDZcIixcImxlc3NlcWd0clwiOlwiXFx1MjJEQVwiLFwibGVzc2VxcWd0clwiOlwiXFx1MkE4QlwiLFwiTGVzc0VxdWFsR3JlYXRlclwiOlwiXFx1MjJEQVwiLFwiTGVzc0Z1bGxFcXVhbFwiOlwiXFx1MjI2NlwiLFwiTGVzc0dyZWF0ZXJcIjpcIlxcdTIyNzZcIixcImxlc3NndHJcIjpcIlxcdTIyNzZcIixcIkxlc3NMZXNzXCI6XCJcXHUyQUExXCIsXCJsZXNzc2ltXCI6XCJcXHUyMjcyXCIsXCJMZXNzU2xhbnRFcXVhbFwiOlwiXFx1MkE3RFwiLFwiTGVzc1RpbGRlXCI6XCJcXHUyMjcyXCIsXCJsZmlzaHRcIjpcIlxcdTI5N0NcIixcImxmbG9vclwiOlwiXFx1MjMwQVwiLFwiTGZyXCI6XCJcXHVEODM1XFx1REQwRlwiLFwibGZyXCI6XCJcXHVEODM1XFx1REQyOVwiLFwibGdcIjpcIlxcdTIyNzZcIixcImxnRVwiOlwiXFx1MkE5MVwiLFwibEhhclwiOlwiXFx1Mjk2MlwiLFwibGhhcmRcIjpcIlxcdTIxQkRcIixcImxoYXJ1XCI6XCJcXHUyMUJDXCIsXCJsaGFydWxcIjpcIlxcdTI5NkFcIixcImxoYmxrXCI6XCJcXHUyNTg0XCIsXCJMSmN5XCI6XCJcXHUwNDA5XCIsXCJsamN5XCI6XCJcXHUwNDU5XCIsXCJsbGFyclwiOlwiXFx1MjFDN1wiLFwibGxcIjpcIlxcdTIyNkFcIixcIkxsXCI6XCJcXHUyMkQ4XCIsXCJsbGNvcm5lclwiOlwiXFx1MjMxRVwiLFwiTGxlZnRhcnJvd1wiOlwiXFx1MjFEQVwiLFwibGxoYXJkXCI6XCJcXHUyOTZCXCIsXCJsbHRyaVwiOlwiXFx1MjVGQVwiLFwiTG1pZG90XCI6XCJcXHUwMTNGXCIsXCJsbWlkb3RcIjpcIlxcdTAxNDBcIixcImxtb3VzdGFjaGVcIjpcIlxcdTIzQjBcIixcImxtb3VzdFwiOlwiXFx1MjNCMFwiLFwibG5hcFwiOlwiXFx1MkE4OVwiLFwibG5hcHByb3hcIjpcIlxcdTJBODlcIixcImxuZVwiOlwiXFx1MkE4N1wiLFwibG5FXCI6XCJcXHUyMjY4XCIsXCJsbmVxXCI6XCJcXHUyQTg3XCIsXCJsbmVxcVwiOlwiXFx1MjI2OFwiLFwibG5zaW1cIjpcIlxcdTIyRTZcIixcImxvYW5nXCI6XCJcXHUyN0VDXCIsXCJsb2FyclwiOlwiXFx1MjFGRFwiLFwibG9icmtcIjpcIlxcdTI3RTZcIixcImxvbmdsZWZ0YXJyb3dcIjpcIlxcdTI3RjVcIixcIkxvbmdMZWZ0QXJyb3dcIjpcIlxcdTI3RjVcIixcIkxvbmdsZWZ0YXJyb3dcIjpcIlxcdTI3RjhcIixcImxvbmdsZWZ0cmlnaHRhcnJvd1wiOlwiXFx1MjdGN1wiLFwiTG9uZ0xlZnRSaWdodEFycm93XCI6XCJcXHUyN0Y3XCIsXCJMb25nbGVmdHJpZ2h0YXJyb3dcIjpcIlxcdTI3RkFcIixcImxvbmdtYXBzdG9cIjpcIlxcdTI3RkNcIixcImxvbmdyaWdodGFycm93XCI6XCJcXHUyN0Y2XCIsXCJMb25nUmlnaHRBcnJvd1wiOlwiXFx1MjdGNlwiLFwiTG9uZ3JpZ2h0YXJyb3dcIjpcIlxcdTI3RjlcIixcImxvb3BhcnJvd2xlZnRcIjpcIlxcdTIxQUJcIixcImxvb3BhcnJvd3JpZ2h0XCI6XCJcXHUyMUFDXCIsXCJsb3BhclwiOlwiXFx1Mjk4NVwiLFwiTG9wZlwiOlwiXFx1RDgzNVxcdURENDNcIixcImxvcGZcIjpcIlxcdUQ4MzVcXHVERDVEXCIsXCJsb3BsdXNcIjpcIlxcdTJBMkRcIixcImxvdGltZXNcIjpcIlxcdTJBMzRcIixcImxvd2FzdFwiOlwiXFx1MjIxN1wiLFwibG93YmFyXCI6XCJfXCIsXCJMb3dlckxlZnRBcnJvd1wiOlwiXFx1MjE5OVwiLFwiTG93ZXJSaWdodEFycm93XCI6XCJcXHUyMTk4XCIsXCJsb3pcIjpcIlxcdTI1Q0FcIixcImxvemVuZ2VcIjpcIlxcdTI1Q0FcIixcImxvemZcIjpcIlxcdTI5RUJcIixcImxwYXJcIjpcIihcIixcImxwYXJsdFwiOlwiXFx1Mjk5M1wiLFwibHJhcnJcIjpcIlxcdTIxQzZcIixcImxyY29ybmVyXCI6XCJcXHUyMzFGXCIsXCJscmhhclwiOlwiXFx1MjFDQlwiLFwibHJoYXJkXCI6XCJcXHUyOTZEXCIsXCJscm1cIjpcIlxcdTIwMEVcIixcImxydHJpXCI6XCJcXHUyMkJGXCIsXCJsc2FxdW9cIjpcIlxcdTIwMzlcIixcImxzY3JcIjpcIlxcdUQ4MzVcXHVEQ0MxXCIsXCJMc2NyXCI6XCJcXHUyMTEyXCIsXCJsc2hcIjpcIlxcdTIxQjBcIixcIkxzaFwiOlwiXFx1MjFCMFwiLFwibHNpbVwiOlwiXFx1MjI3MlwiLFwibHNpbWVcIjpcIlxcdTJBOERcIixcImxzaW1nXCI6XCJcXHUyQThGXCIsXCJsc3FiXCI6XCJbXCIsXCJsc3F1b1wiOlwiXFx1MjAxOFwiLFwibHNxdW9yXCI6XCJcXHUyMDFBXCIsXCJMc3Ryb2tcIjpcIlxcdTAxNDFcIixcImxzdHJva1wiOlwiXFx1MDE0MlwiLFwibHRjY1wiOlwiXFx1MkFBNlwiLFwibHRjaXJcIjpcIlxcdTJBNzlcIixcImx0XCI6XCI8XCIsXCJMVFwiOlwiPFwiLFwiTHRcIjpcIlxcdTIyNkFcIixcImx0ZG90XCI6XCJcXHUyMkQ2XCIsXCJsdGhyZWVcIjpcIlxcdTIyQ0JcIixcImx0aW1lc1wiOlwiXFx1MjJDOVwiLFwibHRsYXJyXCI6XCJcXHUyOTc2XCIsXCJsdHF1ZXN0XCI6XCJcXHUyQTdCXCIsXCJsdHJpXCI6XCJcXHUyNUMzXCIsXCJsdHJpZVwiOlwiXFx1MjJCNFwiLFwibHRyaWZcIjpcIlxcdTI1QzJcIixcImx0clBhclwiOlwiXFx1Mjk5NlwiLFwibHVyZHNoYXJcIjpcIlxcdTI5NEFcIixcImx1cnVoYXJcIjpcIlxcdTI5NjZcIixcImx2ZXJ0bmVxcVwiOlwiXFx1MjI2OFxcdUZFMDBcIixcImx2bkVcIjpcIlxcdTIyNjhcXHVGRTAwXCIsXCJtYWNyXCI6XCJcXHUwMEFGXCIsXCJtYWxlXCI6XCJcXHUyNjQyXCIsXCJtYWx0XCI6XCJcXHUyNzIwXCIsXCJtYWx0ZXNlXCI6XCJcXHUyNzIwXCIsXCJNYXBcIjpcIlxcdTI5MDVcIixcIm1hcFwiOlwiXFx1MjFBNlwiLFwibWFwc3RvXCI6XCJcXHUyMUE2XCIsXCJtYXBzdG9kb3duXCI6XCJcXHUyMUE3XCIsXCJtYXBzdG9sZWZ0XCI6XCJcXHUyMUE0XCIsXCJtYXBzdG91cFwiOlwiXFx1MjFBNVwiLFwibWFya2VyXCI6XCJcXHUyNUFFXCIsXCJtY29tbWFcIjpcIlxcdTJBMjlcIixcIk1jeVwiOlwiXFx1MDQxQ1wiLFwibWN5XCI6XCJcXHUwNDNDXCIsXCJtZGFzaFwiOlwiXFx1MjAxNFwiLFwibUREb3RcIjpcIlxcdTIyM0FcIixcIm1lYXN1cmVkYW5nbGVcIjpcIlxcdTIyMjFcIixcIk1lZGl1bVNwYWNlXCI6XCJcXHUyMDVGXCIsXCJNZWxsaW50cmZcIjpcIlxcdTIxMzNcIixcIk1mclwiOlwiXFx1RDgzNVxcdUREMTBcIixcIm1mclwiOlwiXFx1RDgzNVxcdUREMkFcIixcIm1ob1wiOlwiXFx1MjEyN1wiLFwibWljcm9cIjpcIlxcdTAwQjVcIixcIm1pZGFzdFwiOlwiKlwiLFwibWlkY2lyXCI6XCJcXHUyQUYwXCIsXCJtaWRcIjpcIlxcdTIyMjNcIixcIm1pZGRvdFwiOlwiXFx1MDBCN1wiLFwibWludXNiXCI6XCJcXHUyMjlGXCIsXCJtaW51c1wiOlwiXFx1MjIxMlwiLFwibWludXNkXCI6XCJcXHUyMjM4XCIsXCJtaW51c2R1XCI6XCJcXHUyQTJBXCIsXCJNaW51c1BsdXNcIjpcIlxcdTIyMTNcIixcIm1sY3BcIjpcIlxcdTJBREJcIixcIm1sZHJcIjpcIlxcdTIwMjZcIixcIm1ucGx1c1wiOlwiXFx1MjIxM1wiLFwibW9kZWxzXCI6XCJcXHUyMkE3XCIsXCJNb3BmXCI6XCJcXHVEODM1XFx1REQ0NFwiLFwibW9wZlwiOlwiXFx1RDgzNVxcdURENUVcIixcIm1wXCI6XCJcXHUyMjEzXCIsXCJtc2NyXCI6XCJcXHVEODM1XFx1RENDMlwiLFwiTXNjclwiOlwiXFx1MjEzM1wiLFwibXN0cG9zXCI6XCJcXHUyMjNFXCIsXCJNdVwiOlwiXFx1MDM5Q1wiLFwibXVcIjpcIlxcdTAzQkNcIixcIm11bHRpbWFwXCI6XCJcXHUyMkI4XCIsXCJtdW1hcFwiOlwiXFx1MjJCOFwiLFwibmFibGFcIjpcIlxcdTIyMDdcIixcIk5hY3V0ZVwiOlwiXFx1MDE0M1wiLFwibmFjdXRlXCI6XCJcXHUwMTQ0XCIsXCJuYW5nXCI6XCJcXHUyMjIwXFx1MjBEMlwiLFwibmFwXCI6XCJcXHUyMjQ5XCIsXCJuYXBFXCI6XCJcXHUyQTcwXFx1MDMzOFwiLFwibmFwaWRcIjpcIlxcdTIyNEJcXHUwMzM4XCIsXCJuYXBvc1wiOlwiXFx1MDE0OVwiLFwibmFwcHJveFwiOlwiXFx1MjI0OVwiLFwibmF0dXJhbFwiOlwiXFx1MjY2RVwiLFwibmF0dXJhbHNcIjpcIlxcdTIxMTVcIixcIm5hdHVyXCI6XCJcXHUyNjZFXCIsXCJuYnNwXCI6XCJcXHUwMEEwXCIsXCJuYnVtcFwiOlwiXFx1MjI0RVxcdTAzMzhcIixcIm5idW1wZVwiOlwiXFx1MjI0RlxcdTAzMzhcIixcIm5jYXBcIjpcIlxcdTJBNDNcIixcIk5jYXJvblwiOlwiXFx1MDE0N1wiLFwibmNhcm9uXCI6XCJcXHUwMTQ4XCIsXCJOY2VkaWxcIjpcIlxcdTAxNDVcIixcIm5jZWRpbFwiOlwiXFx1MDE0NlwiLFwibmNvbmdcIjpcIlxcdTIyNDdcIixcIm5jb25nZG90XCI6XCJcXHUyQTZEXFx1MDMzOFwiLFwibmN1cFwiOlwiXFx1MkE0MlwiLFwiTmN5XCI6XCJcXHUwNDFEXCIsXCJuY3lcIjpcIlxcdTA0M0RcIixcIm5kYXNoXCI6XCJcXHUyMDEzXCIsXCJuZWFyaGtcIjpcIlxcdTI5MjRcIixcIm5lYXJyXCI6XCJcXHUyMTk3XCIsXCJuZUFyclwiOlwiXFx1MjFEN1wiLFwibmVhcnJvd1wiOlwiXFx1MjE5N1wiLFwibmVcIjpcIlxcdTIyNjBcIixcIm5lZG90XCI6XCJcXHUyMjUwXFx1MDMzOFwiLFwiTmVnYXRpdmVNZWRpdW1TcGFjZVwiOlwiXFx1MjAwQlwiLFwiTmVnYXRpdmVUaGlja1NwYWNlXCI6XCJcXHUyMDBCXCIsXCJOZWdhdGl2ZVRoaW5TcGFjZVwiOlwiXFx1MjAwQlwiLFwiTmVnYXRpdmVWZXJ5VGhpblNwYWNlXCI6XCJcXHUyMDBCXCIsXCJuZXF1aXZcIjpcIlxcdTIyNjJcIixcIm5lc2VhclwiOlwiXFx1MjkyOFwiLFwibmVzaW1cIjpcIlxcdTIyNDJcXHUwMzM4XCIsXCJOZXN0ZWRHcmVhdGVyR3JlYXRlclwiOlwiXFx1MjI2QlwiLFwiTmVzdGVkTGVzc0xlc3NcIjpcIlxcdTIyNkFcIixcIk5ld0xpbmVcIjpcIlxcblwiLFwibmV4aXN0XCI6XCJcXHUyMjA0XCIsXCJuZXhpc3RzXCI6XCJcXHUyMjA0XCIsXCJOZnJcIjpcIlxcdUQ4MzVcXHVERDExXCIsXCJuZnJcIjpcIlxcdUQ4MzVcXHVERDJCXCIsXCJuZ0VcIjpcIlxcdTIyNjdcXHUwMzM4XCIsXCJuZ2VcIjpcIlxcdTIyNzFcIixcIm5nZXFcIjpcIlxcdTIyNzFcIixcIm5nZXFxXCI6XCJcXHUyMjY3XFx1MDMzOFwiLFwibmdlcXNsYW50XCI6XCJcXHUyQTdFXFx1MDMzOFwiLFwibmdlc1wiOlwiXFx1MkE3RVxcdTAzMzhcIixcIm5HZ1wiOlwiXFx1MjJEOVxcdTAzMzhcIixcIm5nc2ltXCI6XCJcXHUyMjc1XCIsXCJuR3RcIjpcIlxcdTIyNkJcXHUyMEQyXCIsXCJuZ3RcIjpcIlxcdTIyNkZcIixcIm5ndHJcIjpcIlxcdTIyNkZcIixcIm5HdHZcIjpcIlxcdTIyNkJcXHUwMzM4XCIsXCJuaGFyclwiOlwiXFx1MjFBRVwiLFwibmhBcnJcIjpcIlxcdTIxQ0VcIixcIm5ocGFyXCI6XCJcXHUyQUYyXCIsXCJuaVwiOlwiXFx1MjIwQlwiLFwibmlzXCI6XCJcXHUyMkZDXCIsXCJuaXNkXCI6XCJcXHUyMkZBXCIsXCJuaXZcIjpcIlxcdTIyMEJcIixcIk5KY3lcIjpcIlxcdTA0MEFcIixcIm5qY3lcIjpcIlxcdTA0NUFcIixcIm5sYXJyXCI6XCJcXHUyMTlBXCIsXCJubEFyclwiOlwiXFx1MjFDRFwiLFwibmxkclwiOlwiXFx1MjAyNVwiLFwibmxFXCI6XCJcXHUyMjY2XFx1MDMzOFwiLFwibmxlXCI6XCJcXHUyMjcwXCIsXCJubGVmdGFycm93XCI6XCJcXHUyMTlBXCIsXCJuTGVmdGFycm93XCI6XCJcXHUyMUNEXCIsXCJubGVmdHJpZ2h0YXJyb3dcIjpcIlxcdTIxQUVcIixcIm5MZWZ0cmlnaHRhcnJvd1wiOlwiXFx1MjFDRVwiLFwibmxlcVwiOlwiXFx1MjI3MFwiLFwibmxlcXFcIjpcIlxcdTIyNjZcXHUwMzM4XCIsXCJubGVxc2xhbnRcIjpcIlxcdTJBN0RcXHUwMzM4XCIsXCJubGVzXCI6XCJcXHUyQTdEXFx1MDMzOFwiLFwibmxlc3NcIjpcIlxcdTIyNkVcIixcIm5MbFwiOlwiXFx1MjJEOFxcdTAzMzhcIixcIm5sc2ltXCI6XCJcXHUyMjc0XCIsXCJuTHRcIjpcIlxcdTIyNkFcXHUyMEQyXCIsXCJubHRcIjpcIlxcdTIyNkVcIixcIm5sdHJpXCI6XCJcXHUyMkVBXCIsXCJubHRyaWVcIjpcIlxcdTIyRUNcIixcIm5MdHZcIjpcIlxcdTIyNkFcXHUwMzM4XCIsXCJubWlkXCI6XCJcXHUyMjI0XCIsXCJOb0JyZWFrXCI6XCJcXHUyMDYwXCIsXCJOb25CcmVha2luZ1NwYWNlXCI6XCJcXHUwMEEwXCIsXCJub3BmXCI6XCJcXHVEODM1XFx1REQ1RlwiLFwiTm9wZlwiOlwiXFx1MjExNVwiLFwiTm90XCI6XCJcXHUyQUVDXCIsXCJub3RcIjpcIlxcdTAwQUNcIixcIk5vdENvbmdydWVudFwiOlwiXFx1MjI2MlwiLFwiTm90Q3VwQ2FwXCI6XCJcXHUyMjZEXCIsXCJOb3REb3VibGVWZXJ0aWNhbEJhclwiOlwiXFx1MjIyNlwiLFwiTm90RWxlbWVudFwiOlwiXFx1MjIwOVwiLFwiTm90RXF1YWxcIjpcIlxcdTIyNjBcIixcIk5vdEVxdWFsVGlsZGVcIjpcIlxcdTIyNDJcXHUwMzM4XCIsXCJOb3RFeGlzdHNcIjpcIlxcdTIyMDRcIixcIk5vdEdyZWF0ZXJcIjpcIlxcdTIyNkZcIixcIk5vdEdyZWF0ZXJFcXVhbFwiOlwiXFx1MjI3MVwiLFwiTm90R3JlYXRlckZ1bGxFcXVhbFwiOlwiXFx1MjI2N1xcdTAzMzhcIixcIk5vdEdyZWF0ZXJHcmVhdGVyXCI6XCJcXHUyMjZCXFx1MDMzOFwiLFwiTm90R3JlYXRlckxlc3NcIjpcIlxcdTIyNzlcIixcIk5vdEdyZWF0ZXJTbGFudEVxdWFsXCI6XCJcXHUyQTdFXFx1MDMzOFwiLFwiTm90R3JlYXRlclRpbGRlXCI6XCJcXHUyMjc1XCIsXCJOb3RIdW1wRG93bkh1bXBcIjpcIlxcdTIyNEVcXHUwMzM4XCIsXCJOb3RIdW1wRXF1YWxcIjpcIlxcdTIyNEZcXHUwMzM4XCIsXCJub3RpblwiOlwiXFx1MjIwOVwiLFwibm90aW5kb3RcIjpcIlxcdTIyRjVcXHUwMzM4XCIsXCJub3RpbkVcIjpcIlxcdTIyRjlcXHUwMzM4XCIsXCJub3RpbnZhXCI6XCJcXHUyMjA5XCIsXCJub3RpbnZiXCI6XCJcXHUyMkY3XCIsXCJub3RpbnZjXCI6XCJcXHUyMkY2XCIsXCJOb3RMZWZ0VHJpYW5nbGVCYXJcIjpcIlxcdTI5Q0ZcXHUwMzM4XCIsXCJOb3RMZWZ0VHJpYW5nbGVcIjpcIlxcdTIyRUFcIixcIk5vdExlZnRUcmlhbmdsZUVxdWFsXCI6XCJcXHUyMkVDXCIsXCJOb3RMZXNzXCI6XCJcXHUyMjZFXCIsXCJOb3RMZXNzRXF1YWxcIjpcIlxcdTIyNzBcIixcIk5vdExlc3NHcmVhdGVyXCI6XCJcXHUyMjc4XCIsXCJOb3RMZXNzTGVzc1wiOlwiXFx1MjI2QVxcdTAzMzhcIixcIk5vdExlc3NTbGFudEVxdWFsXCI6XCJcXHUyQTdEXFx1MDMzOFwiLFwiTm90TGVzc1RpbGRlXCI6XCJcXHUyMjc0XCIsXCJOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlclwiOlwiXFx1MkFBMlxcdTAzMzhcIixcIk5vdE5lc3RlZExlc3NMZXNzXCI6XCJcXHUyQUExXFx1MDMzOFwiLFwibm90bmlcIjpcIlxcdTIyMENcIixcIm5vdG5pdmFcIjpcIlxcdTIyMENcIixcIm5vdG5pdmJcIjpcIlxcdTIyRkVcIixcIm5vdG5pdmNcIjpcIlxcdTIyRkRcIixcIk5vdFByZWNlZGVzXCI6XCJcXHUyMjgwXCIsXCJOb3RQcmVjZWRlc0VxdWFsXCI6XCJcXHUyQUFGXFx1MDMzOFwiLFwiTm90UHJlY2VkZXNTbGFudEVxdWFsXCI6XCJcXHUyMkUwXCIsXCJOb3RSZXZlcnNlRWxlbWVudFwiOlwiXFx1MjIwQ1wiLFwiTm90UmlnaHRUcmlhbmdsZUJhclwiOlwiXFx1MjlEMFxcdTAzMzhcIixcIk5vdFJpZ2h0VHJpYW5nbGVcIjpcIlxcdTIyRUJcIixcIk5vdFJpZ2h0VHJpYW5nbGVFcXVhbFwiOlwiXFx1MjJFRFwiLFwiTm90U3F1YXJlU3Vic2V0XCI6XCJcXHUyMjhGXFx1MDMzOFwiLFwiTm90U3F1YXJlU3Vic2V0RXF1YWxcIjpcIlxcdTIyRTJcIixcIk5vdFNxdWFyZVN1cGVyc2V0XCI6XCJcXHUyMjkwXFx1MDMzOFwiLFwiTm90U3F1YXJlU3VwZXJzZXRFcXVhbFwiOlwiXFx1MjJFM1wiLFwiTm90U3Vic2V0XCI6XCJcXHUyMjgyXFx1MjBEMlwiLFwiTm90U3Vic2V0RXF1YWxcIjpcIlxcdTIyODhcIixcIk5vdFN1Y2NlZWRzXCI6XCJcXHUyMjgxXCIsXCJOb3RTdWNjZWVkc0VxdWFsXCI6XCJcXHUyQUIwXFx1MDMzOFwiLFwiTm90U3VjY2VlZHNTbGFudEVxdWFsXCI6XCJcXHUyMkUxXCIsXCJOb3RTdWNjZWVkc1RpbGRlXCI6XCJcXHUyMjdGXFx1MDMzOFwiLFwiTm90U3VwZXJzZXRcIjpcIlxcdTIyODNcXHUyMEQyXCIsXCJOb3RTdXBlcnNldEVxdWFsXCI6XCJcXHUyMjg5XCIsXCJOb3RUaWxkZVwiOlwiXFx1MjI0MVwiLFwiTm90VGlsZGVFcXVhbFwiOlwiXFx1MjI0NFwiLFwiTm90VGlsZGVGdWxsRXF1YWxcIjpcIlxcdTIyNDdcIixcIk5vdFRpbGRlVGlsZGVcIjpcIlxcdTIyNDlcIixcIk5vdFZlcnRpY2FsQmFyXCI6XCJcXHUyMjI0XCIsXCJucGFyYWxsZWxcIjpcIlxcdTIyMjZcIixcIm5wYXJcIjpcIlxcdTIyMjZcIixcIm5wYXJzbFwiOlwiXFx1MkFGRFxcdTIwRTVcIixcIm5wYXJ0XCI6XCJcXHUyMjAyXFx1MDMzOFwiLFwibnBvbGludFwiOlwiXFx1MkExNFwiLFwibnByXCI6XCJcXHUyMjgwXCIsXCJucHJjdWVcIjpcIlxcdTIyRTBcIixcIm5wcmVjXCI6XCJcXHUyMjgwXCIsXCJucHJlY2VxXCI6XCJcXHUyQUFGXFx1MDMzOFwiLFwibnByZVwiOlwiXFx1MkFBRlxcdTAzMzhcIixcIm5yYXJyY1wiOlwiXFx1MjkzM1xcdTAzMzhcIixcIm5yYXJyXCI6XCJcXHUyMTlCXCIsXCJuckFyclwiOlwiXFx1MjFDRlwiLFwibnJhcnJ3XCI6XCJcXHUyMTlEXFx1MDMzOFwiLFwibnJpZ2h0YXJyb3dcIjpcIlxcdTIxOUJcIixcIm5SaWdodGFycm93XCI6XCJcXHUyMUNGXCIsXCJucnRyaVwiOlwiXFx1MjJFQlwiLFwibnJ0cmllXCI6XCJcXHUyMkVEXCIsXCJuc2NcIjpcIlxcdTIyODFcIixcIm5zY2N1ZVwiOlwiXFx1MjJFMVwiLFwibnNjZVwiOlwiXFx1MkFCMFxcdTAzMzhcIixcIk5zY3JcIjpcIlxcdUQ4MzVcXHVEQ0E5XCIsXCJuc2NyXCI6XCJcXHVEODM1XFx1RENDM1wiLFwibnNob3J0bWlkXCI6XCJcXHUyMjI0XCIsXCJuc2hvcnRwYXJhbGxlbFwiOlwiXFx1MjIyNlwiLFwibnNpbVwiOlwiXFx1MjI0MVwiLFwibnNpbWVcIjpcIlxcdTIyNDRcIixcIm5zaW1lcVwiOlwiXFx1MjI0NFwiLFwibnNtaWRcIjpcIlxcdTIyMjRcIixcIm5zcGFyXCI6XCJcXHUyMjI2XCIsXCJuc3FzdWJlXCI6XCJcXHUyMkUyXCIsXCJuc3FzdXBlXCI6XCJcXHUyMkUzXCIsXCJuc3ViXCI6XCJcXHUyMjg0XCIsXCJuc3ViRVwiOlwiXFx1MkFDNVxcdTAzMzhcIixcIm5zdWJlXCI6XCJcXHUyMjg4XCIsXCJuc3Vic2V0XCI6XCJcXHUyMjgyXFx1MjBEMlwiLFwibnN1YnNldGVxXCI6XCJcXHUyMjg4XCIsXCJuc3Vic2V0ZXFxXCI6XCJcXHUyQUM1XFx1MDMzOFwiLFwibnN1Y2NcIjpcIlxcdTIyODFcIixcIm5zdWNjZXFcIjpcIlxcdTJBQjBcXHUwMzM4XCIsXCJuc3VwXCI6XCJcXHUyMjg1XCIsXCJuc3VwRVwiOlwiXFx1MkFDNlxcdTAzMzhcIixcIm5zdXBlXCI6XCJcXHUyMjg5XCIsXCJuc3Vwc2V0XCI6XCJcXHUyMjgzXFx1MjBEMlwiLFwibnN1cHNldGVxXCI6XCJcXHUyMjg5XCIsXCJuc3Vwc2V0ZXFxXCI6XCJcXHUyQUM2XFx1MDMzOFwiLFwibnRnbFwiOlwiXFx1MjI3OVwiLFwiTnRpbGRlXCI6XCJcXHUwMEQxXCIsXCJudGlsZGVcIjpcIlxcdTAwRjFcIixcIm50bGdcIjpcIlxcdTIyNzhcIixcIm50cmlhbmdsZWxlZnRcIjpcIlxcdTIyRUFcIixcIm50cmlhbmdsZWxlZnRlcVwiOlwiXFx1MjJFQ1wiLFwibnRyaWFuZ2xlcmlnaHRcIjpcIlxcdTIyRUJcIixcIm50cmlhbmdsZXJpZ2h0ZXFcIjpcIlxcdTIyRURcIixcIk51XCI6XCJcXHUwMzlEXCIsXCJudVwiOlwiXFx1MDNCRFwiLFwibnVtXCI6XCIjXCIsXCJudW1lcm9cIjpcIlxcdTIxMTZcIixcIm51bXNwXCI6XCJcXHUyMDA3XCIsXCJudmFwXCI6XCJcXHUyMjREXFx1MjBEMlwiLFwibnZkYXNoXCI6XCJcXHUyMkFDXCIsXCJudkRhc2hcIjpcIlxcdTIyQURcIixcIm5WZGFzaFwiOlwiXFx1MjJBRVwiLFwiblZEYXNoXCI6XCJcXHUyMkFGXCIsXCJudmdlXCI6XCJcXHUyMjY1XFx1MjBEMlwiLFwibnZndFwiOlwiPlxcdTIwRDJcIixcIm52SGFyclwiOlwiXFx1MjkwNFwiLFwibnZpbmZpblwiOlwiXFx1MjlERVwiLFwibnZsQXJyXCI6XCJcXHUyOTAyXCIsXCJudmxlXCI6XCJcXHUyMjY0XFx1MjBEMlwiLFwibnZsdFwiOlwiPFxcdTIwRDJcIixcIm52bHRyaWVcIjpcIlxcdTIyQjRcXHUyMEQyXCIsXCJudnJBcnJcIjpcIlxcdTI5MDNcIixcIm52cnRyaWVcIjpcIlxcdTIyQjVcXHUyMEQyXCIsXCJudnNpbVwiOlwiXFx1MjIzQ1xcdTIwRDJcIixcIm53YXJoa1wiOlwiXFx1MjkyM1wiLFwibndhcnJcIjpcIlxcdTIxOTZcIixcIm53QXJyXCI6XCJcXHUyMUQ2XCIsXCJud2Fycm93XCI6XCJcXHUyMTk2XCIsXCJud25lYXJcIjpcIlxcdTI5MjdcIixcIk9hY3V0ZVwiOlwiXFx1MDBEM1wiLFwib2FjdXRlXCI6XCJcXHUwMEYzXCIsXCJvYXN0XCI6XCJcXHUyMjlCXCIsXCJPY2lyY1wiOlwiXFx1MDBENFwiLFwib2NpcmNcIjpcIlxcdTAwRjRcIixcIm9jaXJcIjpcIlxcdTIyOUFcIixcIk9jeVwiOlwiXFx1MDQxRVwiLFwib2N5XCI6XCJcXHUwNDNFXCIsXCJvZGFzaFwiOlwiXFx1MjI5RFwiLFwiT2RibGFjXCI6XCJcXHUwMTUwXCIsXCJvZGJsYWNcIjpcIlxcdTAxNTFcIixcIm9kaXZcIjpcIlxcdTJBMzhcIixcIm9kb3RcIjpcIlxcdTIyOTlcIixcIm9kc29sZFwiOlwiXFx1MjlCQ1wiLFwiT0VsaWdcIjpcIlxcdTAxNTJcIixcIm9lbGlnXCI6XCJcXHUwMTUzXCIsXCJvZmNpclwiOlwiXFx1MjlCRlwiLFwiT2ZyXCI6XCJcXHVEODM1XFx1REQxMlwiLFwib2ZyXCI6XCJcXHVEODM1XFx1REQyQ1wiLFwib2dvblwiOlwiXFx1MDJEQlwiLFwiT2dyYXZlXCI6XCJcXHUwMEQyXCIsXCJvZ3JhdmVcIjpcIlxcdTAwRjJcIixcIm9ndFwiOlwiXFx1MjlDMVwiLFwib2hiYXJcIjpcIlxcdTI5QjVcIixcIm9obVwiOlwiXFx1MDNBOVwiLFwib2ludFwiOlwiXFx1MjIyRVwiLFwib2xhcnJcIjpcIlxcdTIxQkFcIixcIm9sY2lyXCI6XCJcXHUyOUJFXCIsXCJvbGNyb3NzXCI6XCJcXHUyOUJCXCIsXCJvbGluZVwiOlwiXFx1MjAzRVwiLFwib2x0XCI6XCJcXHUyOUMwXCIsXCJPbWFjclwiOlwiXFx1MDE0Q1wiLFwib21hY3JcIjpcIlxcdTAxNERcIixcIk9tZWdhXCI6XCJcXHUwM0E5XCIsXCJvbWVnYVwiOlwiXFx1MDNDOVwiLFwiT21pY3JvblwiOlwiXFx1MDM5RlwiLFwib21pY3JvblwiOlwiXFx1MDNCRlwiLFwib21pZFwiOlwiXFx1MjlCNlwiLFwib21pbnVzXCI6XCJcXHUyMjk2XCIsXCJPb3BmXCI6XCJcXHVEODM1XFx1REQ0NlwiLFwib29wZlwiOlwiXFx1RDgzNVxcdURENjBcIixcIm9wYXJcIjpcIlxcdTI5QjdcIixcIk9wZW5DdXJseURvdWJsZVF1b3RlXCI6XCJcXHUyMDFDXCIsXCJPcGVuQ3VybHlRdW90ZVwiOlwiXFx1MjAxOFwiLFwib3BlcnBcIjpcIlxcdTI5QjlcIixcIm9wbHVzXCI6XCJcXHUyMjk1XCIsXCJvcmFyclwiOlwiXFx1MjFCQlwiLFwiT3JcIjpcIlxcdTJBNTRcIixcIm9yXCI6XCJcXHUyMjI4XCIsXCJvcmRcIjpcIlxcdTJBNURcIixcIm9yZGVyXCI6XCJcXHUyMTM0XCIsXCJvcmRlcm9mXCI6XCJcXHUyMTM0XCIsXCJvcmRmXCI6XCJcXHUwMEFBXCIsXCJvcmRtXCI6XCJcXHUwMEJBXCIsXCJvcmlnb2ZcIjpcIlxcdTIyQjZcIixcIm9yb3JcIjpcIlxcdTJBNTZcIixcIm9yc2xvcGVcIjpcIlxcdTJBNTdcIixcIm9ydlwiOlwiXFx1MkE1QlwiLFwib1NcIjpcIlxcdTI0QzhcIixcIk9zY3JcIjpcIlxcdUQ4MzVcXHVEQ0FBXCIsXCJvc2NyXCI6XCJcXHUyMTM0XCIsXCJPc2xhc2hcIjpcIlxcdTAwRDhcIixcIm9zbGFzaFwiOlwiXFx1MDBGOFwiLFwib3NvbFwiOlwiXFx1MjI5OFwiLFwiT3RpbGRlXCI6XCJcXHUwMEQ1XCIsXCJvdGlsZGVcIjpcIlxcdTAwRjVcIixcIm90aW1lc2FzXCI6XCJcXHUyQTM2XCIsXCJPdGltZXNcIjpcIlxcdTJBMzdcIixcIm90aW1lc1wiOlwiXFx1MjI5N1wiLFwiT3VtbFwiOlwiXFx1MDBENlwiLFwib3VtbFwiOlwiXFx1MDBGNlwiLFwib3ZiYXJcIjpcIlxcdTIzM0RcIixcIk92ZXJCYXJcIjpcIlxcdTIwM0VcIixcIk92ZXJCcmFjZVwiOlwiXFx1MjNERVwiLFwiT3ZlckJyYWNrZXRcIjpcIlxcdTIzQjRcIixcIk92ZXJQYXJlbnRoZXNpc1wiOlwiXFx1MjNEQ1wiLFwicGFyYVwiOlwiXFx1MDBCNlwiLFwicGFyYWxsZWxcIjpcIlxcdTIyMjVcIixcInBhclwiOlwiXFx1MjIyNVwiLFwicGFyc2ltXCI6XCJcXHUyQUYzXCIsXCJwYXJzbFwiOlwiXFx1MkFGRFwiLFwicGFydFwiOlwiXFx1MjIwMlwiLFwiUGFydGlhbERcIjpcIlxcdTIyMDJcIixcIlBjeVwiOlwiXFx1MDQxRlwiLFwicGN5XCI6XCJcXHUwNDNGXCIsXCJwZXJjbnRcIjpcIiVcIixcInBlcmlvZFwiOlwiLlwiLFwicGVybWlsXCI6XCJcXHUyMDMwXCIsXCJwZXJwXCI6XCJcXHUyMkE1XCIsXCJwZXJ0ZW5rXCI6XCJcXHUyMDMxXCIsXCJQZnJcIjpcIlxcdUQ4MzVcXHVERDEzXCIsXCJwZnJcIjpcIlxcdUQ4MzVcXHVERDJEXCIsXCJQaGlcIjpcIlxcdTAzQTZcIixcInBoaVwiOlwiXFx1MDNDNlwiLFwicGhpdlwiOlwiXFx1MDNENVwiLFwicGhtbWF0XCI6XCJcXHUyMTMzXCIsXCJwaG9uZVwiOlwiXFx1MjYwRVwiLFwiUGlcIjpcIlxcdTAzQTBcIixcInBpXCI6XCJcXHUwM0MwXCIsXCJwaXRjaGZvcmtcIjpcIlxcdTIyRDRcIixcInBpdlwiOlwiXFx1MDNENlwiLFwicGxhbmNrXCI6XCJcXHUyMTBGXCIsXCJwbGFuY2toXCI6XCJcXHUyMTBFXCIsXCJwbGFua3ZcIjpcIlxcdTIxMEZcIixcInBsdXNhY2lyXCI6XCJcXHUyQTIzXCIsXCJwbHVzYlwiOlwiXFx1MjI5RVwiLFwicGx1c2NpclwiOlwiXFx1MkEyMlwiLFwicGx1c1wiOlwiK1wiLFwicGx1c2RvXCI6XCJcXHUyMjE0XCIsXCJwbHVzZHVcIjpcIlxcdTJBMjVcIixcInBsdXNlXCI6XCJcXHUyQTcyXCIsXCJQbHVzTWludXNcIjpcIlxcdTAwQjFcIixcInBsdXNtblwiOlwiXFx1MDBCMVwiLFwicGx1c3NpbVwiOlwiXFx1MkEyNlwiLFwicGx1c3R3b1wiOlwiXFx1MkEyN1wiLFwicG1cIjpcIlxcdTAwQjFcIixcIlBvaW5jYXJlcGxhbmVcIjpcIlxcdTIxMENcIixcInBvaW50aW50XCI6XCJcXHUyQTE1XCIsXCJwb3BmXCI6XCJcXHVEODM1XFx1REQ2MVwiLFwiUG9wZlwiOlwiXFx1MjExOVwiLFwicG91bmRcIjpcIlxcdTAwQTNcIixcInByYXBcIjpcIlxcdTJBQjdcIixcIlByXCI6XCJcXHUyQUJCXCIsXCJwclwiOlwiXFx1MjI3QVwiLFwicHJjdWVcIjpcIlxcdTIyN0NcIixcInByZWNhcHByb3hcIjpcIlxcdTJBQjdcIixcInByZWNcIjpcIlxcdTIyN0FcIixcInByZWNjdXJseWVxXCI6XCJcXHUyMjdDXCIsXCJQcmVjZWRlc1wiOlwiXFx1MjI3QVwiLFwiUHJlY2VkZXNFcXVhbFwiOlwiXFx1MkFBRlwiLFwiUHJlY2VkZXNTbGFudEVxdWFsXCI6XCJcXHUyMjdDXCIsXCJQcmVjZWRlc1RpbGRlXCI6XCJcXHUyMjdFXCIsXCJwcmVjZXFcIjpcIlxcdTJBQUZcIixcInByZWNuYXBwcm94XCI6XCJcXHUyQUI5XCIsXCJwcmVjbmVxcVwiOlwiXFx1MkFCNVwiLFwicHJlY25zaW1cIjpcIlxcdTIyRThcIixcInByZVwiOlwiXFx1MkFBRlwiLFwicHJFXCI6XCJcXHUyQUIzXCIsXCJwcmVjc2ltXCI6XCJcXHUyMjdFXCIsXCJwcmltZVwiOlwiXFx1MjAzMlwiLFwiUHJpbWVcIjpcIlxcdTIwMzNcIixcInByaW1lc1wiOlwiXFx1MjExOVwiLFwicHJuYXBcIjpcIlxcdTJBQjlcIixcInBybkVcIjpcIlxcdTJBQjVcIixcInBybnNpbVwiOlwiXFx1MjJFOFwiLFwicHJvZFwiOlwiXFx1MjIwRlwiLFwiUHJvZHVjdFwiOlwiXFx1MjIwRlwiLFwicHJvZmFsYXJcIjpcIlxcdTIzMkVcIixcInByb2ZsaW5lXCI6XCJcXHUyMzEyXCIsXCJwcm9mc3VyZlwiOlwiXFx1MjMxM1wiLFwicHJvcFwiOlwiXFx1MjIxRFwiLFwiUHJvcG9ydGlvbmFsXCI6XCJcXHUyMjFEXCIsXCJQcm9wb3J0aW9uXCI6XCJcXHUyMjM3XCIsXCJwcm9wdG9cIjpcIlxcdTIyMURcIixcInByc2ltXCI6XCJcXHUyMjdFXCIsXCJwcnVyZWxcIjpcIlxcdTIyQjBcIixcIlBzY3JcIjpcIlxcdUQ4MzVcXHVEQ0FCXCIsXCJwc2NyXCI6XCJcXHVEODM1XFx1RENDNVwiLFwiUHNpXCI6XCJcXHUwM0E4XCIsXCJwc2lcIjpcIlxcdTAzQzhcIixcInB1bmNzcFwiOlwiXFx1MjAwOFwiLFwiUWZyXCI6XCJcXHVEODM1XFx1REQxNFwiLFwicWZyXCI6XCJcXHVEODM1XFx1REQyRVwiLFwicWludFwiOlwiXFx1MkEwQ1wiLFwicW9wZlwiOlwiXFx1RDgzNVxcdURENjJcIixcIlFvcGZcIjpcIlxcdTIxMUFcIixcInFwcmltZVwiOlwiXFx1MjA1N1wiLFwiUXNjclwiOlwiXFx1RDgzNVxcdURDQUNcIixcInFzY3JcIjpcIlxcdUQ4MzVcXHVEQ0M2XCIsXCJxdWF0ZXJuaW9uc1wiOlwiXFx1MjEwRFwiLFwicXVhdGludFwiOlwiXFx1MkExNlwiLFwicXVlc3RcIjpcIj9cIixcInF1ZXN0ZXFcIjpcIlxcdTIyNUZcIixcInF1b3RcIjpcIlxcXCJcIixcIlFVT1RcIjpcIlxcXCJcIixcInJBYXJyXCI6XCJcXHUyMURCXCIsXCJyYWNlXCI6XCJcXHUyMjNEXFx1MDMzMVwiLFwiUmFjdXRlXCI6XCJcXHUwMTU0XCIsXCJyYWN1dGVcIjpcIlxcdTAxNTVcIixcInJhZGljXCI6XCJcXHUyMjFBXCIsXCJyYWVtcHR5dlwiOlwiXFx1MjlCM1wiLFwicmFuZ1wiOlwiXFx1MjdFOVwiLFwiUmFuZ1wiOlwiXFx1MjdFQlwiLFwicmFuZ2RcIjpcIlxcdTI5OTJcIixcInJhbmdlXCI6XCJcXHUyOUE1XCIsXCJyYW5nbGVcIjpcIlxcdTI3RTlcIixcInJhcXVvXCI6XCJcXHUwMEJCXCIsXCJyYXJyYXBcIjpcIlxcdTI5NzVcIixcInJhcnJiXCI6XCJcXHUyMUU1XCIsXCJyYXJyYmZzXCI6XCJcXHUyOTIwXCIsXCJyYXJyY1wiOlwiXFx1MjkzM1wiLFwicmFyclwiOlwiXFx1MjE5MlwiLFwiUmFyclwiOlwiXFx1MjFBMFwiLFwickFyclwiOlwiXFx1MjFEMlwiLFwicmFycmZzXCI6XCJcXHUyOTFFXCIsXCJyYXJyaGtcIjpcIlxcdTIxQUFcIixcInJhcnJscFwiOlwiXFx1MjFBQ1wiLFwicmFycnBsXCI6XCJcXHUyOTQ1XCIsXCJyYXJyc2ltXCI6XCJcXHUyOTc0XCIsXCJSYXJydGxcIjpcIlxcdTI5MTZcIixcInJhcnJ0bFwiOlwiXFx1MjFBM1wiLFwicmFycndcIjpcIlxcdTIxOURcIixcInJhdGFpbFwiOlwiXFx1MjkxQVwiLFwickF0YWlsXCI6XCJcXHUyOTFDXCIsXCJyYXRpb1wiOlwiXFx1MjIzNlwiLFwicmF0aW9uYWxzXCI6XCJcXHUyMTFBXCIsXCJyYmFyclwiOlwiXFx1MjkwRFwiLFwickJhcnJcIjpcIlxcdTI5MEZcIixcIlJCYXJyXCI6XCJcXHUyOTEwXCIsXCJyYmJya1wiOlwiXFx1Mjc3M1wiLFwicmJyYWNlXCI6XCJ9XCIsXCJyYnJhY2tcIjpcIl1cIixcInJicmtlXCI6XCJcXHUyOThDXCIsXCJyYnJrc2xkXCI6XCJcXHUyOThFXCIsXCJyYnJrc2x1XCI6XCJcXHUyOTkwXCIsXCJSY2Fyb25cIjpcIlxcdTAxNThcIixcInJjYXJvblwiOlwiXFx1MDE1OVwiLFwiUmNlZGlsXCI6XCJcXHUwMTU2XCIsXCJyY2VkaWxcIjpcIlxcdTAxNTdcIixcInJjZWlsXCI6XCJcXHUyMzA5XCIsXCJyY3ViXCI6XCJ9XCIsXCJSY3lcIjpcIlxcdTA0MjBcIixcInJjeVwiOlwiXFx1MDQ0MFwiLFwicmRjYVwiOlwiXFx1MjkzN1wiLFwicmRsZGhhclwiOlwiXFx1Mjk2OVwiLFwicmRxdW9cIjpcIlxcdTIwMURcIixcInJkcXVvclwiOlwiXFx1MjAxRFwiLFwicmRzaFwiOlwiXFx1MjFCM1wiLFwicmVhbFwiOlwiXFx1MjExQ1wiLFwicmVhbGluZVwiOlwiXFx1MjExQlwiLFwicmVhbHBhcnRcIjpcIlxcdTIxMUNcIixcInJlYWxzXCI6XCJcXHUyMTFEXCIsXCJSZVwiOlwiXFx1MjExQ1wiLFwicmVjdFwiOlwiXFx1MjVBRFwiLFwicmVnXCI6XCJcXHUwMEFFXCIsXCJSRUdcIjpcIlxcdTAwQUVcIixcIlJldmVyc2VFbGVtZW50XCI6XCJcXHUyMjBCXCIsXCJSZXZlcnNlRXF1aWxpYnJpdW1cIjpcIlxcdTIxQ0JcIixcIlJldmVyc2VVcEVxdWlsaWJyaXVtXCI6XCJcXHUyOTZGXCIsXCJyZmlzaHRcIjpcIlxcdTI5N0RcIixcInJmbG9vclwiOlwiXFx1MjMwQlwiLFwicmZyXCI6XCJcXHVEODM1XFx1REQyRlwiLFwiUmZyXCI6XCJcXHUyMTFDXCIsXCJySGFyXCI6XCJcXHUyOTY0XCIsXCJyaGFyZFwiOlwiXFx1MjFDMVwiLFwicmhhcnVcIjpcIlxcdTIxQzBcIixcInJoYXJ1bFwiOlwiXFx1Mjk2Q1wiLFwiUmhvXCI6XCJcXHUwM0ExXCIsXCJyaG9cIjpcIlxcdTAzQzFcIixcInJob3ZcIjpcIlxcdTAzRjFcIixcIlJpZ2h0QW5nbGVCcmFja2V0XCI6XCJcXHUyN0U5XCIsXCJSaWdodEFycm93QmFyXCI6XCJcXHUyMUU1XCIsXCJyaWdodGFycm93XCI6XCJcXHUyMTkyXCIsXCJSaWdodEFycm93XCI6XCJcXHUyMTkyXCIsXCJSaWdodGFycm93XCI6XCJcXHUyMUQyXCIsXCJSaWdodEFycm93TGVmdEFycm93XCI6XCJcXHUyMUM0XCIsXCJyaWdodGFycm93dGFpbFwiOlwiXFx1MjFBM1wiLFwiUmlnaHRDZWlsaW5nXCI6XCJcXHUyMzA5XCIsXCJSaWdodERvdWJsZUJyYWNrZXRcIjpcIlxcdTI3RTdcIixcIlJpZ2h0RG93blRlZVZlY3RvclwiOlwiXFx1Mjk1RFwiLFwiUmlnaHREb3duVmVjdG9yQmFyXCI6XCJcXHUyOTU1XCIsXCJSaWdodERvd25WZWN0b3JcIjpcIlxcdTIxQzJcIixcIlJpZ2h0Rmxvb3JcIjpcIlxcdTIzMEJcIixcInJpZ2h0aGFycG9vbmRvd25cIjpcIlxcdTIxQzFcIixcInJpZ2h0aGFycG9vbnVwXCI6XCJcXHUyMUMwXCIsXCJyaWdodGxlZnRhcnJvd3NcIjpcIlxcdTIxQzRcIixcInJpZ2h0bGVmdGhhcnBvb25zXCI6XCJcXHUyMUNDXCIsXCJyaWdodHJpZ2h0YXJyb3dzXCI6XCJcXHUyMUM5XCIsXCJyaWdodHNxdWlnYXJyb3dcIjpcIlxcdTIxOURcIixcIlJpZ2h0VGVlQXJyb3dcIjpcIlxcdTIxQTZcIixcIlJpZ2h0VGVlXCI6XCJcXHUyMkEyXCIsXCJSaWdodFRlZVZlY3RvclwiOlwiXFx1Mjk1QlwiLFwicmlnaHR0aHJlZXRpbWVzXCI6XCJcXHUyMkNDXCIsXCJSaWdodFRyaWFuZ2xlQmFyXCI6XCJcXHUyOUQwXCIsXCJSaWdodFRyaWFuZ2xlXCI6XCJcXHUyMkIzXCIsXCJSaWdodFRyaWFuZ2xlRXF1YWxcIjpcIlxcdTIyQjVcIixcIlJpZ2h0VXBEb3duVmVjdG9yXCI6XCJcXHUyOTRGXCIsXCJSaWdodFVwVGVlVmVjdG9yXCI6XCJcXHUyOTVDXCIsXCJSaWdodFVwVmVjdG9yQmFyXCI6XCJcXHUyOTU0XCIsXCJSaWdodFVwVmVjdG9yXCI6XCJcXHUyMUJFXCIsXCJSaWdodFZlY3RvckJhclwiOlwiXFx1Mjk1M1wiLFwiUmlnaHRWZWN0b3JcIjpcIlxcdTIxQzBcIixcInJpbmdcIjpcIlxcdTAyREFcIixcInJpc2luZ2RvdHNlcVwiOlwiXFx1MjI1M1wiLFwicmxhcnJcIjpcIlxcdTIxQzRcIixcInJsaGFyXCI6XCJcXHUyMUNDXCIsXCJybG1cIjpcIlxcdTIwMEZcIixcInJtb3VzdGFjaGVcIjpcIlxcdTIzQjFcIixcInJtb3VzdFwiOlwiXFx1MjNCMVwiLFwicm5taWRcIjpcIlxcdTJBRUVcIixcInJvYW5nXCI6XCJcXHUyN0VEXCIsXCJyb2FyclwiOlwiXFx1MjFGRVwiLFwicm9icmtcIjpcIlxcdTI3RTdcIixcInJvcGFyXCI6XCJcXHUyOTg2XCIsXCJyb3BmXCI6XCJcXHVEODM1XFx1REQ2M1wiLFwiUm9wZlwiOlwiXFx1MjExRFwiLFwicm9wbHVzXCI6XCJcXHUyQTJFXCIsXCJyb3RpbWVzXCI6XCJcXHUyQTM1XCIsXCJSb3VuZEltcGxpZXNcIjpcIlxcdTI5NzBcIixcInJwYXJcIjpcIilcIixcInJwYXJndFwiOlwiXFx1Mjk5NFwiLFwicnBwb2xpbnRcIjpcIlxcdTJBMTJcIixcInJyYXJyXCI6XCJcXHUyMUM5XCIsXCJScmlnaHRhcnJvd1wiOlwiXFx1MjFEQlwiLFwicnNhcXVvXCI6XCJcXHUyMDNBXCIsXCJyc2NyXCI6XCJcXHVEODM1XFx1RENDN1wiLFwiUnNjclwiOlwiXFx1MjExQlwiLFwicnNoXCI6XCJcXHUyMUIxXCIsXCJSc2hcIjpcIlxcdTIxQjFcIixcInJzcWJcIjpcIl1cIixcInJzcXVvXCI6XCJcXHUyMDE5XCIsXCJyc3F1b3JcIjpcIlxcdTIwMTlcIixcInJ0aHJlZVwiOlwiXFx1MjJDQ1wiLFwicnRpbWVzXCI6XCJcXHUyMkNBXCIsXCJydHJpXCI6XCJcXHUyNUI5XCIsXCJydHJpZVwiOlwiXFx1MjJCNVwiLFwicnRyaWZcIjpcIlxcdTI1QjhcIixcInJ0cmlsdHJpXCI6XCJcXHUyOUNFXCIsXCJSdWxlRGVsYXllZFwiOlwiXFx1MjlGNFwiLFwicnVsdWhhclwiOlwiXFx1Mjk2OFwiLFwicnhcIjpcIlxcdTIxMUVcIixcIlNhY3V0ZVwiOlwiXFx1MDE1QVwiLFwic2FjdXRlXCI6XCJcXHUwMTVCXCIsXCJzYnF1b1wiOlwiXFx1MjAxQVwiLFwic2NhcFwiOlwiXFx1MkFCOFwiLFwiU2Nhcm9uXCI6XCJcXHUwMTYwXCIsXCJzY2Fyb25cIjpcIlxcdTAxNjFcIixcIlNjXCI6XCJcXHUyQUJDXCIsXCJzY1wiOlwiXFx1MjI3QlwiLFwic2NjdWVcIjpcIlxcdTIyN0RcIixcInNjZVwiOlwiXFx1MkFCMFwiLFwic2NFXCI6XCJcXHUyQUI0XCIsXCJTY2VkaWxcIjpcIlxcdTAxNUVcIixcInNjZWRpbFwiOlwiXFx1MDE1RlwiLFwiU2NpcmNcIjpcIlxcdTAxNUNcIixcInNjaXJjXCI6XCJcXHUwMTVEXCIsXCJzY25hcFwiOlwiXFx1MkFCQVwiLFwic2NuRVwiOlwiXFx1MkFCNlwiLFwic2Nuc2ltXCI6XCJcXHUyMkU5XCIsXCJzY3BvbGludFwiOlwiXFx1MkExM1wiLFwic2NzaW1cIjpcIlxcdTIyN0ZcIixcIlNjeVwiOlwiXFx1MDQyMVwiLFwic2N5XCI6XCJcXHUwNDQxXCIsXCJzZG90YlwiOlwiXFx1MjJBMVwiLFwic2RvdFwiOlwiXFx1MjJDNVwiLFwic2RvdGVcIjpcIlxcdTJBNjZcIixcInNlYXJoa1wiOlwiXFx1MjkyNVwiLFwic2VhcnJcIjpcIlxcdTIxOThcIixcInNlQXJyXCI6XCJcXHUyMUQ4XCIsXCJzZWFycm93XCI6XCJcXHUyMTk4XCIsXCJzZWN0XCI6XCJcXHUwMEE3XCIsXCJzZW1pXCI6XCI7XCIsXCJzZXN3YXJcIjpcIlxcdTI5MjlcIixcInNldG1pbnVzXCI6XCJcXHUyMjE2XCIsXCJzZXRtblwiOlwiXFx1MjIxNlwiLFwic2V4dFwiOlwiXFx1MjczNlwiLFwiU2ZyXCI6XCJcXHVEODM1XFx1REQxNlwiLFwic2ZyXCI6XCJcXHVEODM1XFx1REQzMFwiLFwic2Zyb3duXCI6XCJcXHUyMzIyXCIsXCJzaGFycFwiOlwiXFx1MjY2RlwiLFwiU0hDSGN5XCI6XCJcXHUwNDI5XCIsXCJzaGNoY3lcIjpcIlxcdTA0NDlcIixcIlNIY3lcIjpcIlxcdTA0MjhcIixcInNoY3lcIjpcIlxcdTA0NDhcIixcIlNob3J0RG93bkFycm93XCI6XCJcXHUyMTkzXCIsXCJTaG9ydExlZnRBcnJvd1wiOlwiXFx1MjE5MFwiLFwic2hvcnRtaWRcIjpcIlxcdTIyMjNcIixcInNob3J0cGFyYWxsZWxcIjpcIlxcdTIyMjVcIixcIlNob3J0UmlnaHRBcnJvd1wiOlwiXFx1MjE5MlwiLFwiU2hvcnRVcEFycm93XCI6XCJcXHUyMTkxXCIsXCJzaHlcIjpcIlxcdTAwQURcIixcIlNpZ21hXCI6XCJcXHUwM0EzXCIsXCJzaWdtYVwiOlwiXFx1MDNDM1wiLFwic2lnbWFmXCI6XCJcXHUwM0MyXCIsXCJzaWdtYXZcIjpcIlxcdTAzQzJcIixcInNpbVwiOlwiXFx1MjIzQ1wiLFwic2ltZG90XCI6XCJcXHUyQTZBXCIsXCJzaW1lXCI6XCJcXHUyMjQzXCIsXCJzaW1lcVwiOlwiXFx1MjI0M1wiLFwic2ltZ1wiOlwiXFx1MkE5RVwiLFwic2ltZ0VcIjpcIlxcdTJBQTBcIixcInNpbWxcIjpcIlxcdTJBOURcIixcInNpbWxFXCI6XCJcXHUyQTlGXCIsXCJzaW1uZVwiOlwiXFx1MjI0NlwiLFwic2ltcGx1c1wiOlwiXFx1MkEyNFwiLFwic2ltcmFyclwiOlwiXFx1Mjk3MlwiLFwic2xhcnJcIjpcIlxcdTIxOTBcIixcIlNtYWxsQ2lyY2xlXCI6XCJcXHUyMjE4XCIsXCJzbWFsbHNldG1pbnVzXCI6XCJcXHUyMjE2XCIsXCJzbWFzaHBcIjpcIlxcdTJBMzNcIixcInNtZXBhcnNsXCI6XCJcXHUyOUU0XCIsXCJzbWlkXCI6XCJcXHUyMjIzXCIsXCJzbWlsZVwiOlwiXFx1MjMyM1wiLFwic210XCI6XCJcXHUyQUFBXCIsXCJzbXRlXCI6XCJcXHUyQUFDXCIsXCJzbXRlc1wiOlwiXFx1MkFBQ1xcdUZFMDBcIixcIlNPRlRjeVwiOlwiXFx1MDQyQ1wiLFwic29mdGN5XCI6XCJcXHUwNDRDXCIsXCJzb2xiYXJcIjpcIlxcdTIzM0ZcIixcInNvbGJcIjpcIlxcdTI5QzRcIixcInNvbFwiOlwiL1wiLFwiU29wZlwiOlwiXFx1RDgzNVxcdURENEFcIixcInNvcGZcIjpcIlxcdUQ4MzVcXHVERDY0XCIsXCJzcGFkZXNcIjpcIlxcdTI2NjBcIixcInNwYWRlc3VpdFwiOlwiXFx1MjY2MFwiLFwic3BhclwiOlwiXFx1MjIyNVwiLFwic3FjYXBcIjpcIlxcdTIyOTNcIixcInNxY2Fwc1wiOlwiXFx1MjI5M1xcdUZFMDBcIixcInNxY3VwXCI6XCJcXHUyMjk0XCIsXCJzcWN1cHNcIjpcIlxcdTIyOTRcXHVGRTAwXCIsXCJTcXJ0XCI6XCJcXHUyMjFBXCIsXCJzcXN1YlwiOlwiXFx1MjI4RlwiLFwic3FzdWJlXCI6XCJcXHUyMjkxXCIsXCJzcXN1YnNldFwiOlwiXFx1MjI4RlwiLFwic3FzdWJzZXRlcVwiOlwiXFx1MjI5MVwiLFwic3FzdXBcIjpcIlxcdTIyOTBcIixcInNxc3VwZVwiOlwiXFx1MjI5MlwiLFwic3FzdXBzZXRcIjpcIlxcdTIyOTBcIixcInNxc3Vwc2V0ZXFcIjpcIlxcdTIyOTJcIixcInNxdWFyZVwiOlwiXFx1MjVBMVwiLFwiU3F1YXJlXCI6XCJcXHUyNUExXCIsXCJTcXVhcmVJbnRlcnNlY3Rpb25cIjpcIlxcdTIyOTNcIixcIlNxdWFyZVN1YnNldFwiOlwiXFx1MjI4RlwiLFwiU3F1YXJlU3Vic2V0RXF1YWxcIjpcIlxcdTIyOTFcIixcIlNxdWFyZVN1cGVyc2V0XCI6XCJcXHUyMjkwXCIsXCJTcXVhcmVTdXBlcnNldEVxdWFsXCI6XCJcXHUyMjkyXCIsXCJTcXVhcmVVbmlvblwiOlwiXFx1MjI5NFwiLFwic3F1YXJmXCI6XCJcXHUyNUFBXCIsXCJzcXVcIjpcIlxcdTI1QTFcIixcInNxdWZcIjpcIlxcdTI1QUFcIixcInNyYXJyXCI6XCJcXHUyMTkyXCIsXCJTc2NyXCI6XCJcXHVEODM1XFx1RENBRVwiLFwic3NjclwiOlwiXFx1RDgzNVxcdURDQzhcIixcInNzZXRtblwiOlwiXFx1MjIxNlwiLFwic3NtaWxlXCI6XCJcXHUyMzIzXCIsXCJzc3RhcmZcIjpcIlxcdTIyQzZcIixcIlN0YXJcIjpcIlxcdTIyQzZcIixcInN0YXJcIjpcIlxcdTI2MDZcIixcInN0YXJmXCI6XCJcXHUyNjA1XCIsXCJzdHJhaWdodGVwc2lsb25cIjpcIlxcdTAzRjVcIixcInN0cmFpZ2h0cGhpXCI6XCJcXHUwM0Q1XCIsXCJzdHJuc1wiOlwiXFx1MDBBRlwiLFwic3ViXCI6XCJcXHUyMjgyXCIsXCJTdWJcIjpcIlxcdTIyRDBcIixcInN1YmRvdFwiOlwiXFx1MkFCRFwiLFwic3ViRVwiOlwiXFx1MkFDNVwiLFwic3ViZVwiOlwiXFx1MjI4NlwiLFwic3ViZWRvdFwiOlwiXFx1MkFDM1wiLFwic3VibXVsdFwiOlwiXFx1MkFDMVwiLFwic3VibkVcIjpcIlxcdTJBQ0JcIixcInN1Ym5lXCI6XCJcXHUyMjhBXCIsXCJzdWJwbHVzXCI6XCJcXHUyQUJGXCIsXCJzdWJyYXJyXCI6XCJcXHUyOTc5XCIsXCJzdWJzZXRcIjpcIlxcdTIyODJcIixcIlN1YnNldFwiOlwiXFx1MjJEMFwiLFwic3Vic2V0ZXFcIjpcIlxcdTIyODZcIixcInN1YnNldGVxcVwiOlwiXFx1MkFDNVwiLFwiU3Vic2V0RXF1YWxcIjpcIlxcdTIyODZcIixcInN1YnNldG5lcVwiOlwiXFx1MjI4QVwiLFwic3Vic2V0bmVxcVwiOlwiXFx1MkFDQlwiLFwic3Vic2ltXCI6XCJcXHUyQUM3XCIsXCJzdWJzdWJcIjpcIlxcdTJBRDVcIixcInN1YnN1cFwiOlwiXFx1MkFEM1wiLFwic3VjY2FwcHJveFwiOlwiXFx1MkFCOFwiLFwic3VjY1wiOlwiXFx1MjI3QlwiLFwic3VjY2N1cmx5ZXFcIjpcIlxcdTIyN0RcIixcIlN1Y2NlZWRzXCI6XCJcXHUyMjdCXCIsXCJTdWNjZWVkc0VxdWFsXCI6XCJcXHUyQUIwXCIsXCJTdWNjZWVkc1NsYW50RXF1YWxcIjpcIlxcdTIyN0RcIixcIlN1Y2NlZWRzVGlsZGVcIjpcIlxcdTIyN0ZcIixcInN1Y2NlcVwiOlwiXFx1MkFCMFwiLFwic3VjY25hcHByb3hcIjpcIlxcdTJBQkFcIixcInN1Y2NuZXFxXCI6XCJcXHUyQUI2XCIsXCJzdWNjbnNpbVwiOlwiXFx1MjJFOVwiLFwic3VjY3NpbVwiOlwiXFx1MjI3RlwiLFwiU3VjaFRoYXRcIjpcIlxcdTIyMEJcIixcInN1bVwiOlwiXFx1MjIxMVwiLFwiU3VtXCI6XCJcXHUyMjExXCIsXCJzdW5nXCI6XCJcXHUyNjZBXCIsXCJzdXAxXCI6XCJcXHUwMEI5XCIsXCJzdXAyXCI6XCJcXHUwMEIyXCIsXCJzdXAzXCI6XCJcXHUwMEIzXCIsXCJzdXBcIjpcIlxcdTIyODNcIixcIlN1cFwiOlwiXFx1MjJEMVwiLFwic3VwZG90XCI6XCJcXHUyQUJFXCIsXCJzdXBkc3ViXCI6XCJcXHUyQUQ4XCIsXCJzdXBFXCI6XCJcXHUyQUM2XCIsXCJzdXBlXCI6XCJcXHUyMjg3XCIsXCJzdXBlZG90XCI6XCJcXHUyQUM0XCIsXCJTdXBlcnNldFwiOlwiXFx1MjI4M1wiLFwiU3VwZXJzZXRFcXVhbFwiOlwiXFx1MjI4N1wiLFwic3VwaHNvbFwiOlwiXFx1MjdDOVwiLFwic3VwaHN1YlwiOlwiXFx1MkFEN1wiLFwic3VwbGFyclwiOlwiXFx1Mjk3QlwiLFwic3VwbXVsdFwiOlwiXFx1MkFDMlwiLFwic3VwbkVcIjpcIlxcdTJBQ0NcIixcInN1cG5lXCI6XCJcXHUyMjhCXCIsXCJzdXBwbHVzXCI6XCJcXHUyQUMwXCIsXCJzdXBzZXRcIjpcIlxcdTIyODNcIixcIlN1cHNldFwiOlwiXFx1MjJEMVwiLFwic3Vwc2V0ZXFcIjpcIlxcdTIyODdcIixcInN1cHNldGVxcVwiOlwiXFx1MkFDNlwiLFwic3Vwc2V0bmVxXCI6XCJcXHUyMjhCXCIsXCJzdXBzZXRuZXFxXCI6XCJcXHUyQUNDXCIsXCJzdXBzaW1cIjpcIlxcdTJBQzhcIixcInN1cHN1YlwiOlwiXFx1MkFENFwiLFwic3Vwc3VwXCI6XCJcXHUyQUQ2XCIsXCJzd2FyaGtcIjpcIlxcdTI5MjZcIixcInN3YXJyXCI6XCJcXHUyMTk5XCIsXCJzd0FyclwiOlwiXFx1MjFEOVwiLFwic3dhcnJvd1wiOlwiXFx1MjE5OVwiLFwic3dud2FyXCI6XCJcXHUyOTJBXCIsXCJzemxpZ1wiOlwiXFx1MDBERlwiLFwiVGFiXCI6XCJcXHRcIixcInRhcmdldFwiOlwiXFx1MjMxNlwiLFwiVGF1XCI6XCJcXHUwM0E0XCIsXCJ0YXVcIjpcIlxcdTAzQzRcIixcInRicmtcIjpcIlxcdTIzQjRcIixcIlRjYXJvblwiOlwiXFx1MDE2NFwiLFwidGNhcm9uXCI6XCJcXHUwMTY1XCIsXCJUY2VkaWxcIjpcIlxcdTAxNjJcIixcInRjZWRpbFwiOlwiXFx1MDE2M1wiLFwiVGN5XCI6XCJcXHUwNDIyXCIsXCJ0Y3lcIjpcIlxcdTA0NDJcIixcInRkb3RcIjpcIlxcdTIwREJcIixcInRlbHJlY1wiOlwiXFx1MjMxNVwiLFwiVGZyXCI6XCJcXHVEODM1XFx1REQxN1wiLFwidGZyXCI6XCJcXHVEODM1XFx1REQzMVwiLFwidGhlcmU0XCI6XCJcXHUyMjM0XCIsXCJ0aGVyZWZvcmVcIjpcIlxcdTIyMzRcIixcIlRoZXJlZm9yZVwiOlwiXFx1MjIzNFwiLFwiVGhldGFcIjpcIlxcdTAzOThcIixcInRoZXRhXCI6XCJcXHUwM0I4XCIsXCJ0aGV0YXN5bVwiOlwiXFx1MDNEMVwiLFwidGhldGF2XCI6XCJcXHUwM0QxXCIsXCJ0aGlja2FwcHJveFwiOlwiXFx1MjI0OFwiLFwidGhpY2tzaW1cIjpcIlxcdTIyM0NcIixcIlRoaWNrU3BhY2VcIjpcIlxcdTIwNUZcXHUyMDBBXCIsXCJUaGluU3BhY2VcIjpcIlxcdTIwMDlcIixcInRoaW5zcFwiOlwiXFx1MjAwOVwiLFwidGhrYXBcIjpcIlxcdTIyNDhcIixcInRoa3NpbVwiOlwiXFx1MjIzQ1wiLFwiVEhPUk5cIjpcIlxcdTAwREVcIixcInRob3JuXCI6XCJcXHUwMEZFXCIsXCJ0aWxkZVwiOlwiXFx1MDJEQ1wiLFwiVGlsZGVcIjpcIlxcdTIyM0NcIixcIlRpbGRlRXF1YWxcIjpcIlxcdTIyNDNcIixcIlRpbGRlRnVsbEVxdWFsXCI6XCJcXHUyMjQ1XCIsXCJUaWxkZVRpbGRlXCI6XCJcXHUyMjQ4XCIsXCJ0aW1lc2JhclwiOlwiXFx1MkEzMVwiLFwidGltZXNiXCI6XCJcXHUyMkEwXCIsXCJ0aW1lc1wiOlwiXFx1MDBEN1wiLFwidGltZXNkXCI6XCJcXHUyQTMwXCIsXCJ0aW50XCI6XCJcXHUyMjJEXCIsXCJ0b2VhXCI6XCJcXHUyOTI4XCIsXCJ0b3Bib3RcIjpcIlxcdTIzMzZcIixcInRvcGNpclwiOlwiXFx1MkFGMVwiLFwidG9wXCI6XCJcXHUyMkE0XCIsXCJUb3BmXCI6XCJcXHVEODM1XFx1REQ0QlwiLFwidG9wZlwiOlwiXFx1RDgzNVxcdURENjVcIixcInRvcGZvcmtcIjpcIlxcdTJBREFcIixcInRvc2FcIjpcIlxcdTI5MjlcIixcInRwcmltZVwiOlwiXFx1MjAzNFwiLFwidHJhZGVcIjpcIlxcdTIxMjJcIixcIlRSQURFXCI6XCJcXHUyMTIyXCIsXCJ0cmlhbmdsZVwiOlwiXFx1MjVCNVwiLFwidHJpYW5nbGVkb3duXCI6XCJcXHUyNUJGXCIsXCJ0cmlhbmdsZWxlZnRcIjpcIlxcdTI1QzNcIixcInRyaWFuZ2xlbGVmdGVxXCI6XCJcXHUyMkI0XCIsXCJ0cmlhbmdsZXFcIjpcIlxcdTIyNUNcIixcInRyaWFuZ2xlcmlnaHRcIjpcIlxcdTI1QjlcIixcInRyaWFuZ2xlcmlnaHRlcVwiOlwiXFx1MjJCNVwiLFwidHJpZG90XCI6XCJcXHUyNUVDXCIsXCJ0cmllXCI6XCJcXHUyMjVDXCIsXCJ0cmltaW51c1wiOlwiXFx1MkEzQVwiLFwiVHJpcGxlRG90XCI6XCJcXHUyMERCXCIsXCJ0cmlwbHVzXCI6XCJcXHUyQTM5XCIsXCJ0cmlzYlwiOlwiXFx1MjlDRFwiLFwidHJpdGltZVwiOlwiXFx1MkEzQlwiLFwidHJwZXppdW1cIjpcIlxcdTIzRTJcIixcIlRzY3JcIjpcIlxcdUQ4MzVcXHVEQ0FGXCIsXCJ0c2NyXCI6XCJcXHVEODM1XFx1RENDOVwiLFwiVFNjeVwiOlwiXFx1MDQyNlwiLFwidHNjeVwiOlwiXFx1MDQ0NlwiLFwiVFNIY3lcIjpcIlxcdTA0MEJcIixcInRzaGN5XCI6XCJcXHUwNDVCXCIsXCJUc3Ryb2tcIjpcIlxcdTAxNjZcIixcInRzdHJva1wiOlwiXFx1MDE2N1wiLFwidHdpeHRcIjpcIlxcdTIyNkNcIixcInR3b2hlYWRsZWZ0YXJyb3dcIjpcIlxcdTIxOUVcIixcInR3b2hlYWRyaWdodGFycm93XCI6XCJcXHUyMUEwXCIsXCJVYWN1dGVcIjpcIlxcdTAwREFcIixcInVhY3V0ZVwiOlwiXFx1MDBGQVwiLFwidWFyclwiOlwiXFx1MjE5MVwiLFwiVWFyclwiOlwiXFx1MjE5RlwiLFwidUFyclwiOlwiXFx1MjFEMVwiLFwiVWFycm9jaXJcIjpcIlxcdTI5NDlcIixcIlVicmN5XCI6XCJcXHUwNDBFXCIsXCJ1YnJjeVwiOlwiXFx1MDQ1RVwiLFwiVWJyZXZlXCI6XCJcXHUwMTZDXCIsXCJ1YnJldmVcIjpcIlxcdTAxNkRcIixcIlVjaXJjXCI6XCJcXHUwMERCXCIsXCJ1Y2lyY1wiOlwiXFx1MDBGQlwiLFwiVWN5XCI6XCJcXHUwNDIzXCIsXCJ1Y3lcIjpcIlxcdTA0NDNcIixcInVkYXJyXCI6XCJcXHUyMUM1XCIsXCJVZGJsYWNcIjpcIlxcdTAxNzBcIixcInVkYmxhY1wiOlwiXFx1MDE3MVwiLFwidWRoYXJcIjpcIlxcdTI5NkVcIixcInVmaXNodFwiOlwiXFx1Mjk3RVwiLFwiVWZyXCI6XCJcXHVEODM1XFx1REQxOFwiLFwidWZyXCI6XCJcXHVEODM1XFx1REQzMlwiLFwiVWdyYXZlXCI6XCJcXHUwMEQ5XCIsXCJ1Z3JhdmVcIjpcIlxcdTAwRjlcIixcInVIYXJcIjpcIlxcdTI5NjNcIixcInVoYXJsXCI6XCJcXHUyMUJGXCIsXCJ1aGFyclwiOlwiXFx1MjFCRVwiLFwidWhibGtcIjpcIlxcdTI1ODBcIixcInVsY29yblwiOlwiXFx1MjMxQ1wiLFwidWxjb3JuZXJcIjpcIlxcdTIzMUNcIixcInVsY3JvcFwiOlwiXFx1MjMwRlwiLFwidWx0cmlcIjpcIlxcdTI1RjhcIixcIlVtYWNyXCI6XCJcXHUwMTZBXCIsXCJ1bWFjclwiOlwiXFx1MDE2QlwiLFwidW1sXCI6XCJcXHUwMEE4XCIsXCJVbmRlckJhclwiOlwiX1wiLFwiVW5kZXJCcmFjZVwiOlwiXFx1MjNERlwiLFwiVW5kZXJCcmFja2V0XCI6XCJcXHUyM0I1XCIsXCJVbmRlclBhcmVudGhlc2lzXCI6XCJcXHUyM0REXCIsXCJVbmlvblwiOlwiXFx1MjJDM1wiLFwiVW5pb25QbHVzXCI6XCJcXHUyMjhFXCIsXCJVb2dvblwiOlwiXFx1MDE3MlwiLFwidW9nb25cIjpcIlxcdTAxNzNcIixcIlVvcGZcIjpcIlxcdUQ4MzVcXHVERDRDXCIsXCJ1b3BmXCI6XCJcXHVEODM1XFx1REQ2NlwiLFwiVXBBcnJvd0JhclwiOlwiXFx1MjkxMlwiLFwidXBhcnJvd1wiOlwiXFx1MjE5MVwiLFwiVXBBcnJvd1wiOlwiXFx1MjE5MVwiLFwiVXBhcnJvd1wiOlwiXFx1MjFEMVwiLFwiVXBBcnJvd0Rvd25BcnJvd1wiOlwiXFx1MjFDNVwiLFwidXBkb3duYXJyb3dcIjpcIlxcdTIxOTVcIixcIlVwRG93bkFycm93XCI6XCJcXHUyMTk1XCIsXCJVcGRvd25hcnJvd1wiOlwiXFx1MjFENVwiLFwiVXBFcXVpbGlicml1bVwiOlwiXFx1Mjk2RVwiLFwidXBoYXJwb29ubGVmdFwiOlwiXFx1MjFCRlwiLFwidXBoYXJwb29ucmlnaHRcIjpcIlxcdTIxQkVcIixcInVwbHVzXCI6XCJcXHUyMjhFXCIsXCJVcHBlckxlZnRBcnJvd1wiOlwiXFx1MjE5NlwiLFwiVXBwZXJSaWdodEFycm93XCI6XCJcXHUyMTk3XCIsXCJ1cHNpXCI6XCJcXHUwM0M1XCIsXCJVcHNpXCI6XCJcXHUwM0QyXCIsXCJ1cHNpaFwiOlwiXFx1MDNEMlwiLFwiVXBzaWxvblwiOlwiXFx1MDNBNVwiLFwidXBzaWxvblwiOlwiXFx1MDNDNVwiLFwiVXBUZWVBcnJvd1wiOlwiXFx1MjFBNVwiLFwiVXBUZWVcIjpcIlxcdTIyQTVcIixcInVwdXBhcnJvd3NcIjpcIlxcdTIxQzhcIixcInVyY29yblwiOlwiXFx1MjMxRFwiLFwidXJjb3JuZXJcIjpcIlxcdTIzMURcIixcInVyY3JvcFwiOlwiXFx1MjMwRVwiLFwiVXJpbmdcIjpcIlxcdTAxNkVcIixcInVyaW5nXCI6XCJcXHUwMTZGXCIsXCJ1cnRyaVwiOlwiXFx1MjVGOVwiLFwiVXNjclwiOlwiXFx1RDgzNVxcdURDQjBcIixcInVzY3JcIjpcIlxcdUQ4MzVcXHVEQ0NBXCIsXCJ1dGRvdFwiOlwiXFx1MjJGMFwiLFwiVXRpbGRlXCI6XCJcXHUwMTY4XCIsXCJ1dGlsZGVcIjpcIlxcdTAxNjlcIixcInV0cmlcIjpcIlxcdTI1QjVcIixcInV0cmlmXCI6XCJcXHUyNUI0XCIsXCJ1dWFyclwiOlwiXFx1MjFDOFwiLFwiVXVtbFwiOlwiXFx1MDBEQ1wiLFwidXVtbFwiOlwiXFx1MDBGQ1wiLFwidXdhbmdsZVwiOlwiXFx1MjlBN1wiLFwidmFuZ3J0XCI6XCJcXHUyOTlDXCIsXCJ2YXJlcHNpbG9uXCI6XCJcXHUwM0Y1XCIsXCJ2YXJrYXBwYVwiOlwiXFx1MDNGMFwiLFwidmFybm90aGluZ1wiOlwiXFx1MjIwNVwiLFwidmFycGhpXCI6XCJcXHUwM0Q1XCIsXCJ2YXJwaVwiOlwiXFx1MDNENlwiLFwidmFycHJvcHRvXCI6XCJcXHUyMjFEXCIsXCJ2YXJyXCI6XCJcXHUyMTk1XCIsXCJ2QXJyXCI6XCJcXHUyMUQ1XCIsXCJ2YXJyaG9cIjpcIlxcdTAzRjFcIixcInZhcnNpZ21hXCI6XCJcXHUwM0MyXCIsXCJ2YXJzdWJzZXRuZXFcIjpcIlxcdTIyOEFcXHVGRTAwXCIsXCJ2YXJzdWJzZXRuZXFxXCI6XCJcXHUyQUNCXFx1RkUwMFwiLFwidmFyc3Vwc2V0bmVxXCI6XCJcXHUyMjhCXFx1RkUwMFwiLFwidmFyc3Vwc2V0bmVxcVwiOlwiXFx1MkFDQ1xcdUZFMDBcIixcInZhcnRoZXRhXCI6XCJcXHUwM0QxXCIsXCJ2YXJ0cmlhbmdsZWxlZnRcIjpcIlxcdTIyQjJcIixcInZhcnRyaWFuZ2xlcmlnaHRcIjpcIlxcdTIyQjNcIixcInZCYXJcIjpcIlxcdTJBRThcIixcIlZiYXJcIjpcIlxcdTJBRUJcIixcInZCYXJ2XCI6XCJcXHUyQUU5XCIsXCJWY3lcIjpcIlxcdTA0MTJcIixcInZjeVwiOlwiXFx1MDQzMlwiLFwidmRhc2hcIjpcIlxcdTIyQTJcIixcInZEYXNoXCI6XCJcXHUyMkE4XCIsXCJWZGFzaFwiOlwiXFx1MjJBOVwiLFwiVkRhc2hcIjpcIlxcdTIyQUJcIixcIlZkYXNobFwiOlwiXFx1MkFFNlwiLFwidmVlYmFyXCI6XCJcXHUyMkJCXCIsXCJ2ZWVcIjpcIlxcdTIyMjhcIixcIlZlZVwiOlwiXFx1MjJDMVwiLFwidmVlZXFcIjpcIlxcdTIyNUFcIixcInZlbGxpcFwiOlwiXFx1MjJFRVwiLFwidmVyYmFyXCI6XCJ8XCIsXCJWZXJiYXJcIjpcIlxcdTIwMTZcIixcInZlcnRcIjpcInxcIixcIlZlcnRcIjpcIlxcdTIwMTZcIixcIlZlcnRpY2FsQmFyXCI6XCJcXHUyMjIzXCIsXCJWZXJ0aWNhbExpbmVcIjpcInxcIixcIlZlcnRpY2FsU2VwYXJhdG9yXCI6XCJcXHUyNzU4XCIsXCJWZXJ0aWNhbFRpbGRlXCI6XCJcXHUyMjQwXCIsXCJWZXJ5VGhpblNwYWNlXCI6XCJcXHUyMDBBXCIsXCJWZnJcIjpcIlxcdUQ4MzVcXHVERDE5XCIsXCJ2ZnJcIjpcIlxcdUQ4MzVcXHVERDMzXCIsXCJ2bHRyaVwiOlwiXFx1MjJCMlwiLFwidm5zdWJcIjpcIlxcdTIyODJcXHUyMEQyXCIsXCJ2bnN1cFwiOlwiXFx1MjI4M1xcdTIwRDJcIixcIlZvcGZcIjpcIlxcdUQ4MzVcXHVERDREXCIsXCJ2b3BmXCI6XCJcXHVEODM1XFx1REQ2N1wiLFwidnByb3BcIjpcIlxcdTIyMURcIixcInZydHJpXCI6XCJcXHUyMkIzXCIsXCJWc2NyXCI6XCJcXHVEODM1XFx1RENCMVwiLFwidnNjclwiOlwiXFx1RDgzNVxcdURDQ0JcIixcInZzdWJuRVwiOlwiXFx1MkFDQlxcdUZFMDBcIixcInZzdWJuZVwiOlwiXFx1MjI4QVxcdUZFMDBcIixcInZzdXBuRVwiOlwiXFx1MkFDQ1xcdUZFMDBcIixcInZzdXBuZVwiOlwiXFx1MjI4QlxcdUZFMDBcIixcIlZ2ZGFzaFwiOlwiXFx1MjJBQVwiLFwidnppZ3phZ1wiOlwiXFx1Mjk5QVwiLFwiV2NpcmNcIjpcIlxcdTAxNzRcIixcIndjaXJjXCI6XCJcXHUwMTc1XCIsXCJ3ZWRiYXJcIjpcIlxcdTJBNUZcIixcIndlZGdlXCI6XCJcXHUyMjI3XCIsXCJXZWRnZVwiOlwiXFx1MjJDMFwiLFwid2VkZ2VxXCI6XCJcXHUyMjU5XCIsXCJ3ZWllcnBcIjpcIlxcdTIxMThcIixcIldmclwiOlwiXFx1RDgzNVxcdUREMUFcIixcIndmclwiOlwiXFx1RDgzNVxcdUREMzRcIixcIldvcGZcIjpcIlxcdUQ4MzVcXHVERDRFXCIsXCJ3b3BmXCI6XCJcXHVEODM1XFx1REQ2OFwiLFwid3BcIjpcIlxcdTIxMThcIixcIndyXCI6XCJcXHUyMjQwXCIsXCJ3cmVhdGhcIjpcIlxcdTIyNDBcIixcIldzY3JcIjpcIlxcdUQ4MzVcXHVEQ0IyXCIsXCJ3c2NyXCI6XCJcXHVEODM1XFx1RENDQ1wiLFwieGNhcFwiOlwiXFx1MjJDMlwiLFwieGNpcmNcIjpcIlxcdTI1RUZcIixcInhjdXBcIjpcIlxcdTIyQzNcIixcInhkdHJpXCI6XCJcXHUyNUJEXCIsXCJYZnJcIjpcIlxcdUQ4MzVcXHVERDFCXCIsXCJ4ZnJcIjpcIlxcdUQ4MzVcXHVERDM1XCIsXCJ4aGFyclwiOlwiXFx1MjdGN1wiLFwieGhBcnJcIjpcIlxcdTI3RkFcIixcIlhpXCI6XCJcXHUwMzlFXCIsXCJ4aVwiOlwiXFx1MDNCRVwiLFwieGxhcnJcIjpcIlxcdTI3RjVcIixcInhsQXJyXCI6XCJcXHUyN0Y4XCIsXCJ4bWFwXCI6XCJcXHUyN0ZDXCIsXCJ4bmlzXCI6XCJcXHUyMkZCXCIsXCJ4b2RvdFwiOlwiXFx1MkEwMFwiLFwiWG9wZlwiOlwiXFx1RDgzNVxcdURENEZcIixcInhvcGZcIjpcIlxcdUQ4MzVcXHVERDY5XCIsXCJ4b3BsdXNcIjpcIlxcdTJBMDFcIixcInhvdGltZVwiOlwiXFx1MkEwMlwiLFwieHJhcnJcIjpcIlxcdTI3RjZcIixcInhyQXJyXCI6XCJcXHUyN0Y5XCIsXCJYc2NyXCI6XCJcXHVEODM1XFx1RENCM1wiLFwieHNjclwiOlwiXFx1RDgzNVxcdURDQ0RcIixcInhzcWN1cFwiOlwiXFx1MkEwNlwiLFwieHVwbHVzXCI6XCJcXHUyQTA0XCIsXCJ4dXRyaVwiOlwiXFx1MjVCM1wiLFwieHZlZVwiOlwiXFx1MjJDMVwiLFwieHdlZGdlXCI6XCJcXHUyMkMwXCIsXCJZYWN1dGVcIjpcIlxcdTAwRERcIixcInlhY3V0ZVwiOlwiXFx1MDBGRFwiLFwiWUFjeVwiOlwiXFx1MDQyRlwiLFwieWFjeVwiOlwiXFx1MDQ0RlwiLFwiWWNpcmNcIjpcIlxcdTAxNzZcIixcInljaXJjXCI6XCJcXHUwMTc3XCIsXCJZY3lcIjpcIlxcdTA0MkJcIixcInljeVwiOlwiXFx1MDQ0QlwiLFwieWVuXCI6XCJcXHUwMEE1XCIsXCJZZnJcIjpcIlxcdUQ4MzVcXHVERDFDXCIsXCJ5ZnJcIjpcIlxcdUQ4MzVcXHVERDM2XCIsXCJZSWN5XCI6XCJcXHUwNDA3XCIsXCJ5aWN5XCI6XCJcXHUwNDU3XCIsXCJZb3BmXCI6XCJcXHVEODM1XFx1REQ1MFwiLFwieW9wZlwiOlwiXFx1RDgzNVxcdURENkFcIixcIllzY3JcIjpcIlxcdUQ4MzVcXHVEQ0I0XCIsXCJ5c2NyXCI6XCJcXHVEODM1XFx1RENDRVwiLFwiWVVjeVwiOlwiXFx1MDQyRVwiLFwieXVjeVwiOlwiXFx1MDQ0RVwiLFwieXVtbFwiOlwiXFx1MDBGRlwiLFwiWXVtbFwiOlwiXFx1MDE3OFwiLFwiWmFjdXRlXCI6XCJcXHUwMTc5XCIsXCJ6YWN1dGVcIjpcIlxcdTAxN0FcIixcIlpjYXJvblwiOlwiXFx1MDE3RFwiLFwiemNhcm9uXCI6XCJcXHUwMTdFXCIsXCJaY3lcIjpcIlxcdTA0MTdcIixcInpjeVwiOlwiXFx1MDQzN1wiLFwiWmRvdFwiOlwiXFx1MDE3QlwiLFwiemRvdFwiOlwiXFx1MDE3Q1wiLFwiemVldHJmXCI6XCJcXHUyMTI4XCIsXCJaZXJvV2lkdGhTcGFjZVwiOlwiXFx1MjAwQlwiLFwiWmV0YVwiOlwiXFx1MDM5NlwiLFwiemV0YVwiOlwiXFx1MDNCNlwiLFwiemZyXCI6XCJcXHVEODM1XFx1REQzN1wiLFwiWmZyXCI6XCJcXHUyMTI4XCIsXCJaSGN5XCI6XCJcXHUwNDE2XCIsXCJ6aGN5XCI6XCJcXHUwNDM2XCIsXCJ6aWdyYXJyXCI6XCJcXHUyMUREXCIsXCJ6b3BmXCI6XCJcXHVEODM1XFx1REQ2QlwiLFwiWm9wZlwiOlwiXFx1MjEyNFwiLFwiWnNjclwiOlwiXFx1RDgzNVxcdURDQjVcIixcInpzY3JcIjpcIlxcdUQ4MzVcXHVEQ0NGXCIsXCJ6d2pcIjpcIlxcdTIwMERcIixcInp3bmpcIjpcIlxcdTIwMENcIn0iLCJtb2R1bGUuZXhwb3J0cz17XCJBYWN1dGVcIjpcIlxcdTAwQzFcIixcImFhY3V0ZVwiOlwiXFx1MDBFMVwiLFwiQWNpcmNcIjpcIlxcdTAwQzJcIixcImFjaXJjXCI6XCJcXHUwMEUyXCIsXCJhY3V0ZVwiOlwiXFx1MDBCNFwiLFwiQUVsaWdcIjpcIlxcdTAwQzZcIixcImFlbGlnXCI6XCJcXHUwMEU2XCIsXCJBZ3JhdmVcIjpcIlxcdTAwQzBcIixcImFncmF2ZVwiOlwiXFx1MDBFMFwiLFwiYW1wXCI6XCImXCIsXCJBTVBcIjpcIiZcIixcIkFyaW5nXCI6XCJcXHUwMEM1XCIsXCJhcmluZ1wiOlwiXFx1MDBFNVwiLFwiQXRpbGRlXCI6XCJcXHUwMEMzXCIsXCJhdGlsZGVcIjpcIlxcdTAwRTNcIixcIkF1bWxcIjpcIlxcdTAwQzRcIixcImF1bWxcIjpcIlxcdTAwRTRcIixcImJydmJhclwiOlwiXFx1MDBBNlwiLFwiQ2NlZGlsXCI6XCJcXHUwMEM3XCIsXCJjY2VkaWxcIjpcIlxcdTAwRTdcIixcImNlZGlsXCI6XCJcXHUwMEI4XCIsXCJjZW50XCI6XCJcXHUwMEEyXCIsXCJjb3B5XCI6XCJcXHUwMEE5XCIsXCJDT1BZXCI6XCJcXHUwMEE5XCIsXCJjdXJyZW5cIjpcIlxcdTAwQTRcIixcImRlZ1wiOlwiXFx1MDBCMFwiLFwiZGl2aWRlXCI6XCJcXHUwMEY3XCIsXCJFYWN1dGVcIjpcIlxcdTAwQzlcIixcImVhY3V0ZVwiOlwiXFx1MDBFOVwiLFwiRWNpcmNcIjpcIlxcdTAwQ0FcIixcImVjaXJjXCI6XCJcXHUwMEVBXCIsXCJFZ3JhdmVcIjpcIlxcdTAwQzhcIixcImVncmF2ZVwiOlwiXFx1MDBFOFwiLFwiRVRIXCI6XCJcXHUwMEQwXCIsXCJldGhcIjpcIlxcdTAwRjBcIixcIkV1bWxcIjpcIlxcdTAwQ0JcIixcImV1bWxcIjpcIlxcdTAwRUJcIixcImZyYWMxMlwiOlwiXFx1MDBCRFwiLFwiZnJhYzE0XCI6XCJcXHUwMEJDXCIsXCJmcmFjMzRcIjpcIlxcdTAwQkVcIixcImd0XCI6XCI+XCIsXCJHVFwiOlwiPlwiLFwiSWFjdXRlXCI6XCJcXHUwMENEXCIsXCJpYWN1dGVcIjpcIlxcdTAwRURcIixcIkljaXJjXCI6XCJcXHUwMENFXCIsXCJpY2lyY1wiOlwiXFx1MDBFRVwiLFwiaWV4Y2xcIjpcIlxcdTAwQTFcIixcIklncmF2ZVwiOlwiXFx1MDBDQ1wiLFwiaWdyYXZlXCI6XCJcXHUwMEVDXCIsXCJpcXVlc3RcIjpcIlxcdTAwQkZcIixcIkl1bWxcIjpcIlxcdTAwQ0ZcIixcIml1bWxcIjpcIlxcdTAwRUZcIixcImxhcXVvXCI6XCJcXHUwMEFCXCIsXCJsdFwiOlwiPFwiLFwiTFRcIjpcIjxcIixcIm1hY3JcIjpcIlxcdTAwQUZcIixcIm1pY3JvXCI6XCJcXHUwMEI1XCIsXCJtaWRkb3RcIjpcIlxcdTAwQjdcIixcIm5ic3BcIjpcIlxcdTAwQTBcIixcIm5vdFwiOlwiXFx1MDBBQ1wiLFwiTnRpbGRlXCI6XCJcXHUwMEQxXCIsXCJudGlsZGVcIjpcIlxcdTAwRjFcIixcIk9hY3V0ZVwiOlwiXFx1MDBEM1wiLFwib2FjdXRlXCI6XCJcXHUwMEYzXCIsXCJPY2lyY1wiOlwiXFx1MDBENFwiLFwib2NpcmNcIjpcIlxcdTAwRjRcIixcIk9ncmF2ZVwiOlwiXFx1MDBEMlwiLFwib2dyYXZlXCI6XCJcXHUwMEYyXCIsXCJvcmRmXCI6XCJcXHUwMEFBXCIsXCJvcmRtXCI6XCJcXHUwMEJBXCIsXCJPc2xhc2hcIjpcIlxcdTAwRDhcIixcIm9zbGFzaFwiOlwiXFx1MDBGOFwiLFwiT3RpbGRlXCI6XCJcXHUwMEQ1XCIsXCJvdGlsZGVcIjpcIlxcdTAwRjVcIixcIk91bWxcIjpcIlxcdTAwRDZcIixcIm91bWxcIjpcIlxcdTAwRjZcIixcInBhcmFcIjpcIlxcdTAwQjZcIixcInBsdXNtblwiOlwiXFx1MDBCMVwiLFwicG91bmRcIjpcIlxcdTAwQTNcIixcInF1b3RcIjpcIlxcXCJcIixcIlFVT1RcIjpcIlxcXCJcIixcInJhcXVvXCI6XCJcXHUwMEJCXCIsXCJyZWdcIjpcIlxcdTAwQUVcIixcIlJFR1wiOlwiXFx1MDBBRVwiLFwic2VjdFwiOlwiXFx1MDBBN1wiLFwic2h5XCI6XCJcXHUwMEFEXCIsXCJzdXAxXCI6XCJcXHUwMEI5XCIsXCJzdXAyXCI6XCJcXHUwMEIyXCIsXCJzdXAzXCI6XCJcXHUwMEIzXCIsXCJzemxpZ1wiOlwiXFx1MDBERlwiLFwiVEhPUk5cIjpcIlxcdTAwREVcIixcInRob3JuXCI6XCJcXHUwMEZFXCIsXCJ0aW1lc1wiOlwiXFx1MDBEN1wiLFwiVWFjdXRlXCI6XCJcXHUwMERBXCIsXCJ1YWN1dGVcIjpcIlxcdTAwRkFcIixcIlVjaXJjXCI6XCJcXHUwMERCXCIsXCJ1Y2lyY1wiOlwiXFx1MDBGQlwiLFwiVWdyYXZlXCI6XCJcXHUwMEQ5XCIsXCJ1Z3JhdmVcIjpcIlxcdTAwRjlcIixcInVtbFwiOlwiXFx1MDBBOFwiLFwiVXVtbFwiOlwiXFx1MDBEQ1wiLFwidXVtbFwiOlwiXFx1MDBGQ1wiLFwiWWFjdXRlXCI6XCJcXHUwMEREXCIsXCJ5YWN1dGVcIjpcIlxcdTAwRkRcIixcInllblwiOlwiXFx1MDBBNVwiLFwieXVtbFwiOlwiXFx1MDBGRlwifSIsIm1vZHVsZS5leHBvcnRzPXtcImFtcFwiOlwiJlwiLFwiYXBvc1wiOlwiJ1wiLFwiZ3RcIjpcIj5cIixcImx0XCI6XCI8XCIsXCJxdW90XCI6XCJcXFwiXCJ9XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiaHRtbFwiOiB7XG4gICAgXCJjb250ZW50XCI6IFsgXCI8aGVhZD5cIiwgXCI8Ym9keT5cIiBdLFxuICAgIFwic2luZ3VsYXJcIjogdHJ1ZVxuICB9LFxuICBcImhlYWRcIjoge1xuICAgIFwiY29udGVudFwiOiBbIFwibWV0YWRhdGEgY29udGVudFwiIF0sXG4gICAgXCJwYXJlbnRcIjogWyBcIjxodG1sPlwiIF0sXG4gICAgXCJzaW5ndWxhclwiOiB0cnVlXG4gIH0sXG4gIFwiYm9keVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJzZWN0aW9uaW5nIHJvb3RcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwiZmxvdyBjb250ZW50XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPGh0bWw+XCIgXSxcbiAgICBcInNpbmd1bGFyXCI6IHRydWVcbiAgfSxcblxuICBcInRpdGxlXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcIm1ldGFkYXRhIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwidGV4dFwiIF0sXG4gICAgXCJwYXJlbnRcIjogWyBcIjxoZWFkPlwiIF0sXG4gICAgXCJzaW5ndWxhclwiOiB0cnVlXG4gIH0sXG4gIFwiYmFzZVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJtZXRhZGF0YSBjb250ZW50XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPGhlYWQ+XCIgXSxcbiAgICBcInNpbmd1bGFyXCI6IHRydWVcbiAgfSxcbiAgXCJsaW5rXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcIm1ldGFkYXRhIGNvbnRlbnRcIiBdLFxuICAgIFwicGFyZW50XCI6IFsgXCI8aGVhZD5cIiBdXG4gIH0sXG4gIFwibWV0YVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJtZXRhZGF0YSBjb250ZW50XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPGhlYWQ+XCIgXVxuICB9LFxuICBcInN0eWxlXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcIm1ldGFkYXRhIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwidGV4dFwiIF0sXG4gICAgXCJwYXJlbnRcIjogWyBcIjxoZWFkPlwiIF1cbiAgfSxcblxuICBcImFkZHJlc3NcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJmbG93IGNvbnRlbnRcIiBdLFxuICAgIFwiZGlzYWxsb3dcIjogWyBcIjxhZGRyZXNzPlwiLCBcImhlYWRpbmcgY29udGVudFwiLCBcInNlY3Rpb25pbmcgY29udGVudFwiLCBcIjxoZWFkZXI+XCIsIFwiPGZvb3Rlcj5cIiBdXG4gIH0sXG4gIFwiYXJ0aWNsZVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJzZWN0aW9uaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcImZsb3cgY29udGVudFwiIF0sXG4gICAgXCJkaXNhbGxvd1wiOiBbIFwiPG1haW4+XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcbiAgXCJhc2lkZVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJzZWN0aW9uaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcImZsb3cgY29udGVudFwiIF0sXG4gICAgXCJkaXNhbGxvd1wiOiBbIFwiPG1haW4+XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcbiAgXCJmb290ZXJcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJmbG93IGNvbnRlbnRcIiBdLFxuICAgIFwiZGlzYWxsb3dcIjogWyBcIjxmb290ZXI+XCIsIFwiPGhlYWRlcj5cIiwgXCI8bWFpbj5cIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuICBcImhlYWRlclwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcImZsb3cgY29udGVudFwiIF0sXG4gICAgXCJkaXNhbGxvd1wiOiBbIFwiPGZvb3Rlcj5cIiwgXCI8aGVhZGVyPlwiLCBcIjxtYWluPlwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiBdXG4gIH0sXG4gIFwiaDFcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwiaGVhZGluZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcImgyXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcImhlYWRpbmcgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiIF1cbiAgfSxcbiAgXCJoM1wiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJoZWFkaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwiaDRcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwiaGVhZGluZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcImg1XCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcImhlYWRpbmcgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiIF1cbiAgfSxcbiAgXCJoNlwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJoZWFkaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwibmF2XCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInNlY3Rpb25pbmcgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwiZmxvdyBjb250ZW50XCIgXSxcbiAgICBcImRpc2FsbG93XCI6IFsgXCI8bWFpbj5cIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuXG4gIFwiYmxvY2txdW90ZVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJzZWN0aW9uaW5nIHJvb3RcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcImZsb3cgY29udGVudFwiIF1cbiAgfSxcbiAgXCJkZFwiOiB7XG4gICAgXCJjb250ZW50XCI6IFsgXCJmbG93IGNvbnRlbnRcIiBdLFxuICAgIFwicGFyZW50XCI6IFsgXCI8ZGw+XCIgXSxcbiAgICBcInByZXZpb3VzXCI6IFsgXCI8ZHQ+XCIsIFwiPGRkPlwiIF1cbiAgfSxcbiAgXCJkaXZcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJmbG93IGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwiZGxcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcIjxkdD5cIiwgXCI8ZGQ+XCIgXVxuICB9LFxuICBcImR0XCI6IHtcbiAgICBcImNvbnRlbnRcIjogWyBcImZsb3cgY29udGVudFwiIF0sXG4gICAgXCJwYXJlbnRcIjogWyBcIjxkbD5cIiBdLFxuICAgIFwiZGlzYWxsb3dcIjogWyBcIjxmb290ZXI+XCIsIFwiPGhlYWRlcj5cIiwgXCJzZWN0aW9uaW5nIGNvbnRlbnRcIiwgXCJoZWFkaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwibmV4dFwiOiBbIFwiPGR0PlwiLCBcIjxkZD5cIiBdXG4gIH0sXG4gIFwiZmlnY2FwdGlvblwiOiB7XG4gICAgXCJjb250ZW50XCI6IFsgXCJmbG93IGNvbnRlbnRcIiBdLFxuICAgIFwicGFyZW50XCI6IFsgXCI8ZmlndXJlPlwiIF0sXG4gICAgXCJwb3NpdGlvblwiOiBbIFwiZmlyc3RcIiwgXCJsYXN0XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcbiAgXCJmaWd1cmVcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwic2VjdGlvbmluZyByb290XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCI8ZmlnY2FwdGlvbj5cIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuICBcImhyXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiIF1cbiAgfSxcbiAgXCJsaVwiOiB7XG4gICAgXCJjb250ZW50XCI6IFsgXCJmbG93IGNvbnRlbnRcIiBdLFxuICAgIFwicGFyZW50XCI6IFsgXCI8dWw+XCIsIFwiPG9sPlwiLCBcIjxtZW51PlwiIF1cbiAgfSxcbiAgXCJtYWluXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwiZmxvdyBjb250ZW50XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcbiAgXCJvbFwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwiPGxpPlwiIF0sXG4gICAgXCJzdGF0ZXNcIjoge1xuICAgICAgXCI6bm90KDplbXB0eSlcIjoge1xuICAgICAgICBcImNhdGVnb3JpZXNcIjogWyBcInBhbHBhYmxlIGNvbnRlbnRcIiBdXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcInBcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcInByZVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwic2VjdGlvblwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJzZWN0aW9uaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcImZsb3cgY29udGVudFwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiBdXG4gIH0sXG4gIFwidWxcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcIjxsaT5cIiBdLFxuICAgIFwic3RhdGVzXCI6IHtcbiAgICAgIFwiOm5vdCg6ZW1wdHkpXCI6IHtcbiAgICAgICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJwYWxwYWJsZSBjb250ZW50XCIgXVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBcImFcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiIF0sXG4gICAgXCJkaXNhbGxvd1wiOiBbIFwiaW50ZXJhY3RpdmUgY29udGVudFwiIF0sXG4gICAgXCJzdGF0ZXNcIjoge1xuICAgICAgXCJbaHJlZl1cIiA6IHtcbiAgICAgICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJpbnRlcmFjdGl2ZSBjb250ZW50XCIgXVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJhYmJyXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwiYlwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcImJkaVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcbiAgXCJiZG9cIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiBdXG4gIH0sXG4gIFwiYnJcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiIF1cbiAgfSxcbiAgXCJjaXRlXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwiY29kZVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcImRhdGFcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiBdXG4gIH0sXG4gIFwiZGZuXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwiZGlzYWxsb3dcIjogWyBcIjxkZm4+XCIgXVxuICB9LFxuICBcImVtXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwiaVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcImtiZFwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcIm1hcmtcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiBdXG4gIH0sXG4gIFwicVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcInJwXCI6IHtcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwicGFyZW50XCI6IFsgXCI8cnVieT5cIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuICBcInJ0XCI6IHtcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwicGFyZW50XCI6IFsgXCI8cnVieT5cIiwgXCI8cnRjPlwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiBdXG4gIH0sXG4gIFwicnRjXCI6IHtcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCI8cnQ+XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPHJ1Ynk+XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcbiAgXCJydWJ5XCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiLCBcIjxycD5cIiwgXCI8cnQ+XCIsIFwiPHJ0Yz5cIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuICBcInNcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiIF1cbiAgfSxcbiAgXCJzYW1wXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwic21hbGxcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiIF1cbiAgfSxcbiAgXCJzcGFuXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwic3Ryb25nXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwic3ViXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwic3VwXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwidGltZVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcbiAgXCJ1XCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwidmFyXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwid2JyXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuXG4gIFwiYXJlYVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIgXSxcbiAgICBcImFuY2VzdG9yXCI6IFsgXCI8bWFwPlwiIF1cbiAgfSxcbiAgXCJhdWRpb1wiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwiZW1iZWRkZWQgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJ0cmFuc3BhcmVudFwiLCBcIjx0cmFjaz5cIiBdLFxuICAgIFwiZGlzYWxsb3dcIjogWyBcIjxhdWRpbz5cIiwgXCI8dmlkZW8+XCIgXSxcbiAgICBcInN0YXRlc1wiOiB7XG4gICAgICBcIltjb250cm9sc11cIjoge1xuICAgICAgICBcImNhdGVnb3JpZXNcIjogWyBcImludGVyYWN0aXZlIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXVxuICAgICAgfSxcbiAgICAgIFwiOm5vdChbc3JjXSlcIjoge1xuICAgICAgICBcImNvbnRlbnRcIjogWyBcIjxzb3VyY2U+XCIgXVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiBdXG4gIH0sXG4gIFwibWFwXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInRyYW5zcGFyZW50XCIsIFwiPGFyZWE+XCIgXVxuICB9LFxuICBcInRyYWNrXCI6IHtcbiAgICBcInBhcmVudFwiOiBbIFwiPGF1ZGlvPlwiLCBcIjx2aWRlbz5cIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuICBcInZpZGVvXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJlbWJlZGRlZCBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInRyYW5zcGFyZW50XCIsIFwiPHRyYWNrPlwiIF0sXG4gICAgXCJkaXNhbGxvd1wiOiBbIFwiPGF1ZGlvPlwiLCBcIjx2aWRlbz5cIiBdLFxuICAgIFwic3RhdGVzXCI6IHtcbiAgICAgIFwiW2NvbnRyb2xzXVwiOiB7XG4gICAgICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiaW50ZXJhY3RpdmUgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdXG4gICAgICB9LFxuICAgICAgXCI6bm90KFtzcmNdKVwiOiB7XG4gICAgICAgIFwiY29udGVudFwiOiBbIFwiPHNvdXJjZT5cIiBdXG4gICAgICB9XG4gICAgfSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcblxuICBcImVtYmVkXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJlbWJlZGRlZCBjb250ZW50XCIsIFwiaW50ZXJhY3RpdmUgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuICBcImlmcmFtZVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwiZW1iZWRkZWQgY29udGVudFwiLCBcImludGVyYWN0aXZlIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwiZGlzYWxsb3dcIjogWyBcIjxzY3JpcHQ+XCIgXVxuICB9LFxuICBcImltZ1wiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwiZW1iZWRkZWQgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwic3RhdGVzXCI6IHtcbiAgICAgIFwiW3VzZW1hcF1cIjoge1xuICAgICAgICBcImNhdGVnb3JpZXNcIjogWyBcImludGVyYWN0aXZlIGNvbnRlbnRcIiBdXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcIm9iamVjdFwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwiZW1iZWRkZWQgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiwgXCJmb3JtLWFzc29jaWF0ZWQgY29udGVudFwiLCBcImxpc3RlZFwiLCBcInN1Ym1pdHRhYmxlXCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInRyYW5zcGFyZW50XCIsIFwiPHBhcmFtPlwiIF0sXG4gICAgXCJzdGF0ZXNcIjoge1xuICAgICAgXCJbdXNlbWFwXVwiOiB7XG4gICAgICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiaW50ZXJhY3RpdmUgY29udGVudFwiIF1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwicGFyYW1cIjoge1xuICAgIFwicGFyZW50XCI6IFsgXCI8b2JqZWN0PlwiIF1cbiAgfSxcbiAgXCJzb3VyY2VcIjoge1xuICAgIFwicGFyZW50XCI6IFsgXCI8cGljdHVyZT5cIiwgXCI8YXVkaW8+XCIsIFwiPHZpZGVvPlwiIF0sXG4gICAgXCJwb3NpdGlvblwiOiBbIFwiZmlyc3RcIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuXG4gIFwiY2FudmFzXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJlbWJlZGRlZCBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJ0cmFuc3BhcmVudFwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiBdXG4gIH0sXG4gIFwibm9zY3JpcHRcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcIm1ldGFkYXRhIGNvbnRlbnRcIiBdLFxuICAgIFwiZGlzYWxsb3dcIjogWyBcIjxub3NjcmlwdD5cIiBdLFxuICAgIFwic3RhdGVzXCI6IHtcbiAgICAgIFwiaGVhZCA+IG5vc2NyaXB0XCI6IHtcbiAgICAgICAgXCJjb250ZW50XCI6IFsgXCI8bGluaz5cIiwgXCI8c3R5bGU+XCIsIFwiPG1ldGE+XCIgXVxuICAgICAgfSxcbiAgICAgIFwiOm5vdCggaGVhZCA+IG5vc2NyaXB0IClcIjoge1xuICAgICAgICBcImNvbnRlbnRcIjogWyBcInRyYW5zcGFyZW50XCIgXVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJzY3JpcHRcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcIm1ldGFkYXRhIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwidGV4dFwiIF1cbiAgfSxcbiAgXCJ0ZW1wbGF0ZVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJtZXRhZGF0YSBjb250ZW50XCIsIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJtZXRhZGF0YSBjb250ZW50XCIsIFwiZmxvdyBjb250ZW50XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiYm9keVwiLCBcImhlYWRcIiwgXCJjb2xncm91cFwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiBdXG4gIH0sXG5cbiAgXCJkZWxcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJ0cmFuc3BhcmVudFwiIF1cbiAgfSxcbiAgXCJpbnNcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJ0cmFuc3BhcmVudFwiIF1cbiAgfSxcblxuICBcImNhcHRpb25cIjoge1xuICAgIFwiY29udGVudFwiOiBbIFwiZmxvdyBjb250ZW50XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPHRhYmxlPlwiIF0sXG4gICAgXCJwb3NpdGlvblwiOiBbIFwiZmlyc3RcIiBdXG4gIH0sXG4gIFwiY29sXCI6IHtcbiAgICBcInBhcmVudFwiOiBbIFwiPGNvbGdyb3VwPlwiIF1cbiAgfSxcbiAgXCJjb2xncm91cFwiOiB7XG4gICAgXCJwYXJlbnRcIjogWyBcIjx0YWJsZT5cIiBdLFxuICAgIFwic3RhdGVzXCI6IHtcbiAgICAgIFwiOm5vdChbc3Bhbl0pXCI6IHtcbiAgICAgICAgXCJjb250ZW50XCI6IFsgXCI8Y29sPlwiIF1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwidGFibGVcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcIjxjYXB0aW9uPlwiLCBcIjxjb2xncm91cD5cIiwgXCI8dGhlYWQ+XCIsIFwiPHRib2R5PlwiLCBcIjx0Zm9vdD5cIiwgXCI8dHI+XCIgXVxuICB9LFxuICBcInRib2R5XCI6IHtcbiAgICBcImNvbnRlbnRcIjogWyBcIjx0cj5cIiBdLFxuICAgIFwicGFyZW50XCI6IFsgXCI8dGFibGU+XCIgXVxuICB9LFxuICBcInRkXCI6IHtcbiAgICBcImNvbnRlbnRcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwicGFyZW50XCI6IFsgXCI8dHI+XCIgXVxuICB9LFxuICBcInRmb290XCI6IHtcbiAgICBcImNvbnRlbnRcIjogWyBcIjx0cj5cIiBdLFxuICAgIFwicGFyZW50XCI6IFsgXCI8dGFibGU+XCIgXVxuICB9LFxuICBcInRoXCI6IHtcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwicGFyZW50XCI6IFsgXCI8dHI+XCIgXVxuICB9LFxuICBcInRoZWFkXCI6IHtcbiAgICBcImNvbnRlbnRcIjogWyBcIjx0cj5cIiBdLFxuICAgIFwicGFyZW50XCI6IFsgXCI8dGFibGU+XCIgXVxuICB9LFxuICBcInRyXCI6IHtcbiAgICBcImNvbnRlbnRcIjogWyBcIjx0aD5cIiwgXCI8dGQ+XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPHRhYmxlPlwiLCBcIjx0aGVhZD5cIiwgXCI8dGJvZHk+XCIsIFwiPHRmb290PlwiIF1cbiAgfSxcblxuICBcImJ1dHRvblwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwiaW50ZXJhY3RpdmUgY29udGVudFwiLCBcImZvcm0tYXNzb2NpYXRlZCBjb250ZW50XCIsIFwibGlzdGVkXCIsIFwibGFiZWxhYmxlXCIsIFwic3VibWl0dGFibGVcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwiZGF0YWxpc3RcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIsIFwiPG9wdGlvbj5cIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuICBcImZpZWxkc2V0XCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInNlY3Rpb25pbmcgcm9vdFwiLCBcImZvcm0tYXNzb2NpYXRlZCBjb250ZW50XCIsIFwibGlzdGVkXCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCI8bGVnZW5kPlwiLCBcImZsb3cgY29udGVudFwiIF1cbiAgfSxcbiAgXCJmb3JtXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwiZmxvdyBjb250ZW50XCIgXSxcbiAgICBcImRpc2FsbG93XCI6IFsgXCI8Zm9ybT5cIiBdXG4gIH0sXG4gIFwiaW5wdXRcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcImZvcm0tYXNzb2NpYXRlZCBjb250ZW50XCIsIFwibGlzdGVkXCIsIFwic3VibWl0dGFibGVcIiwgXCJyZXNldHRhYmxlXCIgXSxcbiAgICBcInN0YXRlc1wiOiB7XG4gICAgICBcIjpub3QoW3R5cGU9aGlkZGVuXSlcIjoge1xuICAgICAgICBcImNhdGVnb3JpZXNcIjogWyBcImxhYmVsYWJsZVwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcImxhYmVsXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJpbnRlcmFjdGl2ZSBjb250ZW50XCIsIFwiZm9ybS1hc3NvY2lhdGVkIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwiZGlzYWxsb3dcIjogWyBcIjxsYWJlbD5cIiBdXG4gIH0sXG4gIFwibGVnZW5kXCI6IHtcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwicGFyZW50XCI6IFsgXCI8ZmllbGRzZXQ+XCIgXSxcbiAgICBcInBvc2l0aW9uXCI6IFsgXCJmaXJzdFwiIF1cbiAgfSxcbiAgXCJtZXRlclwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwiZm9ybS1hc3NvY2lhdGVkIGNvbnRlbnRcIiwgXCJsYWJlbGFibGVcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwiZGlzYWxsb3dcIjogWyBcIjxtZXRlcj5cIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuICBcIm9wdGdyb3VwXCI6IHtcbiAgICBcImNvbnRlbnRcIjogWyBcIjxvcHRpb24+XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPHNlbGVjdD5cIiBdXG4gIH0sXG4gIFwib3B0aW9uXCI6IHtcbiAgICBcImNvbnRlbnRcIjogWyBcInRleHRcIiBdLFxuICAgIFwicGFyZW50XCI6IFsgXCI8c2VsZWN0PlwiLCBcIjxvcHRncm91cD5cIiwgXCI8ZGF0YWxpc3Q+XCIgXVxuICB9LFxuICBcIm91dHB1dFwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwiZm9ybS1hc3NvY2lhdGVkIGNvbnRlbnRcIiwgXCJsaXN0ZWRcIiwgXCJsYWJlbGFibGVcIiwgXCJyZXNldHRhYmxlXCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcbiAgXCJwcm9ncmVzc1wiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwiZm9ybS1hc3NvY2lhdGVkIGNvbnRlbnRcIiwgXCJsYWJlbGFibGVcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwiZGlzYWxsb3dcIjogWyBcIjxwcm9ncmVzcz5cIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuICBcInNlbGVjdFwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwiaW50ZXJhY3RpdmUgY29udGVudFwiLCBcImZvcm0tYXNzb2NpYXRlZCBjb250ZW50XCIsIFwibGlzdGVkXCIsIFwibGFiZWxhYmxlXCIsIFwic3VibWl0dGFibGVcIiwgXCJyZXNldHRhYmxlXCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcIjxvcHRncm91cD5cIiwgXCI8b3B0aW9uPlwiIF1cbiAgfSxcbiAgXCJ0ZXh0YXJlYVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwiaW50ZXJhY3RpdmUgY29udGVudFwiLCBcImZvcm0tYXNzb2NpYXRlZCBjb250ZW50XCIsIFwibGlzdGVkXCIsIFwibGFiZWxhYmxlXCIsIFwic3VibWl0dGFibGVcIiwgXCJyZXNldHRhYmxlXCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInRleHRcIiBdXG4gIH0sXG5cbiAgXCJkZXRhaWxzXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInNlY3Rpb25pbmcgcm9vdFwiLCBcImludGVyYWN0aXZlIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcIjxzdW1tYXJ5PlwiLCBcImZsb3cgY29udGVudFwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiwgXCI1XCIgXSxcbiAgICBcImV4cGVyaW1lbnRhbFwiOiB0cnVlXG4gIH0sXG4gIFwiZGlhbG9nXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInNlY3Rpb25pbmcgcm9vdFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJmbG93IGNvbnRlbnRcIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIsIFwiNVwiIF0sXG4gICAgXCJleHBlcmltZW50YWxcIjogdHJ1ZVxuICB9LFxuICAgXCJoZ3JvdXBcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwiaGVhZGluZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCI8aDE+XCIsIFwiPGgyPlwiLCBcIjxoMz5cIiwgXCI8aDQ+XCIsIFwiPGg1PlwiLCBcIjxoNj5cIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIsIFwiNVwiIF0sXG4gICAgXCJleHBlcmltZW50YWxcIjogdHJ1ZVxuICB9LFxuICBcIm1lbnVcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIgXSxcbiAgICBcInN0YXRlc1wiOiB7XG4gICAgICBcIlt0eXBlPWxpc3RdLCA6bm90KFt0eXBlXSlcIjoge1xuICAgICAgICBcImNhdGVnb3JpZXNcIjogWyBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgICAgICBcImNvbnRlbnRcIjogWyBcImZsb3cgY29udGVudFwiLCBcIjxsaT5cIiwgXCI8c2NyaXB0PlwiLCBcIjx0ZW1wbGF0ZT5cIiBdXG4gICAgICB9LFxuICAgICAgXCJbdHlwZT1tZW51XVwiOiB7XG4gICAgICAgIFwiY29udGVudFwiOiBbIFwiPHNjcmlwdD5cIiwgXCI8dGVtcGxhdGU+XCIsIFwiPG1lbnU+XCIsIFwiPG1lbnVpdGVtPlwiLCBcIjxocj5cIiBdXG4gICAgICB9XG4gICAgfSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiLCBcIjVcIiBdLFxuICAgIFwiZXhwZXJpbWVudGFsXCI6IHRydWVcbiAgfSxcbiAgXCJtZW51aXRlbVwiOiB7XG4gICAgXCJwYXJlbnRcIjogWyBcIjxtZW51PlwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiwgXCI1XCIgXSxcbiAgICBcImV4cGVyaW1lbnRhbFwiOiB0cnVlXG4gIH0sXG4gIFwicGljdHVyZVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwiZW1iZWRkZWQgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCI8c291cmNlPlwiLCBcIjxpbWc+XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiLCBcIjVcIiwgXCI1LjFcIiBdLFxuICAgIFwiZXhwZXJpbWVudGFsXCI6IHRydWVcbiAgfSxcbiAgXCJzaGFkb3dcIjoge1xuICAgIFwiY29udGVudFwiOiBbIFwiZmxvdyBjb250ZW50XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiLCBcIjVcIiwgXCI1LjFcIiwgXCJMU1wiIF0sXG4gICAgXCJleHBlcmltZW50YWxcIjogdHJ1ZVxuICB9LFxuICBcInN1bW1hcnlcIjoge1xuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiLCBcImhlYWRpbmcgY29udGVudFwiIF0sXG4gICAgXCJwYXJlbnRcIjogWyBcIjxkZXRhaWxzPlwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiwgXCI1XCIgXSxcbiAgICBcImV4cGVyaW1lbnRhbFwiOiB0cnVlXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBlbGVtZW50RGF0YSA9IHJlcXVpcmUoJy4uL2RhdGEvZWxlbWVudHMuanNvbicpO1xyXG52YXIgc2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hL2hpbmZvLnNjaGVtYS5qc29uJyk7XHJcblxyXG4vLyBlbnN1cmUgYSBmcmVzaCBjb3B5LCBpbiBjYXNlIHRoZSBjb25zdW1lciBtb2RpZmllcyBpdFxyXG52YXIgaGluZm8gPSBmdW5jdGlvbiBoaW5mbygpIHtcclxuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbGVtZW50RGF0YSkpO1xyXG59O1xyXG5cclxuaGluZm8uc2NoZW1hID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNjaGVtYSkpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBoaW5mbzsiLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gICAgXCJ0aXRsZVwiOiBcImh0bWwgZWxlbWVudCBtZXRhIGRhdGFcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwic2NoZW1hIGZvciBodG1sIGVsZW1lbnQgbWV0YSBkYXRhXCIsXG4gICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgXCJwYXR0ZXJuUHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwiXlthLXpdW2EtelxcXFxkXSokXCI6IHtcbiAgICAgICAgICAgIFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvZWxlbWVudERlZlwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gICAgXCJkZWZpbml0aW9uc1wiOiB7XG4gICAgICAgIFwiZWxlbWVudERlZlwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgICAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjYXRlZ29yaWVzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9jYXRlZ29yeUFycmF5RGVmXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiY29udGVudFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc3RyaW5nQXJyYXlEZWZcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJwYXJlbnRcIjoge1xuICAgICAgICAgICAgICAgICAgICBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5RGVmXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZGlzYWxsb3dcIjoge1xuICAgICAgICAgICAgICAgICAgICBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5RGVmXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYW5jZXN0b3JcIjoge1xuICAgICAgICAgICAgICAgICAgICBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5RGVmXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICAgICAgICAgICAgICBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3Bvc2l0aW9uQXJyYXlEZWZcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJwcmV2aW91c1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvdGFnQXJyYXlEZWZcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJuZXh0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy90YWdBcnJheURlZlwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInN0YXRlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc3RhdGVEZWZcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJub3NwZWNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vc3BlY0RlZlwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInNpbmd1bGFyXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImV4cGVyaW1lbnRhbFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwic3RyaW5nQXJyYXlEZWZcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIFwidGFnQXJyYXlEZWZcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIFwicGF0dGVyblwiOiBcIl48W2Etel1bYS16MC05XSo+JFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2F0ZWdvcnlBcnJheURlZlwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJlbWJlZGRlZCBjb250ZW50XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZmxvdyBjb250ZW50XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZm9ybS1hc3NvY2lhdGVkIGNvbnRlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJoZWFkaW5nIGNvbnRlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnRlcmFjdGl2ZSBjb250ZW50XCIsXG4gICAgICAgICAgICAgICAgICAgIFwibGFiZWxhYmxlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibGlzdGVkXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWV0YWRhdGEgY29udGVudFwiLFxuICAgICAgICAgICAgICAgICAgICBcInBhbHBhYmxlIGNvbnRlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwaHJhc2luZyBjb250ZW50XCIsXG4gICAgICAgICAgICAgICAgICAgIFwicmVzZXR0YWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNlY3Rpb25pbmcgY29udGVudFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNlY3Rpb25pbmcgcm9vdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInN1Ym1pdHRhYmxlXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIFwicG9zaXRpb25BcnJheURlZlwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJmaXJzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImxhc3RcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgXCJzdGF0ZURlZlwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgICAgICAgIFwicGF0dGVyblByb3BlcnRpZXNcIjoge1xuICAgICAgICAgICAgICAgIFwiXltcXFxcd1xcXFxkIDo9LDw+XFxcXChcXFxcKVxcXFxbXFxcXF1dKyRcIjoge1xuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY2F0ZWdvcmllc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheURlZlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjb250ZW50XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5RGVmXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwibm9zcGVjRGVmXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgICAgICAgICBcIjQuMDFcIixcbiAgICAgICAgICAgICAgICAgICAgXCI1XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiNS4xXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiTFNcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWVcbiAgICAgICAgfVxuICAgIH1cbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoaW5mbyA9IHJlcXVpcmUoJ2hpbmZvJyk7XG5cbnZhciBub2RlRGVmcyA9IHtcbiAgJyNkb2N1bWVudCc6IHtcbiAgICAnY29udGVudCc6IFsnI2RvY3VtZW50VHlwZScsICc8aHRtbD4nXVxuICB9LFxuICAnI2RvY3VtZW50VHlwZSc6IHtcbiAgICAncGFyZW50JzogWycjZG9jdW1lbnQnXVxuICB9LFxuICAnI3RleHQnOiB7XG4gICAgJ2NhdGVnb3JpZXMnOiBbJ2Zsb3cgY29udGVudCcsICdwaHJhc2luZyBjb250ZW50JywgJ3BhbHBhYmxlIGNvbnRlbnQnXVxuICB9LFxuICAnI2NvbW1lbnQnOiB7XG4gICAgJ2NhdGVnb3JpZXMnOiBbJ2Zsb3cgY29udGVudCddXG4gIH0sXG4gICcjZG9jdW1lbnRGcmFnbWVudCc6IHtcbiAgICAnY29udGVudCc6IFsnZmxvdyBjb250ZW50J11cbiAgfVxufTtcblxudmFyIGVuc3VyZUFycmF5ID0gZnVuY3Rpb24gZW5zdXJlQXJyYXkob2JqLCBuYW1lKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShvYmpbbmFtZV0pKSBvYmpbbmFtZV0gPSBbXTtcbn07XG5cbnZhciBlbnN1cmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZW5zdXJlUHJvcGVydGllcyhkZWYpIHtcbiAgZW5zdXJlQXJyYXkoZGVmLCAnY2F0ZWdvcmllcycpO1xuICBlbnN1cmVBcnJheShkZWYsICdjb250ZW50Jyk7XG4gIGVuc3VyZUFycmF5KGRlZiwgJ3BhcmVudCcpO1xufTtcblxudmFyIGRlZmF1bHREZWZzID0gT2JqZWN0LmFzc2lnbihoaW5mbygpLCBub2RlRGVmcyk7XG5cbnZhciBIdG1sID0gZnVuY3Rpb24gSHRtbCgpIHtcbiAgdmFyIGRlZnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGRlZmF1bHREZWZzO1xuXG4gIGRlZnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRlZnMpKTtcblxuICB2YXIgX3RhZ05hbWVzID0gT2JqZWN0LmtleXMoZGVmcyk7XG5cbiAgdmFyIGhhc0NhdGVnb3J5ID0gZnVuY3Rpb24gaGFzQ2F0ZWdvcnkodGFnTmFtZSwgY2F0ZWdvcnlOYW1lKSB7XG4gICAgcmV0dXJuIGRlZnNbdGFnTmFtZV0uY2F0ZWdvcmllcy5pbmNsdWRlcyhjYXRlZ29yeU5hbWUpO1xuICB9O1xuXG4gIHZhciBwcmVkaWNhdGVzID0ge1xuICAgIGVtcHR5OiBmdW5jdGlvbiBlbXB0eSh0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gZGVmc1t0YWdOYW1lXS5jb250ZW50Lmxlbmd0aCA9PT0gMDtcbiAgICB9LFxuICAgIG1ldGFkYXRhOiBmdW5jdGlvbiBtZXRhZGF0YSh0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gaGFzQ2F0ZWdvcnkodGFnTmFtZSwgJ21ldGFkYXRhIGNvbnRlbnQnKTtcbiAgICB9LFxuICAgIGlubGluZTogZnVuY3Rpb24gaW5saW5lKHRhZ05hbWUpIHtcbiAgICAgIHJldHVybiBoYXNDYXRlZ29yeSh0YWdOYW1lLCAncGhyYXNpbmcgY29udGVudCcpO1xuICAgIH0sXG4gICAgZW1iZWRkZWQ6IGZ1bmN0aW9uIGVtYmVkZGVkKHRhZ05hbWUpIHtcbiAgICAgIHJldHVybiBoYXNDYXRlZ29yeSh0YWdOYW1lLCAnZW1iZWRkZWQgY29udGVudCcpO1xuICAgIH0sXG4gICAgYmxvY2s6IGZ1bmN0aW9uIGJsb2NrKHRhZ05hbWUpIHtcbiAgICAgIHJldHVybiBoYXNDYXRlZ29yeSh0YWdOYW1lLCAnZmxvdyBjb250ZW50JykgJiYgIXByZWRpY2F0ZXMuaW5saW5lKHRhZ05hbWUpO1xuICAgIH0sXG4gICAgY29udGFpbmVyOiBmdW5jdGlvbiBjb250YWluZXIodGFnTmFtZSkge1xuICAgICAgcmV0dXJuICFwcmVkaWNhdGVzLmVtcHR5KHRhZ05hbWUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZG9lc0FjY2VwdCA9IGZ1bmN0aW9uIGRvZXNBY2NlcHQodGFnTmFtZSwgY2hpbGRUYWdOYW1lKSB7XG4gICAgaWYgKHByZWRpY2F0ZXMuZW1wdHkodGFnTmFtZSkpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBkZWYgPSBkZWZzW3RhZ05hbWVdO1xuICAgIHZhciBjaGlsZERlZiA9IGRlZnNbY2hpbGRUYWdOYW1lXTtcblxuICAgIGlmIChjaGlsZERlZi5wYXJlbnQuaW5jbHVkZXMoJzwnICsgdGFnTmFtZSArICc+JykpIHJldHVybiB0cnVlO1xuXG4gICAgaWYgKGRlZi5jb250ZW50LmluY2x1ZGVzKCc8JyArIGNoaWxkVGFnTmFtZSArICc+JykgfHwgZGVmLmNvbnRlbnQuaW5jbHVkZXMoJyMnICsgY2hpbGRUYWdOYW1lKSkgcmV0dXJuIHRydWU7XG5cbiAgICByZXR1cm4gY2hpbGREZWYuY2F0ZWdvcmllcy5zb21lKGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICAgICAgcmV0dXJuIGRlZi5jb250ZW50LmluY2x1ZGVzKGNhdGVnb3J5KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcHJlZGljYXRlTmFtZXMgPSBPYmplY3Qua2V5cyhwcmVkaWNhdGVzKTtcblxuICB2YXIgbWFwcyA9IHtcbiAgICBhY2NlcHRzOiB7fVxuICB9O1xuXG4gIHByZWRpY2F0ZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gbWFwc1tuYW1lXSA9IHt9O1xuICB9KTtcblxuICB2YXIgYWxsQ2F0ZWdvcmllcyA9IFtdO1xuXG4gIF90YWdOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgdmFyIGRlZiA9IGRlZnNbdGFnTmFtZV07XG5cbiAgICBlbnN1cmVQcm9wZXJ0aWVzKGRlZik7XG5cbiAgICBhbGxDYXRlZ29yaWVzID0gYWxsQ2F0ZWdvcmllcy5jb25jYXQoZGVmLmNhdGVnb3JpZXMpO1xuXG4gICAgcHJlZGljYXRlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZGljYXRlTmFtZSkge1xuICAgICAgcmV0dXJuIG1hcHNbcHJlZGljYXRlTmFtZV1bdGFnTmFtZV0gPSBwcmVkaWNhdGVzW3ByZWRpY2F0ZU5hbWVdKHRhZ05hbWUpO1xuICAgIH0pO1xuXG4gICAgbWFwcy5hY2NlcHRzW3RhZ05hbWVdID0ge307XG5cbiAgICBfdGFnTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRUYWdOYW1lKSB7XG4gICAgICBlbnN1cmVQcm9wZXJ0aWVzKGRlZnNbY2hpbGRUYWdOYW1lXSk7XG5cbiAgICAgIG1hcHMuYWNjZXB0c1t0YWdOYW1lXVtjaGlsZFRhZ05hbWVdID0gZG9lc0FjY2VwdCh0YWdOYW1lLCBjaGlsZFRhZ05hbWUpO1xuICAgIH0pO1xuICB9KTtcblxuICB2YXIgX2NhdGVnb3J5TmFtZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoYWxsQ2F0ZWdvcmllcykpLnNvcnQoKTtcblxuICB2YXIgYXBpID0ge1xuICAgIHRhZ05hbWVzOiBmdW5jdGlvbiB0YWdOYW1lcygpIHtcbiAgICAgIHJldHVybiBfdGFnTmFtZXM7XG4gICAgfSxcbiAgICBjYXRlZ29yeU5hbWVzOiBmdW5jdGlvbiBjYXRlZ29yeU5hbWVzKCkge1xuICAgICAgcmV0dXJuIF9jYXRlZ29yeU5hbWVzO1xuICAgIH0sXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gaXNFbXB0eSh0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gbWFwcy5lbXB0eVt0YWdOYW1lXTtcbiAgICB9LFxuICAgIGlzTWV0YWRhdGE6IGZ1bmN0aW9uIGlzTWV0YWRhdGEodGFnTmFtZSkge1xuICAgICAgcmV0dXJuIG1hcHMubWV0YWRhdGFbdGFnTmFtZV07XG4gICAgfSxcbiAgICBpc0lubGluZTogZnVuY3Rpb24gaXNJbmxpbmUodGFnTmFtZSkge1xuICAgICAgcmV0dXJuIG1hcHMuaW5saW5lW3RhZ05hbWVdO1xuICAgIH0sXG4gICAgaXNFbWJlZGRlZDogZnVuY3Rpb24gaXNFbWJlZGRlZCh0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gbWFwcy5lbWJlZGRlZFt0YWdOYW1lXTtcbiAgICB9LFxuICAgIGlzQmxvY2s6IGZ1bmN0aW9uIGlzQmxvY2sodGFnTmFtZSkge1xuICAgICAgcmV0dXJuIG1hcHMuYmxvY2tbdGFnTmFtZV07XG4gICAgfSxcbiAgICBpc0NvbnRhaW5lcjogZnVuY3Rpb24gaXNDb250YWluZXIodGFnTmFtZSkge1xuICAgICAgcmV0dXJuIG1hcHMuY29udGFpbmVyW3RhZ05hbWVdO1xuICAgIH0sXG4gICAgYWNjZXB0czogZnVuY3Rpb24gYWNjZXB0cyh0YWdOYW1lLCBjaGlsZFRhZ05hbWUpIHtcbiAgICAgIHJldHVybiBtYXBzLmFjY2VwdHNbdGFnTmFtZV1bY2hpbGRUYWdOYW1lXTtcbiAgICB9LFxuICAgIGRlZjogZnVuY3Rpb24gZGVmKHRhZ05hbWUpIHtcbiAgICAgIGlmIChkZWZzW3RhZ05hbWVdKSByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkZWZzW3RhZ05hbWVdKSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBhcGk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWw7IiwibW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0aW5nSGFuZGxlcjtcblxuZnVuY3Rpb24gQ29sbGVjdGluZ0hhbmRsZXIoY2JzKXtcblx0dGhpcy5fY2JzID0gY2JzIHx8IHt9O1xuXHR0aGlzLmV2ZW50cyA9IFtdO1xufVxuXG52YXIgRVZFTlRTID0gcmVxdWlyZShcIi4vXCIpLkVWRU5UUztcbk9iamVjdC5rZXlzKEVWRU5UUykuZm9yRWFjaChmdW5jdGlvbihuYW1lKXtcblx0aWYoRVZFTlRTW25hbWVdID09PSAwKXtcblx0XHRuYW1lID0gXCJvblwiICsgbmFtZTtcblx0XHRDb2xsZWN0aW5nSGFuZGxlci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5ldmVudHMucHVzaChbbmFtZV0pO1xuXHRcdFx0aWYodGhpcy5fY2JzW25hbWVdKSB0aGlzLl9jYnNbbmFtZV0oKTtcblx0XHR9O1xuXHR9IGVsc2UgaWYoRVZFTlRTW25hbWVdID09PSAxKXtcblx0XHRuYW1lID0gXCJvblwiICsgbmFtZTtcblx0XHRDb2xsZWN0aW5nSGFuZGxlci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbihhKXtcblx0XHRcdHRoaXMuZXZlbnRzLnB1c2goW25hbWUsIGFdKTtcblx0XHRcdGlmKHRoaXMuX2Nic1tuYW1lXSkgdGhpcy5fY2JzW25hbWVdKGEpO1xuXHRcdH07XG5cdH0gZWxzZSBpZihFVkVOVFNbbmFtZV0gPT09IDIpe1xuXHRcdG5hbWUgPSBcIm9uXCIgKyBuYW1lO1xuXHRcdENvbGxlY3RpbmdIYW5kbGVyLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKGEsIGIpe1xuXHRcdFx0dGhpcy5ldmVudHMucHVzaChbbmFtZSwgYSwgYl0pO1xuXHRcdFx0aWYodGhpcy5fY2JzW25hbWVdKSB0aGlzLl9jYnNbbmFtZV0oYSwgYik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBFcnJvcihcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHNcIik7XG5cdH1cbn0pO1xuXG5Db2xsZWN0aW5nSGFuZGxlci5wcm90b3R5cGUub25yZXNldCA9IGZ1bmN0aW9uKCl7XG5cdHRoaXMuZXZlbnRzID0gW107XG5cdGlmKHRoaXMuX2Nicy5vbnJlc2V0KSB0aGlzLl9jYnMub25yZXNldCgpO1xufTtcblxuQ29sbGVjdGluZ0hhbmRsZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbigpe1xuXHRpZih0aGlzLl9jYnMub25yZXNldCkgdGhpcy5fY2JzLm9ucmVzZXQoKTtcblxuXHRmb3IodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmV2ZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG5cdFx0aWYodGhpcy5fY2JzW3RoaXMuZXZlbnRzW2ldWzBdXSl7XG5cblx0XHRcdHZhciBudW0gPSB0aGlzLmV2ZW50c1tpXS5sZW5ndGg7XG5cblx0XHRcdGlmKG51bSA9PT0gMSl7XG5cdFx0XHRcdHRoaXMuX2Nic1t0aGlzLmV2ZW50c1tpXVswXV0oKTtcblx0XHRcdH0gZWxzZSBpZihudW0gPT09IDIpe1xuXHRcdFx0XHR0aGlzLl9jYnNbdGhpcy5ldmVudHNbaV1bMF1dKHRoaXMuZXZlbnRzW2ldWzFdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2Nic1t0aGlzLmV2ZW50c1tpXVswXV0odGhpcy5ldmVudHNbaV1bMV0sIHRoaXMuZXZlbnRzW2ldWzJdKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG4iLCJ2YXIgaW5kZXggPSByZXF1aXJlKFwiLi9pbmRleC5qc1wiKSxcbiAgICBEb21IYW5kbGVyID0gaW5kZXguRG9tSGFuZGxlcixcbiAgICBEb21VdGlscyA9IGluZGV4LkRvbVV0aWxzO1xuXG4vL1RPRE86IG1ha2UgdGhpcyBhIHN0cmVhbWFibGUgaGFuZGxlclxuZnVuY3Rpb24gRmVlZEhhbmRsZXIoY2FsbGJhY2ssIG9wdGlvbnMpe1xuXHR0aGlzLmluaXQoY2FsbGJhY2ssIG9wdGlvbnMpO1xufVxuXG5yZXF1aXJlKFwiaW5oZXJpdHNcIikoRmVlZEhhbmRsZXIsIERvbUhhbmRsZXIpO1xuXG5GZWVkSGFuZGxlci5wcm90b3R5cGUuaW5pdCA9IERvbUhhbmRsZXI7XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRzKHdoYXQsIHdoZXJlKXtcblx0cmV0dXJuIERvbVV0aWxzLmdldEVsZW1lbnRzQnlUYWdOYW1lKHdoYXQsIHdoZXJlLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGdldE9uZUVsZW1lbnQod2hhdCwgd2hlcmUpe1xuXHRyZXR1cm4gRG9tVXRpbHMuZ2V0RWxlbWVudHNCeVRhZ05hbWUod2hhdCwgd2hlcmUsIHRydWUsIDEpWzBdO1xufVxuZnVuY3Rpb24gZmV0Y2god2hhdCwgd2hlcmUsIHJlY3Vyc2Upe1xuXHRyZXR1cm4gRG9tVXRpbHMuZ2V0VGV4dChcblx0XHREb21VdGlscy5nZXRFbGVtZW50c0J5VGFnTmFtZSh3aGF0LCB3aGVyZSwgcmVjdXJzZSwgMSlcblx0KS50cmltKCk7XG59XG5cbmZ1bmN0aW9uIGFkZENvbmRpdGlvbmFsbHkob2JqLCBwcm9wLCB3aGF0LCB3aGVyZSwgcmVjdXJzZSl7XG5cdHZhciB0bXAgPSBmZXRjaCh3aGF0LCB3aGVyZSwgcmVjdXJzZSk7XG5cdGlmKHRtcCkgb2JqW3Byb3BdID0gdG1wO1xufVxuXG52YXIgaXNWYWxpZEZlZWQgPSBmdW5jdGlvbih2YWx1ZSl7XG5cdHJldHVybiB2YWx1ZSA9PT0gXCJyc3NcIiB8fCB2YWx1ZSA9PT0gXCJmZWVkXCIgfHwgdmFsdWUgPT09IFwicmRmOlJERlwiO1xufTtcblxuRmVlZEhhbmRsZXIucHJvdG90eXBlLm9uZW5kID0gZnVuY3Rpb24oKXtcblx0dmFyIGZlZWQgPSB7fSxcblx0ICAgIGZlZWRSb290ID0gZ2V0T25lRWxlbWVudChpc1ZhbGlkRmVlZCwgdGhpcy5kb20pLFxuXHQgICAgdG1wLCBjaGlsZHM7XG5cblx0aWYoZmVlZFJvb3Qpe1xuXHRcdGlmKGZlZWRSb290Lm5hbWUgPT09IFwiZmVlZFwiKXtcblx0XHRcdGNoaWxkcyA9IGZlZWRSb290LmNoaWxkcmVuO1xuXG5cdFx0XHRmZWVkLnR5cGUgPSBcImF0b21cIjtcblx0XHRcdGFkZENvbmRpdGlvbmFsbHkoZmVlZCwgXCJpZFwiLCBcImlkXCIsIGNoaWxkcyk7XG5cdFx0XHRhZGRDb25kaXRpb25hbGx5KGZlZWQsIFwidGl0bGVcIiwgXCJ0aXRsZVwiLCBjaGlsZHMpO1xuXHRcdFx0aWYoKHRtcCA9IGdldE9uZUVsZW1lbnQoXCJsaW5rXCIsIGNoaWxkcykpICYmICh0bXAgPSB0bXAuYXR0cmlicykgJiYgKHRtcCA9IHRtcC5ocmVmKSkgZmVlZC5saW5rID0gdG1wO1xuXHRcdFx0YWRkQ29uZGl0aW9uYWxseShmZWVkLCBcImRlc2NyaXB0aW9uXCIsIFwic3VidGl0bGVcIiwgY2hpbGRzKTtcblx0XHRcdGlmKCh0bXAgPSBmZXRjaChcInVwZGF0ZWRcIiwgY2hpbGRzKSkpIGZlZWQudXBkYXRlZCA9IG5ldyBEYXRlKHRtcCk7XG5cdFx0XHRhZGRDb25kaXRpb25hbGx5KGZlZWQsIFwiYXV0aG9yXCIsIFwiZW1haWxcIiwgY2hpbGRzLCB0cnVlKTtcblxuXHRcdFx0ZmVlZC5pdGVtcyA9IGdldEVsZW1lbnRzKFwiZW50cnlcIiwgY2hpbGRzKS5tYXAoZnVuY3Rpb24oaXRlbSl7XG5cdFx0XHRcdHZhciBlbnRyeSA9IHt9LCB0bXA7XG5cblx0XHRcdFx0aXRlbSA9IGl0ZW0uY2hpbGRyZW47XG5cblx0XHRcdFx0YWRkQ29uZGl0aW9uYWxseShlbnRyeSwgXCJpZFwiLCBcImlkXCIsIGl0ZW0pO1xuXHRcdFx0XHRhZGRDb25kaXRpb25hbGx5KGVudHJ5LCBcInRpdGxlXCIsIFwidGl0bGVcIiwgaXRlbSk7XG5cdFx0XHRcdGlmKCh0bXAgPSBnZXRPbmVFbGVtZW50KFwibGlua1wiLCBpdGVtKSkgJiYgKHRtcCA9IHRtcC5hdHRyaWJzKSAmJiAodG1wID0gdG1wLmhyZWYpKSBlbnRyeS5saW5rID0gdG1wO1xuXHRcdFx0XHRpZigodG1wID0gZmV0Y2goXCJzdW1tYXJ5XCIsIGl0ZW0pIHx8IGZldGNoKFwiY29udGVudFwiLCBpdGVtKSkpIGVudHJ5LmRlc2NyaXB0aW9uID0gdG1wO1xuXHRcdFx0XHRpZigodG1wID0gZmV0Y2goXCJ1cGRhdGVkXCIsIGl0ZW0pKSkgZW50cnkucHViRGF0ZSA9IG5ldyBEYXRlKHRtcCk7XG5cdFx0XHRcdHJldHVybiBlbnRyeTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjaGlsZHMgPSBnZXRPbmVFbGVtZW50KFwiY2hhbm5lbFwiLCBmZWVkUm9vdC5jaGlsZHJlbikuY2hpbGRyZW47XG5cblx0XHRcdGZlZWQudHlwZSA9IGZlZWRSb290Lm5hbWUuc3Vic3RyKDAsIDMpO1xuXHRcdFx0ZmVlZC5pZCA9IFwiXCI7XG5cdFx0XHRhZGRDb25kaXRpb25hbGx5KGZlZWQsIFwidGl0bGVcIiwgXCJ0aXRsZVwiLCBjaGlsZHMpO1xuXHRcdFx0YWRkQ29uZGl0aW9uYWxseShmZWVkLCBcImxpbmtcIiwgXCJsaW5rXCIsIGNoaWxkcyk7XG5cdFx0XHRhZGRDb25kaXRpb25hbGx5KGZlZWQsIFwiZGVzY3JpcHRpb25cIiwgXCJkZXNjcmlwdGlvblwiLCBjaGlsZHMpO1xuXHRcdFx0aWYoKHRtcCA9IGZldGNoKFwibGFzdEJ1aWxkRGF0ZVwiLCBjaGlsZHMpKSkgZmVlZC51cGRhdGVkID0gbmV3IERhdGUodG1wKTtcblx0XHRcdGFkZENvbmRpdGlvbmFsbHkoZmVlZCwgXCJhdXRob3JcIiwgXCJtYW5hZ2luZ0VkaXRvclwiLCBjaGlsZHMsIHRydWUpO1xuXG5cdFx0XHRmZWVkLml0ZW1zID0gZ2V0RWxlbWVudHMoXCJpdGVtXCIsIGZlZWRSb290LmNoaWxkcmVuKS5tYXAoZnVuY3Rpb24oaXRlbSl7XG5cdFx0XHRcdHZhciBlbnRyeSA9IHt9LCB0bXA7XG5cblx0XHRcdFx0aXRlbSA9IGl0ZW0uY2hpbGRyZW47XG5cblx0XHRcdFx0YWRkQ29uZGl0aW9uYWxseShlbnRyeSwgXCJpZFwiLCBcImd1aWRcIiwgaXRlbSk7XG5cdFx0XHRcdGFkZENvbmRpdGlvbmFsbHkoZW50cnksIFwidGl0bGVcIiwgXCJ0aXRsZVwiLCBpdGVtKTtcblx0XHRcdFx0YWRkQ29uZGl0aW9uYWxseShlbnRyeSwgXCJsaW5rXCIsIFwibGlua1wiLCBpdGVtKTtcblx0XHRcdFx0YWRkQ29uZGl0aW9uYWxseShlbnRyeSwgXCJkZXNjcmlwdGlvblwiLCBcImRlc2NyaXB0aW9uXCIsIGl0ZW0pO1xuXHRcdFx0XHRpZigodG1wID0gZmV0Y2goXCJwdWJEYXRlXCIsIGl0ZW0pKSkgZW50cnkucHViRGF0ZSA9IG5ldyBEYXRlKHRtcCk7XG5cdFx0XHRcdHJldHVybiBlbnRyeTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXHR0aGlzLmRvbSA9IGZlZWQ7XG5cdERvbUhhbmRsZXIucHJvdG90eXBlLl9oYW5kbGVDYWxsYmFjay5jYWxsKFxuXHRcdHRoaXMsIGZlZWRSb290ID8gbnVsbCA6IEVycm9yKFwiY291bGRuJ3QgZmluZCByb290IG9mIGZlZWRcIilcblx0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmVlZEhhbmRsZXI7XG4iLCJ2YXIgVG9rZW5pemVyID0gcmVxdWlyZShcIi4vVG9rZW5pemVyLmpzXCIpO1xuXG4vKlxuXHRPcHRpb25zOlxuXG5cdHhtbE1vZGU6IERpc2FibGVzIHRoZSBzcGVjaWFsIGJlaGF2aW9yIGZvciBzY3JpcHQvc3R5bGUgdGFncyAoZmFsc2UgYnkgZGVmYXVsdClcblx0bG93ZXJDYXNlQXR0cmlidXRlTmFtZXM6IGNhbGwgLnRvTG93ZXJDYXNlIGZvciBlYWNoIGF0dHJpYnV0ZSBuYW1lICh0cnVlIGlmIHhtbE1vZGUgaXMgYGZhbHNlYClcblx0bG93ZXJDYXNlVGFnczogY2FsbCAudG9Mb3dlckNhc2UgZm9yIGVhY2ggdGFnIG5hbWUgKHRydWUgaWYgeG1sTW9kZSBpcyBgZmFsc2VgKVxuKi9cblxuLypcblx0Q2FsbGJhY2tzOlxuXG5cdG9uY2RhdGFlbmQsXG5cdG9uY2RhdGFzdGFydCxcblx0b25jbG9zZXRhZyxcblx0b25jb21tZW50LFxuXHRvbmNvbW1lbnRlbmQsXG5cdG9uZXJyb3IsXG5cdG9ub3BlbnRhZyxcblx0b25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24sXG5cdG9ucmVzZXQsXG5cdG9udGV4dFxuKi9cblxudmFyIGZvcm1UYWdzID0ge1xuXHRpbnB1dDogdHJ1ZSxcblx0b3B0aW9uOiB0cnVlLFxuXHRvcHRncm91cDogdHJ1ZSxcblx0c2VsZWN0OiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGRhdGFsaXN0OiB0cnVlLFxuXHR0ZXh0YXJlYTogdHJ1ZVxufTtcblxudmFyIG9wZW5JbXBsaWVzQ2xvc2UgPSB7XG5cdHRyICAgICAgOiB7IHRyOnRydWUsIHRoOnRydWUsIHRkOnRydWUgfSxcblx0dGggICAgICA6IHsgdGg6dHJ1ZSB9LFxuXHR0ZCAgICAgIDogeyB0aGVhZDp0cnVlLCB0aDp0cnVlLCB0ZDp0cnVlIH0sXG5cdGJvZHkgICAgOiB7IGhlYWQ6dHJ1ZSwgbGluazp0cnVlLCBzY3JpcHQ6dHJ1ZSB9LFxuXHRsaSAgICAgIDogeyBsaTp0cnVlIH0sXG5cdHAgICAgICAgOiB7IHA6dHJ1ZSB9LFxuXHRoMSAgICAgIDogeyBwOnRydWUgfSxcblx0aDIgICAgICA6IHsgcDp0cnVlIH0sXG5cdGgzICAgICAgOiB7IHA6dHJ1ZSB9LFxuXHRoNCAgICAgIDogeyBwOnRydWUgfSxcblx0aDUgICAgICA6IHsgcDp0cnVlIH0sXG5cdGg2ICAgICAgOiB7IHA6dHJ1ZSB9LFxuXHRzZWxlY3QgIDogZm9ybVRhZ3MsXG5cdGlucHV0ICAgOiBmb3JtVGFncyxcblx0b3V0cHV0ICA6IGZvcm1UYWdzLFxuXHRidXR0b24gIDogZm9ybVRhZ3MsXG5cdGRhdGFsaXN0OiBmb3JtVGFncyxcblx0dGV4dGFyZWE6IGZvcm1UYWdzLFxuXHRvcHRpb24gIDogeyBvcHRpb246dHJ1ZSB9LFxuXHRvcHRncm91cDogeyBvcHRncm91cDp0cnVlIH1cbn07XG5cbnZhciB2b2lkRWxlbWVudHMgPSB7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0YXJlYTogdHJ1ZSxcblx0YmFzZTogdHJ1ZSxcblx0YmFzZWZvbnQ6IHRydWUsXG5cdGJyOiB0cnVlLFxuXHRjb2w6IHRydWUsXG5cdGNvbW1hbmQ6IHRydWUsXG5cdGVtYmVkOiB0cnVlLFxuXHRmcmFtZTogdHJ1ZSxcblx0aHI6IHRydWUsXG5cdGltZzogdHJ1ZSxcblx0aW5wdXQ6IHRydWUsXG5cdGlzaW5kZXg6IHRydWUsXG5cdGtleWdlbjogdHJ1ZSxcblx0bGluazogdHJ1ZSxcblx0bWV0YTogdHJ1ZSxcblx0cGFyYW06IHRydWUsXG5cdHNvdXJjZTogdHJ1ZSxcblx0dHJhY2s6IHRydWUsXG5cdHdicjogdHJ1ZSxcblxuXHQvL2NvbW1vbiBzZWxmIGNsb3Npbmcgc3ZnIGVsZW1lbnRzXG5cdHBhdGg6IHRydWUsXG5cdGNpcmNsZTogdHJ1ZSxcblx0ZWxsaXBzZTogdHJ1ZSxcblx0bGluZTogdHJ1ZSxcblx0cmVjdDogdHJ1ZSxcblx0dXNlOiB0cnVlLFxuXHRzdG9wOiB0cnVlLFxuXHRwb2x5bGluZTogdHJ1ZSxcblx0cG9seWdvbjogdHJ1ZVxufTtcblxudmFyIHJlX25hbWVFbmQgPSAvXFxzfFxcLy87XG5cbmZ1bmN0aW9uIFBhcnNlcihjYnMsIG9wdGlvbnMpe1xuXHR0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0dGhpcy5fY2JzID0gY2JzIHx8IHt9O1xuXG5cdHRoaXMuX3RhZ25hbWUgPSBcIlwiO1xuXHR0aGlzLl9hdHRyaWJuYW1lID0gXCJcIjtcblx0dGhpcy5fYXR0cmlidmFsdWUgPSBcIlwiO1xuXHR0aGlzLl9hdHRyaWJzID0gbnVsbDtcblx0dGhpcy5fc3RhY2sgPSBbXTtcblxuXHR0aGlzLnN0YXJ0SW5kZXggPSAwO1xuXHR0aGlzLmVuZEluZGV4ID0gbnVsbDtcblxuXHR0aGlzLl9sb3dlckNhc2VUYWdOYW1lcyA9IFwibG93ZXJDYXNlVGFnc1wiIGluIHRoaXMuX29wdGlvbnMgP1xuXHRcdFx0XHRcdFx0XHRcdFx0ISF0aGlzLl9vcHRpb25zLmxvd2VyQ2FzZVRhZ3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0IXRoaXMuX29wdGlvbnMueG1sTW9kZTtcblx0dGhpcy5fbG93ZXJDYXNlQXR0cmlidXRlTmFtZXMgPSBcImxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzXCIgaW4gdGhpcy5fb3B0aW9ucyA/XG5cdFx0XHRcdFx0XHRcdFx0XHQhIXRoaXMuX29wdGlvbnMubG93ZXJDYXNlQXR0cmlidXRlTmFtZXMgOlxuXHRcdFx0XHRcdFx0XHRcdFx0IXRoaXMuX29wdGlvbnMueG1sTW9kZTtcblxuXHRpZih0aGlzLl9vcHRpb25zLlRva2VuaXplcikge1xuXHRcdFRva2VuaXplciA9IHRoaXMuX29wdGlvbnMuVG9rZW5pemVyO1xuXHR9XG5cdHRoaXMuX3Rva2VuaXplciA9IG5ldyBUb2tlbml6ZXIodGhpcy5fb3B0aW9ucywgdGhpcyk7XG5cblx0aWYodGhpcy5fY2JzLm9ucGFyc2VyaW5pdCkgdGhpcy5fY2JzLm9ucGFyc2VyaW5pdCh0aGlzKTtcbn1cblxucmVxdWlyZShcImluaGVyaXRzXCIpKFBhcnNlciwgcmVxdWlyZShcImV2ZW50c1wiKS5FdmVudEVtaXR0ZXIpO1xuXG5QYXJzZXIucHJvdG90eXBlLl91cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uKGluaXRpYWxPZmZzZXQpe1xuXHRpZih0aGlzLmVuZEluZGV4ID09PSBudWxsKXtcblx0XHRpZih0aGlzLl90b2tlbml6ZXIuX3NlY3Rpb25TdGFydCA8PSBpbml0aWFsT2Zmc2V0KXtcblx0XHRcdHRoaXMuc3RhcnRJbmRleCA9IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc3RhcnRJbmRleCA9IHRoaXMuX3Rva2VuaXplci5fc2VjdGlvblN0YXJ0IC0gaW5pdGlhbE9mZnNldDtcblx0XHR9XG5cdH1cblx0ZWxzZSB0aGlzLnN0YXJ0SW5kZXggPSB0aGlzLmVuZEluZGV4ICsgMTtcblx0dGhpcy5lbmRJbmRleCA9IHRoaXMuX3Rva2VuaXplci5nZXRBYnNvbHV0ZUluZGV4KCk7XG59O1xuXG4vL1Rva2VuaXplciBldmVudCBoYW5kbGVyc1xuUGFyc2VyLnByb3RvdHlwZS5vbnRleHQgPSBmdW5jdGlvbihkYXRhKXtcblx0dGhpcy5fdXBkYXRlUG9zaXRpb24oMSk7XG5cdHRoaXMuZW5kSW5kZXgtLTtcblxuXHRpZih0aGlzLl9jYnMub250ZXh0KSB0aGlzLl9jYnMub250ZXh0KGRhdGEpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5vbm9wZW50YWduYW1lID0gZnVuY3Rpb24obmFtZSl7XG5cdGlmKHRoaXMuX2xvd2VyQ2FzZVRhZ05hbWVzKXtcblx0XHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9XG5cblx0dGhpcy5fdGFnbmFtZSA9IG5hbWU7XG5cblx0aWYoIXRoaXMuX29wdGlvbnMueG1sTW9kZSAmJiBuYW1lIGluIG9wZW5JbXBsaWVzQ2xvc2UpIHtcblx0XHRmb3IoXG5cdFx0XHR2YXIgZWw7XG5cdFx0XHQoZWwgPSB0aGlzLl9zdGFja1t0aGlzLl9zdGFjay5sZW5ndGggLSAxXSkgaW4gb3BlbkltcGxpZXNDbG9zZVtuYW1lXTtcblx0XHRcdHRoaXMub25jbG9zZXRhZyhlbClcblx0XHQpO1xuXHR9XG5cblx0aWYodGhpcy5fb3B0aW9ucy54bWxNb2RlIHx8ICEobmFtZSBpbiB2b2lkRWxlbWVudHMpKXtcblx0XHR0aGlzLl9zdGFjay5wdXNoKG5hbWUpO1xuXHR9XG5cblx0aWYodGhpcy5fY2JzLm9ub3BlbnRhZ25hbWUpIHRoaXMuX2Nicy5vbm9wZW50YWduYW1lKG5hbWUpO1xuXHRpZih0aGlzLl9jYnMub25vcGVudGFnKSB0aGlzLl9hdHRyaWJzID0ge307XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLm9ub3BlbnRhZ2VuZCA9IGZ1bmN0aW9uKCl7XG5cdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKDEpO1xuXG5cdGlmKHRoaXMuX2F0dHJpYnMpe1xuXHRcdGlmKHRoaXMuX2Nicy5vbm9wZW50YWcpIHRoaXMuX2Nicy5vbm9wZW50YWcodGhpcy5fdGFnbmFtZSwgdGhpcy5fYXR0cmlicyk7XG5cdFx0dGhpcy5fYXR0cmlicyA9IG51bGw7XG5cdH1cblxuXHRpZighdGhpcy5fb3B0aW9ucy54bWxNb2RlICYmIHRoaXMuX2Nicy5vbmNsb3NldGFnICYmIHRoaXMuX3RhZ25hbWUgaW4gdm9pZEVsZW1lbnRzKXtcblx0XHR0aGlzLl9jYnMub25jbG9zZXRhZyh0aGlzLl90YWduYW1lKTtcblx0fVxuXG5cdHRoaXMuX3RhZ25hbWUgPSBcIlwiO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5vbmNsb3NldGFnID0gZnVuY3Rpb24obmFtZSl7XG5cdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKDEpO1xuXG5cdGlmKHRoaXMuX2xvd2VyQ2FzZVRhZ05hbWVzKXtcblx0XHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9XG5cblx0aWYodGhpcy5fc3RhY2subGVuZ3RoICYmICghKG5hbWUgaW4gdm9pZEVsZW1lbnRzKSB8fCB0aGlzLl9vcHRpb25zLnhtbE1vZGUpKXtcblx0XHR2YXIgcG9zID0gdGhpcy5fc3RhY2subGFzdEluZGV4T2YobmFtZSk7XG5cdFx0aWYocG9zICE9PSAtMSl7XG5cdFx0XHRpZih0aGlzLl9jYnMub25jbG9zZXRhZyl7XG5cdFx0XHRcdHBvcyA9IHRoaXMuX3N0YWNrLmxlbmd0aCAtIHBvcztcblx0XHRcdFx0d2hpbGUocG9zLS0pIHRoaXMuX2Nicy5vbmNsb3NldGFnKHRoaXMuX3N0YWNrLnBvcCgpKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgdGhpcy5fc3RhY2subGVuZ3RoID0gcG9zO1xuXHRcdH0gZWxzZSBpZihuYW1lID09PSBcInBcIiAmJiAhdGhpcy5fb3B0aW9ucy54bWxNb2RlKXtcblx0XHRcdHRoaXMub25vcGVudGFnbmFtZShuYW1lKTtcblx0XHRcdHRoaXMuX2Nsb3NlQ3VycmVudFRhZygpO1xuXHRcdH1cblx0fSBlbHNlIGlmKCF0aGlzLl9vcHRpb25zLnhtbE1vZGUgJiYgKG5hbWUgPT09IFwiYnJcIiB8fCBuYW1lID09PSBcInBcIikpe1xuXHRcdHRoaXMub25vcGVudGFnbmFtZShuYW1lKTtcblx0XHR0aGlzLl9jbG9zZUN1cnJlbnRUYWcoKTtcblx0fVxufTtcblxuUGFyc2VyLnByb3RvdHlwZS5vbnNlbGZjbG9zaW5ndGFnID0gZnVuY3Rpb24oKXtcblx0aWYodGhpcy5fb3B0aW9ucy54bWxNb2RlIHx8IHRoaXMuX29wdGlvbnMucmVjb2duaXplU2VsZkNsb3Npbmcpe1xuXHRcdHRoaXMuX2Nsb3NlQ3VycmVudFRhZygpO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMub25vcGVudGFnZW5kKCk7XG5cdH1cbn07XG5cblBhcnNlci5wcm90b3R5cGUuX2Nsb3NlQ3VycmVudFRhZyA9IGZ1bmN0aW9uKCl7XG5cdHZhciBuYW1lID0gdGhpcy5fdGFnbmFtZTtcblxuXHR0aGlzLm9ub3BlbnRhZ2VuZCgpO1xuXG5cdC8vc2VsZi1jbG9zaW5nIHRhZ3Mgd2lsbCBiZSBvbiB0aGUgdG9wIG9mIHRoZSBzdGFja1xuXHQvLyhjaGVhcGVyIGNoZWNrIHRoYW4gaW4gb25jbG9zZXRhZylcblx0aWYodGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoIC0gMV0gPT09IG5hbWUpe1xuXHRcdGlmKHRoaXMuX2Nicy5vbmNsb3NldGFnKXtcblx0XHRcdHRoaXMuX2Nicy5vbmNsb3NldGFnKG5hbWUpO1xuXHRcdH1cblx0XHR0aGlzLl9zdGFjay5wb3AoKTtcblx0fVxufTtcblxuUGFyc2VyLnByb3RvdHlwZS5vbmF0dHJpYm5hbWUgPSBmdW5jdGlvbihuYW1lKXtcblx0aWYodGhpcy5fbG93ZXJDYXNlQXR0cmlidXRlTmFtZXMpe1xuXHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdH1cblx0dGhpcy5fYXR0cmlibmFtZSA9IG5hbWU7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLm9uYXR0cmliZGF0YSA9IGZ1bmN0aW9uKHZhbHVlKXtcblx0dGhpcy5fYXR0cmlidmFsdWUgKz0gdmFsdWU7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLm9uYXR0cmliZW5kID0gZnVuY3Rpb24oKXtcblx0aWYodGhpcy5fY2JzLm9uYXR0cmlidXRlKSB0aGlzLl9jYnMub25hdHRyaWJ1dGUodGhpcy5fYXR0cmlibmFtZSwgdGhpcy5fYXR0cmlidmFsdWUpO1xuXHRpZihcblx0XHR0aGlzLl9hdHRyaWJzICYmXG5cdFx0IU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9hdHRyaWJzLCB0aGlzLl9hdHRyaWJuYW1lKVxuXHQpe1xuXHRcdHRoaXMuX2F0dHJpYnNbdGhpcy5fYXR0cmlibmFtZV0gPSB0aGlzLl9hdHRyaWJ2YWx1ZTtcblx0fVxuXHR0aGlzLl9hdHRyaWJuYW1lID0gXCJcIjtcblx0dGhpcy5fYXR0cmlidmFsdWUgPSBcIlwiO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5fZ2V0SW5zdHJ1Y3Rpb25OYW1lID0gZnVuY3Rpb24odmFsdWUpe1xuXHR2YXIgaWR4ID0gdmFsdWUuc2VhcmNoKHJlX25hbWVFbmQpLFxuXHQgICAgbmFtZSA9IGlkeCA8IDAgPyB2YWx1ZSA6IHZhbHVlLnN1YnN0cigwLCBpZHgpO1xuXG5cdGlmKHRoaXMuX2xvd2VyQ2FzZVRhZ05hbWVzKXtcblx0XHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9XG5cblx0cmV0dXJuIG5hbWU7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLm9uZGVjbGFyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSl7XG5cdGlmKHRoaXMuX2Nicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbil7XG5cdFx0dmFyIG5hbWUgPSB0aGlzLl9nZXRJbnN0cnVjdGlvbk5hbWUodmFsdWUpO1xuXHRcdHRoaXMuX2Nicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbihcIiFcIiArIG5hbWUsIFwiIVwiICsgdmFsdWUpO1xuXHR9XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uID0gZnVuY3Rpb24odmFsdWUpe1xuXHRpZih0aGlzLl9jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24pe1xuXHRcdHZhciBuYW1lID0gdGhpcy5fZ2V0SW5zdHJ1Y3Rpb25OYW1lKHZhbHVlKTtcblx0XHR0aGlzLl9jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24oXCI/XCIgKyBuYW1lLCBcIj9cIiArIHZhbHVlKTtcblx0fVxufTtcblxuUGFyc2VyLnByb3RvdHlwZS5vbmNvbW1lbnQgPSBmdW5jdGlvbih2YWx1ZSl7XG5cdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKDQpO1xuXG5cdGlmKHRoaXMuX2Nicy5vbmNvbW1lbnQpIHRoaXMuX2Nicy5vbmNvbW1lbnQodmFsdWUpO1xuXHRpZih0aGlzLl9jYnMub25jb21tZW50ZW5kKSB0aGlzLl9jYnMub25jb21tZW50ZW5kKCk7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLm9uY2RhdGEgPSBmdW5jdGlvbih2YWx1ZSl7XG5cdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKDEpO1xuXG5cdGlmKHRoaXMuX29wdGlvbnMueG1sTW9kZSB8fCB0aGlzLl9vcHRpb25zLnJlY29nbml6ZUNEQVRBKXtcblx0XHRpZih0aGlzLl9jYnMub25jZGF0YXN0YXJ0KSB0aGlzLl9jYnMub25jZGF0YXN0YXJ0KCk7XG5cdFx0aWYodGhpcy5fY2JzLm9udGV4dCkgdGhpcy5fY2JzLm9udGV4dCh2YWx1ZSk7XG5cdFx0aWYodGhpcy5fY2JzLm9uY2RhdGFlbmQpIHRoaXMuX2Nicy5vbmNkYXRhZW5kKCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5vbmNvbW1lbnQoXCJbQ0RBVEFbXCIgKyB2YWx1ZSArIFwiXV1cIik7XG5cdH1cbn07XG5cblBhcnNlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uKGVycil7XG5cdGlmKHRoaXMuX2Nicy5vbmVycm9yKSB0aGlzLl9jYnMub25lcnJvcihlcnIpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5vbmVuZCA9IGZ1bmN0aW9uKCl7XG5cdGlmKHRoaXMuX2Nicy5vbmNsb3NldGFnKXtcblx0XHRmb3IoXG5cdFx0XHR2YXIgaSA9IHRoaXMuX3N0YWNrLmxlbmd0aDtcblx0XHRcdGkgPiAwO1xuXHRcdFx0dGhpcy5fY2JzLm9uY2xvc2V0YWcodGhpcy5fc3RhY2tbLS1pXSlcblx0XHQpO1xuXHR9XG5cdGlmKHRoaXMuX2Nicy5vbmVuZCkgdGhpcy5fY2JzLm9uZW5kKCk7XG59O1xuXG5cbi8vUmVzZXRzIHRoZSBwYXJzZXIgdG8gYSBibGFuayBzdGF0ZSwgcmVhZHkgdG8gcGFyc2UgYSBuZXcgSFRNTCBkb2N1bWVudFxuUGFyc2VyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG5cdGlmKHRoaXMuX2Nicy5vbnJlc2V0KSB0aGlzLl9jYnMub25yZXNldCgpO1xuXHR0aGlzLl90b2tlbml6ZXIucmVzZXQoKTtcblxuXHR0aGlzLl90YWduYW1lID0gXCJcIjtcblx0dGhpcy5fYXR0cmlibmFtZSA9IFwiXCI7XG5cdHRoaXMuX2F0dHJpYnMgPSBudWxsO1xuXHR0aGlzLl9zdGFjayA9IFtdO1xuXG5cdGlmKHRoaXMuX2Nicy5vbnBhcnNlcmluaXQpIHRoaXMuX2Nicy5vbnBhcnNlcmluaXQodGhpcyk7XG59O1xuXG4vL1BhcnNlcyBhIGNvbXBsZXRlIEhUTUwgZG9jdW1lbnQgYW5kIHB1c2hlcyBpdCB0byB0aGUgaGFuZGxlclxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvbXBsZXRlID0gZnVuY3Rpb24oZGF0YSl7XG5cdHRoaXMucmVzZXQoKTtcblx0dGhpcy5lbmQoZGF0YSk7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmspe1xuXHR0aGlzLl90b2tlbml6ZXIud3JpdGUoY2h1bmspO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihjaHVuayl7XG5cdHRoaXMuX3Rva2VuaXplci5lbmQoY2h1bmspO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCl7XG5cdHRoaXMuX3Rva2VuaXplci5wYXVzZSgpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpe1xuXHR0aGlzLl90b2tlbml6ZXIucmVzdW1lKCk7XG59O1xuXG4vL2FsaWFzIGZvciBiYWNrd2FyZHMgY29tcGF0XG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ2h1bmsgPSBQYXJzZXIucHJvdG90eXBlLndyaXRlO1xuUGFyc2VyLnByb3RvdHlwZS5kb25lID0gUGFyc2VyLnByb3RvdHlwZS5lbmQ7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBQcm94eUhhbmRsZXI7XG5cbmZ1bmN0aW9uIFByb3h5SGFuZGxlcihjYnMpe1xuXHR0aGlzLl9jYnMgPSBjYnMgfHwge307XG59XG5cbnZhciBFVkVOVFMgPSByZXF1aXJlKFwiLi9cIikuRVZFTlRTO1xuT2JqZWN0LmtleXMoRVZFTlRTKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpe1xuXHRpZihFVkVOVFNbbmFtZV0gPT09IDApe1xuXHRcdG5hbWUgPSBcIm9uXCIgKyBuYW1lO1xuXHRcdFByb3h5SGFuZGxlci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpe1xuXHRcdFx0aWYodGhpcy5fY2JzW25hbWVdKSB0aGlzLl9jYnNbbmFtZV0oKTtcblx0XHR9O1xuXHR9IGVsc2UgaWYoRVZFTlRTW25hbWVdID09PSAxKXtcblx0XHRuYW1lID0gXCJvblwiICsgbmFtZTtcblx0XHRQcm94eUhhbmRsZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oYSl7XG5cdFx0XHRpZih0aGlzLl9jYnNbbmFtZV0pIHRoaXMuX2Nic1tuYW1lXShhKTtcblx0XHR9O1xuXHR9IGVsc2UgaWYoRVZFTlRTW25hbWVdID09PSAyKXtcblx0XHRuYW1lID0gXCJvblwiICsgbmFtZTtcblx0XHRQcm94eUhhbmRsZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oYSwgYil7XG5cdFx0XHRpZih0aGlzLl9jYnNbbmFtZV0pIHRoaXMuX2Nic1tuYW1lXShhLCBiKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IEVycm9yKFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50c1wiKTtcblx0fVxufSk7IiwibW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBQYXJzZXIgPSByZXF1aXJlKFwiLi9Xcml0YWJsZVN0cmVhbS5qc1wiKTtcblxuZnVuY3Rpb24gU3RyZWFtKG9wdGlvbnMpe1xuXHRQYXJzZXIuY2FsbCh0aGlzLCBuZXcgQ2JzKHRoaXMpLCBvcHRpb25zKTtcbn1cblxucmVxdWlyZShcImluaGVyaXRzXCIpKFN0cmVhbSwgUGFyc2VyKTtcblxuU3RyZWFtLnByb3RvdHlwZS5yZWFkYWJsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIENicyhzY29wZSl7XG5cdHRoaXMuc2NvcGUgPSBzY29wZTtcbn1cblxudmFyIEVWRU5UUyA9IHJlcXVpcmUoXCIuLi9cIikuRVZFTlRTO1xuXG5PYmplY3Qua2V5cyhFVkVOVFMpLmZvckVhY2goZnVuY3Rpb24obmFtZSl7XG5cdGlmKEVWRU5UU1tuYW1lXSA9PT0gMCl7XG5cdFx0Q2JzLnByb3RvdHlwZVtcIm9uXCIgKyBuYW1lXSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLnNjb3BlLmVtaXQobmFtZSk7XG5cdFx0fTtcblx0fSBlbHNlIGlmKEVWRU5UU1tuYW1lXSA9PT0gMSl7XG5cdFx0Q2JzLnByb3RvdHlwZVtcIm9uXCIgKyBuYW1lXSA9IGZ1bmN0aW9uKGEpe1xuXHRcdFx0dGhpcy5zY29wZS5lbWl0KG5hbWUsIGEpO1xuXHRcdH07XG5cdH0gZWxzZSBpZihFVkVOVFNbbmFtZV0gPT09IDIpe1xuXHRcdENicy5wcm90b3R5cGVbXCJvblwiICsgbmFtZV0gPSBmdW5jdGlvbihhLCBiKXtcblx0XHRcdHRoaXMuc2NvcGUuZW1pdChuYW1lLCBhLCBiKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IEVycm9yKFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyFcIik7XG5cdH1cbn0pOyIsIm1vZHVsZS5leHBvcnRzID0gVG9rZW5pemVyO1xuXG52YXIgZGVjb2RlQ29kZVBvaW50ID0gcmVxdWlyZShcImVudGl0aWVzL2xpYi9kZWNvZGVfY29kZXBvaW50LmpzXCIpLFxuICAgIGVudGl0eU1hcCA9IHJlcXVpcmUoXCJlbnRpdGllcy9tYXBzL2VudGl0aWVzLmpzb25cIiksXG4gICAgbGVnYWN5TWFwID0gcmVxdWlyZShcImVudGl0aWVzL21hcHMvbGVnYWN5Lmpzb25cIiksXG4gICAgeG1sTWFwICAgID0gcmVxdWlyZShcImVudGl0aWVzL21hcHMveG1sLmpzb25cIiksXG5cbiAgICBpID0gMCxcblxuICAgIFRFWFQgICAgICAgICAgICAgICAgICAgICAgPSBpKyssXG4gICAgQkVGT1JFX1RBR19OQU1FICAgICAgICAgICA9IGkrKywgLy9hZnRlciA8XG4gICAgSU5fVEFHX05BTUUgICAgICAgICAgICAgICA9IGkrKyxcbiAgICBJTl9TRUxGX0NMT1NJTkdfVEFHICAgICAgID0gaSsrLFxuICAgIEJFRk9SRV9DTE9TSU5HX1RBR19OQU1FICAgPSBpKyssXG4gICAgSU5fQ0xPU0lOR19UQUdfTkFNRSAgICAgICA9IGkrKyxcbiAgICBBRlRFUl9DTE9TSU5HX1RBR19OQU1FICAgID0gaSsrLFxuXG4gICAgLy9hdHRyaWJ1dGVzXG4gICAgQkVGT1JFX0FUVFJJQlVURV9OQU1FICAgICA9IGkrKyxcbiAgICBJTl9BVFRSSUJVVEVfTkFNRSAgICAgICAgID0gaSsrLFxuICAgIEFGVEVSX0FUVFJJQlVURV9OQU1FICAgICAgPSBpKyssXG4gICAgQkVGT1JFX0FUVFJJQlVURV9WQUxVRSAgICA9IGkrKyxcbiAgICBJTl9BVFRSSUJVVEVfVkFMVUVfRFEgICAgID0gaSsrLCAvLyBcIlxuICAgIElOX0FUVFJJQlVURV9WQUxVRV9TUSAgICAgPSBpKyssIC8vICdcbiAgICBJTl9BVFRSSUJVVEVfVkFMVUVfTlEgICAgID0gaSsrLFxuXG4gICAgLy9kZWNsYXJhdGlvbnNcbiAgICBCRUZPUkVfREVDTEFSQVRJT04gICAgICAgID0gaSsrLCAvLyAhXG4gICAgSU5fREVDTEFSQVRJT04gICAgICAgICAgICA9IGkrKyxcblxuICAgIC8vcHJvY2Vzc2luZyBpbnN0cnVjdGlvbnNcbiAgICBJTl9QUk9DRVNTSU5HX0lOU1RSVUNUSU9OID0gaSsrLCAvLyA/XG5cbiAgICAvL2NvbW1lbnRzXG4gICAgQkVGT1JFX0NPTU1FTlQgICAgICAgICAgICA9IGkrKyxcbiAgICBJTl9DT01NRU5UICAgICAgICAgICAgICAgID0gaSsrLFxuICAgIEFGVEVSX0NPTU1FTlRfMSAgICAgICAgICAgPSBpKyssXG4gICAgQUZURVJfQ09NTUVOVF8yICAgICAgICAgICA9IGkrKyxcblxuICAgIC8vY2RhdGFcbiAgICBCRUZPUkVfQ0RBVEFfMSAgICAgICAgICAgID0gaSsrLCAvLyBbXG4gICAgQkVGT1JFX0NEQVRBXzIgICAgICAgICAgICA9IGkrKywgLy8gQ1xuICAgIEJFRk9SRV9DREFUQV8zICAgICAgICAgICAgPSBpKyssIC8vIERcbiAgICBCRUZPUkVfQ0RBVEFfNCAgICAgICAgICAgID0gaSsrLCAvLyBBXG4gICAgQkVGT1JFX0NEQVRBXzUgICAgICAgICAgICA9IGkrKywgLy8gVFxuICAgIEJFRk9SRV9DREFUQV82ICAgICAgICAgICAgPSBpKyssIC8vIEFcbiAgICBJTl9DREFUQSAgICAgICAgICAgICAgICAgID0gaSsrLCAvLyBbXG4gICAgQUZURVJfQ0RBVEFfMSAgICAgICAgICAgICA9IGkrKywgLy8gXVxuICAgIEFGVEVSX0NEQVRBXzIgICAgICAgICAgICAgPSBpKyssIC8vIF1cblxuICAgIC8vc3BlY2lhbCB0YWdzXG4gICAgQkVGT1JFX1NQRUNJQUwgICAgICAgICAgICA9IGkrKywgLy9TXG4gICAgQkVGT1JFX1NQRUNJQUxfRU5EICAgICAgICA9IGkrKywgICAvL1NcblxuICAgIEJFRk9SRV9TQ1JJUFRfMSAgICAgICAgICAgPSBpKyssIC8vQ1xuICAgIEJFRk9SRV9TQ1JJUFRfMiAgICAgICAgICAgPSBpKyssIC8vUlxuICAgIEJFRk9SRV9TQ1JJUFRfMyAgICAgICAgICAgPSBpKyssIC8vSVxuICAgIEJFRk9SRV9TQ1JJUFRfNCAgICAgICAgICAgPSBpKyssIC8vUFxuICAgIEJFRk9SRV9TQ1JJUFRfNSAgICAgICAgICAgPSBpKyssIC8vVFxuICAgIEFGVEVSX1NDUklQVF8xICAgICAgICAgICAgPSBpKyssIC8vQ1xuICAgIEFGVEVSX1NDUklQVF8yICAgICAgICAgICAgPSBpKyssIC8vUlxuICAgIEFGVEVSX1NDUklQVF8zICAgICAgICAgICAgPSBpKyssIC8vSVxuICAgIEFGVEVSX1NDUklQVF80ICAgICAgICAgICAgPSBpKyssIC8vUFxuICAgIEFGVEVSX1NDUklQVF81ICAgICAgICAgICAgPSBpKyssIC8vVFxuXG4gICAgQkVGT1JFX1NUWUxFXzEgICAgICAgICAgICA9IGkrKywgLy9UXG4gICAgQkVGT1JFX1NUWUxFXzIgICAgICAgICAgICA9IGkrKywgLy9ZXG4gICAgQkVGT1JFX1NUWUxFXzMgICAgICAgICAgICA9IGkrKywgLy9MXG4gICAgQkVGT1JFX1NUWUxFXzQgICAgICAgICAgICA9IGkrKywgLy9FXG4gICAgQUZURVJfU1RZTEVfMSAgICAgICAgICAgICA9IGkrKywgLy9UXG4gICAgQUZURVJfU1RZTEVfMiAgICAgICAgICAgICA9IGkrKywgLy9ZXG4gICAgQUZURVJfU1RZTEVfMyAgICAgICAgICAgICA9IGkrKywgLy9MXG4gICAgQUZURVJfU1RZTEVfNCAgICAgICAgICAgICA9IGkrKywgLy9FXG5cbiAgICBCRUZPUkVfRU5USVRZICAgICAgICAgICAgID0gaSsrLCAvLyZcbiAgICBCRUZPUkVfTlVNRVJJQ19FTlRJVFkgICAgID0gaSsrLCAvLyNcbiAgICBJTl9OQU1FRF9FTlRJVFkgICAgICAgICAgID0gaSsrLFxuICAgIElOX05VTUVSSUNfRU5USVRZICAgICAgICAgPSBpKyssXG4gICAgSU5fSEVYX0VOVElUWSAgICAgICAgICAgICA9IGkrKywgLy9YXG5cbiAgICBqID0gMCxcblxuICAgIFNQRUNJQUxfTk9ORSAgICAgICAgICAgICAgPSBqKyssXG4gICAgU1BFQ0lBTF9TQ1JJUFQgICAgICAgICAgICA9IGorKyxcbiAgICBTUEVDSUFMX1NUWUxFICAgICAgICAgICAgID0gaisrO1xuXG5mdW5jdGlvbiB3aGl0ZXNwYWNlKGMpe1xuXHRyZXR1cm4gYyA9PT0gXCIgXCIgfHwgYyA9PT0gXCJcXG5cIiB8fCBjID09PSBcIlxcdFwiIHx8IGMgPT09IFwiXFxmXCIgfHwgYyA9PT0gXCJcXHJcIjtcbn1cblxuZnVuY3Rpb24gY2hhcmFjdGVyU3RhdGUoY2hhciwgU1VDQ0VTUyl7XG5cdHJldHVybiBmdW5jdGlvbihjKXtcblx0XHRpZihjID09PSBjaGFyKSB0aGlzLl9zdGF0ZSA9IFNVQ0NFU1M7XG5cdH07XG59XG5cbmZ1bmN0aW9uIGlmRWxzZVN0YXRlKHVwcGVyLCBTVUNDRVNTLCBGQUlMVVJFKXtcblx0dmFyIGxvd2VyID0gdXBwZXIudG9Mb3dlckNhc2UoKTtcblxuXHRpZih1cHBlciA9PT0gbG93ZXIpe1xuXHRcdHJldHVybiBmdW5jdGlvbihjKXtcblx0XHRcdGlmKGMgPT09IGxvd2VyKXtcblx0XHRcdFx0dGhpcy5fc3RhdGUgPSBTVUNDRVNTO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fc3RhdGUgPSBGQUlMVVJFO1xuXHRcdFx0XHR0aGlzLl9pbmRleC0tO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGMpe1xuXHRcdFx0aWYoYyA9PT0gbG93ZXIgfHwgYyA9PT0gdXBwZXIpe1xuXHRcdFx0XHR0aGlzLl9zdGF0ZSA9IFNVQ0NFU1M7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9zdGF0ZSA9IEZBSUxVUkU7XG5cdFx0XHRcdHRoaXMuX2luZGV4LS07XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufVxuXG5mdW5jdGlvbiBjb25zdW1lU3BlY2lhbE5hbWVDaGFyKHVwcGVyLCBORVhUX1NUQVRFKXtcblx0dmFyIGxvd2VyID0gdXBwZXIudG9Mb3dlckNhc2UoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oYyl7XG5cdFx0aWYoYyA9PT0gbG93ZXIgfHwgYyA9PT0gdXBwZXIpe1xuXHRcdFx0dGhpcy5fc3RhdGUgPSBORVhUX1NUQVRFO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zdGF0ZSA9IElOX1RBR19OQU1FO1xuXHRcdFx0dGhpcy5faW5kZXgtLTsgLy9jb25zdW1lIHRoZSB0b2tlbiBhZ2FpblxuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gVG9rZW5pemVyKG9wdGlvbnMsIGNicyl7XG5cdHRoaXMuX3N0YXRlID0gVEVYVDtcblx0dGhpcy5fYnVmZmVyID0gXCJcIjtcblx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gMDtcblx0dGhpcy5faW5kZXggPSAwO1xuXHR0aGlzLl9idWZmZXJPZmZzZXQgPSAwOyAvL2NoYXJzIHJlbW92ZWQgZnJvbSBfYnVmZmVyXG5cdHRoaXMuX2Jhc2VTdGF0ZSA9IFRFWFQ7XG5cdHRoaXMuX3NwZWNpYWwgPSBTUEVDSUFMX05PTkU7XG5cdHRoaXMuX2NicyA9IGNicztcblx0dGhpcy5fcnVubmluZyA9IHRydWU7XG5cdHRoaXMuX2VuZGVkID0gZmFsc2U7XG5cdHRoaXMuX3htbE1vZGUgPSAhIShvcHRpb25zICYmIG9wdGlvbnMueG1sTW9kZSk7XG5cdHRoaXMuX2RlY29kZUVudGl0aWVzID0gISEob3B0aW9ucyAmJiBvcHRpb25zLmRlY29kZUVudGl0aWVzKTtcbn1cblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVUZXh0ID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiPFwiKXtcblx0XHRpZih0aGlzLl9pbmRleCA+IHRoaXMuX3NlY3Rpb25TdGFydCl7XG5cdFx0XHR0aGlzLl9jYnMub250ZXh0KHRoaXMuX2dldFNlY3Rpb24oKSk7XG5cdFx0fVxuXHRcdHRoaXMuX3N0YXRlID0gQkVGT1JFX1RBR19OQU1FO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuXHR9IGVsc2UgaWYodGhpcy5fZGVjb2RlRW50aXRpZXMgJiYgdGhpcy5fc3BlY2lhbCA9PT0gU1BFQ0lBTF9OT05FICYmIGMgPT09IFwiJlwiKXtcblx0XHRpZih0aGlzLl9pbmRleCA+IHRoaXMuX3NlY3Rpb25TdGFydCl7XG5cdFx0XHR0aGlzLl9jYnMub250ZXh0KHRoaXMuX2dldFNlY3Rpb24oKSk7XG5cdFx0fVxuXHRcdHRoaXMuX2Jhc2VTdGF0ZSA9IFRFWFQ7XG5cdFx0dGhpcy5fc3RhdGUgPSBCRUZPUkVfRU5USVRZO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZVRhZ05hbWUgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCIvXCIpe1xuXHRcdHRoaXMuX3N0YXRlID0gQkVGT1JFX0NMT1NJTkdfVEFHX05BTUU7XG5cdH0gZWxzZSBpZihjID09PSBcIjxcIil7XG5cdFx0dGhpcy5fY2JzLm9udGV4dCh0aGlzLl9nZXRTZWN0aW9uKCkpO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuXHR9IGVsc2UgaWYoYyA9PT0gXCI+XCIgfHwgdGhpcy5fc3BlY2lhbCAhPT0gU1BFQ0lBTF9OT05FIHx8IHdoaXRlc3BhY2UoYykpIHtcblx0XHR0aGlzLl9zdGF0ZSA9IFRFWFQ7XG5cdH0gZWxzZSBpZihjID09PSBcIiFcIil7XG5cdFx0dGhpcy5fc3RhdGUgPSBCRUZPUkVfREVDTEFSQVRJT047XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuXHR9IGVsc2UgaWYoYyA9PT0gXCI/XCIpe1xuXHRcdHRoaXMuX3N0YXRlID0gSU5fUFJPQ0VTU0lOR19JTlNUUlVDVElPTjtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5fc3RhdGUgPSAoIXRoaXMuX3htbE1vZGUgJiYgKGMgPT09IFwic1wiIHx8IGMgPT09IFwiU1wiKSkgP1xuXHRcdFx0XHRcdFx0QkVGT1JFX1NQRUNJQUwgOiBJTl9UQUdfTkFNRTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcblx0fVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJblRhZ05hbWUgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCIvXCIgfHwgYyA9PT0gXCI+XCIgfHwgd2hpdGVzcGFjZShjKSl7XG5cdFx0dGhpcy5fZW1pdFRva2VuKFwib25vcGVudGFnbmFtZVwiKTtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9BVFRSSUJVVEVfTkFNRTtcblx0XHR0aGlzLl9pbmRleC0tO1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUNsb3NlaW5nVGFnTmFtZSA9IGZ1bmN0aW9uKGMpe1xuXHRpZih3aGl0ZXNwYWNlKGMpKTtcblx0ZWxzZSBpZihjID09PSBcIj5cIil7XG5cdFx0dGhpcy5fc3RhdGUgPSBURVhUO1xuXHR9IGVsc2UgaWYodGhpcy5fc3BlY2lhbCAhPT0gU1BFQ0lBTF9OT05FKXtcblx0XHRpZihjID09PSBcInNcIiB8fCBjID09PSBcIlNcIil7XG5cdFx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9TUEVDSUFMX0VORDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fc3RhdGUgPSBURVhUO1xuXHRcdFx0dGhpcy5faW5kZXgtLTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9DTE9TSU5HX1RBR19OQU1FO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluQ2xvc2VpbmdUYWdOYW1lID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiPlwiIHx8IHdoaXRlc3BhY2UoYykpe1xuXHRcdHRoaXMuX2VtaXRUb2tlbihcIm9uY2xvc2V0YWdcIik7XG5cdFx0dGhpcy5fc3RhdGUgPSBBRlRFUl9DTE9TSU5HX1RBR19OQU1FO1xuXHRcdHRoaXMuX2luZGV4LS07XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJDbG9zZWluZ1RhZ05hbWUgPSBmdW5jdGlvbihjKXtcblx0Ly9za2lwIGV2ZXJ5dGhpbmcgdW50aWwgXCI+XCJcblx0aWYoYyA9PT0gXCI+XCIpe1xuXHRcdHRoaXMuX3N0YXRlID0gVEVYVDtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIj5cIil7XG5cdFx0dGhpcy5fY2JzLm9ub3BlbnRhZ2VuZCgpO1xuXHRcdHRoaXMuX3N0YXRlID0gVEVYVDtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG5cdH0gZWxzZSBpZihjID09PSBcIi9cIil7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9TRUxGX0NMT1NJTkdfVEFHO1xuXHR9IGVsc2UgaWYoIXdoaXRlc3BhY2UoYykpe1xuXHRcdHRoaXMuX3N0YXRlID0gSU5fQVRUUklCVVRFX05BTUU7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5TZWxmQ2xvc2luZ1RhZyA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIj5cIil7XG5cdFx0dGhpcy5fY2JzLm9uc2VsZmNsb3Npbmd0YWcoKTtcblx0XHR0aGlzLl9zdGF0ZSA9IFRFWFQ7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuXHR9IGVsc2UgaWYoIXdoaXRlc3BhY2UoYykpe1xuXHRcdHRoaXMuX3N0YXRlID0gQkVGT1JFX0FUVFJJQlVURV9OQU1FO1xuXHRcdHRoaXMuX2luZGV4LS07XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5BdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiPVwiIHx8IGMgPT09IFwiL1wiIHx8IGMgPT09IFwiPlwiIHx8IHdoaXRlc3BhY2UoYykpe1xuXHRcdHRoaXMuX2Nicy5vbmF0dHJpYm5hbWUodGhpcy5fZ2V0U2VjdGlvbigpKTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSAtMTtcblx0XHR0aGlzLl9zdGF0ZSA9IEFGVEVSX0FUVFJJQlVURV9OQU1FO1xuXHRcdHRoaXMuX2luZGV4LS07XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiPVwiKXtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9BVFRSSUJVVEVfVkFMVUU7XG5cdH0gZWxzZSBpZihjID09PSBcIi9cIiB8fCBjID09PSBcIj5cIil7XG5cdFx0dGhpcy5fY2JzLm9uYXR0cmliZW5kKCk7XG5cdFx0dGhpcy5fc3RhdGUgPSBCRUZPUkVfQVRUUklCVVRFX05BTUU7XG5cdFx0dGhpcy5faW5kZXgtLTtcblx0fSBlbHNlIGlmKCF3aGl0ZXNwYWNlKGMpKXtcblx0XHR0aGlzLl9jYnMub25hdHRyaWJlbmQoKTtcblx0XHR0aGlzLl9zdGF0ZSA9IElOX0FUVFJJQlVURV9OQU1FO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUF0dHJpYnV0ZVZhbHVlID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiXFxcIlwiKXtcblx0XHR0aGlzLl9zdGF0ZSA9IElOX0FUVFJJQlVURV9WQUxVRV9EUTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG5cdH0gZWxzZSBpZihjID09PSBcIidcIil7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9BVFRSSUJVVEVfVkFMVUVfU1E7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuXHR9IGVsc2UgaWYoIXdoaXRlc3BhY2UoYykpe1xuXHRcdHRoaXMuX3N0YXRlID0gSU5fQVRUUklCVVRFX1ZBTFVFX05RO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuXHRcdHRoaXMuX2luZGV4LS07IC8vcmVjb25zdW1lIHRva2VuXG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5BdHRyaWJ1dGVWYWx1ZURvdWJsZVF1b3RlcyA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIlxcXCJcIil7XG5cdFx0dGhpcy5fZW1pdFRva2VuKFwib25hdHRyaWJkYXRhXCIpO1xuXHRcdHRoaXMuX2Nicy5vbmF0dHJpYmVuZCgpO1xuXHRcdHRoaXMuX3N0YXRlID0gQkVGT1JFX0FUVFJJQlVURV9OQU1FO1xuXHR9IGVsc2UgaWYodGhpcy5fZGVjb2RlRW50aXRpZXMgJiYgYyA9PT0gXCImXCIpe1xuXHRcdHRoaXMuX2VtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTtcblx0XHR0aGlzLl9iYXNlU3RhdGUgPSB0aGlzLl9zdGF0ZTtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9FTlRJVFk7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5BdHRyaWJ1dGVWYWx1ZVNpbmdsZVF1b3RlcyA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIidcIil7XG5cdFx0dGhpcy5fZW1pdFRva2VuKFwib25hdHRyaWJkYXRhXCIpO1xuXHRcdHRoaXMuX2Nicy5vbmF0dHJpYmVuZCgpO1xuXHRcdHRoaXMuX3N0YXRlID0gQkVGT1JFX0FUVFJJQlVURV9OQU1FO1xuXHR9IGVsc2UgaWYodGhpcy5fZGVjb2RlRW50aXRpZXMgJiYgYyA9PT0gXCImXCIpe1xuXHRcdHRoaXMuX2VtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTtcblx0XHR0aGlzLl9iYXNlU3RhdGUgPSB0aGlzLl9zdGF0ZTtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9FTlRJVFk7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5BdHRyaWJ1dGVWYWx1ZU5vUXVvdGVzID0gZnVuY3Rpb24oYyl7XG5cdGlmKHdoaXRlc3BhY2UoYykgfHwgYyA9PT0gXCI+XCIpe1xuXHRcdHRoaXMuX2VtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTtcblx0XHR0aGlzLl9jYnMub25hdHRyaWJlbmQoKTtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9BVFRSSUJVVEVfTkFNRTtcblx0XHR0aGlzLl9pbmRleC0tO1xuXHR9IGVsc2UgaWYodGhpcy5fZGVjb2RlRW50aXRpZXMgJiYgYyA9PT0gXCImXCIpe1xuXHRcdHRoaXMuX2VtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTtcblx0XHR0aGlzLl9iYXNlU3RhdGUgPSB0aGlzLl9zdGF0ZTtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9FTlRJVFk7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlRGVjbGFyYXRpb24gPSBmdW5jdGlvbihjKXtcblx0dGhpcy5fc3RhdGUgPSBjID09PSBcIltcIiA/IEJFRk9SRV9DREFUQV8xIDpcblx0XHRcdFx0XHRjID09PSBcIi1cIiA/IEJFRk9SRV9DT01NRU5UIDpcblx0XHRcdFx0XHRcdElOX0RFQ0xBUkFUSU9OO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbkRlY2xhcmF0aW9uID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiPlwiKXtcblx0XHR0aGlzLl9jYnMub25kZWNsYXJhdGlvbih0aGlzLl9nZXRTZWN0aW9uKCkpO1xuXHRcdHRoaXMuX3N0YXRlID0gVEVYVDtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCI+XCIpe1xuXHRcdHRoaXMuX2Nicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbih0aGlzLl9nZXRTZWN0aW9uKCkpO1xuXHRcdHRoaXMuX3N0YXRlID0gVEVYVDtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlQ29tbWVudCA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIi1cIil7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9DT01NRU5UO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLl9zdGF0ZSA9IElOX0RFQ0xBUkFUSU9OO1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluQ29tbWVudCA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIi1cIikgdGhpcy5fc3RhdGUgPSBBRlRFUl9DT01NRU5UXzE7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyQ29tbWVudDEgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCItXCIpe1xuXHRcdHRoaXMuX3N0YXRlID0gQUZURVJfQ09NTUVOVF8yO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuX3N0YXRlID0gSU5fQ09NTUVOVDtcblx0fVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlckNvbW1lbnQyID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiPlwiKXtcblx0XHQvL3JlbW92ZSAyIHRyYWlsaW5nIGNoYXJzXG5cdFx0dGhpcy5fY2JzLm9uY29tbWVudCh0aGlzLl9idWZmZXIuc3Vic3RyaW5nKHRoaXMuX3NlY3Rpb25TdGFydCwgdGhpcy5faW5kZXggLSAyKSk7XG5cdFx0dGhpcy5fc3RhdGUgPSBURVhUO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcblx0fSBlbHNlIGlmKGMgIT09IFwiLVwiKXtcblx0XHR0aGlzLl9zdGF0ZSA9IElOX0NPTU1FTlQ7XG5cdH1cblx0Ly8gZWxzZTogc3RheSBpbiBBRlRFUl9DT01NRU5UXzIgKGAtLS0+YClcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlQ2RhdGExID0gaWZFbHNlU3RhdGUoXCJDXCIsIEJFRk9SRV9DREFUQV8yLCBJTl9ERUNMQVJBVElPTik7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUNkYXRhMiA9IGlmRWxzZVN0YXRlKFwiRFwiLCBCRUZPUkVfQ0RBVEFfMywgSU5fREVDTEFSQVRJT04pO1xuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVDZGF0YTMgPSBpZkVsc2VTdGF0ZShcIkFcIiwgQkVGT1JFX0NEQVRBXzQsIElOX0RFQ0xBUkFUSU9OKTtcblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlQ2RhdGE0ID0gaWZFbHNlU3RhdGUoXCJUXCIsIEJFRk9SRV9DREFUQV81LCBJTl9ERUNMQVJBVElPTik7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUNkYXRhNSA9IGlmRWxzZVN0YXRlKFwiQVwiLCBCRUZPUkVfQ0RBVEFfNiwgSU5fREVDTEFSQVRJT04pO1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUNkYXRhNiA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIltcIil7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9DREFUQTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9ERUNMQVJBVElPTjtcblx0XHR0aGlzLl9pbmRleC0tO1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluQ2RhdGEgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCJdXCIpIHRoaXMuX3N0YXRlID0gQUZURVJfQ0RBVEFfMTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJDZGF0YTEgPSBjaGFyYWN0ZXJTdGF0ZShcIl1cIiwgQUZURVJfQ0RBVEFfMik7XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJDZGF0YTIgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCI+XCIpe1xuXHRcdC8vcmVtb3ZlIDIgdHJhaWxpbmcgY2hhcnNcblx0XHR0aGlzLl9jYnMub25jZGF0YSh0aGlzLl9idWZmZXIuc3Vic3RyaW5nKHRoaXMuX3NlY3Rpb25TdGFydCwgdGhpcy5faW5kZXggLSAyKSk7XG5cdFx0dGhpcy5fc3RhdGUgPSBURVhUO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcblx0fSBlbHNlIGlmKGMgIT09IFwiXVwiKSB7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9DREFUQTtcblx0fVxuXHQvL2Vsc2U6IHN0YXkgaW4gQUZURVJfQ0RBVEFfMiAoYF1dXT5gKVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTcGVjaWFsID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiY1wiIHx8IGMgPT09IFwiQ1wiKXtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9TQ1JJUFRfMTtcblx0fSBlbHNlIGlmKGMgPT09IFwidFwiIHx8IGMgPT09IFwiVFwiKXtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9TVFlMRV8xO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuX3N0YXRlID0gSU5fVEFHX05BTUU7XG5cdFx0dGhpcy5faW5kZXgtLTsgLy9jb25zdW1lIHRoZSB0b2tlbiBhZ2FpblxuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZVNwZWNpYWxFbmQgPSBmdW5jdGlvbihjKXtcblx0aWYodGhpcy5fc3BlY2lhbCA9PT0gU1BFQ0lBTF9TQ1JJUFQgJiYgKGMgPT09IFwiY1wiIHx8IGMgPT09IFwiQ1wiKSl7XG5cdFx0dGhpcy5fc3RhdGUgPSBBRlRFUl9TQ1JJUFRfMTtcblx0fSBlbHNlIGlmKHRoaXMuX3NwZWNpYWwgPT09IFNQRUNJQUxfU1RZTEUgJiYgKGMgPT09IFwidFwiIHx8IGMgPT09IFwiVFwiKSl7XG5cdFx0dGhpcy5fc3RhdGUgPSBBRlRFUl9TVFlMRV8xO1xuXHR9XG5cdGVsc2UgdGhpcy5fc3RhdGUgPSBURVhUO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTY3JpcHQxID0gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIlJcIiwgQkVGT1JFX1NDUklQVF8yKTtcblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlU2NyaXB0MiA9IGNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJJXCIsIEJFRk9SRV9TQ1JJUFRfMyk7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZVNjcmlwdDMgPSBjb25zdW1lU3BlY2lhbE5hbWVDaGFyKFwiUFwiLCBCRUZPUkVfU0NSSVBUXzQpO1xuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTY3JpcHQ0ID0gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIlRcIiwgQkVGT1JFX1NDUklQVF81KTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTY3JpcHQ1ID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiL1wiIHx8IGMgPT09IFwiPlwiIHx8IHdoaXRlc3BhY2UoYykpe1xuXHRcdHRoaXMuX3NwZWNpYWwgPSBTUEVDSUFMX1NDUklQVDtcblx0fVxuXHR0aGlzLl9zdGF0ZSA9IElOX1RBR19OQU1FO1xuXHR0aGlzLl9pbmRleC0tOyAvL2NvbnN1bWUgdGhlIHRva2VuIGFnYWluXG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyU2NyaXB0MSA9IGlmRWxzZVN0YXRlKFwiUlwiLCBBRlRFUl9TQ1JJUFRfMiwgVEVYVCk7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyU2NyaXB0MiA9IGlmRWxzZVN0YXRlKFwiSVwiLCBBRlRFUl9TQ1JJUFRfMywgVEVYVCk7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyU2NyaXB0MyA9IGlmRWxzZVN0YXRlKFwiUFwiLCBBRlRFUl9TQ1JJUFRfNCwgVEVYVCk7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyU2NyaXB0NCA9IGlmRWxzZVN0YXRlKFwiVFwiLCBBRlRFUl9TQ1JJUFRfNSwgVEVYVCk7XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJTY3JpcHQ1ID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiPlwiIHx8IHdoaXRlc3BhY2UoYykpe1xuXHRcdHRoaXMuX3NwZWNpYWwgPSBTUEVDSUFMX05PTkU7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9DTE9TSU5HX1RBR19OQU1FO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4IC0gNjtcblx0XHR0aGlzLl9pbmRleC0tOyAvL3JlY29uc3VtZSB0aGUgdG9rZW5cblx0fVxuXHRlbHNlIHRoaXMuX3N0YXRlID0gVEVYVDtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlU3R5bGUxID0gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIllcIiwgQkVGT1JFX1NUWUxFXzIpO1xuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTdHlsZTIgPSBjb25zdW1lU3BlY2lhbE5hbWVDaGFyKFwiTFwiLCBCRUZPUkVfU1RZTEVfMyk7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZVN0eWxlMyA9IGNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJFXCIsIEJFRk9SRV9TVFlMRV80KTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTdHlsZTQgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCIvXCIgfHwgYyA9PT0gXCI+XCIgfHwgd2hpdGVzcGFjZShjKSl7XG5cdFx0dGhpcy5fc3BlY2lhbCA9IFNQRUNJQUxfU1RZTEU7XG5cdH1cblx0dGhpcy5fc3RhdGUgPSBJTl9UQUdfTkFNRTtcblx0dGhpcy5faW5kZXgtLTsgLy9jb25zdW1lIHRoZSB0b2tlbiBhZ2FpblxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlclN0eWxlMSA9IGlmRWxzZVN0YXRlKFwiWVwiLCBBRlRFUl9TVFlMRV8yLCBURVhUKTtcblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJTdHlsZTIgPSBpZkVsc2VTdGF0ZShcIkxcIiwgQUZURVJfU1RZTEVfMywgVEVYVCk7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyU3R5bGUzID0gaWZFbHNlU3RhdGUoXCJFXCIsIEFGVEVSX1NUWUxFXzQsIFRFWFQpO1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyU3R5bGU0ID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiPlwiIHx8IHdoaXRlc3BhY2UoYykpe1xuXHRcdHRoaXMuX3NwZWNpYWwgPSBTUEVDSUFMX05PTkU7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9DTE9TSU5HX1RBR19OQU1FO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4IC0gNTtcblx0XHR0aGlzLl9pbmRleC0tOyAvL3JlY29uc3VtZSB0aGUgdG9rZW5cblx0fVxuXHRlbHNlIHRoaXMuX3N0YXRlID0gVEVYVDtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlRW50aXR5ID0gaWZFbHNlU3RhdGUoXCIjXCIsIEJFRk9SRV9OVU1FUklDX0VOVElUWSwgSU5fTkFNRURfRU5USVRZKTtcblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlTnVtZXJpY0VudGl0eSA9IGlmRWxzZVN0YXRlKFwiWFwiLCBJTl9IRVhfRU5USVRZLCBJTl9OVU1FUklDX0VOVElUWSk7XG5cbi8vZm9yIGVudGl0aWVzIHRlcm1pbmF0ZWQgd2l0aCBhIHNlbWljb2xvblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcGFyc2VOYW1lZEVudGl0eVN0cmljdCA9IGZ1bmN0aW9uKCl7XG5cdC8vb2Zmc2V0ID0gMVxuXHRpZih0aGlzLl9zZWN0aW9uU3RhcnQgKyAxIDwgdGhpcy5faW5kZXgpe1xuXHRcdHZhciBlbnRpdHkgPSB0aGlzLl9idWZmZXIuc3Vic3RyaW5nKHRoaXMuX3NlY3Rpb25TdGFydCArIDEsIHRoaXMuX2luZGV4KSxcblx0XHQgICAgbWFwID0gdGhpcy5feG1sTW9kZSA/IHhtbE1hcCA6IGVudGl0eU1hcDtcblxuXHRcdGlmKG1hcC5oYXNPd25Qcm9wZXJ0eShlbnRpdHkpKXtcblx0XHRcdHRoaXMuX2VtaXRQYXJ0aWFsKG1hcFtlbnRpdHldKTtcblx0XHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcblx0XHR9XG5cdH1cbn07XG5cblxuLy9wYXJzZXMgbGVnYWN5IGVudGl0aWVzICh3aXRob3V0IHRyYWlsaW5nIHNlbWljb2xvbilcblRva2VuaXplci5wcm90b3R5cGUuX3BhcnNlTGVnYWN5RW50aXR5ID0gZnVuY3Rpb24oKXtcblx0dmFyIHN0YXJ0ID0gdGhpcy5fc2VjdGlvblN0YXJ0ICsgMSxcblx0ICAgIGxpbWl0ID0gdGhpcy5faW5kZXggLSBzdGFydDtcblxuXHRpZihsaW1pdCA+IDYpIGxpbWl0ID0gNjsgLy90aGUgbWF4IGxlbmd0aCBvZiBsZWdhY3kgZW50aXRpZXMgaXMgNlxuXG5cdHdoaWxlKGxpbWl0ID49IDIpeyAvL3RoZSBtaW4gbGVuZ3RoIG9mIGxlZ2FjeSBlbnRpdGllcyBpcyAyXG5cdFx0dmFyIGVudGl0eSA9IHRoaXMuX2J1ZmZlci5zdWJzdHIoc3RhcnQsIGxpbWl0KTtcblxuXHRcdGlmKGxlZ2FjeU1hcC5oYXNPd25Qcm9wZXJ0eShlbnRpdHkpKXtcblx0XHRcdHRoaXMuX2VtaXRQYXJ0aWFsKGxlZ2FjeU1hcFtlbnRpdHldKTtcblx0XHRcdHRoaXMuX3NlY3Rpb25TdGFydCArPSBsaW1pdCArIDE7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxpbWl0LS07XG5cdFx0fVxuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluTmFtZWRFbnRpdHkgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCI7XCIpe1xuXHRcdHRoaXMuX3BhcnNlTmFtZWRFbnRpdHlTdHJpY3QoKTtcblx0XHRpZih0aGlzLl9zZWN0aW9uU3RhcnQgKyAxIDwgdGhpcy5faW5kZXggJiYgIXRoaXMuX3htbE1vZGUpe1xuXHRcdFx0dGhpcy5fcGFyc2VMZWdhY3lFbnRpdHkoKTtcblx0XHR9XG5cdFx0dGhpcy5fc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cdH0gZWxzZSBpZigoYyA8IFwiYVwiIHx8IGMgPiBcInpcIikgJiYgKGMgPCBcIkFcIiB8fCBjID4gXCJaXCIpICYmIChjIDwgXCIwXCIgfHwgYyA+IFwiOVwiKSl7XG5cdFx0aWYodGhpcy5feG1sTW9kZSk7XG5cdFx0ZWxzZSBpZih0aGlzLl9zZWN0aW9uU3RhcnQgKyAxID09PSB0aGlzLl9pbmRleCk7XG5cdFx0ZWxzZSBpZih0aGlzLl9iYXNlU3RhdGUgIT09IFRFWFQpe1xuXHRcdFx0aWYoYyAhPT0gXCI9XCIpe1xuXHRcdFx0XHR0aGlzLl9wYXJzZU5hbWVkRW50aXR5U3RyaWN0KCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3BhcnNlTGVnYWN5RW50aXR5KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cdFx0dGhpcy5faW5kZXgtLTtcblx0fVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fZGVjb2RlTnVtZXJpY0VudGl0eSA9IGZ1bmN0aW9uKG9mZnNldCwgYmFzZSl7XG5cdHZhciBzZWN0aW9uU3RhcnQgPSB0aGlzLl9zZWN0aW9uU3RhcnQgKyBvZmZzZXQ7XG5cblx0aWYoc2VjdGlvblN0YXJ0ICE9PSB0aGlzLl9pbmRleCl7XG5cdFx0Ly9wYXJzZSBlbnRpdHlcblx0XHR2YXIgZW50aXR5ID0gdGhpcy5fYnVmZmVyLnN1YnN0cmluZyhzZWN0aW9uU3RhcnQsIHRoaXMuX2luZGV4KTtcblx0XHR2YXIgcGFyc2VkID0gcGFyc2VJbnQoZW50aXR5LCBiYXNlKTtcblxuXHRcdHRoaXMuX2VtaXRQYXJ0aWFsKGRlY29kZUNvZGVQb2ludChwYXJzZWQpKTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcblx0fSBlbHNlIHtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQtLTtcblx0fVxuXG5cdHRoaXMuX3N0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbk51bWVyaWNFbnRpdHkgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCI7XCIpe1xuXHRcdHRoaXMuX2RlY29kZU51bWVyaWNFbnRpdHkoMiwgMTApO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCsrO1xuXHR9IGVsc2UgaWYoYyA8IFwiMFwiIHx8IGMgPiBcIjlcIil7XG5cdFx0aWYoIXRoaXMuX3htbE1vZGUpe1xuXHRcdFx0dGhpcy5fZGVjb2RlTnVtZXJpY0VudGl0eSgyLCAxMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3N0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXHRcdH1cblx0XHR0aGlzLl9pbmRleC0tO1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluSGV4RW50aXR5ID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiO1wiKXtcblx0XHR0aGlzLl9kZWNvZGVOdW1lcmljRW50aXR5KDMsIDE2KTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQrKztcblx0fSBlbHNlIGlmKChjIDwgXCJhXCIgfHwgYyA+IFwiZlwiKSAmJiAoYyA8IFwiQVwiIHx8IGMgPiBcIkZcIikgJiYgKGMgPCBcIjBcIiB8fCBjID4gXCI5XCIpKXtcblx0XHRpZighdGhpcy5feG1sTW9kZSl7XG5cdFx0XHR0aGlzLl9kZWNvZGVOdW1lcmljRW50aXR5KDMsIDE2KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cdFx0fVxuXHRcdHRoaXMuX2luZGV4LS07XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbiAoKXtcblx0aWYodGhpcy5fc2VjdGlvblN0YXJ0IDwgMCl7XG5cdFx0dGhpcy5fYnVmZmVyID0gXCJcIjtcblx0XHR0aGlzLl9idWZmZXJPZmZzZXQgKz0gdGhpcy5faW5kZXg7XG5cdFx0dGhpcy5faW5kZXggPSAwO1xuXHR9IGVsc2UgaWYodGhpcy5fcnVubmluZyl7XG5cdFx0aWYodGhpcy5fc3RhdGUgPT09IFRFWFQpe1xuXHRcdFx0aWYodGhpcy5fc2VjdGlvblN0YXJ0ICE9PSB0aGlzLl9pbmRleCl7XG5cdFx0XHRcdHRoaXMuX2Nicy5vbnRleHQodGhpcy5fYnVmZmVyLnN1YnN0cih0aGlzLl9zZWN0aW9uU3RhcnQpKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2J1ZmZlciA9IFwiXCI7XG5cdFx0XHR0aGlzLl9idWZmZXJPZmZzZXQgKz0gdGhpcy5faW5kZXg7XG5cdFx0XHR0aGlzLl9pbmRleCA9IDA7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3NlY3Rpb25TdGFydCA9PT0gdGhpcy5faW5kZXgpe1xuXHRcdFx0Ly90aGUgc2VjdGlvbiBqdXN0IHN0YXJ0ZWRcblx0XHRcdHRoaXMuX2J1ZmZlciA9IFwiXCI7XG5cdFx0XHR0aGlzLl9idWZmZXJPZmZzZXQgKz0gdGhpcy5faW5kZXg7XG5cdFx0XHR0aGlzLl9pbmRleCA9IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vcmVtb3ZlIGV2ZXJ5dGhpbmcgdW5uZWNlc3Nhcnlcblx0XHRcdHRoaXMuX2J1ZmZlciA9IHRoaXMuX2J1ZmZlci5zdWJzdHIodGhpcy5fc2VjdGlvblN0YXJ0KTtcblx0XHRcdHRoaXMuX2luZGV4IC09IHRoaXMuX3NlY3Rpb25TdGFydDtcblx0XHRcdHRoaXMuX2J1ZmZlck9mZnNldCArPSB0aGlzLl9zZWN0aW9uU3RhcnQ7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gMDtcblx0fVxufTtcblxuLy9UT0RPIG1ha2UgZXZlbnRzIGNvbmRpdGlvbmFsXG5Ub2tlbml6ZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmspe1xuXHRpZih0aGlzLl9lbmRlZCkgdGhpcy5fY2JzLm9uZXJyb3IoRXJyb3IoXCIud3JpdGUoKSBhZnRlciBkb25lIVwiKSk7XG5cblx0dGhpcy5fYnVmZmVyICs9IGNodW5rO1xuXHR0aGlzLl9wYXJzZSgpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcGFyc2UgPSBmdW5jdGlvbigpe1xuXHR3aGlsZSh0aGlzLl9pbmRleCA8IHRoaXMuX2J1ZmZlci5sZW5ndGggJiYgdGhpcy5fcnVubmluZyl7XG5cdFx0dmFyIGMgPSB0aGlzLl9idWZmZXIuY2hhckF0KHRoaXMuX2luZGV4KTtcblx0XHRpZih0aGlzLl9zdGF0ZSA9PT0gVEVYVCkge1xuXHRcdFx0dGhpcy5fc3RhdGVUZXh0KGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX1RBR19OQU1FKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlVGFnTmFtZShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX1RBR19OQU1FKSB7XG5cdFx0XHR0aGlzLl9zdGF0ZUluVGFnTmFtZShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9DTE9TSU5HX1RBR19OQU1FKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlQ2xvc2VpbmdUYWdOYW1lKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gSU5fQ0xPU0lOR19UQUdfTkFNRSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUluQ2xvc2VpbmdUYWdOYW1lKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQUZURVJfQ0xPU0lOR19UQUdfTkFNRSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUFmdGVyQ2xvc2VpbmdUYWdOYW1lKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gSU5fU0VMRl9DTE9TSU5HX1RBRyl7XG5cdFx0XHR0aGlzLl9zdGF0ZUluU2VsZkNsb3NpbmdUYWcoYyk7XG5cdFx0fVxuXG5cdFx0Lypcblx0XHQqXHRhdHRyaWJ1dGVzXG5cdFx0Ki9cblx0XHRlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfQVRUUklCVVRFX05BTUUpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVBdHRyaWJ1dGVOYW1lKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gSU5fQVRUUklCVVRFX05BTUUpe1xuXHRcdFx0dGhpcy5fc3RhdGVJbkF0dHJpYnV0ZU5hbWUoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBBRlRFUl9BVFRSSUJVVEVfTkFNRSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUFmdGVyQXR0cmlidXRlTmFtZShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9BVFRSSUJVVEVfVkFMVUUpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVBdHRyaWJ1dGVWYWx1ZShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX0FUVFJJQlVURV9WQUxVRV9EUSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUluQXR0cmlidXRlVmFsdWVEb3VibGVRdW90ZXMoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBJTl9BVFRSSUJVVEVfVkFMVUVfU1Epe1xuXHRcdFx0dGhpcy5fc3RhdGVJbkF0dHJpYnV0ZVZhbHVlU2luZ2xlUXVvdGVzKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gSU5fQVRUUklCVVRFX1ZBTFVFX05RKXtcblx0XHRcdHRoaXMuX3N0YXRlSW5BdHRyaWJ1dGVWYWx1ZU5vUXVvdGVzKGMpO1xuXHRcdH1cblxuXHRcdC8qXG5cdFx0Klx0ZGVjbGFyYXRpb25zXG5cdFx0Ki9cblx0XHRlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfREVDTEFSQVRJT04pe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVEZWNsYXJhdGlvbihjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX0RFQ0xBUkFUSU9OKXtcblx0XHRcdHRoaXMuX3N0YXRlSW5EZWNsYXJhdGlvbihjKTtcblx0XHR9XG5cblx0XHQvKlxuXHRcdCpcdHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb25zXG5cdFx0Ki9cblx0XHRlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBJTl9QUk9DRVNTSU5HX0lOU1RSVUNUSU9OKXtcblx0XHRcdHRoaXMuX3N0YXRlSW5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oYyk7XG5cdFx0fVxuXG5cdFx0Lypcblx0XHQqXHRjb21tZW50c1xuXHRcdCovXG5cdFx0ZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX0NPTU1FTlQpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVDb21tZW50KGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gSU5fQ09NTUVOVCl7XG5cdFx0XHR0aGlzLl9zdGF0ZUluQ29tbWVudChjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEFGVEVSX0NPTU1FTlRfMSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUFmdGVyQ29tbWVudDEoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBBRlRFUl9DT01NRU5UXzIpe1xuXHRcdFx0dGhpcy5fc3RhdGVBZnRlckNvbW1lbnQyKGMpO1xuXHRcdH1cblxuXHRcdC8qXG5cdFx0Klx0Y2RhdGFcblx0XHQqL1xuXHRcdGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9DREFUQV8xKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlQ2RhdGExKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX0NEQVRBXzIpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVDZGF0YTIoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfQ0RBVEFfMyl7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZUNkYXRhMyhjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9DREFUQV80KXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlQ2RhdGE0KGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX0NEQVRBXzUpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVDZGF0YTUoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfQ0RBVEFfNil7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZUNkYXRhNihjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX0NEQVRBKXtcblx0XHRcdHRoaXMuX3N0YXRlSW5DZGF0YShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEFGVEVSX0NEQVRBXzEpe1xuXHRcdFx0dGhpcy5fc3RhdGVBZnRlckNkYXRhMShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEFGVEVSX0NEQVRBXzIpe1xuXHRcdFx0dGhpcy5fc3RhdGVBZnRlckNkYXRhMihjKTtcblx0XHR9XG5cblx0XHQvKlxuXHRcdCogc3BlY2lhbCB0YWdzXG5cdFx0Ki9cblx0XHRlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfU1BFQ0lBTCl7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZVNwZWNpYWwoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfU1BFQ0lBTF9FTkQpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVTcGVjaWFsRW5kKGMpO1xuXHRcdH1cblxuXHRcdC8qXG5cdFx0KiBzY3JpcHRcblx0XHQqL1xuXHRcdGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9TQ1JJUFRfMSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZVNjcmlwdDEoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfU0NSSVBUXzIpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVTY3JpcHQyKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX1NDUklQVF8zKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlU2NyaXB0MyhjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9TQ1JJUFRfNCl7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZVNjcmlwdDQoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfU0NSSVBUXzUpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVTY3JpcHQ1KGMpO1xuXHRcdH1cblxuXHRcdGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEFGVEVSX1NDUklQVF8xKXtcblx0XHRcdHRoaXMuX3N0YXRlQWZ0ZXJTY3JpcHQxKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQUZURVJfU0NSSVBUXzIpe1xuXHRcdFx0dGhpcy5fc3RhdGVBZnRlclNjcmlwdDIoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBBRlRFUl9TQ1JJUFRfMyl7XG5cdFx0XHR0aGlzLl9zdGF0ZUFmdGVyU2NyaXB0MyhjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEFGVEVSX1NDUklQVF80KXtcblx0XHRcdHRoaXMuX3N0YXRlQWZ0ZXJTY3JpcHQ0KGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQUZURVJfU0NSSVBUXzUpe1xuXHRcdFx0dGhpcy5fc3RhdGVBZnRlclNjcmlwdDUoYyk7XG5cdFx0fVxuXG5cdFx0Lypcblx0XHQqIHN0eWxlXG5cdFx0Ki9cblx0XHRlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfU1RZTEVfMSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZVN0eWxlMShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9TVFlMRV8yKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlU3R5bGUyKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX1NUWUxFXzMpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVTdHlsZTMoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfU1RZTEVfNCl7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZVN0eWxlNChjKTtcblx0XHR9XG5cblx0XHRlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBBRlRFUl9TVFlMRV8xKXtcblx0XHRcdHRoaXMuX3N0YXRlQWZ0ZXJTdHlsZTEoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBBRlRFUl9TVFlMRV8yKXtcblx0XHRcdHRoaXMuX3N0YXRlQWZ0ZXJTdHlsZTIoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBBRlRFUl9TVFlMRV8zKXtcblx0XHRcdHRoaXMuX3N0YXRlQWZ0ZXJTdHlsZTMoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBBRlRFUl9TVFlMRV80KXtcblx0XHRcdHRoaXMuX3N0YXRlQWZ0ZXJTdHlsZTQoYyk7XG5cdFx0fVxuXG5cdFx0Lypcblx0XHQqIGVudGl0aWVzXG5cdFx0Ki9cblx0XHRlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfRU5USVRZKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlRW50aXR5KGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX05VTUVSSUNfRU5USVRZKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlTnVtZXJpY0VudGl0eShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX05BTUVEX0VOVElUWSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUluTmFtZWRFbnRpdHkoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBJTl9OVU1FUklDX0VOVElUWSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUluTnVtZXJpY0VudGl0eShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX0hFWF9FTlRJVFkpe1xuXHRcdFx0dGhpcy5fc3RhdGVJbkhleEVudGl0eShjKTtcblx0XHR9XG5cblx0XHRlbHNlIHtcblx0XHRcdHRoaXMuX2Nicy5vbmVycm9yKEVycm9yKFwidW5rbm93biBfc3RhdGVcIiksIHRoaXMuX3N0YXRlKTtcblx0XHR9XG5cblx0XHR0aGlzLl9pbmRleCsrO1xuXHR9XG5cblx0dGhpcy5fY2xlYW51cCgpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCl7XG5cdHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbn07XG5Ub2tlbml6ZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCl7XG5cdHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXG5cdGlmKHRoaXMuX2luZGV4IDwgdGhpcy5fYnVmZmVyLmxlbmd0aCl7XG5cdFx0dGhpcy5fcGFyc2UoKTtcblx0fVxuXHRpZih0aGlzLl9lbmRlZCl7XG5cdFx0dGhpcy5fZmluaXNoKCk7XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmspe1xuXHRpZih0aGlzLl9lbmRlZCkgdGhpcy5fY2JzLm9uZXJyb3IoRXJyb3IoXCIuZW5kKCkgYWZ0ZXIgZG9uZSFcIikpO1xuXHRpZihjaHVuaykgdGhpcy53cml0ZShjaHVuayk7XG5cblx0dGhpcy5fZW5kZWQgPSB0cnVlO1xuXG5cdGlmKHRoaXMuX3J1bm5pbmcpIHRoaXMuX2ZpbmlzaCgpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fZmluaXNoID0gZnVuY3Rpb24oKXtcblx0Ly9pZiB0aGVyZSBpcyByZW1haW5pbmcgZGF0YSwgZW1pdCBpdCBpbiBhIHJlYXNvbmFibGUgd2F5XG5cdGlmKHRoaXMuX3NlY3Rpb25TdGFydCA8IHRoaXMuX2luZGV4KXtcblx0XHR0aGlzLl9oYW5kbGVUcmFpbGluZ0RhdGEoKTtcblx0fVxuXG5cdHRoaXMuX2Nicy5vbmVuZCgpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faGFuZGxlVHJhaWxpbmdEYXRhID0gZnVuY3Rpb24oKXtcblx0dmFyIGRhdGEgPSB0aGlzLl9idWZmZXIuc3Vic3RyKHRoaXMuX3NlY3Rpb25TdGFydCk7XG5cblx0aWYodGhpcy5fc3RhdGUgPT09IElOX0NEQVRBIHx8IHRoaXMuX3N0YXRlID09PSBBRlRFUl9DREFUQV8xIHx8IHRoaXMuX3N0YXRlID09PSBBRlRFUl9DREFUQV8yKXtcblx0XHR0aGlzLl9jYnMub25jZGF0YShkYXRhKTtcblx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBJTl9DT01NRU5UIHx8IHRoaXMuX3N0YXRlID09PSBBRlRFUl9DT01NRU5UXzEgfHwgdGhpcy5fc3RhdGUgPT09IEFGVEVSX0NPTU1FTlRfMil7XG5cdFx0dGhpcy5fY2JzLm9uY29tbWVudChkYXRhKTtcblx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBJTl9OQU1FRF9FTlRJVFkgJiYgIXRoaXMuX3htbE1vZGUpe1xuXHRcdHRoaXMuX3BhcnNlTGVnYWN5RW50aXR5KCk7XG5cdFx0aWYodGhpcy5fc2VjdGlvblN0YXJ0IDwgdGhpcy5faW5kZXgpe1xuXHRcdFx0dGhpcy5fc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cdFx0XHR0aGlzLl9oYW5kbGVUcmFpbGluZ0RhdGEoKTtcblx0XHR9XG5cdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gSU5fTlVNRVJJQ19FTlRJVFkgJiYgIXRoaXMuX3htbE1vZGUpe1xuXHRcdHRoaXMuX2RlY29kZU51bWVyaWNFbnRpdHkoMiwgMTApO1xuXHRcdGlmKHRoaXMuX3NlY3Rpb25TdGFydCA8IHRoaXMuX2luZGV4KXtcblx0XHRcdHRoaXMuX3N0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXHRcdFx0dGhpcy5faGFuZGxlVHJhaWxpbmdEYXRhKCk7XG5cdFx0fVxuXHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX0hFWF9FTlRJVFkgJiYgIXRoaXMuX3htbE1vZGUpe1xuXHRcdHRoaXMuX2RlY29kZU51bWVyaWNFbnRpdHkoMywgMTYpO1xuXHRcdGlmKHRoaXMuX3NlY3Rpb25TdGFydCA8IHRoaXMuX2luZGV4KXtcblx0XHRcdHRoaXMuX3N0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXHRcdFx0dGhpcy5faGFuZGxlVHJhaWxpbmdEYXRhKCk7XG5cdFx0fVxuXHR9IGVsc2UgaWYoXG5cdFx0dGhpcy5fc3RhdGUgIT09IElOX1RBR19OQU1FICYmXG5cdFx0dGhpcy5fc3RhdGUgIT09IEJFRk9SRV9BVFRSSUJVVEVfTkFNRSAmJlxuXHRcdHRoaXMuX3N0YXRlICE9PSBCRUZPUkVfQVRUUklCVVRFX1ZBTFVFICYmXG5cdFx0dGhpcy5fc3RhdGUgIT09IEFGVEVSX0FUVFJJQlVURV9OQU1FICYmXG5cdFx0dGhpcy5fc3RhdGUgIT09IElOX0FUVFJJQlVURV9OQU1FICYmXG5cdFx0dGhpcy5fc3RhdGUgIT09IElOX0FUVFJJQlVURV9WQUxVRV9TUSAmJlxuXHRcdHRoaXMuX3N0YXRlICE9PSBJTl9BVFRSSUJVVEVfVkFMVUVfRFEgJiZcblx0XHR0aGlzLl9zdGF0ZSAhPT0gSU5fQVRUUklCVVRFX1ZBTFVFX05RICYmXG5cdFx0dGhpcy5fc3RhdGUgIT09IElOX0NMT1NJTkdfVEFHX05BTUVcblx0KXtcblx0XHR0aGlzLl9jYnMub250ZXh0KGRhdGEpO1xuXHR9XG5cdC8vZWxzZSwgaWdub3JlIHJlbWFpbmluZyBkYXRhXG5cdC8vVE9ETyBhZGQgYSB3YXkgdG8gcmVtb3ZlIGN1cnJlbnQgdGFnXG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcblx0VG9rZW5pemVyLmNhbGwodGhpcywge3htbE1vZGU6IHRoaXMuX3htbE1vZGUsIGRlY29kZUVudGl0aWVzOiB0aGlzLl9kZWNvZGVFbnRpdGllc30sIHRoaXMuX2Nicyk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLmdldEFic29sdXRlSW5kZXggPSBmdW5jdGlvbigpe1xuXHRyZXR1cm4gdGhpcy5fYnVmZmVyT2Zmc2V0ICsgdGhpcy5faW5kZXg7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9nZXRTZWN0aW9uID0gZnVuY3Rpb24oKXtcblx0cmV0dXJuIHRoaXMuX2J1ZmZlci5zdWJzdHJpbmcodGhpcy5fc2VjdGlvblN0YXJ0LCB0aGlzLl9pbmRleCk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9lbWl0VG9rZW4gPSBmdW5jdGlvbihuYW1lKXtcblx0dGhpcy5fY2JzW25hbWVdKHRoaXMuX2dldFNlY3Rpb24oKSk7XG5cdHRoaXMuX3NlY3Rpb25TdGFydCA9IC0xO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fZW1pdFBhcnRpYWwgPSBmdW5jdGlvbih2YWx1ZSl7XG5cdGlmKHRoaXMuX2Jhc2VTdGF0ZSAhPT0gVEVYVCl7XG5cdFx0dGhpcy5fY2JzLm9uYXR0cmliZGF0YSh2YWx1ZSk7IC8vVE9ETyBpbXBsZW1lbnQgdGhlIG5ldyBldmVudFxuXHR9IGVsc2Uge1xuXHRcdHRoaXMuX2Nicy5vbnRleHQodmFsdWUpO1xuXHR9XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBQYXJzZXIgPSByZXF1aXJlKFwiLi9QYXJzZXIuanNcIiksXG4gICAgV3JpdGFibGVTdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtXCIpLldyaXRhYmxlIHx8IHJlcXVpcmUoXCJyZWFkYWJsZS1zdHJlYW1cIikuV3JpdGFibGUsXG4gICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoXCJzdHJpbmdfZGVjb2RlclwiKS5TdHJpbmdEZWNvZGVyLFxuICAgIEJ1ZmZlciA9IHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xuXG5mdW5jdGlvbiBTdHJlYW0oY2JzLCBvcHRpb25zKXtcblx0dmFyIHBhcnNlciA9IHRoaXMuX3BhcnNlciA9IG5ldyBQYXJzZXIoY2JzLCBvcHRpb25zKTtcblx0dmFyIGRlY29kZXIgPSB0aGlzLl9kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoKTtcblxuXHRXcml0YWJsZVN0cmVhbS5jYWxsKHRoaXMsIHtkZWNvZGVTdHJpbmdzOiBmYWxzZX0pO1xuXG5cdHRoaXMub25jZShcImZpbmlzaFwiLCBmdW5jdGlvbigpe1xuXHRcdHBhcnNlci5lbmQoZGVjb2Rlci5lbmQoKSk7XG5cdH0pO1xufVxuXG5yZXF1aXJlKFwiaW5oZXJpdHNcIikoU3RyZWFtLCBXcml0YWJsZVN0cmVhbSk7XG5cbldyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKXtcblx0aWYoY2h1bmsgaW5zdGFuY2VvZiBCdWZmZXIpIGNodW5rID0gdGhpcy5fZGVjb2Rlci53cml0ZShjaHVuayk7XG5cdHRoaXMuX3BhcnNlci53cml0ZShjaHVuayk7XG5cdGNiKCk7XG59OyIsInZhciBQYXJzZXIgPSByZXF1aXJlKFwiLi9QYXJzZXIuanNcIiksXG4gICAgRG9tSGFuZGxlciA9IHJlcXVpcmUoXCJkb21oYW5kbGVyXCIpO1xuXG5mdW5jdGlvbiBkZWZpbmVQcm9wKG5hbWUsIHZhbHVlKXtcblx0ZGVsZXRlIG1vZHVsZS5leHBvcnRzW25hbWVdO1xuXHRtb2R1bGUuZXhwb3J0c1tuYW1lXSA9IHZhbHVlO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRQYXJzZXI6IFBhcnNlcixcblx0VG9rZW5pemVyOiByZXF1aXJlKFwiLi9Ub2tlbml6ZXIuanNcIiksXG5cdEVsZW1lbnRUeXBlOiByZXF1aXJlKFwiZG9tZWxlbWVudHR5cGVcIiksXG5cdERvbUhhbmRsZXI6IERvbUhhbmRsZXIsXG5cdGdldCBGZWVkSGFuZGxlcigpe1xuXHRcdHJldHVybiBkZWZpbmVQcm9wKFwiRmVlZEhhbmRsZXJcIiwgcmVxdWlyZShcIi4vRmVlZEhhbmRsZXIuanNcIikpO1xuXHR9LFxuXHRnZXQgU3RyZWFtKCl7XG5cdFx0cmV0dXJuIGRlZmluZVByb3AoXCJTdHJlYW1cIiwgcmVxdWlyZShcIi4vU3RyZWFtLmpzXCIpKTtcblx0fSxcblx0Z2V0IFdyaXRhYmxlU3RyZWFtKCl7XG5cdFx0cmV0dXJuIGRlZmluZVByb3AoXCJXcml0YWJsZVN0cmVhbVwiLCByZXF1aXJlKFwiLi9Xcml0YWJsZVN0cmVhbS5qc1wiKSk7XG5cdH0sXG5cdGdldCBQcm94eUhhbmRsZXIoKXtcblx0XHRyZXR1cm4gZGVmaW5lUHJvcChcIlByb3h5SGFuZGxlclwiLCByZXF1aXJlKFwiLi9Qcm94eUhhbmRsZXIuanNcIikpO1xuXHR9LFxuXHRnZXQgRG9tVXRpbHMoKXtcblx0XHRyZXR1cm4gZGVmaW5lUHJvcChcIkRvbVV0aWxzXCIsIHJlcXVpcmUoXCJkb211dGlsc1wiKSk7XG5cdH0sXG5cdGdldCBDb2xsZWN0aW5nSGFuZGxlcigpe1xuXHRcdHJldHVybiBkZWZpbmVQcm9wKFwiQ29sbGVjdGluZ0hhbmRsZXJcIiwgcmVxdWlyZShcIi4vQ29sbGVjdGluZ0hhbmRsZXIuanNcIikpO1xuXHR9LFxuXHQvLyBGb3IgbGVnYWN5IHN1cHBvcnRcblx0RGVmYXVsdEhhbmRsZXI6IERvbUhhbmRsZXIsXG5cdGdldCBSc3NIYW5kbGVyKCl7XG5cdFx0cmV0dXJuIGRlZmluZVByb3AoXCJSc3NIYW5kbGVyXCIsIHRoaXMuRmVlZEhhbmRsZXIpO1xuXHR9LFxuXHQvL2hlbHBlciBtZXRob2RzXG5cdHBhcnNlRE9NOiBmdW5jdGlvbihkYXRhLCBvcHRpb25zKXtcblx0XHR2YXIgaGFuZGxlciA9IG5ldyBEb21IYW5kbGVyKG9wdGlvbnMpO1xuXHRcdG5ldyBQYXJzZXIoaGFuZGxlciwgb3B0aW9ucykuZW5kKGRhdGEpO1xuXHRcdHJldHVybiBoYW5kbGVyLmRvbTtcblx0fSxcblx0cGFyc2VGZWVkOiBmdW5jdGlvbihmZWVkLCBvcHRpb25zKXtcblx0XHR2YXIgaGFuZGxlciA9IG5ldyBtb2R1bGUuZXhwb3J0cy5GZWVkSGFuZGxlcihvcHRpb25zKTtcblx0XHRuZXcgUGFyc2VyKGhhbmRsZXIsIG9wdGlvbnMpLmVuZChmZWVkKTtcblx0XHRyZXR1cm4gaGFuZGxlci5kb207XG5cdH0sXG5cdGNyZWF0ZURvbVN0cmVhbTogZnVuY3Rpb24oY2IsIG9wdGlvbnMsIGVsZW1lbnRDYil7XG5cdFx0dmFyIGhhbmRsZXIgPSBuZXcgRG9tSGFuZGxlcihjYiwgb3B0aW9ucywgZWxlbWVudENiKTtcblx0XHRyZXR1cm4gbmV3IFBhcnNlcihoYW5kbGVyLCBvcHRpb25zKTtcblx0fSxcblx0Ly8gTGlzdCBvZiBhbGwgZXZlbnRzIHRoYXQgdGhlIHBhcnNlciBlbWl0c1xuXHRFVkVOVFM6IHsgLyogRm9ybWF0OiBldmVudG5hbWU6IG51bWJlciBvZiBhcmd1bWVudHMgKi9cblx0XHRhdHRyaWJ1dGU6IDIsXG5cdFx0Y2RhdGFzdGFydDogMCxcblx0XHRjZGF0YWVuZDogMCxcblx0XHR0ZXh0OiAxLFxuXHRcdHByb2Nlc3NpbmdpbnN0cnVjdGlvbjogMixcblx0XHRjb21tZW50OiAxLFxuXHRcdGNvbW1lbnRlbmQ6IDAsXG5cdFx0Y2xvc2V0YWc6IDEsXG5cdFx0b3BlbnRhZzogMixcblx0XHRvcGVudGFnbmFtZTogMSxcblx0XHRlcnJvcjogMSxcblx0XHRlbmQ6IDBcblx0fVxufTtcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIE10cmVlID0gcmVxdWlyZSgnMXRyZWUtZmFjdG9yeScpO1xuXG52YXIgY3JlYXRlVHJlZSA9IHJlcXVpcmUoJy4vcGx1Z2lucy9jcmVhdGVUcmVlJyk7XG52YXIgaW5zZXJ0QmVmb3JlID0gcmVxdWlyZSgnLi9wbHVnaW5zL2luc2VydEJlZm9yZScpO1xudmFyIGRvbSA9IHJlcXVpcmUoJy4vcGx1Z2lucy9kb20nKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4vcGx1Z2lucy9wYXJzZScpO1xudmFyIHNlbGVjdCA9IHJlcXVpcmUoJy4vcGx1Z2lucy9zZWxlY3QnKTtcbnZhciBzdHJpbmdpZnkgPSByZXF1aXJlKCcuL3BsdWdpbnMvc3RyaW5naWZ5Jyk7XG52YXIgdHlwZXMgPSByZXF1aXJlKCcuL3BsdWdpbnMvdHlwZXMnKTtcbnZhciB2ZG9tID0gcmVxdWlyZSgnLi9wbHVnaW5zL3Zkb20nKTtcblxudmFyIEh0cmVlID0gTXRyZWUoZG9tLCBwYXJzZSwgc2VsZWN0LCBzdHJpbmdpZnksIHR5cGVzLCB2ZG9tKTtcblxuLy8gYWRkIGFmdGVyd2FyZHMgYmVjYXVzZSB0aGUgb3JpZ2luYWwgY3JlYXRlVHJlZSBkb2Vzbid0IGV4aXN0IHVudGlsIG5vd1xuSHRyZWUucGx1Z2luKGNyZWF0ZVRyZWUpO1xuLy8gYWRkIGFmdGVyd2FyZHMgc28gdGhhdCBpdCB3cmFwcyBwYXJlbnRNYXAgYW5kIG5vdCB0aGUgb3RoZXIgd2F5IHJvdW5kXG5IdHJlZS5wbHVnaW4oaW5zZXJ0QmVmb3JlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBIdHJlZTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBFbnRpdHlOb2RlID0gcmVxdWlyZSgnbXR5cGUtbm9kZScpO1xuXG52YXIgRG9tSGFuZGxlciA9IGZ1bmN0aW9uIERvbUhhbmRsZXIob3B0aW9ucykge1xuICB2YXIgc3RhdGUgPSBTdGF0ZShvcHRpb25zKTtcblxuICB2YXIgaGFuZGxlciA9IHsgc3RhdGU6IHN0YXRlIH07XG5cbiAgdmFyIGFwaSA9IEFwaShoYW5kbGVyKTtcblxuICByZXR1cm4gYXBpO1xufTtcblxuLy9kZWZhdWx0IG9wdGlvbnNcbnZhciBkZWZhdWx0T3B0cyA9IHtcbiAgbm9ybWFsaXplV2hpdGVzcGFjZTogZmFsc2Vcbn07XG5cbnZhciB3aGl0ZXNwYWNlID0gL1xccysvZztcblxudmFyIFN0YXRlID0gZnVuY3Rpb24gU3RhdGUob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0T3B0cztcblxuICB2YXIgZG9tID0gRW50aXR5Tm9kZSgnZG9jdW1lbnRGcmFnbWVudCcpO1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB2YXIgdGFnU3RhY2sgPSBbXTtcbiAgdmFyIHBhcnNlciA9IG51bGw7XG5cbiAgdmFyIHN0YXRlID0ge1xuICAgIG9wdGlvbnM6IG9wdGlvbnMsIGRvbTogZG9tLCBkb25lOiBkb25lLCB0YWdTdGFjazogdGFnU3RhY2ssIHBhcnNlcjogcGFyc2VyXG4gIH07XG5cbiAgcmV0dXJuIHN0YXRlO1xufTtcblxudmFyIEFwaSA9IGZ1bmN0aW9uIEFwaShoYW5kbGVyKSB7XG4gIHZhciBvbmluaXQgPSBmdW5jdGlvbiBvbmluaXQocGFyc2VyKSB7XG4gICAgcmV0dXJuIGhhbmRsZXIuc3RhdGUucGFyc2VyID0gcGFyc2VyO1xuICB9O1xuXG4gIHZhciBvbnJlc2V0ID0gZnVuY3Rpb24gb25yZXNldCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGhhbmRsZXIuc3RhdGUub3B0aW9ucztcblxuXG4gICAgaGFuZGxlci5zdGF0ZSA9IFN0YXRlKG9wdGlvbnMpO1xuICB9O1xuXG4gIHZhciBvbmVuZCA9IGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChoYW5kbGVyLnN0YXRlLmRvbmUpIHJldHVybjtcblxuICAgIGhhbmRsZXIuc3RhdGUuZG9uZSA9IHRydWU7XG4gICAgaGFuZGxlci5zdGF0ZS5wYXJzZXIgPSBudWxsO1xuICAgIG9uZXJyb3IobnVsbCk7XG4gIH07XG5cbiAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgIGlmIChlcnIpIHRocm93IGVycjtcbiAgfTtcblxuICB2YXIgb25jbG9zZXRhZyA9IGZ1bmN0aW9uIG9uY2xvc2V0YWcoKSB7XG4gICAgdmFyIHRhZ1N0YWNrID0gaGFuZGxlci5zdGF0ZS50YWdTdGFjaztcblxuXG4gICAgdGFnU3RhY2sucG9wKCk7XG4gIH07XG5cbiAgdmFyIG9ub3BlbnRhZyA9IGZ1bmN0aW9uIG9ub3BlbnRhZyhuYW1lLCBhdHRyaWJzKSB7XG4gICAgdmFyIHRhZ1N0YWNrID0gaGFuZGxlci5zdGF0ZS50YWdTdGFjaztcblxuXG4gICAgdmFyIGVsZW1lbnQgPSBFbnRpdHlOb2RlKCdlbGVtZW50Jywge1xuICAgICAgdGFnTmFtZTogbmFtZSxcbiAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnNcbiAgICB9KTtcblxuICAgIGFkZERvbUVsZW1lbnQoaGFuZGxlciwgZWxlbWVudCk7XG4gICAgdGFnU3RhY2sucHVzaChlbGVtZW50KTtcbiAgfTtcblxuICB2YXIgb250ZXh0ID0gZnVuY3Rpb24gb250ZXh0KGRhdGEpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGhhbmRsZXIuc3RhdGUub3B0aW9ucztcblxuXG4gICAgdmFyIG5vcm1hbGl6ZSA9IG9wdGlvbnMubm9ybWFsaXplV2hpdGVzcGFjZSB8fCBvcHRpb25zLmlnbm9yZVdoaXRlc3BhY2UgPyBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2Uod2hpdGVzcGFjZSwgJyAnKTtcbiAgICB9IDogZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuXG4gICAgdmFyIHByZXZpb3VzVGV4dCA9IGZpbmRQcmV2aW91c1RleHQoaGFuZGxlcik7XG5cbiAgICBpZiAocHJldmlvdXNUZXh0KSB7XG4gICAgICBwcmV2aW91c1RleHQudmFsdWUubm9kZVZhbHVlID0gbm9ybWFsaXplKHByZXZpb3VzVGV4dC5ub2RlVmFsdWUgKyBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IG5vcm1hbGl6ZShkYXRhKTtcblxuICAgICAgdmFyIHRleHQgPSBFbnRpdHlOb2RlKCd0ZXh0JywgeyBub2RlVmFsdWU6IGRhdGEgfSk7XG5cbiAgICAgIGFkZERvbUVsZW1lbnQoaGFuZGxlciwgdGV4dCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBvbmNvbW1lbnQgPSBmdW5jdGlvbiBvbmNvbW1lbnQoZGF0YSkge1xuICAgIHZhciB0YWdTdGFjayA9IGhhbmRsZXIuc3RhdGUudGFnU3RhY2s7XG5cblxuICAgIHZhciBsYXN0VGFnID0gdGFnU3RhY2tbdGFnU3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICBpZiAobGFzdFRhZyAmJiBsYXN0VGFnLnZhbHVlLm5vZGVUeXBlID09PSAnY29tbWVudCcpIHtcbiAgICAgIGxhc3RUYWcudmFsdWUubm9kZVZhbHVlICs9IGRhdGE7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29tbWVudCA9IEVudGl0eU5vZGUoJ2NvbW1lbnQnLCB7IG5vZGVWYWx1ZTogZGF0YSB9KTtcblxuICAgIGFkZERvbUVsZW1lbnQoaGFuZGxlciwgY29tbWVudCk7XG4gICAgdGFnU3RhY2sucHVzaChjb21tZW50KTtcbiAgfTtcblxuICB2YXIgb25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbiBvbnByb2Nlc3NpbmdpbnN0cnVjdGlvbihuYW1lLCBkYXRhKSB7XG4gICAgb25jb21tZW50KGRhdGEpO1xuICAgIG9uY29tbWVudGVuZCgpO1xuICB9O1xuXG4gIHZhciBvbmNvbW1lbnRlbmQgPSBmdW5jdGlvbiBvbmNvbW1lbnRlbmQoKSB7XG4gICAgcmV0dXJuIGhhbmRsZXIuc3RhdGUudGFnU3RhY2sucG9wKCk7XG4gIH07XG5cbiAgdmFyIGdldERvbSA9IGZ1bmN0aW9uIGdldERvbSgpIHtcbiAgICByZXR1cm4gaGFuZGxlci5zdGF0ZS5kb207XG4gIH07XG5cbiAgdmFyIGFwaSA9IHtcbiAgICBvbmluaXQ6IG9uaW5pdCwgb25yZXNldDogb25yZXNldCwgb25lbmQ6IG9uZW5kLCBvbmVycm9yOiBvbmVycm9yLCBvbmNsb3NldGFnOiBvbmNsb3NldGFnLCBvbm9wZW50YWc6IG9ub3BlbnRhZywgb250ZXh0OiBvbnRleHQsIG9uY29tbWVudDogb25jb21tZW50LFxuICAgIG9uY29tbWVudGVuZDogb25jb21tZW50ZW5kLCBvbnByb2Nlc3NpbmdpbnN0cnVjdGlvbjogb25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24sIGdldERvbTogZ2V0RG9tXG4gIH07XG5cbiAgcmV0dXJuIGFwaTtcbn07XG5cbnZhciBmaW5kUHJldmlvdXNUZXh0ID0gZnVuY3Rpb24gZmluZFByZXZpb3VzVGV4dChoYW5kbGVyKSB7XG4gIHZhciBfaGFuZGxlciRzdGF0ZSA9IGhhbmRsZXIuc3RhdGUsXG4gICAgICB0YWdTdGFjayA9IF9oYW5kbGVyJHN0YXRlLnRhZ1N0YWNrLFxuICAgICAgZG9tID0gX2hhbmRsZXIkc3RhdGUuZG9tO1xuXG5cbiAgaWYgKHRhZ1N0YWNrLmxlbmd0aCkge1xuICAgIHZhciBsYXN0VGFnID0gdGFnU3RhY2tbdGFnU3RhY2subGVuZ3RoIC0gMV07XG4gICAgdmFyIF9jaGlsZHJlbiA9IGxhc3RUYWcuY2hpbGRyZW47XG5cbiAgICBpZiAoX2NoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIF9sYXN0Q2hpbGQgPSBfY2hpbGRyZW5bX2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAoX2xhc3RDaGlsZC52YWx1ZS5ub2RlVHlwZSA9PT0gJ3RleHQnKSByZXR1cm4gX2xhc3RDaGlsZDtcbiAgICB9XG4gIH1cblxuICB2YXIgY2hpbGRyZW4gPSBkb20uY2hpbGRyZW47XG5cbiAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSByZXR1cm47XG5cbiAgdmFyIGxhc3RDaGlsZCA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuXG4gIGlmIChsYXN0Q2hpbGQudmFsdWUubm9kZVR5cGUgPT09ICd0ZXh0JykgcmV0dXJuIGxhc3RDaGlsZDtcbn07XG5cbnZhciBhZGREb21FbGVtZW50ID0gZnVuY3Rpb24gYWRkRG9tRWxlbWVudChoYW5kbGVyLCBlbGVtZW50KSB7XG4gIHZhciBfaGFuZGxlciRzdGF0ZTIgPSBoYW5kbGVyLnN0YXRlLFxuICAgICAgdGFnU3RhY2sgPSBfaGFuZGxlciRzdGF0ZTIudGFnU3RhY2ssXG4gICAgICBkb20gPSBfaGFuZGxlciRzdGF0ZTIuZG9tO1xuXG5cbiAgdmFyIHBhcmVudCA9IHRhZ1N0YWNrW3RhZ1N0YWNrLmxlbmd0aCAtIDFdO1xuICB2YXIgdGFyZ2V0ID0gcGFyZW50ID8gcGFyZW50LmNoaWxkcmVuIDogZG9tLmNoaWxkcmVuO1xuXG4gIHRhcmdldC5wdXNoKGVsZW1lbnQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEb21IYW5kbGVyOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGh0bWxwYXJzZXIyID0gcmVxdWlyZSgnaHRtbHBhcnNlcjInKTtcbnZhciBEb21IYW5kbGVyID0gcmVxdWlyZSgnLi9kb21oYW5kbGVyLWFkYXB0ZXInKTtcblxudmFyIHBhcnNlID0gZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHZhciBoYW5kbGVyID0gRG9tSGFuZGxlcigpO1xuICBuZXcgaHRtbHBhcnNlcjIuUGFyc2VyKGhhbmRsZXIpLmVuZChzdHIpO1xuXG4gIHJldHVybiBoYW5kbGVyLmdldERvbSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZTsiLCIndXNlIHN0cmljdCc7XG5cbi8qXG4gIEV4dGVuZCBjcmVhdGVUcmVlIHRvIGFsbG93IGNyZWF0aW5nIGEgdHJlZSBmcm9tIGFuIEhUTUwgc3RyaW5nXG4qL1xuXG52YXIgcGFyc2VTdHIgPSByZXF1aXJlKCcuLi8uLi9wYXJzZScpO1xuXG4vLyBzaG91bGQgYmUgYWRkZWQgYWZ0ZXIgdGhlIGRlZmF1bHQgcGx1Z2lucyBzbyB0aGF0IGNyZWF0ZVRyZWUgZXhpc3RzIVxudmFyIGNyZWF0ZVRyZWVGcm9tU3RyID0gZnVuY3Rpb24gY3JlYXRlVHJlZUZyb21TdHIoZm4pIHtcbiAgLy8gb3ZlcnJpZGUgY3JlYXRlVHJlZSB0byBhbGxvdyBwYXNzaW5nIGEgc3RyaW5nXG4gIHZhciBvcmlnaW5hbENyZWF0ZVRyZWUgPSBmbi5jcmVhdGVUcmVlO1xuXG4gIHZhciBjcmVhdGVUcmVlID0gZnVuY3Rpb24gY3JlYXRlVHJlZShyb290VmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHJvb3RWYWx1ZSA9PT0gJ3N0cmluZycpIHJvb3RWYWx1ZSA9IHBhcnNlU3RyKHJvb3RWYWx1ZSk7XG5cbiAgICByZXR1cm4gb3JpZ2luYWxDcmVhdGVUcmVlKHJvb3RWYWx1ZSk7XG4gIH07XG5cbiAgY3JlYXRlVHJlZS5kZWYgPSBvcmlnaW5hbENyZWF0ZVRyZWUuZGVmO1xuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKGZuLCB7IGNyZWF0ZVRyZWU6IGNyZWF0ZVRyZWUgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVRyZWVGcm9tU3RyOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEVudGl0eU5vZGUgPSByZXF1aXJlKCdtdHlwZS1ub2RlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdtb2p1bGUtdXRpbHMnKTtcblxudmFyIGNhcGl0YWxpemVGaXJzdExldHRlciA9IHV0aWxzLmNhcGl0YWxpemVGaXJzdExldHRlcjtcblxuXG52YXIgbm9kZU1hcCA9IHtcbiAgZWxlbWVudDogZnVuY3Rpb24gZWxlbWVudCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFnTmFtZTogJ2RpdicsXG4gICAgICBhdHRyaWJ1dGVzOiB7fVxuICAgIH07XG4gIH0sXG4gIGNvbW1lbnQ6IGZ1bmN0aW9uIGNvbW1lbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGVWYWx1ZTogJycsXG4gICAgICBpc0VtcHR5OiB0cnVlXG4gICAgfTtcbiAgfSxcbiAgdGV4dDogZnVuY3Rpb24gdGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZVZhbHVlOiAnJyxcbiAgICAgIGlzRW1wdHk6IHRydWVcbiAgICB9O1xuICB9LFxuICBkb2N1bWVudFR5cGU6IGZ1bmN0aW9uIGRvY3VtZW50VHlwZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ2h0bWwnLFxuICAgICAgcHVibGljSWQ6ICcnLFxuICAgICAgc3lzdGVtSWQ6ICcnLFxuICAgICAgaXNFbXB0eTogdHJ1ZVxuICAgIH07XG4gIH1cbn07XG5cbnZhciBjcmVhdGVEb21Ob2RlID0gZnVuY3Rpb24gY3JlYXRlRG9tTm9kZShmbiwgbm9kZVR5cGUsIHZhbHVlKSB7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBub2RlVHlwZSBpbiBub2RlTWFwID8gbm9kZU1hcFtub2RlVHlwZV0oKSA6IHt9O1xuXG4gIHZhbHVlID0gT2JqZWN0LmFzc2lnbih7IG5vZGVUeXBlOiBub2RlVHlwZSB9LCBkZWZhdWx0VmFsdWUsIHZhbHVlIHx8IHt9KTtcblxuICB2YXIgZW50aXR5Tm9kZSA9IEVudGl0eU5vZGUobm9kZVR5cGUsIHZhbHVlKTtcblxuICB2YXIgbm9kZSA9IGZuLmNyZWF0ZU5vZGUoZW50aXR5Tm9kZS52YWx1ZSk7XG5cbiAgdmFyIGNhcE5vZGVUeXBlID0gY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKG5vZGVUeXBlKTtcbiAgdmFyIGFzc2VydE5hbWUgPSAnYXNzZXJ0JyArIGNhcE5vZGVUeXBlO1xuXG4gIGZuW2Fzc2VydE5hbWVdKG5vZGUpO1xuXG4gIHJldHVybiBub2RlO1xufTtcblxudmFyIGNyZWF0ZURvbU5vZGVEZWYgPSBmdW5jdGlvbiBjcmVhdGVEb21Ob2RlRGVmKG5vZGVUeXBlLCBhcmdUeXBlcykge1xuICByZXR1cm4ge1xuICAgIGFyZ1R5cGVzOiBhcmdUeXBlcyxcbiAgICByZXR1cm5UeXBlOiAnbm9kZScsXG4gICAgcmVxdWlyZXM6IFsnY3JlYXRlTm9kZScsICdhc3NlcnQnICsgY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKG5vZGVUeXBlKV0sXG4gICAgY2F0ZWdvcmllczogWydjcmVhdGUnLCAncGx1Z2luJ11cbiAgfTtcbn07XG5cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoZm4pIHtcbiAgdmFyIGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZ05hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCB7fTtcblxuICAgIHJldHVybiBjcmVhdGVEb21Ob2RlKGZuLCAnZWxlbWVudCcsIHsgdGFnTmFtZTogdGFnTmFtZSwgYXR0cmlidXRlczogYXR0cmlidXRlcyB9KTtcbiAgfTtcblxuICBjcmVhdGVFbGVtZW50LmRlZiA9IGNyZWF0ZURvbU5vZGVEZWYoJ2VsZW1lbnQnLCBbJ3N0cmluZycsICdvYmplY3QnXSk7XG5cbiAgdmFyIGNyZWF0ZUNvbW1lbnQgPSBmdW5jdGlvbiBjcmVhdGVDb21tZW50KG5vZGVWYWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGVEb21Ob2RlKGZuLCAnZWxlbWVudCcsIHsgbm9kZVZhbHVlOiBub2RlVmFsdWUgfSk7XG4gIH07XG5cbiAgY3JlYXRlQ29tbWVudC5kZWYgPSBjcmVhdGVEb21Ob2RlRGVmKCdjb21tZW50JywgWydzdHJpbmcnXSk7XG5cbiAgdmFyIGNyZWF0ZURvY3VtZW50ID0gZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURvbU5vZGUoZm4sICdkb2N1bWVudCcpO1xuICB9O1xuXG4gIGNyZWF0ZURvY3VtZW50LmRlZiA9IGNyZWF0ZURvbU5vZGVEZWYoJ2RvY3VtZW50JywgW10pO1xuXG4gIHZhciBjcmVhdGVEb2N1bWVudEZyYWdtZW50ID0gZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpIHtcbiAgICByZXR1cm4gY3JlYXRlRG9tTm9kZShmbiwgJ2RvY3VtZW50RnJhZ21lbnQnKTtcbiAgfTtcblxuICBjcmVhdGVEb2N1bWVudEZyYWdtZW50LmRlZiA9IGNyZWF0ZURvbU5vZGVEZWYoJ2RvY3VtZW50RnJhZ21lbnQnLCBbXSk7XG5cbiAgdmFyIGNyZWF0ZVRleHQgPSBmdW5jdGlvbiBjcmVhdGVUZXh0KG5vZGVWYWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGVEb21Ob2RlKGZuLCAndGV4dCcsIHtcbiAgICAgIG5vZGVWYWx1ZTogU3RyaW5nKG5vZGVWYWx1ZSlcbiAgICB9KTtcbiAgfTtcblxuICBjcmVhdGVUZXh0LmRlZiA9IGNyZWF0ZURvbU5vZGVEZWYoJ3RleHQnLCBbJ3N0cmluZyddKTtcblxuICB2YXIgY3JlYXRlRG9jdW1lbnRUeXBlID0gZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnRUeXBlKG5hbWUsIHB1YmxpY0lkLCBzeXN0ZW1JZCkge1xuICAgIHJldHVybiBjcmVhdGVEb21Ob2RlKGZuLCAnZG9jdW1lbnRUeXBlJywgeyBuYW1lOiBuYW1lLCBwdWJsaWNJZDogcHVibGljSWQsIHN5c3RlbUlkOiBzeXN0ZW1JZCB9KTtcbiAgfTtcblxuICBjcmVhdGVEb2N1bWVudFR5cGUuZGVmID0gY3JlYXRlRG9tTm9kZURlZignZG9jdW1lbnRUeXBlJywgWydzdHJpbmcnLCAnc3RyaW5nJywgJ3N0cmluZyddKTtcblxuICB2YXIgcGx1Z2lucyA9IHtcbiAgICBjcmVhdGVUZXh0OiBjcmVhdGVUZXh0LCBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50LCBjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LCBjcmVhdGVEb2N1bWVudDogY3JlYXRlRG9jdW1lbnQsXG4gICAgY3JlYXRlRG9jdW1lbnRGcmFnbWVudDogY3JlYXRlRG9jdW1lbnRGcmFnbWVudCwgY3JlYXRlRG9jdW1lbnRUeXBlOiBjcmVhdGVEb2N1bWVudFR5cGVcbiAgfTtcblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihmbiwgcGx1Z2lucyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnbW9qdWxlLXV0aWxzJyk7XG5cbnZhciBjbG9uZSA9IHV0aWxzLmNsb25lO1xuXG5cbnZhciBlbGVtZW50ID0gZnVuY3Rpb24gZWxlbWVudChmbikge1xuICB2YXIgYXR0cmlidXRlcyA9IGZ1bmN0aW9uIGF0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlTWFwKSB7XG4gICAgZm4uYXNzZXJ0RWxlbWVudChub2RlKTtcblxuICAgIHZhciBub2RlVmFsdWUgPSBmbi52YWx1ZShub2RlKTtcblxuICAgIGlmICgodHlwZW9mIGF0dHJpYnV0ZU1hcCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYXR0cmlidXRlTWFwKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVNYXApLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZVZhbHVlID0gYXR0cmlidXRlTWFwW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgICAgIGZuLmF0dHIobm9kZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGVWYWx1ZS5hdHRyaWJ1dGVzID09PSB1bmRlZmluZWQpIHJldHVybiB7fTtcblxuICAgIHJldHVybiBjbG9uZShub2RlVmFsdWUuYXR0cmlidXRlcyk7XG4gIH07XG5cbiAgYXR0cmlidXRlcy5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnbm9kZScsICdvYmplY3Q/J10sXG4gICAgcmV0dXJuVHlwZTogJ29iamVjdCcsXG4gICAgcmVxdWlyZXM6IFsndmFsdWUnLCAnYXNzZXJ0RWxlbWVudCcsICdhdHRyJ10sXG4gICAgY2F0ZWdvcmllczogWydkb20nLCAnYXR0cmlidXRlcycsICdwbHVnaW5zJ11cbiAgfTtcblxuICB2YXIgdGFnTmFtZSA9IGZ1bmN0aW9uIHRhZ05hbWUobm9kZSwgdmFsdWUpIHtcbiAgICBmbi5hc3NlcnRFbGVtZW50KG5vZGUpO1xuXG4gICAgdmFyIG5vZGVWYWx1ZSA9IGZuLnZhbHVlKG5vZGUpO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vZGVWYWx1ZS50YWdOYW1lID0gdmFsdWU7XG5cbiAgICAgIGZuLnZhbHVlKG5vZGUsIG5vZGVWYWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVWYWx1ZS50YWdOYW1lO1xuICB9O1xuXG4gIHRhZ05hbWUuZGVmID0ge1xuICAgIGFyZ1R5cGVzOiBbJ25vZGUnLCAnc3RyaW5nJ10sXG4gICAgcmV0dXJuVHlwZTogJ3N0cmluZycsXG4gICAgcmVxdWlyZXM6IFsndmFsdWUnLCAnYXNzZXJ0RWxlbWVudCddLFxuICAgIGNhdGVnb3JpZXM6IFsnZG9tJywgJ3RhZ05hbWUnLCAncGx1Z2lucyddXG4gIH07XG5cbiAgdmFyIGF0dHIgPSBmdW5jdGlvbiBhdHRyKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgZm4uYXNzZXJ0RWxlbWVudChub2RlKTtcblxuICAgIHZhciBub2RlVmFsdWUgPSBmbi52YWx1ZShub2RlKTtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAobm9kZVZhbHVlLmF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCkgbm9kZVZhbHVlLmF0dHJpYnV0ZXMgPSB7fTtcblxuICAgICAgbm9kZVZhbHVlLmF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICBmbi52YWx1ZShub2RlLCBub2RlVmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChfdHlwZW9mKG5vZGVWYWx1ZS5hdHRyaWJ1dGVzKSA9PT0gJ29iamVjdCcpIHJldHVybiBub2RlVmFsdWUuYXR0cmlidXRlc1tuYW1lXTtcbiAgfTtcblxuICBhdHRyLmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydub2RlJywgJ3N0cmluZycsICdzdHJpbmcnXSxcbiAgICByZXR1cm5UeXBlOiAnc3RyaW5nJyxcbiAgICByZXF1aXJlczogWyd2YWx1ZScsICdhc3NlcnRFbGVtZW50J10sXG4gICAgY2F0ZWdvcmllczogWydkb20nLCAnYXR0cicsICdwbHVnaW5zJ11cbiAgfTtcblxuICB2YXIgaGFzQXR0ciA9IGZ1bmN0aW9uIGhhc0F0dHIobm9kZSwgbmFtZSkge1xuICAgIGZuLmFzc2VydEVsZW1lbnQobm9kZSk7XG5cbiAgICByZXR1cm4gZm4uYXR0cihub2RlLCBuYW1lKSAhPT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIGhhc0F0dHIuZGVmID0ge1xuICAgIGFyZ1R5cGVzOiBbJ25vZGUnLCAnc3RyaW5nJ10sXG4gICAgcmV0dXJuVHlwZTogJ2Jvb2xlYW4nLFxuICAgIHJlcXVpcmVzOiBbJ3ZhbHVlJywgJ2Fzc2VydEVsZW1lbnQnXSxcbiAgICBjYXRlZ29yaWVzOiBbJ2RvbScsICdoYXNBdHRyJywgJ3BsdWdpbnMnXVxuICB9O1xuXG4gIHZhciByZW1vdmVBdHRyID0gZnVuY3Rpb24gcmVtb3ZlQXR0cihub2RlLCBuYW1lKSB7XG4gICAgZm4uYXNzZXJ0RWxlbWVudChub2RlKTtcblxuICAgIHZhciBub2RlVmFsdWUgPSBmbi52YWx1ZShub2RlKTtcblxuICAgIGlmIChfdHlwZW9mKG5vZGVWYWx1ZS5hdHRyaWJ1dGVzKSA9PT0gJ29iamVjdCcpIGRlbGV0ZSBub2RlVmFsdWUuYXR0cmlidXRlc1tuYW1lXTtcblxuICAgIGZuLnZhbHVlKG5vZGUsIG5vZGVWYWx1ZSk7XG4gIH07XG5cbiAgcmVtb3ZlQXR0ci5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnbm9kZScsICdzdHJpbmcnXSxcbiAgICByZXF1aXJlczogWyd2YWx1ZScsICdhc3NlcnRFbGVtZW50J10sXG4gICAgY2F0ZWdvcmllczogWydkb20nLCAncmVtb3ZlQXR0cicsICdwbHVnaW5zJ11cbiAgfTtcblxuICB2YXIgY2xlYXJBdHRycyA9IGZ1bmN0aW9uIGNsZWFyQXR0cnMobm9kZSkge1xuICAgIGZuLmFzc2VydEVsZW1lbnQobm9kZSk7XG5cbiAgICB2YXIgbm9kZVZhbHVlID0gZm4udmFsdWUobm9kZSk7XG5cbiAgICBub2RlVmFsdWUuYXR0cmlidXRlcyA9IHt9O1xuXG4gICAgZm4udmFsdWUobm9kZSwgbm9kZVZhbHVlKTtcbiAgfTtcblxuICBjbGVhckF0dHJzLmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydub2RlJ10sXG4gICAgcmVxdWlyZXM6IFsndmFsdWUnLCAnYXNzZXJ0RWxlbWVudCddLFxuICAgIGNhdGVnb3JpZXM6IFsnZG9tJywgJ2NsZWFyQXR0cnMnLCAncGx1Z2lucyddXG4gIH07XG5cbiAgdmFyIGNsZWFyQ2xhc3NlcyA9IGZ1bmN0aW9uIGNsZWFyQ2xhc3Nlcyhub2RlKSB7XG4gICAgZm4uYXNzZXJ0RWxlbWVudChub2RlKTtcblxuICAgIGZuLmF0dHIobm9kZSwgJ2NsYXNzJywgJycpO1xuICB9O1xuXG4gIGNsZWFyQ2xhc3Nlcy5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnbm9kZSddLFxuICAgIHJlcXVpcmVzOiBbJ3ZhbHVlJywgJ2Fzc2VydEVsZW1lbnQnXSxcbiAgICBjYXRlZ29yaWVzOiBbJ2RvbScsICdjbGVhckNsYXNzZXMnLCAncGx1Z2lucyddXG4gIH07XG5cbiAgdmFyIGNsYXNzTmFtZXMgPSBmdW5jdGlvbiBjbGFzc05hbWVzKG5vZGUpIHtcbiAgICBmbi5hc3NlcnRFbGVtZW50KG5vZGUpO1xuXG4gICAgdmFyIGNsYXNzTmFtZXMgPSBmbi5hdHRyKG5vZGUsICdjbGFzcycpO1xuXG4gICAgaWYgKHR5cGVvZiBjbGFzc05hbWVzID09PSAnc3RyaW5nJykgcmV0dXJuIGNsYXNzTmFtZXMuc3BsaXQoJyAnKTtcblxuICAgIHJldHVybiBbXTtcbiAgfTtcblxuICBjbGFzc05hbWVzLmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydub2RlJ10sXG4gICAgcmV0dXJuVHlwZTogJ1tzdHJpbmddJyxcbiAgICByZXF1aXJlczogWydhdHRyJywgJ2Fzc2VydEVsZW1lbnQnXSxcbiAgICBjYXRlZ29yaWVzOiBbJ2RvbScsICdjbGFzc05hbWVzJywgJ3BsdWdpbnMnXVxuICB9O1xuXG4gIHZhciBoYXNDbGFzcyA9IGZ1bmN0aW9uIGhhc0NsYXNzKG5vZGUsIGNsYXNzTmFtZSkge1xuICAgIGZuLmFzc2VydEVsZW1lbnQobm9kZSk7XG5cbiAgICByZXR1cm4gZm4uY2xhc3NOYW1lcyhub2RlKS5zb21lKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZSA9PT0gY2xhc3NOYW1lO1xuICAgIH0pO1xuICB9O1xuXG4gIGhhc0NsYXNzLmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydub2RlJywgJ3N0cmluZyddLFxuICAgIHJldHVyblR5cGU6ICdib29sZWFuJyxcbiAgICByZXF1aXJlczogWydjbGFzc05hbWVzJywgJ2Fzc2VydEVsZW1lbnQnXSxcbiAgICBjYXRlZ29yaWVzOiBbJ2RvbScsICdoYXNDbGFzcycsICdwbHVnaW5zJ11cbiAgfTtcblxuICB2YXIgYWRkQ2xhc3MgPSBmdW5jdGlvbiBhZGRDbGFzcyhub2RlLCBjbGFzc05hbWUpIHtcbiAgICBmbi5hc3NlcnRFbGVtZW50KG5vZGUpO1xuXG4gICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lLnRyaW0oKTtcblxuICAgIHZhciBleGlzdGluZyA9IGZuLmNsYXNzTmFtZXMobm9kZSk7XG5cbiAgICBleGlzdGluZy5wdXNoKGNsYXNzTmFtZSk7XG5cbiAgICBmbi5hdHRyKG5vZGUsICdjbGFzcycsIGV4aXN0aW5nLmpvaW4oJyAnKSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBhZGRDbGFzcy5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnbm9kZScsICdzdHJpbmcnXSxcbiAgICByZXR1cm5UeXBlOiAnbm9kZScsXG4gICAgcmVxdWlyZXM6IFsnY2xhc3NOYW1lcycsICdhdHRyJywgJ2Fzc2VydEVsZW1lbnQnXSxcbiAgICBjYXRlZ29yaWVzOiBbJ2RvbScsICdhZGRDbGFzcycsICdwbHVnaW5zJ11cbiAgfTtcblxuICB2YXIgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiByZW1vdmVDbGFzcyhub2RlLCBjbGFzc05hbWUpIHtcbiAgICBmbi5hc3NlcnRFbGVtZW50KG5vZGUpO1xuXG4gICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lLnRyaW0oKTtcblxuICAgIHZhciBleGlzdGluZyA9IGZuLmNsYXNzTmFtZXMobm9kZSkuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZSAhPT0gY2xhc3NOYW1lO1xuICAgIH0pO1xuXG4gICAgZm4uYXR0cihub2RlLCAnY2xhc3MnLCBleGlzdGluZy5qb2luKCcgJykpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgcmVtb3ZlQ2xhc3MuZGVmID0ge1xuICAgIGFyZ1R5cGVzOiBbJ25vZGUnLCAnc3RyaW5nJ10sXG4gICAgcmV0dXJuVHlwZTogJ25vZGUnLFxuICAgIHJlcXVpcmVzOiBbJ2NsYXNzTmFtZXMnLCAnYXR0cicsICdhc3NlcnRFbGVtZW50J10sXG4gICAgY2F0ZWdvcmllczogWydkb20nLCAncmVtb3ZlQ2xhc3MnLCAncGx1Z2lucyddXG4gIH07XG5cbiAgdmFyIHRvZ2dsZUNsYXNzID0gZnVuY3Rpb24gdG9nZ2xlQ2xhc3Mobm9kZSwgY2xhc3NOYW1lLCBzaG91bGRIYXZlKSB7XG4gICAgZm4uYXNzZXJ0RWxlbWVudChub2RlKTtcblxuICAgIHZhciBhbHJlYWR5SGFzID0gZm4uaGFzQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTtcblxuICAgIGlmICh0eXBlb2Ygc2hvdWxkSGF2ZSAhPT0gJ2Jvb2xlYW4nKSByZXR1cm4gZm4udG9nZ2xlQ2xhc3Mobm9kZSwgY2xhc3NOYW1lLCAhYWxyZWFkeUhhcyk7XG5cbiAgICBpZiAoYWxyZWFkeUhhcykge1xuICAgICAgaWYgKHNob3VsZEhhdmUpIHJldHVybiBub2RlO1xuXG4gICAgICByZXR1cm4gZm4ucmVtb3ZlQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkSGF2ZSkgcmV0dXJuIGZuLmFkZENsYXNzKG5vZGUsIGNsYXNzTmFtZSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICB0b2dnbGVDbGFzcy5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnbm9kZScsICdzdHJpbmcnLCAnYm9vbGVhbiddLFxuICAgIHJldHVyblR5cGU6ICdub2RlJyxcbiAgICByZXF1aXJlczogWydoYXNDbGFzcycsICdyZW1vdmVDbGFzcycsICdhZGRDbGFzcycsICdhc3NlcnRFbGVtZW50J10sXG4gICAgY2F0ZWdvcmllczogWydkb20nLCAndG9nZ2xlQ2xhc3MnLCAncGx1Z2lucyddXG4gIH07XG5cbiAgdmFyIHBsdWdpbnMgPSB7XG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlcywgYXR0cjogYXR0ciwgaGFzQXR0cjogaGFzQXR0ciwgcmVtb3ZlQXR0cjogcmVtb3ZlQXR0ciwgY2xhc3NOYW1lczogY2xhc3NOYW1lcywgaGFzQ2xhc3M6IGhhc0NsYXNzLCBhZGRDbGFzczogYWRkQ2xhc3MsXG4gICAgcmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLCB0b2dnbGVDbGFzczogdG9nZ2xlQ2xhc3MsIHRhZ05hbWU6IHRhZ05hbWUsIGNsZWFyQXR0cnM6IGNsZWFyQXR0cnMsIGNsZWFyQ2xhc3NlczogY2xlYXJDbGFzc2VzXG4gIH07XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZm4sIHBsdWdpbnMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVtZW50OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVsZW1lbnQgPSByZXF1aXJlKCcuL2VsZW1lbnQnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL2NyZWF0ZScpO1xudmFyIG5vZGUgPSByZXF1aXJlKCcuL25vZGUnKTtcblxudmFyIGRvbSA9IGZ1bmN0aW9uIGRvbShmbikge1xuICBlbGVtZW50KGZuKTtcbiAgY3JlYXRlKGZuKTtcbiAgbm9kZShmbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRvbTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBIdG1sID0gcmVxdWlyZSgnaHRtbC1ub2RlJyk7XG5cbnZhciBodG1sID0gSHRtbCgpO1xuXG52YXIgZW1wdHlOb2RlVHlwZXMgPSBbJ3RleHQnLCAnY29tbWVudCcsICdkb2N1bWVudFR5cGUnXTtcblxudmFyIG5vZGVOYW1lTWFwID0ge1xuICBlbGVtZW50OiBmdW5jdGlvbiBlbGVtZW50KGZuLCBub2RlKSB7XG4gICAgcmV0dXJuIGZuLnRhZ05hbWUobm9kZSk7XG4gIH0sXG4gIGRvY3VtZW50VHlwZTogZnVuY3Rpb24gZG9jdW1lbnRUeXBlKGZuLCBub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gZm4udmFsdWUobm9kZSk7XG5cbiAgICByZXR1cm4gdmFsdWUubmFtZTtcbiAgfVxufTtcblxudmFyIG5vZGVQbHVnaW5zID0gZnVuY3Rpb24gbm9kZVBsdWdpbnMoZm4pIHtcbiAgdmFyIG5vZGVUeXBlID0gZnVuY3Rpb24gbm9kZVR5cGUoZm4sIG5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSBmbi52YWx1ZShub2RlKTtcblxuICAgIHJldHVybiB2YWx1ZS5ub2RlVHlwZTtcbiAgfTtcblxuICBub2RlVHlwZS5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnZm4nLCAnbm9kZSddLFxuICAgIHJldHVyblR5cGU6ICdzdHJpbmcnLFxuICAgIHJlcXVpcmVzOiBbJ3ZhbHVlJ10sXG4gICAgY2F0ZWdvcmllczogWydub2RlJywgJ3BsdWdpbiddXG4gIH07XG5cbiAgdmFyIG5vZGVOYW1lID0gZnVuY3Rpb24gbm9kZU5hbWUoZm4sIG5vZGUpIHtcbiAgICB2YXIgbm9kZVR5cGUgPSBmbi5ub2RlVHlwZShmbiwgbm9kZSk7XG5cbiAgICBpZiAobm9kZVR5cGUgaW4gbm9kZU5hbWVNYXApIHJldHVybiBub2RlTmFtZU1hcFtub2RlVHlwZV0oZm4sIG5vZGUpO1xuXG4gICAgcmV0dXJuICcjJyArIG5vZGVUeXBlO1xuICB9O1xuXG4gIG5vZGVOYW1lLmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydmbicsICdub2RlJ10sXG4gICAgcmV0dXJuVHlwZTogJ3N0cmluZycsXG4gICAgcmVxdWlyZXM6IFsnbm9kZVR5cGUnXSxcbiAgICBjYXRlZ29yaWVzOiBbJ25vZGUnLCAncGx1Z2luJ11cbiAgfTtcblxuICB2YXIgaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkoZm4sIG5vZGUpIHtcbiAgICB2YXIgbm9kZVR5cGUgPSBmbi5ub2RlVHlwZShmbiwgbm9kZSk7XG5cbiAgICBpZiAoZW1wdHlOb2RlVHlwZXMuaW5jbHVkZXMobm9kZVR5cGUpKSByZXR1cm4gdHJ1ZTtcblxuICAgIGlmIChub2RlVHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgICB2YXIgdGFnTmFtZSA9IGZuLnRhZ05hbWUobm9kZSk7XG5cbiAgICAgIHJldHVybiBodG1sLmlzRW1wdHkodGFnTmFtZSk7XG4gICAgfVxuXG4gICAgLy8gYXNzdW1lcyByZW1haW5pbmcgbm9kZSB0eXBlcyBzaG91bGQgYmUgYWJsZSB0byBoYXZlIGNoaWxkcmVuLCBpcyB0aGlzIHRydWU/XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIGlzRW1wdHkuZGVmID0ge1xuICAgIGFyZ1R5cGU6IFsnZm4nLCAnbm9kZSddLFxuICAgIHJldHVyblR5cGU6ICdib29sZWFuJyxcbiAgICByZXF1aXJlOiBbJ25vZGVUeXBlJywgJ3RhZ05hbWUnXSxcbiAgICBjYXRlZ29yaWVzOiBbJ25vZGUnLCAncGx1Z2luJ11cbiAgfTtcblxuICB2YXIgYWNjZXB0cyA9IGZ1bmN0aW9uIGFjY2VwdHMoZm4sIG5vZGUsIGNoaWxkTm9kZSkge1xuICAgIHZhciBpc0VtcHR5ID0gZm4uaXNFbXB0eShmbiwgbm9kZSk7XG5cbiAgICBpZiAoaXNFbXB0eSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIG5vZGVUeXBlID0gZm4ubm9kZVR5cGUoZm4sIG5vZGUpO1xuICAgIHZhciBjaGlsZE5vZGVUeXBlID0gZm4ubm9kZVR5cGUoZm4sIGNoaWxkTm9kZSk7XG5cbiAgICBpZiAoY2hpbGROb2RlVHlwZSA9PT0gJ2RvY3VtZW50VHlwZScpIHJldHVybiBub2RlVHlwZSA9PT0gJ2RvY3VtZW50JztcblxuICAgIGlmIChub2RlVHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgICBpZiAoY2hpbGROb2RlVHlwZSA9PT0gJ3RleHQnIHx8IGNoaWxkTm9kZVR5cGUgPT09ICdjb21tZW50JykgcmV0dXJuIHRydWU7XG5cbiAgICAgIHZhciBfbm9kZU5hbWUgPSBmbi5ub2RlTmFtZShmbiwgbm9kZSk7XG4gICAgICB2YXIgY2hpbGROYW1lID0gZm4ubm9kZU5hbWUoZm4sIGNoaWxkTm9kZSk7XG5cbiAgICAgIHJldHVybiBodG1sLmFjY2VwdHMoX25vZGVOYW1lLCBjaGlsZE5hbWUpO1xuICAgIH1cblxuICAgIC8vIGFzc3VtZXMgbm9uLWVsZW1lbnRzIHRoYXQgY2FuIGhhdmUgY2hpbGQgbm9kZXMgY2FuIGhhdmUgYW55IGNoaWxkIG5vZGUsXG4gICAgLy8gaXMgdGhpcyB0cnVlP1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIGFjY2VwdHMuZGVmID0ge1xuICAgIGFyZ1R5cGU6IFsnZm4nLCAnbm9kZScsICdub2RlJ10sXG4gICAgcmV0dXJuVHlwZTogJ2Jvb2xlYW4nLFxuICAgIHJlcXVpcmU6IFsnaXNFbXB0eScsICdub2RlVHlwZScsICdub2RlTmFtZSddLFxuICAgIGNhdGVnb3JpZXM6IFsnbm9kZScsICdwbHVnaW4nXVxuICB9O1xuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKGZuLCB7IG5vZGVUeXBlOiBub2RlVHlwZSwgbm9kZU5hbWU6IG5vZGVOYW1lLCBpc0VtcHR5OiBpc0VtcHR5LCBhY2NlcHRzOiBhY2NlcHRzIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlUGx1Z2luczsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbnNlcnRCZWZvcmVXcmFwcGVyID0gZnVuY3Rpb24gaW5zZXJ0QmVmb3JlV3JhcHBlcihmbikge1xuICB2YXIgb3JpZ2luYWxJbnNlcnRCZWZvcmUgPSBmbi5pbnNlcnRCZWZvcmU7XG5cbiAgdmFyIGluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIGluc2VydEJlZm9yZShmbiwgcm9vdCwgcGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gICAgLy8gVE9ET1xuICAgIC8vIGhhbmRsZSBkb2N1bWVudCBmcmFnbWVudHNcbiAgICAvLyBoYW5kbGUgY29tYmluaW5nIHRleHQgZWxlbWVudHNcbiAgICByZXR1cm4gb3JpZ2luYWxJbnNlcnRCZWZvcmUoZm4sIHJvb3QsIHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gIH07XG5cbiAgaW5zZXJ0QmVmb3JlLmRlZiA9IG9yaWdpbmFsSW5zZXJ0QmVmb3JlLmRlZjtcblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihmbiwgeyBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0QmVmb3JlV3JhcHBlcjsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBwYXJzZVN0ciA9IHJlcXVpcmUoJy4uLy4uL3BhcnNlJyk7XG5cbnZhciBwYXJzZXIgPSBmdW5jdGlvbiBwYXJzZXIoZm4pIHtcbiAgdmFyIHBhcnNlID0gZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gICAgcmV0dXJuIGZuLmRlc2VyaWFsaXplKHBhcnNlU3RyKHN0cikpO1xuICB9O1xuXG4gIHBhcnNlLmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydzdHJpbmcnXSxcbiAgICByZXR1cm5UeXBlOiAnbm9kZScsXG4gICAgcmVxdWlyZXM6IFsnZGVzZXJpYWxpemUnXSxcbiAgICBjYXRlZ29yaWVzOiBbJ3BhcnNlcicsICdwbHVnaW4nXVxuICB9O1xuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKGZuLCB7IHBhcnNlOiBwYXJzZSB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VyOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJhc2VBZGFwdGVyID0gcmVxdWlyZSgnY3NzLXNlbGVjdC1iYXNlLWFkYXB0ZXInKTtcblxudmFyIEFkYXB0ZXIgPSBmdW5jdGlvbiBBZGFwdGVyKGZuLCByb290KSB7XG4gIHZhciBpc1RhZyA9IGZ1bmN0aW9uIGlzVGFnKG5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSBmbi52YWx1ZShub2RlKTtcblxuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gJ2VsZW1lbnQnO1xuICB9O1xuXG4gIHZhciBnZXRBdHRyaWJ1dGVWYWx1ZSA9IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZVZhbHVlKG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSBmbi52YWx1ZShub2RlKTtcblxuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5hdHRyaWJ1dGVzKSByZXR1cm4gdmFsdWUuYXR0cmlidXRlc1tuYW1lXTtcbiAgfTtcblxuICB2YXIgZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRDaGlsZHJlbihub2RlKSB7XG4gICAgcmV0dXJuIGZuLmdldENoaWxkcmVuKG5vZGUpO1xuICB9O1xuXG4gIHZhciBnZXROYW1lID0gZnVuY3Rpb24gZ2V0TmFtZShub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gZm4udmFsdWUobm9kZSk7XG5cbiAgICBpZiAodmFsdWUpIHJldHVybiB2YWx1ZS50YWdOYW1lO1xuICB9O1xuXG4gIHZhciBnZXRQYXJlbnQgPSBmdW5jdGlvbiBnZXRQYXJlbnQobm9kZSkge1xuICAgIHJldHVybiBmbi5nZXRQYXJlbnQoZm4sIHJvb3QsIG5vZGUpO1xuICB9O1xuXG4gIHZhciBnZXRUZXh0ID0gZnVuY3Rpb24gZ2V0VGV4dChub2RlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHJldHVybiBub2RlLm1hcChnZXRUZXh0KS5qb2luKCcnKTtcblxuICAgIGlmIChpc1RhZyhub2RlKSkgcmV0dXJuIGdldFRleHQoZ2V0Q2hpbGRyZW4obm9kZSkpO1xuXG4gICAgdmFyIHZhbHVlID0gZm4udmFsdWUobm9kZSk7XG5cbiAgICBpZiAodmFsdWUgJiYgdmFsdWUubm9kZVR5cGUgPT09ICd0ZXh0JykgcmV0dXJuIHZhbHVlLm5vZGVWYWx1ZTtcblxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICB2YXIgYWRhcHRlciA9IHtcbiAgICBpc1RhZzogaXNUYWcsIGdldEF0dHJpYnV0ZVZhbHVlOiBnZXRBdHRyaWJ1dGVWYWx1ZSwgZ2V0Q2hpbGRyZW46IGdldENoaWxkcmVuLCBnZXROYW1lOiBnZXROYW1lLCBnZXRQYXJlbnQ6IGdldFBhcmVudCwgZ2V0VGV4dDogZ2V0VGV4dFxuICB9O1xuXG4gIHJldHVybiBiYXNlQWRhcHRlcihhZGFwdGVyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWRhcHRlcjsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBBZGFwdGVyID0gcmVxdWlyZSgnLi9odG1scGFyc2VyMi1hZGFwdGVyJyk7XG52YXIgU2VsZWN0ID0gcmVxdWlyZSgnLi4vLi4vc2VsZWN0Jyk7XG5cbnZhciBTZWxlY3RlciA9IGZ1bmN0aW9uIFNlbGVjdGVyKGZuLCByb290KSB7XG4gIHJldHVybiBTZWxlY3QoQWRhcHRlcihmbiwgcm9vdCkpO1xufTtcblxudmFyIHF1ZXJ5U2VsZWN0b3IgPSBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yKGZuKSB7XG4gIHZhciBzZWxlY3QgPSBmdW5jdGlvbiBzZWxlY3QoZm4sIHJvb3QsIG5vZGUsIHF1ZXJ5KSB7XG4gICAgcmV0dXJuIFNlbGVjdGVyKGZuLCByb290KS5zZWxlY3Qobm9kZSwgcXVlcnkpO1xuICB9O1xuXG4gIHNlbGVjdC5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnZm4nLCAncm9vdE5vZGUnLCAnbm9kZScsICdzdHJpbmcnXSxcbiAgICByZXR1cm5UeXBlOiAnbm9kZScsXG4gICAgcmVxdWlyZXM6IFsndmFsdWUnLCAnZ2V0Q2hpbGRyZW4nLCAnZ2V0UGFyZW50J10sXG4gICAgY2F0ZWdvcmllczogWydxdWVyeScsICdzZWxlY3QnLCAncGx1Z2lucyddXG4gIH07XG5cbiAgdmFyIHNlbGVjdEFsbCA9IGZ1bmN0aW9uIHNlbGVjdEFsbChmbiwgcm9vdCwgbm9kZSwgcXVlcnkpIHtcbiAgICByZXR1cm4gU2VsZWN0ZXIoZm4sIHJvb3QpLnNlbGVjdEFsbChub2RlLCBxdWVyeSk7XG4gIH07XG5cbiAgc2VsZWN0QWxsLmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydmbicsICdyb290Tm9kZScsICdub2RlJywgJ3N0cmluZyddLFxuICAgIHJldHVyblR5cGU6ICdbbm9kZV0nLFxuICAgIHJlcXVpcmVzOiBbJ3ZhbHVlJywgJ2dldENoaWxkcmVuJywgJ2dldFBhcmVudCddLFxuICAgIGNhdGVnb3JpZXM6IFsncXVlcnknLCAnc2VsZWN0JywgJ3BsdWdpbnMnXVxuICB9O1xuXG4gIHZhciBtYXRjaGVzID0gZnVuY3Rpb24gbWF0Y2hlcyhmbiwgcm9vdCwgbm9kZSwgcXVlcnkpIHtcbiAgICByZXR1cm4gU2VsZWN0ZXIoZm4sIHJvb3QpLm1hdGNoZXMobm9kZSwgcXVlcnkpO1xuICB9O1xuXG4gIG1hdGNoZXMuZGVmID0ge1xuICAgIGFyZ1R5cGVzOiBbJ2ZuJywgJ3Jvb3ROb2RlJywgJ25vZGUnLCAnc3RyaW5nJ10sXG4gICAgcmV0dXJuVHlwZTogJ2Jvb2xlYW4nLFxuICAgIHJlcXVpcmVzOiBbJ3ZhbHVlJywgJ2dldENoaWxkcmVuJywgJ2dldFBhcmVudCddLFxuICAgIGNhdGVnb3JpZXM6IFsncXVlcnknLCAnc2VsZWN0JywgJ3BsdWdpbnMnXVxuICB9O1xuXG4gIHZhciBwbHVnaW4gPSB7IHNlbGVjdDogc2VsZWN0LCBzZWxlY3RBbGw6IHNlbGVjdEFsbCwgbWF0Y2hlczogbWF0Y2hlcyB9O1xuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKGZuLCBwbHVnaW4pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBxdWVyeVNlbGVjdG9yOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeU5vZGUgPSByZXF1aXJlKCcuLi8uLi9zdHJpbmdpZnknKTtcblxudmFyIHN0cmluZ2lmaWVyID0gZnVuY3Rpb24gc3RyaW5naWZpZXIoZm4pIHtcbiAgdmFyIHN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeShub2RlKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU5vZGUobm9kZSk7XG4gIH07XG5cbiAgc3RyaW5naWZ5LmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydub2RlJ10sXG4gICAgcmV0dXJuVHlwZTogJ3N0cmluZycsXG4gICAgcmVxdWlyZXM6IFtdLFxuICAgIGNhdGVnb3JpZXM6IFsnc3RyaW5naWZ5JywgJ3BsdWdpbiddXG4gIH07XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZm4sIHsgc3RyaW5naWZ5OiBzdHJpbmdpZnkgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ2lmaWVyOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZhbGlkYXRvciA9IHJlcXVpcmUoJ210eXBlLXR2NCcpO1xudmFyIHNjaGVtYSA9IHJlcXVpcmUoJy4uLy4uL3NjaGVtYScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnbW9qdWxlLXV0aWxzJyk7XG5cbnZhciBjYXBpdGFsaXplRmlyc3RMZXR0ZXIgPSB1dGlscy5jYXBpdGFsaXplRmlyc3RMZXR0ZXI7XG5cbi8vIGNvdWxkIGdldCB0aGlzIGZyb20gdGhlIG5hbWVzLCBidXQgYmV0dGVyIHRvIGJlIGV4cGxpY2l0XG5cbnZhciBub2RlVHlwZXMgPSBbJ3RleHQnLCAnZWxlbWVudCcsICdjb21tZW50JywgJ2RvY3VtZW50JywgJ2RvY3VtZW50VHlwZScsICdkb2N1bWVudEZyYWdtZW50J107XG5cbnZhciB2YWxpZGF0b3IgPSBWYWxpZGF0b3Ioc2NoZW1hKTtcbnZhciB0ID0gVmFsaWRhdG9yLm10eXBlKHZhbGlkYXRvcik7XG5cbnZhciBpc1R5cGUgPSBmdW5jdGlvbiBpc1R5cGUobm9kZSwgdHlwZW5hbWUpIHtcbiAgcmV0dXJuIHQuaXMobm9kZSwgdHlwZW5hbWUpO1xufTtcblxuaXNUeXBlLmRlZiA9IHtcbiAgYXJnVHlwZXM6IFsnbm9kZScsICdzdHJpbmcnXSxcbiAgcmV0dXJuVHlwZTogJ2Jvb2xlYW4nLFxuICByZXF1aXJlczogW10sXG4gIGNhdGVnb3JpZXM6IFsndHlwZScsICdwbHVnaW4nXVxufTtcblxudmFyIHR5cGVzID0gZnVuY3Rpb24gdHlwZXMoZm4pIHtcbiAgdmFyIGFzc2VydFR5cGUgPSBmdW5jdGlvbiBhc3NlcnRUeXBlKG5vZGUsIHR5cGVuYW1lKSB7XG4gICAgaWYgKCFmbi5pc1R5cGUobm9kZSwgdHlwZW5hbWUpKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdmFsaWRhdG9yLnZhbGlkYXRlTXVsdGlwbGUobm9kZSwgc2NoZW1hW3R5cGVuYW1lXSk7XG4gICAgICB2YXIgZXJyb3JzID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0LmVycm9ycyk7XG5cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIG5vZGUgdG8gYmUgJyArIHR5cGVuYW1lICsgJzsgJyArIGVycm9ycyk7XG4gICAgfVxuICB9O1xuXG4gIGFzc2VydFR5cGUuZGVmID0ge1xuICAgIGFyZ1R5cGVzOiBbJ25vZGUnLCAnc3RyaW5nJ10sXG4gICAgcmVxdWlyZXM6IFsnaXNUeXBlJ10sXG4gICAgY2F0ZWdvcmllczogWyd0eXBlJywgJ3BsdWdpbiddXG4gIH07XG5cbiAgdmFyIHBsdWdpbnMgPSB7IGlzVHlwZTogaXNUeXBlLCBhc3NlcnRUeXBlOiBhc3NlcnRUeXBlIH07XG5cbiAgLy8gYWRkIGlzRG9jdW1lbnQsIGlzVGV4dCBldGNcbiAgbm9kZVR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGVuYW1lKSB7XG4gICAgdmFyIGNhcFR5cGVuYW1lID0gY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHR5cGVuYW1lKTtcbiAgICB2YXIgaXNOYW1lID0gJ2lzJyArIGNhcFR5cGVuYW1lO1xuICAgIHZhciBhc3NlcnROYW1lID0gJ2Fzc2VydCcgKyBjYXBUeXBlbmFtZTtcblxuICAgIHBsdWdpbnNbaXNOYW1lXSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gZm4uaXNUeXBlKG5vZGUsIHR5cGVuYW1lKTtcbiAgICB9O1xuICAgIHBsdWdpbnNbaXNOYW1lXS5kZWYgPSBpc1R5cGUuZGVmO1xuXG4gICAgcGx1Z2luc1thc3NlcnROYW1lXSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gZm4uYXNzZXJ0VHlwZShub2RlLCB0eXBlbmFtZSk7XG4gICAgfTtcbiAgICBwbHVnaW5zW2Fzc2VydE5hbWVdLmRlZiA9IGFzc2VydFR5cGUuZGVmO1xuICB9KTtcblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihmbiwgcGx1Z2lucyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVzOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1vcnBoZG9tID0gcmVxdWlyZSgnbW9ycGhkb20nKTtcbnZhciBWbm9kZSA9IHJlcXVpcmUoJy4uLy4uL3Zkb20nKTtcblxudmFyIG1vcnBoZG9tUGx1Z2luID0gZnVuY3Rpb24gbW9ycGhkb21QbHVnaW4oZm4pIHtcbiAgdmFyIHBhdGNoRG9tID0gZnVuY3Rpb24gcGF0Y2hEb20obm9kZSwgdGFyZ2V0RWwsIG9wdGlvbnMpIHtcbiAgICAvL1Zub2RlIGV4cGVjdHMgd3JhcHBlZCBub2RlIVxuICAgIHZhciB3cmFwcGVkID0gZm4uY3JlYXRlVHJlZShub2RlKTtcbiAgICB2YXIgdmRvbSA9IFZub2RlKHdyYXBwZWQpO1xuXG4gICAgbW9ycGhkb20odGFyZ2V0RWwsIHZkb20sIG9wdGlvbnMpO1xuICB9O1xuXG4gIHBhdGNoRG9tLmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydub2RlJywgJ29iamVjdCcsICdvYmplY3QnXSxcbiAgICByZXF1aXJlczogWydjcmVhdGVUcmVlJ10sXG4gICAgY2F0ZWdvcmllczogWydwYXRjaCcsICdwbHVnaW4nXVxuICB9O1xuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKGZuLCB7IG1vcnBoZG9tOiBwYXRjaERvbSB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbW9ycGhkb21QbHVnaW47IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW50aXR5Tm9kZSA9IHJlcXVpcmUoJ210eXBlLW5vZGUvc2NoZW1hL2VudGl0eU5vZGUuc2NoZW1hLmpzb24nKTtcbnZhciBlbnRpdHlOb2RlVmFsdWUgPSByZXF1aXJlKCdtdHlwZS1ub2RlL3NjaGVtYS9lbnRpdHlOb2RlVmFsdWUuc2NoZW1hLmpzb24nKTtcbnZhciBlbXB0eU5vZGUgPSByZXF1aXJlKCdtdHlwZS1ub2RlL3NjaGVtYS9lbXB0eU5vZGUuc2NoZW1hLmpzb24nKTtcbnZhciBwYXJlbnROb2RlID0gcmVxdWlyZSgnbXR5cGUtbm9kZS9zY2hlbWEvcGFyZW50Tm9kZS5zY2hlbWEuanNvbicpO1xuXG52YXIgY29tbWVudCA9IHJlcXVpcmUoJy4uLy4uL3NjaGVtYS9jb21tZW50LnNjaGVtYS5qc29uJyk7XG52YXIgY29tbWVudFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vc2NoZW1hL2NvbW1lbnRWYWx1ZS5zY2hlbWEuanNvbicpO1xudmFyIGRvY3VtZW50RnJhZ21lbnQgPSByZXF1aXJlKCcuLi8uLi9zY2hlbWEvZG9jdW1lbnRGcmFnbWVudC5zY2hlbWEuanNvbicpO1xudmFyIGRvY3VtZW50RnJhZ21lbnRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3NjaGVtYS9kb2N1bWVudEZyYWdtZW50VmFsdWUuc2NoZW1hLmpzb24nKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4uLy4uL3NjaGVtYS9kb2N1bWVudC5zY2hlbWEuanNvbicpO1xudmFyIGRvY3VtZW50VmFsdWUgPSByZXF1aXJlKCcuLi8uLi9zY2hlbWEvZG9jdW1lbnRWYWx1ZS5zY2hlbWEuanNvbicpO1xudmFyIGRvY3VtZW50VHlwZSA9IHJlcXVpcmUoJy4uLy4uL3NjaGVtYS9kb2N1bWVudFR5cGUuanNvbicpO1xudmFyIGRvY3VtZW50VHlwZVZhbHVlID0gcmVxdWlyZSgnLi4vLi4vc2NoZW1hL2RvY3VtZW50VHlwZVZhbHVlLnNjaGVtYS5qc29uJyk7XG52YXIgZWxlbWVudCA9IHJlcXVpcmUoJy4uLy4uL3NjaGVtYS9lbGVtZW50LnNjaGVtYS5qc29uJyk7XG52YXIgZWxlbWVudFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vc2NoZW1hL2VsZW1lbnRWYWx1ZS5zY2hlbWEuanNvbicpO1xudmFyIHRleHQgPSByZXF1aXJlKCcuLi8uLi9zY2hlbWEvdGV4dC5zY2hlbWEuanNvbicpO1xudmFyIHRleHRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3NjaGVtYS90ZXh0VmFsdWUuc2NoZW1hLmpzb24nKTtcblxudmFyIHNjaGVtYSA9IHtcbiAgY29tbWVudDogY29tbWVudCwgY29tbWVudFZhbHVlOiBjb21tZW50VmFsdWUsIGRvY3VtZW50RnJhZ21lbnQ6IGRvY3VtZW50RnJhZ21lbnQsXG4gIGRvY3VtZW50RnJhZ21lbnRWYWx1ZTogZG9jdW1lbnRGcmFnbWVudFZhbHVlLCBkb2N1bWVudDogZG9jdW1lbnQsIGRvY3VtZW50VmFsdWU6IGRvY3VtZW50VmFsdWUsIGRvY3VtZW50VHlwZTogZG9jdW1lbnRUeXBlLFxuICBkb2N1bWVudFR5cGVWYWx1ZTogZG9jdW1lbnRUeXBlVmFsdWUsIGVsZW1lbnQ6IGVsZW1lbnQsIGVsZW1lbnRWYWx1ZTogZWxlbWVudFZhbHVlLCB0ZXh0OiB0ZXh0LCB0ZXh0VmFsdWU6IHRleHRWYWx1ZSxcblxuICBlbnRpdHlOb2RlOiBlbnRpdHlOb2RlLCBlbnRpdHlOb2RlVmFsdWU6IGVudGl0eU5vZGVWYWx1ZSwgZW1wdHlOb2RlOiBlbXB0eU5vZGUsIHBhcmVudE5vZGU6IHBhcmVudE5vZGVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc2NoZW1hOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIENTU3NlbGVjdCA9IHJlcXVpcmUoJ2Nzcy1zZWxlY3QnKTtcblxudmFyIFNlbGVjdCA9IGZ1bmN0aW9uIFNlbGVjdChhZGFwdGVyKSB7XG4gIHZhciBvcHRpb25zID0geyBhZGFwdGVyOiBhZGFwdGVyIH07XG5cbiAgdmFyIHNlbGVjdCA9IGZ1bmN0aW9uIHNlbGVjdChub2RlLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBDU1NzZWxlY3Quc2VsZWN0T25lKHNlbGVjdG9yLCBub2RlLCBvcHRpb25zKTtcbiAgfTtcblxuICB2YXIgc2VsZWN0QWxsID0gZnVuY3Rpb24gc2VsZWN0QWxsKG5vZGUsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIENTU3NlbGVjdChzZWxlY3Rvciwgbm9kZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgdmFyIG1hdGNoZXMgPSBmdW5jdGlvbiBtYXRjaGVzKG5vZGUsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIENTU3NlbGVjdC5pcyhub2RlLCBzZWxlY3Rvciwgb3B0aW9ucyk7XG4gIH07XG5cbiAgdmFyIGFwaSA9IHtcbiAgICBzZWxlY3Q6IHNlbGVjdCwgc2VsZWN0QWxsOiBzZWxlY3RBbGwsIG1hdGNoZXM6IG1hdGNoZXNcbiAgfTtcblxuICByZXR1cm4gYXBpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3Q7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgSHRtbCA9IHJlcXVpcmUoJ2h0bWwtbm9kZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnbW9qdWxlLXV0aWxzJyk7XG5cbnZhciBlc2NhcGVIdG1sID0gdXRpbHMuZXNjYXBlSHRtbDtcblxuXG52YXIgaW5mbyA9IEh0bWwoKTtcblxudmFyIHN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeShub2RlKSB7XG4gIHZhciBkZXB0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblxuICB2YXIgaHRtbCA9ICcnO1xuXG4gIHZhciBub2RlVHlwZSA9IG5vZGUudmFsdWUubm9kZVR5cGU7XG5cblxuICBpZiAobm9kZVR5cGUgPT09ICd0ZXh0JykgaHRtbCArPSBlc2NhcGVIdG1sKG5vZGUudmFsdWUubm9kZVZhbHVlKTtcblxuICBpZiAobm9kZVR5cGUgPT09ICdjb21tZW50JykgaHRtbCArPSAnPCEtLScgKyBub2RlLnZhbHVlLm5vZGVWYWx1ZSArICctLT4nO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbm9kZSR2YWx1ZSA9IG5vZGUudmFsdWUsXG4gICAgICAgICAgdGFnTmFtZSA9IF9ub2RlJHZhbHVlLnRhZ05hbWUsXG4gICAgICAgICAgYXR0cmlidXRlcyA9IF9ub2RlJHZhbHVlLmF0dHJpYnV0ZXM7XG5cblxuICAgICAgaHRtbCArPSAnPCcgKyB0YWdOYW1lO1xuXG4gICAgICBpZiAoYXR0cmlidXRlcykgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICAgIGh0bWwgKz0gJyAnICsgbmFtZTtcblxuICAgICAgICBpZiAodmFsdWUpIGh0bWwgKz0gJz1cIicgKyB2YWx1ZSArICdcIic7XG4gICAgICB9KTtcblxuICAgICAgaHRtbCArPSBpbmZvLmlzRW1wdHkodGFnTmFtZSkgPyAnIC8+JyA6ICc+JztcblxuICAgICAgZGVwdGgrKztcbiAgICB9KSgpO1xuICB9XG5cbiAgaWYgKG5vZGVUeXBlID09PSAnZG9jdW1lbnRUeXBlJykge1xuICAgIHZhciBfbm9kZSR2YWx1ZTIgPSBub2RlLnZhbHVlLFxuICAgICAgICBuYW1lID0gX25vZGUkdmFsdWUyLm5hbWUsXG4gICAgICAgIHB1YmxpY0lkID0gX25vZGUkdmFsdWUyLnB1YmxpY0lkLFxuICAgICAgICBzeXN0ZW1JZCA9IF9ub2RlJHZhbHVlMi5zeXN0ZW1JZDtcblxuXG4gICAgaHRtbCArPSAnPCFkb2N0eXBlICcgKyBuYW1lO1xuXG4gICAgaWYgKHB1YmxpY0lkKSB7XG4gICAgICBodG1sICs9ICcgcHVibGljIFwiJyArIHB1YmxpY0lkICsgJ1wiJztcbiAgICB9XG5cbiAgICBpZiAoc3lzdGVtSWQpIHtcbiAgICAgIGh0bWwgKz0gJyBcIicgKyBzeXN0ZW1JZCArICdcIic7XG4gICAgfVxuXG4gICAgaHRtbCArPSAnPic7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlLmNoaWxkcmVuKSkgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBodG1sICs9IHN0cmluZ2lmeShjaGlsZCwgZGVwdGgpO1xuICB9KTtcblxuICBpZiAobm9kZVR5cGUgPT09ICdlbGVtZW50JyAmJiAhaW5mby5pc0VtcHR5KG5vZGUudmFsdWUudGFnTmFtZSkpIHtcbiAgICBodG1sICs9ICc8LycgKyBub2RlLnZhbHVlLnRhZ05hbWUgKyAnPic7XG4gIH1cblxuICByZXR1cm4gaHRtbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5naWZ5OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZub2RlID0gZnVuY3Rpb24gVm5vZGUobm9kZSkge1xuICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHZhciB2bm9kZSA9IHtcbiAgICBnZXQgZmlyc3RDaGlsZCgpIHtcbiAgICAgIHJldHVybiBWbm9kZShub2RlLmZpcnN0Q2hpbGQoKSk7XG4gICAgfSxcblxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgIHJldHVybiBWbm9kZShub2RlLm5leHRTaWJsaW5nKCkpO1xuICAgIH0sXG5cbiAgICBnZXQgbm9kZVR5cGUoKSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSgpO1xuICAgIH0sXG5cbiAgICBnZXQgbm9kZU5hbWUoKSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlTmFtZSgpO1xuICAgIH0sXG5cbiAgICAvLyBzaG91bGQgYmUgc29tZXRoaW5nIGZvciBzdmcgb3IgbWF0aCBldGMuIVxuICAgIGdldCBuYW1lc3BhY2VVUkkoKSB7XG4gICAgICByZXR1cm4gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuICAgIH0sXG5cbiAgICBnZXQgbm9kZVZhbHVlKCkge1xuICAgICAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZSgpO1xuXG4gICAgICByZXR1cm4gdmFsdWUubm9kZVZhbHVlIHx8ICcnO1xuICAgIH0sXG5cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBub2RlLnZhbHVlKCk7XG5cbiAgICAgIHJldHVybiB2YWx1ZS52YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZSgpO1xuXG4gICAgICByZXR1cm4gISF2YWx1ZS5zZWxlY3RlZDtcbiAgICB9LFxuXG4gICAgZ2V0IGRpc2FibGVkKCkge1xuICAgICAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZSgpO1xuXG4gICAgICByZXR1cm4gISF2YWx1ZS5kaXNhYmxlZDtcbiAgICB9LFxuXG4gICAgLy8gc2hvdWxkIGJlIHNvbWV0aGluZyBmb3Igc3ZnIG9yIG1hdGggZXRjLiFcbiAgICAvLyBoYXNBdHRyaWJ1dGVOUzogKCBuYW1lc3BhY2VVUkksIG5hbWUgKSA9PiB7XG4gICAgaGFzQXR0cmlidXRlTlM6IGZ1bmN0aW9uIGhhc0F0dHJpYnV0ZU5TKG5hbWVzcGFjZVVSSSkge1xuICAgICAgcmV0dXJuIG5hbWVzcGFjZVVSSSA9PT0gdm5vZGUubmFtZXNwYWNlVVJJO1xuICAgIH0sXG5cbiAgICBhc3NpZ25BdHRyaWJ1dGVzOiBmdW5jdGlvbiBhc3NpZ25BdHRyaWJ1dGVzKHRhcmdldE5vZGUpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzKCk7XG5cbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldE5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJpYnV0ZXNbbmFtZV0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFjdHVhbGl6ZTogZnVuY3Rpb24gYWN0dWFsaXplKGRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gX2FjdHVhbGl6ZVt2bm9kZS5ub2RlVHlwZV0oZG9jdW1lbnQsIHZub2RlKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHZub2RlO1xufTtcblxudmFyIGFkZENoaWxkcmVuID0gZnVuY3Rpb24gYWRkQ2hpbGRyZW4oZG9jdW1lbnQsIGVsLCB2bm9kZSkge1xuICB2YXIgY2hpbGQgPSB2bm9kZS5maXJzdENoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCkge1xuICAgIGVsLmFwcGVuZENoaWxkKGNoaWxkLmFjdHVhbGl6ZShkb2N1bWVudCkpO1xuICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gIH1cbn07XG5cbnZhciBfYWN0dWFsaXplID0ge1xuICB0ZXh0OiBmdW5jdGlvbiB0ZXh0KGRvY3VtZW50LCB2bm9kZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2bm9kZS5ub2RlVmFsdWUpO1xuICB9LFxuICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50KGRvY3VtZW50LCB2bm9kZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHZub2RlLm5vZGVWYWx1ZSk7XG4gIH0sXG4gIGVsZW1lbnQ6IGZ1bmN0aW9uIGVsZW1lbnQoZG9jdW1lbnQsIHZub2RlKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh2bm9kZS5ub2RlTmFtZSk7XG5cbiAgICB2bm9kZS5hc3NpZ25BdHRyaWJ1dGVzKGVsKTtcblxuICAgIGFkZENoaWxkcmVuKGRvY3VtZW50LCBlbCwgdm5vZGUpO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9LFxuICBkb2N1bWVudEZyYWdtZW50OiBmdW5jdGlvbiBkb2N1bWVudEZyYWdtZW50KGRvY3VtZW50LCB2bm9kZSkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIGFkZENoaWxkcmVuKGRvY3VtZW50LCBlbCwgdm5vZGUpO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZub2RlOyIsIm1vZHVsZS5leHBvcnRzPXtcclxuICBcImlkXCI6IFwiY29tbWVudFwiLFxyXG4gIFwiYWxsT2ZcIjogW1xyXG4gICAgeyBcIiRyZWZcIjogXCJlbXB0eU5vZGVcIiB9LFxyXG4gICAge1xyXG4gICAgICBcInByb3BlcnRpZXNcIjoge1xyXG4gICAgICAgIFwidmFsdWVcIjogeyBcIiRyZWZcIjogXCJjb21tZW50VmFsdWVcIiB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBdXHJcbn1cclxuIiwibW9kdWxlLmV4cG9ydHM9e1xyXG4gIFwiaWRcIjogXCJjb21tZW50VmFsdWVcIixcclxuICBcImFsbE9mXCI6ICBbXHJcbiAgICB7IFwiJHJlZlwiOiBcImVudGl0eU5vZGVWYWx1ZVwiIH0sXHJcbiAgICB7XHJcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XHJcbiAgICAgICAgXCJub2RlVHlwZVwiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgICAgIFwiZW51bVwiOiBbIFwiY29tbWVudFwiIF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwibm9kZVZhbHVlXCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfVxyXG4gICAgICB9LFxyXG4gICAgICBcInJlcXVpcmVkXCI6IFsgXCJub2RlVHlwZVwiLCBcIm5vZGVWYWx1ZVwiIF1cclxuICAgIH1cclxuICBdXHJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XHJcbiAgXCJpZFwiOiBcImRvY3VtZW50XCIsXHJcbiAgXCJhbGxPZlwiOiBbXHJcbiAgICB7IFwiJHJlZlwiOiBcInBhcmVudE5vZGVcIiB9LFxyXG4gICAge1xyXG4gICAgICBcInByb3BlcnRpZXNcIjoge1xyXG4gICAgICAgIFwidmFsdWVcIjogeyBcIiRyZWZcIjogXCJkb2N1bWVudFZhbHVlXCIgfVxyXG4gICAgICB9ICAgICAgXHJcbiAgICB9ICAgIFxyXG4gIF1cclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cz17XHJcbiAgXCJpZFwiOiBcImRvY3VtZW50RnJhZ21lbnRcIixcclxuICBcImFsbE9mXCI6IFtcclxuICAgIHsgXCIkcmVmXCI6IFwicGFyZW50Tm9kZVwiIH0sXHJcbiAgICB7XHJcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XHJcbiAgICAgICAgXCJ2YWx1ZVwiOiB7IFwiJHJlZlwiOiBcImRvY3VtZW50RnJhZ21lbnRWYWx1ZVwiIH1cclxuICAgICAgfSAgICAgIFxyXG4gICAgfSAgICBcclxuICBdXHJcbn1cclxuIiwibW9kdWxlLmV4cG9ydHM9e1xyXG4gIFwiaWRcIjogXCJkb2N1bWVudEZyYWdtZW50VmFsdWVcIixcclxuICBcImFsbE9mXCI6ICBbXHJcbiAgICB7IFwiJHJlZlwiOiBcImVudGl0eU5vZGVWYWx1ZVwiIH0sXHJcbiAgICB7XHJcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XHJcbiAgICAgICAgXCJub2RlVHlwZVwiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgICAgIFwiZW51bVwiOiBbIFwiZG9jdW1lbnRGcmFnbWVudFwiIF1cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFwicmVxdWlyZWRcIjogWyBcIm5vZGVUeXBlXCIgXVxyXG4gICAgfVxyXG4gIF1cclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cz17XHJcbiAgXCJpZFwiOiBcImRvY3VtZW50VHlwZVwiLFxyXG4gIFwiYWxsT2ZcIjogW1xyXG4gICAgeyBcIiRyZWZcIjogXCJlbXB0eU5vZGVcIiB9LFxyXG4gICAge1xyXG4gICAgICBcInByb3BlcnRpZXNcIjoge1xyXG4gICAgICAgIFwidmFsdWVcIjogeyBcIiRyZWZcIjogXCJkb2N1bWVudFR5cGVWYWx1ZVwiIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIF1cclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cz17XHJcbiAgXCJpZFwiOiBcImRvY3VtZW50VHlwZVZhbHVlXCIsXHJcbiAgXCJhbGxPZlwiOiAgW1xyXG4gICAgeyBcIiRyZWZcIjogXCJlbnRpdHlOb2RlVmFsdWVcIiB9LFxyXG4gICAge1xyXG4gICAgICBcInByb3BlcnRpZXNcIjoge1xyXG4gICAgICAgIFwibm9kZVR5cGVcIjoge1xyXG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICBcImVudW1cIjogWyBcImRvY3VtZW50VHlwZVwiIF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwibmFtZVwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiIH0sXHJcbiAgICAgICAgXCJwdWJsaWNJZFwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiIH0sXHJcbiAgICAgICAgXCJzeXN0ZW1JZFwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiIH1cclxuICAgICAgfSxcclxuICAgICAgXCJyZXF1aXJlZFwiOiBbIFwibm9kZVR5cGVcIiwgXCJuYW1lXCIsIFwicHVibGljSWRcIiwgXCJzeXN0ZW1JZFwiIF1cclxuICAgIH1cclxuICBdXHJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XHJcbiAgXCJpZFwiOiBcImRvY3VtZW50VmFsdWVcIixcclxuICBcImFsbE9mXCI6ICBbXHJcbiAgICB7IFwiJHJlZlwiOiBcImVudGl0eU5vZGVWYWx1ZVwiIH0sXHJcbiAgICB7XHJcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XHJcbiAgICAgICAgXCJub2RlVHlwZVwiOiB7XHJcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgICAgIFwiZW51bVwiOiBbIFwiZG9jdW1lbnRcIiBdXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBcInJlcXVpcmVkXCI6IFsgXCJub2RlVHlwZVwiIF1cclxuICAgIH1cclxuICBdXHJcbn1cclxuIiwibW9kdWxlLmV4cG9ydHM9e1xyXG4gIFwiaWRcIjogXCJlbGVtZW50XCIsXHJcbiAgXCJhbGxPZlwiOiBbXHJcbiAgICB7IFwiJHJlZlwiOiBcInBhcmVudE5vZGVcIiB9LFxyXG4gICAge1xyXG4gICAgICBcInByb3BlcnRpZXNcIjoge1xyXG4gICAgICAgIFwidmFsdWVcIjogeyBcIiRyZWZcIjogXCJlbGVtZW50VmFsdWVcIiB9XHJcbiAgICAgIH0gICAgICBcclxuICAgIH0gICAgXHJcbiAgXVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzPXtcclxuICBcImlkXCI6IFwiZWxlbWVudFZhbHVlXCIsXHJcbiAgXCJhbGxPZlwiOiAgW1xyXG4gICAgeyBcIiRyZWZcIjogXCJlbnRpdHlOb2RlVmFsdWVcIiB9LFxyXG4gICAge1xyXG4gICAgICBcInByb3BlcnRpZXNcIjoge1xyXG4gICAgICAgIFwibm9kZVR5cGVcIjoge1xyXG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICBcImVudW1cIjogWyBcImVsZW1lbnRcIiBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImF0dHJpYnV0ZXNcIjoge1xyXG4gICAgICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXHJcbiAgICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgXCJyZXF1aXJlZFwiOiBbIFwibm9kZVR5cGVcIiwgXCJhdHRyaWJ1dGVzXCIgXVxyXG4gICAgfVxyXG4gIF1cclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cz17XHJcbiAgXCJpZFwiOiBcInRleHRcIixcclxuICBcImFsbE9mXCI6IFtcclxuICAgIHsgXCIkcmVmXCI6IFwiZW1wdHlOb2RlXCIgfSxcclxuICAgIHtcclxuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcclxuICAgICAgICBcInZhbHVlXCI6IHsgXCIkcmVmXCI6IFwidGV4dFZhbHVlXCIgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgXVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzPXtcclxuICBcImlkXCI6IFwidGV4dFZhbHVlXCIsXHJcbiAgXCJhbGxPZlwiOiAgW1xyXG4gICAgeyBcIiRyZWZcIjogXCJlbnRpdHlOb2RlVmFsdWVcIiB9LFxyXG4gICAge1xyXG4gICAgICBcInByb3BlcnRpZXNcIjoge1xyXG4gICAgICAgIFwibm9kZVR5cGVcIjoge1xyXG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICBcImVudW1cIjogWyBcInRleHRcIiBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIm5vZGVWYWx1ZVwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiIH1cclxuICAgICAgfSxcclxuICAgICAgXCJyZXF1aXJlZFwiOiBbIFwibm9kZVR5cGVcIiwgXCJub2RlVmFsdWVcIiBdXHJcbiAgICB9XHJcbiAgXVxyXG59XHJcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxudmFyIEh0cmVlID0gcmVxdWlyZSgnbW9qdWxlLWRvbScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnbW9qdWxlLXV0aWxzJyk7XG5cbnZhciBjbG9uZSA9IHV0aWxzLmNsb25lO1xuXG5cbnZhciB0b2tlbnMgPSBbJ3RhZycsICd0ZXh0JywgJ2h0bWwnLCAnaWYnLCAnbm90JywgJ2VhY2gnLCAnZW1wdHknLCAnY29udGV4dCcsICdpbmNsdWRlJ107XG5cbnZhciB0b2tlblNlbGVjdG9yID0gZnVuY3Rpb24gdG9rZW5TZWxlY3Rvcih0b2tlbikge1xuICByZXR1cm4gJ1tkYXRhLScgKyB0b2tlbiArICddJztcbn07XG52YXIgc2VsZWN0b3JzID0gdG9rZW5zLm1hcCh0b2tlblNlbGVjdG9yKTtcblxudmFyIHJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKHNjb3BlLCBwcm9wZXJ0eU5hbWUpIHtcbiAgaWYgKF90eXBlb2Yoc2NvcGUuY3VycmVudCkgPT09ICdvYmplY3QnICYmIHByb3BlcnR5TmFtZSBpbiBzY29wZS5jdXJyZW50KSByZXR1cm4gc2NvcGUuY3VycmVudFtwcm9wZXJ0eU5hbWVdO1xuXG4gIGlmIChwcm9wZXJ0eU5hbWUgPT09ICcuJykgcmV0dXJuIHNjb3BlLmN1cnJlbnQ7XG5cbiAgaWYgKHNjb3BlLnBhcmVudCkgcmV0dXJuIHJlc29sdmUoc2NvcGUucGFyZW50LCBwcm9wZXJ0eU5hbWUpO1xufTtcblxudmFyIGFjdGlvbldoaXRlbGlzdCA9IFsndGFnTmFtZScsICdhdHRyJywgJ3JlbW92ZUF0dHInLCAnYWRkQ2xhc3MnLCAncmVtb3ZlQ2xhc3MnLCAndG9nZ2xlQ2xhc3MnLCAnY2xlYXJBdHRycycsICdjbGVhckNsYXNzZXMnLCAnYXR0cmlidXRlcyddO1xuXG52YXIgaGFuZGxlQWN0aW9uID0gZnVuY3Rpb24gaGFuZGxlQWN0aW9uKGVsLCBhY3Rpb24pIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGFjdGlvbikuZmlsdGVyKGZ1bmN0aW9uIChmbmFtZSkge1xuICAgIHJldHVybiBhY3Rpb25XaGl0ZWxpc3QuaW5jbHVkZXMoZm5hbWUpO1xuICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChmbmFtZSkge1xuICAgIHZhciBhcmdzID0gYWN0aW9uW2ZuYW1lXTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShhcmdzKSkgYXJncyA9IFthcmdzXTtcblxuICAgIGVsW2ZuYW1lXS5hcHBseShlbCwgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgfSk7XG59O1xuXG52YXIgVGVtcGxhdGluZyA9IGZ1bmN0aW9uIFRlbXBsYXRpbmcodGVtcGxhdGVzKSB7XG4gIHZhciBnZXRUZW1wbGF0ZUZyYWdtZW50ID0gZnVuY3Rpb24gZ2V0VGVtcGxhdGVGcmFnbWVudChuYW1lKSB7XG4gICAgcmV0dXJuIEh0cmVlKGNsb25lKHRlbXBsYXRlc1tuYW1lXSkpO1xuICB9O1xuXG4gIHZhciBwb3B1bGF0ZUVsID0ge1xuICAgIHRhZzogZnVuY3Rpb24gdGFnKGVsLCBzY29wZSwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHZhbHVlID0gW3ZhbHVlXTtcblxuICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVBY3Rpb24oZWwsIGFjdGlvbik7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHRleHQ6IGZ1bmN0aW9uIHRleHQoZWwsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgZWwuZW1wdHkoKTtcblxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgdmFyIHRleHROb2RlID0gZWwuY3JlYXRlVGV4dCh2YWx1ZSk7XG5cbiAgICAgIGVsLmFwcGVuZCh0ZXh0Tm9kZSk7XG4gICAgfSxcbiAgICBodG1sOiBmdW5jdGlvbiBodG1sKGVsLCBzY29wZSwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVsLmVtcHR5KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwucGFyc2UodmFsdWUpO1xuXG4gICAgICBlbC5hcHBlbmQoY2hpbGRyZW4pO1xuICAgIH0sXG4gICAgaWY6IGZ1bmN0aW9uIF9pZihlbCwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSBlbC5lbXB0eSgpO1xuICAgIH0sXG4gICAgbm90OiBmdW5jdGlvbiBub3QoZWwsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSBlbC5lbXB0eSgpO1xuICAgIH0sXG4gICAgZWFjaDogZnVuY3Rpb24gZWFjaChlbCwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbC5lbXB0eSgpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBwb3B1bGF0ZUVsLmNvbnRleHQoZWwsIHNjb3BlLCB2YWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbC5lbXB0eSgpO1xuXG4gICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBjaGlsZFNjb3BlID0ge1xuICAgICAgICAgIHBhcmVudDogc2NvcGUsXG4gICAgICAgICAgY3VycmVudDogaXRlbVxuICAgICAgICB9O1xuXG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgZWwuYXBwZW5kKGNoaWxkLmNsb25lKCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBwb3B1bGF0ZU5leHQoZWwsIGNoaWxkU2NvcGUpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBlbXB0eTogZnVuY3Rpb24gZW1wdHkoZWwsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWwuZW1wdHkoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCA+IDApIGVsLmVtcHR5KCk7XG4gICAgfSxcbiAgICBjb250ZXh0OiBmdW5jdGlvbiBjb250ZXh0KGVsLCBzY29wZSwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgIHZhciBuZXdTY29wZSA9IHtcbiAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICBjdXJyZW50OiB2YWx1ZVxuICAgICAgfTtcblxuICAgICAgcG9wdWxhdGVOZXh0KGVsLCBuZXdTY29wZSk7XG4gICAgfSxcbiAgICBpbmNsdWRlOiBmdW5jdGlvbiBpbmNsdWRlKGVsLCBzY29wZSwgdmFsdWUpIHtcbiAgICAgIGVsLmVtcHR5KCk7XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgIGVsLmFwcGVuZChnZXRUZW1wbGF0ZUZyYWdtZW50KHZhbHVlKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBwb3B1bGF0ZU5leHQgPSBmdW5jdGlvbiBwb3B1bGF0ZU5leHQodGVtcGxhdGUsIHNjb3BlKSB7XG4gICAgdmFyIG5leHQgPSB0ZW1wbGF0ZS5zZWxlY3Qoc2VsZWN0b3JzLmpvaW4oJywgJykpO1xuXG4gICAgaWYgKCFuZXh0KSByZXR1cm4gdGVtcGxhdGU7XG5cbiAgICB2YXIgY3VycmVudFRva2VuID0gdG9rZW5zLmZpbmQoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICByZXR1cm4gbmV4dC5tYXRjaGVzKHRva2VuU2VsZWN0b3IodG9rZW4pKTtcbiAgICB9KTtcblxuICAgIHZhciBhdHRyTmFtZSA9ICdkYXRhLScgKyBjdXJyZW50VG9rZW47XG4gICAgdmFyIG5hbWUgPSBuZXh0LmF0dHIoYXR0ck5hbWUpO1xuXG4gICAgaWYgKGN1cnJlbnRUb2tlbiA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICBwb3B1bGF0ZUVsW2N1cnJlbnRUb2tlbl0obmV4dCwgc2NvcGUsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmFsdWUgPSByZXNvbHZlKHNjb3BlLCBuYW1lKTtcblxuICAgICAgcG9wdWxhdGVFbFtjdXJyZW50VG9rZW5dKG5leHQsIHNjb3BlLCB2YWx1ZSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNjb3BlID0ge1xuICAgICAgICAgIHBhcmVudDogc2NvcGUsXG4gICAgICAgICAgY3VycmVudDogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXh0LnJlbW92ZUF0dHIoYXR0ck5hbWUpO1xuXG4gICAgcmV0dXJuIHBvcHVsYXRlTmV4dCh0ZW1wbGF0ZSwgc2NvcGUpO1xuICB9O1xuXG4gIHZhciB1bndyYXBGcmFnbWVudENoaWxkcmVuID0gZnVuY3Rpb24gdW53cmFwRnJhZ21lbnRDaGlsZHJlbihmcmFnbWVudCkge1xuICAgIHZhciBub3RGcmFnbWVudCA9IGZyYWdtZW50LmZpbmQoZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiAhbi5tYXRjaGVzKCdmcmFnbWVudCcpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFub3RGcmFnbWVudCkgcmV0dXJuIGZyYWdtZW50O1xuXG4gICAgdmFyIGZyYWdtZW50UGFyZW50ID0gZnJhZ21lbnQuZ2V0UGFyZW50KCk7XG5cbiAgICBmcmFnbWVudFBhcmVudC5pbnNlcnRCZWZvcmUobm90RnJhZ21lbnQsIGZyYWdtZW50KTtcblxuICAgIHJldHVybiB1bndyYXBGcmFnbWVudENoaWxkcmVuKGZyYWdtZW50KTtcbiAgfTtcblxuICB2YXIgdW53cmFwTmV4dEZyYWdtZW50ID0gZnVuY3Rpb24gdW53cmFwTmV4dEZyYWdtZW50KHRlbXBsYXRlKSB7XG4gICAgdmFyIGZyYWdtZW50ID0gdGVtcGxhdGUuc2VsZWN0KCdmcmFnbWVudCcpO1xuXG4gICAgaWYgKCFmcmFnbWVudCkgcmV0dXJuIHRlbXBsYXRlO1xuXG4gICAgdW53cmFwRnJhZ21lbnRDaGlsZHJlbihmcmFnbWVudCk7XG5cbiAgICBmcmFnbWVudC5yZW1vdmUoKTtcblxuICAgIHJldHVybiB1bndyYXBOZXh0RnJhZ21lbnQodGVtcGxhdGUpO1xuICB9O1xuXG4gIHZhciBwb3B1bGF0ZSA9IGZ1bmN0aW9uIHBvcHVsYXRlKG5hbWUsIG1vZGVsKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gZ2V0VGVtcGxhdGVGcmFnbWVudChuYW1lKTtcblxuICAgIHZhciBzY29wZSA9IHtcbiAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgIGN1cnJlbnQ6IG1vZGVsXG4gICAgfTtcblxuICAgIHBvcHVsYXRlTmV4dCh0ZW1wbGF0ZSwgc2NvcGUpO1xuICAgIHVud3JhcE5leHRGcmFnbWVudCh0ZW1wbGF0ZSk7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH07XG5cbiAgcmV0dXJuIHBvcHVsYXRlO1xufTtcblxuVGVtcGxhdGluZy5nZXRUZW1wbGF0ZXMgPSBmdW5jdGlvbiAoaHRyZWUpIHtcbiAgaWYgKHR5cGVvZiBodHJlZSA9PT0gJ3N0cmluZycpIGh0cmVlID0gSHRyZWUoaHRyZWUpO1xuXG4gIHZhciB0ZW1wbGF0ZUVscyA9IGh0cmVlLmNsb25lKCkuc2VsZWN0QWxsKCd0ZW1wbGF0ZVtpZF06bm90KFtpZD1cIlwiXSknKTtcblxuICByZXR1cm4gdGVtcGxhdGVFbHMucmVkdWNlKGZ1bmN0aW9uICh0ZW1wbGF0ZXMsIGVsKSB7XG4gICAgdmFyIGlkID0gZWwuYXR0cignaWQnKTtcblxuICAgIHZhciBmcmFnbWVudCA9IGh0cmVlLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIGVsLmdldENoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBmcmFnbWVudC5hcHBlbmQoY2hpbGQpO1xuICAgIH0pO1xuXG4gICAgdGVtcGxhdGVzW2lkXSA9IGZyYWdtZW50LnNlcmlhbGl6ZSgpO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlcztcbiAgfSwge30pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZW1wbGF0aW5nOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdtb2p1bGUtdXRpbHMnKSxcbiAgICBjbG9uZSA9IF9yZXF1aXJlLmNsb25lO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgnMXRyZWUtanNvbicpLFxuICAgIHRvVHJlZSA9IF9yZXF1aXJlMi50b1RyZWUsXG4gICAgdG9Kc29uID0gX3JlcXVpcmUyLnRvSnNvbjtcblxudmFyIHRyYW5zZm9ybXMgPSB7XG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKGRhdGEpIHtcbiAgICB2YXIgbW9kZWwgPSBkYXRhLm1vZGVsLFxuICAgICAgICB0cmFuc2Zvcm0gPSBkYXRhLnRyYW5zZm9ybTtcblxuXG4gICAgdmFyIHRyYW5zZm9ybVRyZWUgPSB0b1RyZWUodHJhbnNmb3JtKTtcblxuICAgIHZhciB2YWx1ZVByb3BlcnR5Tm9kZXMgPSB0cmFuc2Zvcm1UcmVlLmZpbmRBbGwoZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBuLnZhbHVlKCkucHJvcGVydHlOYW1lID09PSAnJHZhbHVlJztcbiAgICB9KTtcblxuICAgIGlmICh2YWx1ZVByb3BlcnR5Tm9kZXMubGVuZ3RoID09PSAwKSByZXR1cm4gZGF0YTtcblxuICAgIHZhbHVlUHJvcGVydHlOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eU5vZGUpIHtcbiAgICAgIHZhciBvYmplY3ROb2RlID0gcHJvcGVydHlOb2RlLmdldFBhcmVudCgpO1xuICAgICAgdmFyIG9iamVjdE5vZGVQYXJlbnQgPSBvYmplY3ROb2RlLmdldFBhcmVudCgpO1xuXG4gICAgICB2YXIgdmFsdWUgPSBwcm9wZXJ0eU5vZGUudmFsdWUoKTtcbiAgICAgIHZhciBzb3VyY2VQcm9wZXJ0eU5hbWUgPSB2YWx1ZS5ub2RlVmFsdWU7XG5cbiAgICAgIHZhciBuZXdWYWx1ZU5vZGUgPSBzb3VyY2VQcm9wZXJ0eU5hbWUgaW4gbW9kZWwgPyB0b1RyZWUobW9kZWxbc291cmNlUHJvcGVydHlOYW1lXSkgOiB0b1RyZWUoJyRkZWxldGUnKTtcblxuICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IG9iamVjdE5vZGUudmFsdWUoKS5wcm9wZXJ0eU5hbWU7XG5cbiAgICAgIGlmIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gbmV3VmFsdWVOb2RlLnZhbHVlKCk7XG4gICAgICAgIG5ld1ZhbHVlLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcbiAgICAgICAgbmV3VmFsdWVOb2RlLnZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgb2JqZWN0Tm9kZVBhcmVudC5yZXBsYWNlQ2hpbGQobmV3VmFsdWVOb2RlLCBvYmplY3ROb2RlKTtcbiAgICB9KTtcblxuICAgIHRyYW5zZm9ybSA9IHRvSnNvbih0cmFuc2Zvcm1UcmVlKTtcblxuICAgIHJldHVybiB7IG1vZGVsOiBtb2RlbCwgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gfTtcbiAgfSxcbiAgaWZzOiBmdW5jdGlvbiBpZnMoZGF0YSkge1xuICAgIHZhciBtb2RlbCA9IGRhdGEubW9kZWwsXG4gICAgICAgIHRyYW5zZm9ybSA9IGRhdGEudHJhbnNmb3JtO1xuXG5cbiAgICB2YXIgdHJhbnNmb3JtVHJlZSA9IHRvVHJlZSh0cmFuc2Zvcm0pO1xuXG4gICAgdmFyIGlmUHJvcGVydHlOb2RlcyA9IHRyYW5zZm9ybVRyZWUuZmluZEFsbChmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIG4udmFsdWUoKS5wcm9wZXJ0eU5hbWUgPT09ICckaWYnO1xuICAgIH0pO1xuXG4gICAgaWZQcm9wZXJ0eU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5Tm9kZSkge1xuICAgICAgdmFyIG9iamVjdE5vZGUgPSBwcm9wZXJ0eU5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICB2YXIgb2JqZWN0Tm9kZVBhcmVudCA9IG9iamVjdE5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgICAgIHZhciBpZkFyZ05vZGVzID0gcHJvcGVydHlOb2RlLmdldENoaWxkcmVuKCk7XG5cbiAgICAgIHZhciBpc1ZhbHVlID0gaWZBcmdOb2Rlc1swXS52YWx1ZSgpLm5vZGVWYWx1ZTtcblxuICAgICAgaWYgKGlzVmFsdWUgJiYgaXNWYWx1ZSAhPT0gJyRkZWxldGUnKSB7XG4gICAgICAgIHZhciBpZlZhbHVlTm9kZSA9IGlmQXJnTm9kZXNbMV07XG5cbiAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IG9iamVjdE5vZGUudmFsdWUoKS5wcm9wZXJ0eU5hbWU7XG5cbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGlmVmFsdWVOb2RlLnZhbHVlKCk7XG4gICAgICAgICAgbmV3VmFsdWUucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuICAgICAgICAgIGlmVmFsdWVOb2RlLnZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iamVjdE5vZGVQYXJlbnQuaW5zZXJ0QmVmb3JlKGlmVmFsdWVOb2RlLCBvYmplY3ROb2RlKTtcbiAgICAgIH1cblxuICAgICAgb2JqZWN0Tm9kZS5yZW1vdmUoKTtcbiAgICB9KTtcblxuICAgIHRyYW5zZm9ybSA9IHRvSnNvbih0cmFuc2Zvcm1UcmVlKTtcblxuICAgIHJldHVybiB7IG1vZGVsOiBtb2RlbCwgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gfTtcbiAgfSxcbiAgZGVsZXRlczogZnVuY3Rpb24gZGVsZXRlcyhkYXRhKSB7XG4gICAgdmFyIG1vZGVsID0gZGF0YS5tb2RlbCxcbiAgICAgICAgdHJhbnNmb3JtID0gZGF0YS50cmFuc2Zvcm07XG5cblxuICAgIHZhciB0cmFuc2Zvcm1LZXlzID0gT2JqZWN0LmtleXModHJhbnNmb3JtKTtcblxuICAgIHRyYW5zZm9ybUtleXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgICBpZiAodHJhbnNmb3JtW3Byb3BlcnR5TmFtZV0gPT09ICckZGVsZXRlJykge1xuICAgICAgICBkZWxldGUgbW9kZWxbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgZGVsZXRlIHRyYW5zZm9ybVtwcm9wZXJ0eU5hbWVdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgbW9kZWw6IG1vZGVsLCB0cmFuc2Zvcm06IHRyYW5zZm9ybSB9O1xuICB9LFxuICBzdWJzdGl0dXRlczogZnVuY3Rpb24gc3Vic3RpdHV0ZXMoZGF0YSkge1xuICAgIHZhciBtb2RlbCA9IGRhdGEubW9kZWwsXG4gICAgICAgIHRyYW5zZm9ybSA9IGRhdGEudHJhbnNmb3JtO1xuXG5cbiAgICB2YXIgdHJhbnNmb3JtS2V5cyA9IE9iamVjdC5rZXlzKHRyYW5zZm9ybSk7XG5cbiAgICB0cmFuc2Zvcm1LZXlzLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgICAgbW9kZWxbcHJvcGVydHlOYW1lXSA9IHRyYW5zZm9ybVtwcm9wZXJ0eU5hbWVdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgbW9kZWw6IG1vZGVsLCB0cmFuc2Zvcm06IHRyYW5zZm9ybSB9O1xuICB9XG59O1xuXG52YXIgdHJhbnNmb3JtTWFwcGVyID0gZnVuY3Rpb24gdHJhbnNmb3JtTWFwcGVyKG1vZGVsLCB0cmFuc2Zvcm0pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobW9kZWwpKSB7XG4gICAgcmV0dXJuIG1vZGVsLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1NYXBwZXIoZWwsIHRyYW5zZm9ybSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoKHR5cGVvZiBtb2RlbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobW9kZWwpKSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cblxuICB2YXIgZGF0YSA9IGNsb25lKHsgbW9kZWw6IG1vZGVsLCB0cmFuc2Zvcm06IHRyYW5zZm9ybSB9KTtcblxuICBPYmplY3Qua2V5cyh0cmFuc2Zvcm1zKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFuc2Zvcm1OYW1lKSB7XG4gICAgdmFyIGZuID0gdHJhbnNmb3Jtc1t0cmFuc2Zvcm1OYW1lXTtcblxuICAgIGRhdGEgPSBmbihkYXRhKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGEubW9kZWw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybU1hcHBlcjsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICB2YXIgb2JqID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59O1xuXG52YXIgbWF0Y2hlcyA9IGZ1bmN0aW9uIG1hdGNoZXMoKSB7XG4gIHZhciBvYmogPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBvYmpba2V5XSA9PT0gc291cmNlW2tleV07XG4gIH0pO1xufTtcblxudmFyIGlkID0gZnVuY3Rpb24gaWQoKSB7XG4gIHZhciBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAzMjtcblxuICBpZiAocHJlZml4KSBwcmVmaXggPSBpZGVudGlmaWVyKHByZWZpeCkgKyAnLSc7XG5cbiAgdmFyIHN0ciA9IHByZWZpeDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgc3RyICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE2KS50b1N0cmluZygxNik7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxudmFyIGlkZW50aWZpZXIgPSBmdW5jdGlvbiBpZGVudGlmaWVyKCkge1xuICB2YXIgdmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICB2YXIgY2FzZVNlbnNpdGl2ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGlkID0gdmFsdWUucmVwbGFjZSgvW15hLXowLTldL2dpLCAnLScpLnJlcGxhY2UoLy17Mix9L2csICctJyk7XG5cbiAgaWYgKCFjYXNlU2Vuc2l0aXZlKSBpZCA9IGlkLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxudmFyIGVzY2FwZUh0bWwgPSBmdW5jdGlvbiBlc2NhcGVIdG1sKCkge1xuICB2YXIgc3RyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcblxuICB2YXIgcmVzdWx0ID0gc3RyLnJlcGxhY2UoLzwvZywgJyZsdDsnKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBjYXBpdGFsaXplRmlyc3RMZXR0ZXIgPSBmdW5jdGlvbiBjYXBpdGFsaXplRmlyc3RMZXR0ZXIoKSB7XG4gIHZhciBzdHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufTtcblxudmFyIHV0aWxzID0ge1xuICBpZDogaWQsIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsIG1hdGNoZXM6IG1hdGNoZXMsIGNsb25lOiBjbG9uZSwgZXNjYXBlSHRtbDogZXNjYXBlSHRtbCwgY2FwaXRhbGl6ZUZpcnN0TGV0dGVyOiBjYXBpdGFsaXplRmlyc3RMZXR0ZXJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdXRpbHM7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZ2U7IC8vIENyZWF0ZSBhIHJhbmdlIG9iamVjdCBmb3IgZWZmaWNlbnRseSByZW5kZXJpbmcgc3RyaW5ncyB0byBlbGVtZW50cy5cbnZhciBOU19YSFRNTCA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcblxudmFyIGRvYyA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBkb2N1bWVudDtcblxudmFyIHRlc3RFbCA9IGRvYyA/XG4gICAgZG9jLmJvZHkgfHwgZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDpcbiAgICB7fTtcblxuLy8gRml4ZXMgPGh0dHBzOi8vZ2l0aHViLmNvbS9wYXRyaWNrLXN0ZWVsZS1pZGVtL21vcnBoZG9tL2lzc3Vlcy8zMj5cbi8vIChJRTcrIHN1cHBvcnQpIDw9SUU3IGRvZXMgbm90IHN1cHBvcnQgZWwuaGFzQXR0cmlidXRlKG5hbWUpXG52YXIgYWN0dWFsSGFzQXR0cmlidXRlTlM7XG5cbmlmICh0ZXN0RWwuaGFzQXR0cmlidXRlTlMpIHtcbiAgICBhY3R1YWxIYXNBdHRyaWJ1dGVOUyA9IGZ1bmN0aW9uKGVsLCBuYW1lc3BhY2VVUkksIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZU5TKG5hbWVzcGFjZVVSSSwgbmFtZSk7XG4gICAgfTtcbn0gZWxzZSBpZiAodGVzdEVsLmhhc0F0dHJpYnV0ZSkge1xuICAgIGFjdHVhbEhhc0F0dHJpYnV0ZU5TID0gZnVuY3Rpb24oZWwsIG5hbWVzcGFjZVVSSSwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZWwuaGFzQXR0cmlidXRlKG5hbWUpO1xuICAgIH07XG59IGVsc2Uge1xuICAgIGFjdHVhbEhhc0F0dHJpYnV0ZU5TID0gZnVuY3Rpb24oZWwsIG5hbWVzcGFjZVVSSSwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlTm9kZShuYW1lc3BhY2VVUkksIG5hbWUpICE9IG51bGw7XG4gICAgfTtcbn1cblxudmFyIGhhc0F0dHJpYnV0ZU5TID0gYWN0dWFsSGFzQXR0cmlidXRlTlM7XG5cblxuZnVuY3Rpb24gdG9FbGVtZW50KHN0cikge1xuICAgIGlmICghcmFuZ2UgJiYgZG9jLmNyZWF0ZVJhbmdlKSB7XG4gICAgICAgIHJhbmdlID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGUoZG9jLmJvZHkpO1xuICAgIH1cblxuICAgIHZhciBmcmFnbWVudDtcbiAgICBpZiAocmFuZ2UgJiYgcmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KSB7XG4gICAgICAgIGZyYWdtZW50ID0gcmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRWxlbWVudCgnYm9keScpO1xuICAgICAgICBmcmFnbWVudC5pbm5lckhUTUwgPSBzdHI7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0d28gbm9kZSdzIG5hbWVzIGFyZSB0aGUgc2FtZS5cbiAqXG4gKiBOT1RFOiBXZSBkb24ndCBib3RoZXIgY2hlY2tpbmcgYG5hbWVzcGFjZVVSSWAgYmVjYXVzZSB5b3Ugd2lsbCBuZXZlciBmaW5kIHR3byBIVE1MIGVsZW1lbnRzIHdpdGggdGhlIHNhbWVcbiAqICAgICAgIG5vZGVOYW1lIGFuZCBkaWZmZXJlbnQgbmFtZXNwYWNlIFVSSXMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGIgVGhlIHRhcmdldCBlbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb21wYXJlTm9kZU5hbWVzKGZyb21FbCwgdG9FbCkge1xuICAgIHZhciBmcm9tTm9kZU5hbWUgPSBmcm9tRWwubm9kZU5hbWU7XG4gICAgdmFyIHRvTm9kZU5hbWUgPSB0b0VsLm5vZGVOYW1lO1xuXG4gICAgaWYgKGZyb21Ob2RlTmFtZSA9PT0gdG9Ob2RlTmFtZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodG9FbC5hY3R1YWxpemUgJiZcbiAgICAgICAgZnJvbU5vZGVOYW1lLmNoYXJDb2RlQXQoMCkgPCA5MSAmJiAvKiBmcm9tIHRhZyBuYW1lIGlzIHVwcGVyIGNhc2UgKi9cbiAgICAgICAgdG9Ob2RlTmFtZS5jaGFyQ29kZUF0KDApID4gOTAgLyogdGFyZ2V0IHRhZyBuYW1lIGlzIGxvd2VyIGNhc2UgKi8pIHtcbiAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGEgdmlydHVhbCBET00gbm9kZSB0aGVuIHdlIG1heSBuZWVkIHRvIG5vcm1hbGl6ZSB0aGUgdGFnIG5hbWVcbiAgICAgICAgLy8gYmVmb3JlIGNvbXBhcmluZy4gTm9ybWFsIEhUTUwgZWxlbWVudHMgdGhhdCBhcmUgaW4gdGhlIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiXG4gICAgICAgIC8vIGFyZSBjb252ZXJ0ZWQgdG8gdXBwZXIgY2FzZVxuICAgICAgICByZXR1cm4gZnJvbU5vZGVOYW1lID09PSB0b05vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZWxlbWVudCwgb3B0aW9uYWxseSB3aXRoIGEga25vd24gbmFtZXNwYWNlIFVSSS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgZWxlbWVudCBuYW1lLCBlLmcuICdkaXYnIG9yICdzdmcnXG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWVzcGFjZVVSSV0gdGhlIGVsZW1lbnQncyBuYW1lc3BhY2UgVVJJLCBpLmUuIHRoZSB2YWx1ZSBvZlxuICogaXRzIGB4bWxuc2AgYXR0cmlidXRlIG9yIGl0cyBpbmZlcnJlZCBuYW1lc3BhY2UuXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TKG5hbWUsIG5hbWVzcGFjZVVSSSkge1xuICAgIHJldHVybiAhbmFtZXNwYWNlVVJJIHx8IG5hbWVzcGFjZVVSSSA9PT0gTlNfWEhUTUwgP1xuICAgICAgICBkb2MuY3JlYXRlRWxlbWVudChuYW1lKSA6XG4gICAgICAgIGRvYy5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCBuYW1lKTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgdGhlIGNoaWxkcmVuIG9mIG9uZSBET00gZWxlbWVudCB0byBhbm90aGVyIERPTSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIG1vdmVDaGlsZHJlbihmcm9tRWwsIHRvRWwpIHtcbiAgICB2YXIgY3VyQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgdmFyIG5leHRDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICB0b0VsLmFwcGVuZENoaWxkKGN1ckNoaWxkKTtcbiAgICAgICAgY3VyQ2hpbGQgPSBuZXh0Q2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiB0b0VsO1xufVxuXG5mdW5jdGlvbiBtb3JwaEF0dHJzKGZyb21Ob2RlLCB0b05vZGUpIHtcbiAgICB2YXIgYXR0cnMgPSB0b05vZGUuYXR0cmlidXRlcztcbiAgICB2YXIgaTtcbiAgICB2YXIgYXR0cjtcbiAgICB2YXIgYXR0ck5hbWU7XG4gICAgdmFyIGF0dHJOYW1lc3BhY2VVUkk7XG4gICAgdmFyIGF0dHJWYWx1ZTtcbiAgICB2YXIgZnJvbVZhbHVlO1xuXG4gICAgZm9yIChpID0gYXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgYXR0ciA9IGF0dHJzW2ldO1xuICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgYXR0ck5hbWVzcGFjZVVSSSA9IGF0dHIubmFtZXNwYWNlVVJJO1xuICAgICAgICBhdHRyVmFsdWUgPSBhdHRyLnZhbHVlO1xuXG4gICAgICAgIGlmIChhdHRyTmFtZXNwYWNlVVJJKSB7XG4gICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubG9jYWxOYW1lIHx8IGF0dHJOYW1lO1xuICAgICAgICAgICAgZnJvbVZhbHVlID0gZnJvbU5vZGUuZ2V0QXR0cmlidXRlTlMoYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoZnJvbVZhbHVlICE9PSBhdHRyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5zZXRBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21WYWx1ZSA9IGZyb21Ob2RlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChmcm9tVmFsdWUgIT09IGF0dHJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgZXh0cmEgYXR0cmlidXRlcyBmb3VuZCBvbiB0aGUgb3JpZ2luYWwgRE9NIGVsZW1lbnQgdGhhdFxuICAgIC8vIHdlcmVuJ3QgZm91bmQgb24gdGhlIHRhcmdldCBlbGVtZW50LlxuICAgIGF0dHJzID0gZnJvbU5vZGUuYXR0cmlidXRlcztcblxuICAgIGZvciAoaSA9IGF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGF0dHIgPSBhdHRyc1tpXTtcbiAgICAgICAgaWYgKGF0dHIuc3BlY2lmaWVkICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICAgICAgICBhdHRyTmFtZXNwYWNlVVJJID0gYXR0ci5uYW1lc3BhY2VVUkk7XG5cbiAgICAgICAgICAgIGlmIChhdHRyTmFtZXNwYWNlVVJJKSB7XG4gICAgICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLmxvY2FsTmFtZSB8fCBhdHRyTmFtZTtcblxuICAgICAgICAgICAgICAgIGlmICghaGFzQXR0cmlidXRlTlModG9Ob2RlLCBhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbU5vZGUucmVtb3ZlQXR0cmlidXRlTlMoYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNBdHRyaWJ1dGVOUyh0b05vZGUsIG51bGwsIGF0dHJOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tTm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsIG5hbWUpIHtcbiAgICBpZiAoZnJvbUVsW25hbWVdICE9PSB0b0VsW25hbWVdKSB7XG4gICAgICAgIGZyb21FbFtuYW1lXSA9IHRvRWxbbmFtZV07XG4gICAgICAgIGlmIChmcm9tRWxbbmFtZV0pIHtcbiAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lLCAnJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBzcGVjaWFsRWxIYW5kbGVycyA9IHtcbiAgICAvKipcbiAgICAgKiBOZWVkZWQgZm9yIElFLiBBcHBhcmVudGx5IElFIGRvZXNuJ3QgdGhpbmsgdGhhdCBcInNlbGVjdGVkXCIgaXMgYW5cbiAgICAgKiBhdHRyaWJ1dGUgd2hlbiByZWFkaW5nIG92ZXIgdGhlIGF0dHJpYnV0ZXMgdXNpbmcgc2VsZWN0RWwuYXR0cmlidXRlc1xuICAgICAqL1xuICAgIE9QVElPTjogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCAnc2VsZWN0ZWQnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBcInZhbHVlXCIgYXR0cmlidXRlIGlzIHNwZWNpYWwgZm9yIHRoZSA8aW5wdXQ+IGVsZW1lbnQgc2luY2UgaXQgc2V0c1xuICAgICAqIHRoZSBpbml0aWFsIHZhbHVlLiBDaGFuZ2luZyB0aGUgXCJ2YWx1ZVwiIGF0dHJpYnV0ZSB3aXRob3V0IGNoYW5naW5nIHRoZVxuICAgICAqIFwidmFsdWVcIiBwcm9wZXJ0eSB3aWxsIGhhdmUgbm8gZWZmZWN0IHNpbmNlIGl0IGlzIG9ubHkgdXNlZCB0byB0aGUgc2V0IHRoZVxuICAgICAqIGluaXRpYWwgdmFsdWUuICBTaW1pbGFyIGZvciB0aGUgXCJjaGVja2VkXCIgYXR0cmlidXRlLCBhbmQgXCJkaXNhYmxlZFwiLlxuICAgICAqL1xuICAgIElOUFVUOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsICdjaGVja2VkJyk7XG4gICAgICAgIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCAnZGlzYWJsZWQnKTtcblxuICAgICAgICBpZiAoZnJvbUVsLnZhbHVlICE9PSB0b0VsLnZhbHVlKSB7XG4gICAgICAgICAgICBmcm9tRWwudmFsdWUgPSB0b0VsLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXNBdHRyaWJ1dGVOUyh0b0VsLCBudWxsLCAndmFsdWUnKSkge1xuICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBURVhUQVJFQTogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHRvRWwudmFsdWU7XG4gICAgICAgIGlmIChmcm9tRWwudmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBmcm9tRWwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcm9tRWwuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgLy8gTmVlZGVkIGZvciBJRS4gQXBwYXJlbnRseSBJRSBzZXRzIHRoZSBwbGFjZWhvbGRlciBhcyB0aGVcbiAgICAgICAgICAgIC8vIG5vZGUgdmFsdWUgYW5kIHZpc2UgdmVyc2EuIFRoaXMgaWdub3JlcyBhbiBlbXB0eSB1cGRhdGUuXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09ICcnICYmIGZyb21FbC5maXJzdENoaWxkLm5vZGVWYWx1ZSA9PT0gZnJvbUVsLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcm9tRWwuZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgU0VMRUNUOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgaWYgKCFoYXNBdHRyaWJ1dGVOUyh0b0VsLCBudWxsLCAnbXVsdGlwbGUnKSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IHRvRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gY3VyQ2hpbGQubm9kZU5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdPUFRJT04nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNBdHRyaWJ1dGVOUyhjdXJDaGlsZCwgbnVsbCwgJ3NlbGVjdGVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcm9tRWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgRUxFTUVOVF9OT0RFID0gMTtcbnZhciBURVhUX05PREUgPSAzO1xudmFyIENPTU1FTlRfTk9ERSA9IDg7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBkZWZhdWx0R2V0Tm9kZUtleShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuaWQ7XG59XG5cbmZ1bmN0aW9uIG1vcnBoZG9tRmFjdG9yeShtb3JwaEF0dHJzKSB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbW9ycGhkb20oZnJvbU5vZGUsIHRvTm9kZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdG9Ob2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGZyb21Ob2RlLm5vZGVOYW1lID09PSAnI2RvY3VtZW50JyB8fCBmcm9tTm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvTm9kZUh0bWwgPSB0b05vZGU7XG4gICAgICAgICAgICAgICAgdG9Ob2RlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2h0bWwnKTtcbiAgICAgICAgICAgICAgICB0b05vZGUuaW5uZXJIVE1MID0gdG9Ob2RlSHRtbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9Ob2RlID0gdG9FbGVtZW50KHRvTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2V0Tm9kZUtleSA9IG9wdGlvbnMuZ2V0Tm9kZUtleSB8fCBkZWZhdWx0R2V0Tm9kZUtleTtcbiAgICAgICAgdmFyIG9uQmVmb3JlTm9kZUFkZGVkID0gb3B0aW9ucy5vbkJlZm9yZU5vZGVBZGRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25Ob2RlQWRkZWQgPSBvcHRpb25zLm9uTm9kZUFkZGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbkJlZm9yZUVsVXBkYXRlZCA9IG9wdGlvbnMub25CZWZvcmVFbFVwZGF0ZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uRWxVcGRhdGVkID0gb3B0aW9ucy5vbkVsVXBkYXRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25CZWZvcmVOb2RlRGlzY2FyZGVkID0gb3B0aW9ucy5vbkJlZm9yZU5vZGVEaXNjYXJkZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uTm9kZURpc2NhcmRlZCA9IG9wdGlvbnMub25Ob2RlRGlzY2FyZGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkID0gb3B0aW9ucy5vbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBjaGlsZHJlbk9ubHkgPSBvcHRpb25zLmNoaWxkcmVuT25seSA9PT0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIG9iamVjdCBpcyB1c2VkIGFzIGEgbG9va3VwIHRvIHF1aWNrbHkgZmluZCBhbGwga2V5ZWQgZWxlbWVudHMgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlLlxuICAgICAgICB2YXIgZnJvbU5vZGVzTG9va3VwID0ge307XG4gICAgICAgIHZhciBrZXllZFJlbW92YWxMaXN0O1xuXG4gICAgICAgIGZ1bmN0aW9uIGFkZEtleWVkUmVtb3ZhbChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXllZFJlbW92YWxMaXN0KSB7XG4gICAgICAgICAgICAgICAga2V5ZWRSZW1vdmFsTGlzdC5wdXNoKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleWVkUmVtb3ZhbExpc3QgPSBba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKG5vZGUsIHNraXBLZXllZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1ckNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBLZXllZE5vZGVzICYmIChrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBza2lwcGluZyBrZXllZCBub2RlcyB0aGVuIHdlIGFkZCB0aGUga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhIGxpc3Qgc28gdGhhdCBpdCBjYW4gYmUgaGFuZGxlZCBhdCB0aGUgdmVyeSBlbmQuXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVwb3J0IHRoZSBub2RlIGFzIGRpc2NhcmRlZCBpZiBpdCBpcyBub3Qga2V5ZWQuIFdlIGRvIHRoaXMgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXQgdGhlIGVuZCB3ZSBsb29wIHRocm91Z2ggYWxsIGtleWVkIGVsZW1lbnRzIHRoYXQgd2VyZSB1bm1hdGNoZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGVuIGRpc2NhcmQgdGhlbSBpbiBvbmUgZmluYWwgcGFzcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTm9kZURpc2NhcmRlZChjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyQ2hpbGQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKGN1ckNoaWxkLCBza2lwS2V5ZWROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgRE9NIG5vZGUgb3V0IG9mIHRoZSBvcmlnaW5hbCBET01cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmVcbiAgICAgICAgICogQHBhcmFtICB7Tm9kZX0gcGFyZW50Tm9kZSBUaGUgbm9kZXMgcGFyZW50XG4gICAgICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IHNraXBLZXllZE5vZGVzIElmIHRydWUgdGhlbiBlbGVtZW50cyB3aXRoIGtleXMgd2lsbCBiZSBza2lwcGVkIGFuZCBub3QgZGlzY2FyZGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUsIHBhcmVudE5vZGUsIHNraXBLZXllZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAob25CZWZvcmVOb2RlRGlzY2FyZGVkKG5vZGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQobm9kZSk7XG4gICAgICAgICAgICB3YWxrRGlzY2FyZGVkQ2hpbGROb2Rlcyhub2RlLCBza2lwS2V5ZWROb2Rlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAvLyBUcmVlV2Fsa2VyIGltcGxlbWVudGF0aW9uIGlzIG5vIGZhc3RlciwgYnV0IGtlZXBpbmcgdGhpcyBhcm91bmQgaW4gY2FzZSB0aGlzIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAvLyBmdW5jdGlvbiBpbmRleFRyZWUocm9vdCkge1xuICAgICAgICAvLyAgICAgdmFyIHRyZWVXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKFxuICAgICAgICAvLyAgICAgICAgIHJvb3QsXG4gICAgICAgIC8vICAgICAgICAgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgdmFyIGVsO1xuICAgICAgICAvLyAgICAgd2hpbGUoKGVsID0gdHJlZVdhbGtlci5uZXh0Tm9kZSgpKSkge1xuICAgICAgICAvLyAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGVsKTtcbiAgICAgICAgLy8gICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgIC8vICAgICAgICAgICAgIGZyb21Ob2Rlc0xvb2t1cFtrZXldID0gZWw7XG4gICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gLy8gTm9kZUl0ZXJhdG9yIGltcGxlbWVudGF0aW9uIGlzIG5vIGZhc3RlciwgYnV0IGtlZXBpbmcgdGhpcyBhcm91bmQgaW4gY2FzZSB0aGlzIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAvL1xuICAgICAgICAvLyBmdW5jdGlvbiBpbmRleFRyZWUobm9kZSkge1xuICAgICAgICAvLyAgICAgdmFyIG5vZGVJdGVyYXRvciA9IGRvY3VtZW50LmNyZWF0ZU5vZGVJdGVyYXRvcihub2RlLCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCk7XG4gICAgICAgIC8vICAgICB2YXIgZWw7XG4gICAgICAgIC8vICAgICB3aGlsZSgoZWwgPSBub2RlSXRlcmF0b3IubmV4dE5vZGUoKSkpIHtcbiAgICAgICAgLy8gICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShlbCk7XG4gICAgICAgIC8vICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAvLyAgICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGVsO1xuICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluZGV4VHJlZShub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1ckNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21Ob2Rlc0xvb2t1cFtrZXldID0gY3VyQ2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBXYWxrIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAgICAgICAgIGluZGV4VHJlZShjdXJDaGlsZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleFRyZWUoZnJvbU5vZGUpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZU5vZGVBZGRlZChlbCkge1xuICAgICAgICAgICAgb25Ob2RlQWRkZWQoZWwpO1xuXG4gICAgICAgICAgICB2YXIgY3VyQ2hpbGQgPSBlbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdW5tYXRjaGVkRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bm1hdGNoZWRGcm9tRWwgJiYgY29tcGFyZU5vZGVOYW1lcyhjdXJDaGlsZCwgdW5tYXRjaGVkRnJvbUVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodW5tYXRjaGVkRnJvbUVsLCBjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JwaEVsKHVubWF0Y2hlZEZyb21FbCwgY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaGFuZGxlTm9kZUFkZGVkKGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IG5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbW9ycGhFbChmcm9tRWwsIHRvRWwsIGNoaWxkcmVuT25seSkge1xuICAgICAgICAgICAgdmFyIHRvRWxLZXkgPSBnZXROb2RlS2V5KHRvRWwpO1xuICAgICAgICAgICAgdmFyIGN1ckZyb21Ob2RlS2V5O1xuXG4gICAgICAgICAgICBpZiAodG9FbEtleSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGFuIGVsZW1lbnQgd2l0aCBhbiBJRCBpcyBiZWluZyBtb3JwaGVkIHRoZW4gaXQgaXMgd2lsbCBiZSBpbiB0aGUgZmluYWxcbiAgICAgICAgICAgICAgICAvLyBET00gc28gY2xlYXIgaXQgb3V0IG9mIHRoZSBzYXZlZCBlbGVtZW50cyBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgZGVsZXRlIGZyb21Ob2Rlc0xvb2t1cFt0b0VsS2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvTm9kZS5pc1NhbWVOb2RlICYmIHRvTm9kZS5pc1NhbWVOb2RlKGZyb21Ob2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk9ubHkpIHtcbiAgICAgICAgICAgICAgICBpZiAob25CZWZvcmVFbFVwZGF0ZWQoZnJvbUVsLCB0b0VsKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vcnBoQXR0cnMoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICAgICAgICBvbkVsVXBkYXRlZChmcm9tRWwpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlRWxDaGlsZHJlblVwZGF0ZWQoZnJvbUVsLCB0b0VsKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZyb21FbC5ub2RlTmFtZSAhPT0gJ1RFWFRBUkVBJykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJUb05vZGVDaGlsZCA9IHRvRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB2YXIgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIHZhciBjdXJUb05vZGVLZXk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIHZhciB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGluZ0Zyb21FbDtcblxuICAgICAgICAgICAgICAgIG91dGVyOiB3aGlsZSAoY3VyVG9Ob2RlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9OZXh0U2libGluZyA9IGN1clRvTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBjdXJUb05vZGVLZXkgPSBnZXROb2RlS2V5KGN1clRvTm9kZUNoaWxkKTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VyRnJvbU5vZGVDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbU5leHRTaWJsaW5nID0gY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUNoaWxkLmlzU2FtZU5vZGUgJiYgY3VyVG9Ob2RlQ2hpbGQuaXNTYW1lTm9kZShjdXJGcm9tTm9kZUNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyRnJvbU5vZGVDaGlsZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJGcm9tTm9kZVR5cGUgPSBjdXJGcm9tTm9kZUNoaWxkLm5vZGVUeXBlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNDb21wYXRpYmxlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBjdXJUb05vZGVDaGlsZC5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCb3RoIG5vZGVzIGJlaW5nIGNvbXBhcmVkIGFyZSBFbGVtZW50IG5vZGVzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRhcmdldCBub2RlIGhhcyBhIGtleSBzbyB3ZSB3YW50IHRvIG1hdGNoIGl0IHVwIHdpdGggdGhlIGNvcnJlY3QgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5ICE9PSBjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlIGRvZXMgbm90IGhhdmUgYSBtYXRjaGluZyBrZXkgc29cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBjaGVjayBvdXIgbG9va3VwIHRvIHNlZSBpZiB0aGVyZSBpcyBhIG1hdGNoaW5nIGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRE9NIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG1hdGNoaW5nRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2N1clRvTm9kZUtleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUNoaWxkLm5leHRTaWJsaW5nID09PSBtYXRjaGluZ0Zyb21FbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBzaW5nbGUgZWxlbWVudCByZW1vdmFscy4gVG8gYXZvaWQgcmVtb3ZpbmcgdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBET00gbm9kZSBvdXQgb2YgdGhlIHRyZWUgKHNpbmNlIHRoYXQgY2FuIGJyZWFrIENTUyB0cmFuc2l0aW9ucywgZXRjLiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3aWxsIGluc3RlYWQgZGlzY2FyZCB0aGUgY3VycmVudCBub2RlIGFuZCB3YWl0IHVudGlsIHRoZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRpb24gdG8gcHJvcGVybHkgbWF0Y2ggdXAgdGhlIGtleWVkIHRhcmdldCBlbGVtZW50IHdpdGggaXRzIG1hdGNoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGluIHRoZSBvcmlnaW5hbCB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgbWF0Y2hpbmcga2V5ZWQgZWxlbWVudCBzb21ld2hlcmUgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGV0J3MgbW92aW5nIHRoZSBvcmlnaW5hbCBET00gbm9kZSBpbnRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCBtb3JwaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IFdlIHVzZSBpbnNlcnRCZWZvcmUgaW5zdGVhZCBvZiByZXBsYWNlQ2hpbGQgYmVjYXVzZSB3ZSB3YW50IHRvIGdvIHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBgcmVtb3ZlTm9kZSgpYCBmdW5jdGlvbiBmb3IgdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBkaXNjYXJkZWQgc28gdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIGxpZmVjeWNsZSBob29rcyBhcmUgY29ycmVjdGx5IGludm9rZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21FbC5pbnNlcnRCZWZvcmUobWF0Y2hpbmdGcm9tRWwsIGN1ckZyb21Ob2RlQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tTmV4dFNpYmxpbmcgPSBjdXJGcm9tTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgbm9kZSBpcyBrZXllZCBpdCBtaWdodCBiZSBtYXRjaGVkIHVwIGxhdGVyIHNvIHdlIGRlZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgc3RpbGwgYSBjaGFuY2UgdGhleSB3aWxsIGJlIG1hdGNoZWQgdXAgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQsIGZyb21FbCwgdHJ1ZSAvKiBza2lwIGtleWVkIG5vZGVzICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IG1hdGNoaW5nRnJvbUVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5vZGVzIGFyZSBub3QgY29tcGF0aWJsZSBzaW5jZSB0aGUgXCJ0b1wiIG5vZGUgaGFzIGEga2V5IGFuZCB0aGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBubyBtYXRjaGluZyBrZXllZCBub2RlIGluIHRoZSBzb3VyY2UgdHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvcmlnaW5hbCBoYXMgYSBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gaXNDb21wYXRpYmxlICE9PSBmYWxzZSAmJiBjb21wYXJlTm9kZU5hbWVzKGN1ckZyb21Ob2RlQ2hpbGQsIGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgY29tcGF0aWJsZSBET00gZWxlbWVudHMgc28gdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBcImZyb21cIiBub2RlIHRvIG1hdGNoIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0YXJnZXQgRE9NIG5vZGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3JwaEVsKGN1ckZyb21Ob2RlQ2hpbGQsIGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IFRFWFRfTk9ERSB8fCBjdXJGcm9tTm9kZVR5cGUgPT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJvdGggbm9kZXMgYmVpbmcgY29tcGFyZWQgYXJlIFRleHQgb3IgQ29tbWVudCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW1wbHkgdXBkYXRlIG5vZGVWYWx1ZSBvbiB0aGUgb3JpZ2luYWwgbm9kZSB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIHRleHQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZC5ub2RlVmFsdWUgPSBjdXJUb05vZGVDaGlsZC5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBib3RoIHRoZSBcInRvXCIgY2hpbGQgYW5kIHRoZSBcImZyb21cIiBjaGlsZCBzaW5jZSB3ZSBmb3VuZCBhIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGNvbXBhdGlibGUgbWF0Y2ggc28gcmVtb3ZlIHRoZSBvbGQgbm9kZSBmcm9tIHRoZSBET00gYW5kIGNvbnRpbnVlIHRyeWluZyB0byBmaW5kIGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoIGluIHRoZSBvcmlnaW5hbCBET00uIEhvd2V2ZXIsIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgZnJvbSBub2RlIGlzIG5vdCBrZXllZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgaXQgaXMgcG9zc2libGUgdGhhdCBhIGtleWVkIG5vZGUgbWlnaHQgbWF0Y2ggdXAgd2l0aCBhIG5vZGUgc29tZXdoZXJlIGVsc2UgaW4gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0YXJnZXQgdHJlZSBhbmQgd2UgZG9uJ3Qgd2FudCB0byBkaXNjYXJkIGl0IGp1c3QgeWV0IHNpbmNlIGl0IHN0aWxsIG1pZ2h0IGZpbmQgYVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaG9tZSBpbiB0aGUgZmluYWwgRE9NIHRyZWUuIEFmdGVyIGV2ZXJ5dGhpbmcgaXMgZG9uZSB3ZSB3aWxsIHJlbW92ZSBhbnkga2V5ZWQgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgZGlkbid0IGZpbmQgYSBob21lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgbm9kZSBpcyBrZXllZCBpdCBtaWdodCBiZSBtYXRjaGVkIHVwIGxhdGVyIHNvIHdlIGRlZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgc3RpbGwgYSBjaGFuY2UgdGhleSB3aWxsIGJlIG1hdGNoZWQgdXAgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQsIGZyb21FbCwgdHJ1ZSAvKiBza2lwIGtleWVkIG5vZGVzICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGdvdCB0aGlzIGZhciB0aGVuIHdlIGRpZCBub3QgZmluZCBhIGNhbmRpZGF0ZSBtYXRjaCBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gb3VyIFwidG8gbm9kZVwiIGFuZCB3ZSBleGhhdXN0ZWQgYWxsIG9mIHRoZSBjaGlsZHJlbiBcImZyb21cIlxuICAgICAgICAgICAgICAgICAgICAvLyBub2Rlcy4gVGhlcmVmb3JlLCB3ZSB3aWxsIGp1c3QgYXBwZW5kIHRoZSBjdXJyZW50IFwidG9cIiBub2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBlbmRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUtleSAmJiAobWF0Y2hpbmdGcm9tRWwgPSBmcm9tTm9kZXNMb29rdXBbY3VyVG9Ob2RlS2V5XSkgJiYgY29tcGFyZU5vZGVOYW1lcyhtYXRjaGluZ0Zyb21FbCwgY3VyVG9Ob2RlQ2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tRWwuYXBwZW5kQ2hpbGQobWF0Y2hpbmdGcm9tRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9ycGhFbChtYXRjaGluZ0Zyb21FbCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0ID0gb25CZWZvcmVOb2RlQWRkZWQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVDaGlsZC5hY3R1YWxpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSBjdXJUb05vZGVDaGlsZC5hY3R1YWxpemUoZnJvbUVsLm93bmVyRG9jdW1lbnQgfHwgZG9jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUVsLmFwcGVuZENoaWxkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBvZiB0aGUgXCJ0byBub2Rlc1wiLiBJZiBjdXJGcm9tTm9kZUNoaWxkIGlzXG4gICAgICAgICAgICAgICAgLy8gbm9uLW51bGwgdGhlbiB3ZSBzdGlsbCBoYXZlIHNvbWUgZnJvbSBub2RlcyBsZWZ0IG92ZXIgdGhhdCBuZWVkXG4gICAgICAgICAgICAgICAgLy8gdG8gYmUgcmVtb3ZlZFxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoY3VyRnJvbU5vZGVLZXkgPSBnZXROb2RlS2V5KGN1ckZyb21Ob2RlQ2hpbGQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBzdGlsbCBhIGNoYW5jZSB0aGV5IHdpbGwgYmUgbWF0Y2hlZCB1cCBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzcGVjaWFsRWxIYW5kbGVyID0gc3BlY2lhbEVsSGFuZGxlcnNbZnJvbUVsLm5vZGVOYW1lXTtcbiAgICAgICAgICAgIGlmIChzcGVjaWFsRWxIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lhbEVsSGFuZGxlcihmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IC8vIEVORDogbW9ycGhFbCguLi4pXG5cbiAgICAgICAgdmFyIG1vcnBoZWROb2RlID0gZnJvbU5vZGU7XG4gICAgICAgIHZhciBtb3JwaGVkTm9kZVR5cGUgPSBtb3JwaGVkTm9kZS5ub2RlVHlwZTtcbiAgICAgICAgdmFyIHRvTm9kZVR5cGUgPSB0b05vZGUubm9kZVR5cGU7XG5cbiAgICAgICAgaWYgKCFjaGlsZHJlbk9ubHkpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBhcmUgZ2l2ZW4gdHdvIERPTSBub2RlcyB0aGF0IGFyZSBub3RcbiAgICAgICAgICAgIC8vIGNvbXBhdGlibGUgKGUuZy4gPGRpdj4gLS0+IDxzcGFuPiBvciA8ZGl2PiAtLT4gVEVYVClcbiAgICAgICAgICAgIGlmIChtb3JwaGVkTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIGlmICh0b05vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlTm9kZU5hbWVzKGZyb21Ob2RlLCB0b05vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoZnJvbU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9ycGhlZE5vZGUgPSBtb3ZlQ2hpbGRyZW4oZnJvbU5vZGUsIGNyZWF0ZUVsZW1lbnROUyh0b05vZGUubm9kZU5hbWUsIHRvTm9kZS5uYW1lc3BhY2VVUkkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdvaW5nIGZyb20gYW4gZWxlbWVudCBub2RlIHRvIGEgdGV4dCBub2RlXG4gICAgICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gdG9Ob2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobW9ycGhlZE5vZGVUeXBlID09PSBURVhUX05PREUgfHwgbW9ycGhlZE5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHsgLy8gVGV4dCBvciBjb21tZW50IG5vZGVcbiAgICAgICAgICAgICAgICBpZiAodG9Ob2RlVHlwZSA9PT0gbW9ycGhlZE5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlLm5vZGVWYWx1ZSA9IHRvTm9kZS5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb3JwaGVkTm9kZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUZXh0IG5vZGUgdG8gc29tZXRoaW5nIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgbW9ycGhlZE5vZGUgPSB0b05vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vcnBoZWROb2RlID09PSB0b05vZGUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBcInRvIG5vZGVcIiB3YXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgXCJmcm9tIG5vZGVcIiBzbyB3ZSBoYWQgdG9cbiAgICAgICAgICAgIC8vIHRvc3Mgb3V0IHRoZSBcImZyb20gbm9kZVwiIGFuZCB1c2UgdGhlIFwidG8gbm9kZVwiXG4gICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoZnJvbU5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9ycGhFbChtb3JwaGVkTm9kZSwgdG9Ob2RlLCBjaGlsZHJlbk9ubHkpO1xuXG4gICAgICAgICAgICAvLyBXZSBub3cgbmVlZCB0byBsb29wIG92ZXIgYW55IGtleWVkIG5vZGVzIHRoYXQgbWlnaHQgbmVlZCB0byBiZVxuICAgICAgICAgICAgLy8gcmVtb3ZlZC4gV2Ugb25seSBkbyB0aGUgcmVtb3ZhbCBpZiB3ZSBrbm93IHRoYXQgdGhlIGtleWVkIG5vZGVcbiAgICAgICAgICAgIC8vIG5ldmVyIGZvdW5kIGEgbWF0Y2guIFdoZW4gYSBrZXllZCBub2RlIGlzIG1hdGNoZWQgdXAgd2UgcmVtb3ZlXG4gICAgICAgICAgICAvLyBpdCBvdXQgb2YgZnJvbU5vZGVzTG9va3VwIGFuZCB3ZSB1c2UgZnJvbU5vZGVzTG9va3VwIHRvIGRldGVybWluZVxuICAgICAgICAgICAgLy8gaWYgYSBrZXllZCBub2RlIGhhcyBiZWVuIG1hdGNoZWQgdXAgb3Igbm90XG4gICAgICAgICAgICBpZiAoa2V5ZWRSZW1vdmFsTGlzdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MCwgbGVuPWtleWVkUmVtb3ZhbExpc3QubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbFRvUmVtb3ZlID0gZnJvbU5vZGVzTG9va3VwW2tleWVkUmVtb3ZhbExpc3RbaV1dO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxUb1JlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShlbFRvUmVtb3ZlLCBlbFRvUmVtb3ZlLnBhcmVudE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2hpbGRyZW5Pbmx5ICYmIG1vcnBoZWROb2RlICE9PSBmcm9tTm9kZSAmJiBmcm9tTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBpZiAobW9ycGhlZE5vZGUuYWN0dWFsaXplKSB7XG4gICAgICAgICAgICAgICAgbW9ycGhlZE5vZGUgPSBtb3JwaGVkTm9kZS5hY3R1YWxpemUoZnJvbU5vZGUub3duZXJEb2N1bWVudCB8fCBkb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgaGFkIHRvIHN3YXAgb3V0IHRoZSBmcm9tIG5vZGUgd2l0aCBhIG5ldyBub2RlIGJlY2F1c2UgdGhlIG9sZFxuICAgICAgICAgICAgLy8gbm9kZSB3YXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgdGFyZ2V0IG5vZGUgdGhlbiB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBvbGQgRE9NIG5vZGUgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlLiBUaGlzIGlzIG9ubHlcbiAgICAgICAgICAgIC8vIHBvc3NpYmxlIGlmIHRoZSBvcmlnaW5hbCBET00gbm9kZSB3YXMgcGFydCBvZiBhIERPTSB0cmVlIHdoaWNoXG4gICAgICAgICAgICAvLyB3ZSBrbm93IGlzIHRoZSBjYXNlIGlmIGl0IGhhcyBhIHBhcmVudCBub2RlLlxuICAgICAgICAgICAgZnJvbU5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobW9ycGhlZE5vZGUsIGZyb21Ob2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb3JwaGVkTm9kZTtcbiAgICB9O1xufVxuXG52YXIgbW9ycGhkb20gPSBtb3JwaGRvbUZhY3RvcnkobW9ycGhBdHRycyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbW9ycGhkb207XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWYWxpZGF0b3IgPSByZXF1aXJlKCdtdHlwZS10djQnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ21vanVsZS11dGlscycpO1xudmFyIHNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hJyk7XG5cbnZhciBpZCA9IHV0aWxzLmlkO1xuXG5cbnZhciB2YWxpZGF0b3IgPSBWYWxpZGF0b3Ioc2NoZW1hKTtcbnZhciB0ID0gVmFsaWRhdG9yLm10eXBlKHZhbGlkYXRvcik7XG5cbnZhciBFbnRpdHlOb2RlVmFsdWUgPSBmdW5jdGlvbiBFbnRpdHlOb2RlVmFsdWUoKSB7XG4gIHZhciBub2RlVHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ2VudGl0eU5vZGUnO1xuICB2YXIgYWRkaXRpb25hbFZhbHVlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgdmFyIHZhbHVlID0gT2JqZWN0LmFzc2lnbih7IG5vZGVUeXBlOiBub2RlVHlwZSB9LCBhZGRpdGlvbmFsVmFsdWVzKTtcblxuICBpZiAodHlwZW9mIHZhbHVlLl9pZCAhPT0gJ3N0cmluZycpIHZhbHVlLl9pZCA9IGlkKHZhbHVlLm5vZGVUeXBlKTtcblxuICBpZiAoIXQuaXModmFsdWUsICdlbnRpdHlOb2RlVmFsdWUnKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNyZWF0ZSBhbiBlbnRpdHlOb2RlVmFsdWUgd2l0aCB0aG9zZSBhcmd1bWVudHMnKTtcblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgRW50aXR5Tm9kZSA9IGZ1bmN0aW9uIEVudGl0eU5vZGUoKSB7XG4gIHZhciBub2RlVHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ2VudGl0eU5vZGUnO1xuICB2YXIgYWRkaXRpb25hbFZhbHVlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgdmFyIHZhbHVlID0gRW50aXR5Tm9kZVZhbHVlKG5vZGVUeXBlLCBhZGRpdGlvbmFsVmFsdWVzKTtcbiAgdmFyIGNoaWxkcmVuID0gW107XG5cbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBjaGlsZHJlbjogY2hpbGRyZW4gfTtcbn07XG5cbkVudGl0eU5vZGUuVmFsdWUgPSBFbnRpdHlOb2RlVmFsdWU7XG5FbnRpdHlOb2RlLm10eXBlID0gdDtcblxubW9kdWxlLmV4cG9ydHMgPSBFbnRpdHlOb2RlOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVudGl0eU5vZGUgPSByZXF1aXJlKCcuLi9zY2hlbWEvZW50aXR5Tm9kZS5zY2hlbWEuanNvbicpO1xudmFyIGVudGl0eU5vZGVWYWx1ZSA9IHJlcXVpcmUoJy4uL3NjaGVtYS9lbnRpdHlOb2RlVmFsdWUuc2NoZW1hLmpzb24nKTtcbnZhciBlbXB0eU5vZGUgPSByZXF1aXJlKCcuLi9zY2hlbWEvZW1wdHlOb2RlLnNjaGVtYS5qc29uJyk7XG52YXIgcGFyZW50Tm9kZSA9IHJlcXVpcmUoJy4uL3NjaGVtYS9wYXJlbnROb2RlLnNjaGVtYS5qc29uJyk7XG5cbnZhciBzY2hlbWEgPSB7XG4gIGVudGl0eU5vZGU6IGVudGl0eU5vZGUsIGVudGl0eU5vZGVWYWx1ZTogZW50aXR5Tm9kZVZhbHVlLCBlbXB0eU5vZGU6IGVtcHR5Tm9kZSwgcGFyZW50Tm9kZTogcGFyZW50Tm9kZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzY2hlbWE7IiwibW9kdWxlLmV4cG9ydHM9e1xuICBcImlkXCI6IFwiZW1wdHlOb2RlXCIsXG4gIFwiYWxsT2ZcIjogW1xuICAgIHsgXCIkcmVmXCI6IFwiZW50aXR5Tm9kZVwiIH0sXG4gICAge1xuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJ2YWx1ZVwiOiB7IFwiJHJlZlwiOiBcImVudGl0eU5vZGVWYWx1ZVwiIH0sXG4gICAgICAgIFwiY2hpbGRyZW5cIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgXCJtYXhMZW5ndGhcIjogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBdXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiaWRcIjogXCJlbnRpdHlOb2RlXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwidmFsdWVcIjogeyBcIiRyZWZcIjogXCJlbnRpdHlOb2RlVmFsdWVcIiB9XG4gIH0sXG4gIFwicmVxdWlyZWRcIjogWyBcInZhbHVlXCIgXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcImlkXCI6IFwiZW50aXR5Tm9kZVZhbHVlXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiX2lkXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJtaW5MZW5ndGhcIjogMVxuICAgIH0sXG4gICAgXCJub2RlVHlwZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwibWluTGVuZ3RoXCI6IDFcbiAgICB9XG4gIH0sXG4gIFwicmVxdWlyZWRcIjogWyBcIl9pZFwiLCBcIm5vZGVUeXBlXCIgXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcImlkXCI6IFwicGFyZW50Tm9kZVwiLFxuICBcImFsbE9mXCI6IFtcbiAgICB7IFwiJHJlZlwiOiBcImVudGl0eU5vZGVcIiB9LFxuICAgIHtcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwiY2hpbGRyZW5cIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgXCJpdGVtc1wiOiB7IFwiJHJlZlwiOiBcImVudGl0eU5vZGVcIiB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IFsgXCJjaGlsZHJlblwiIF1cbiAgICB9XG4gIF1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHR2NCA9IHJlcXVpcmUoJ3R2NCcpO1xudmFyIFQgPSByZXF1aXJlKCdtdHlwZScpO1xuXG52YXIgVmFsaWRhdG9yID0gZnVuY3Rpb24gVmFsaWRhdG9yKCkge1xuICB2YXIgc2NoZW1hID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICB2YXIgdmFsaWRhdG9yID0gdHY0LmZyZXNoQXBpKCk7XG5cbiAgdmFyIHNjaGVtYXMgPSBPYmplY3Qua2V5cyhzY2hlbWEpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBzY2hlbWFbbmFtZV07XG4gIH0pO1xuXG4gIHNjaGVtYXMuZm9yRWFjaChmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRvci5hZGRTY2hlbWEoc2NoZW1hKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHZhbGlkYXRvcjtcbn07XG5cblZhbGlkYXRvci5tdHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZhbGlkYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogVmFsaWRhdG9yKCk7XG5cbiAgdmFyIHNjaGVtYU5hbWVzID0gdmFsaWRhdG9yLmdldFNjaGVtYVVyaXMoKTtcblxuICB2YXIgaXMgPSBzY2hlbWFOYW1lcy5yZWR1Y2UoZnVuY3Rpb24gKG1hcCwgbmFtZSkge1xuICAgIG1hcFtuYW1lXSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB2YWxpZGF0b3IudmFsaWRhdGUob2JqLCBuYW1lKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIG1hcDtcbiAgfSwge30pO1xuXG4gIHJldHVybiBUKGlzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmFsaWRhdG9yOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGpzb25QcmVkaWNhdGVzID0gcmVxdWlyZSgnLi9qc29uLXByZWRpY2F0ZXMnKTtcblxudmFyIG10eXBlID0gZnVuY3Rpb24gbXR5cGUodHlwZVByZWRpY2F0ZXMpIHtcbiAgdHlwZVByZWRpY2F0ZXMgPSB0eXBlUHJlZGljYXRlcyB8fCBqc29uUHJlZGljYXRlcztcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHR5cGVQcmVkaWNhdGVzKTtcblxuICB2YXIgaXMgPSBmdW5jdGlvbiBpcyhzdWJqZWN0LCB0eXBlbmFtZSkge1xuICAgIHJldHVybiB0eXBlUHJlZGljYXRlc1t0eXBlbmFtZV0gJiYgdHlwZVByZWRpY2F0ZXNbdHlwZW5hbWVdKHN1YmplY3QpO1xuICB9O1xuXG4gIHZhciBpc09ubHkgPSBmdW5jdGlvbiBpc09ubHkoc3ViamVjdCwgdHlwZW5hbWUpIHtcbiAgICByZXR1cm4gaXMoc3ViamVjdCwgdHlwZW5hbWUpICYmIGFsbE9mKHN1YmplY3QpLmxlbmd0aCA9PT0gMTtcbiAgfTtcblxuICB2YXIgc29tZSA9IGZ1bmN0aW9uIHNvbWUoc3ViamVjdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlbmFtZXMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICB0eXBlbmFtZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlbmFtZXMuc29tZShmdW5jdGlvbiAodHlwZW5hbWUpIHtcbiAgICAgIHJldHVybiBpcyhzdWJqZWN0LCB0eXBlbmFtZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGV2ZXJ5ID0gZnVuY3Rpb24gZXZlcnkoc3ViamVjdCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZW5hbWVzID0gQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgdHlwZW5hbWVzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlbmFtZXMuZXZlcnkoZnVuY3Rpb24gKHR5cGVuYW1lKSB7XG4gICAgICByZXR1cm4gaXMoc3ViamVjdCwgdHlwZW5hbWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBvZiA9IGZ1bmN0aW9uIG9mKHN1YmplY3QpIHtcbiAgICByZXR1cm4ga2V5cy5maW5kKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBpcyhzdWJqZWN0LCBrZXkpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBhbGxPZiA9IGZ1bmN0aW9uIGFsbE9mKHN1YmplY3QpIHtcbiAgICByZXR1cm4ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGlzKHN1YmplY3QsIGtleSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHR5cGVzID0gZnVuY3Rpb24gdHlwZXMoKSB7XG4gICAgcmV0dXJuIGtleXMuc2xpY2UoKTtcbiAgfTtcblxuICByZXR1cm4geyBpczogaXMsIGlzT25seTogaXNPbmx5LCBzb21lOiBzb21lLCBldmVyeTogZXZlcnksIG9mOiBvZiwgYWxsT2Y6IGFsbE9mLCB0eXBlczogdHlwZXMgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbXR5cGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBqc29uUHJlZGljYXRlcyA9IHtcbiAgbnVtYmVyOiBmdW5jdGlvbiBudW1iZXIoc3ViamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygc3ViamVjdCA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoc3ViamVjdCk7XG4gIH0sXG4gIHN0cmluZzogZnVuY3Rpb24gc3RyaW5nKHN1YmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdzdHJpbmcnO1xuICB9LFxuICBib29sZWFuOiBmdW5jdGlvbiBib29sZWFuKHN1YmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdib29sZWFuJztcbiAgfSxcbiAgYXJyYXk6IGZ1bmN0aW9uIGFycmF5KHN1YmplY3QpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShzdWJqZWN0KTtcbiAgfSxcbiAgbnVsbDogZnVuY3Rpb24gX251bGwoc3ViamVjdCkge1xuICAgIHJldHVybiBzdWJqZWN0ID09PSBudWxsO1xuICB9LFxuICBvYmplY3Q6IGZ1bmN0aW9uIG9iamVjdChzdWJqZWN0KSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygc3ViamVjdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3ViamVjdCkpID09PSAnb2JqZWN0JyAmJiAhanNvblByZWRpY2F0ZXMubnVsbChzdWJqZWN0KSAmJiAhanNvblByZWRpY2F0ZXMuYXJyYXkoc3ViamVjdCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ganNvblByZWRpY2F0ZXM7IiwibW9kdWxlLmV4cG9ydHMgPSBjb21waWxlO1xuXG52YXIgQmFzZUZ1bmNzID0gcmVxdWlyZShcImJvb2xiYXNlXCIpLFxuICAgIHRydWVGdW5jICA9IEJhc2VGdW5jcy50cnVlRnVuYyxcbiAgICBmYWxzZUZ1bmMgPSBCYXNlRnVuY3MuZmFsc2VGdW5jO1xuXG4vKlxuXHRyZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYW4gZWxlbWVudHMgaW5kZXggbWF0Y2hlcyB0aGUgZ2l2ZW4gcnVsZVxuXHRoaWdobHkgb3B0aW1pemVkIHRvIHJldHVybiB0aGUgZmFzdGVzdCBzb2x1dGlvblxuKi9cbmZ1bmN0aW9uIGNvbXBpbGUocGFyc2VkKXtcblx0dmFyIGEgPSBwYXJzZWRbMF0sXG5cdCAgICBiID0gcGFyc2VkWzFdIC0gMTtcblxuXHQvL3doZW4gYiA8PSAwLCBhKm4gd29uJ3QgYmUgcG9zc2libGUgZm9yIGFueSBtYXRjaGVzIHdoZW4gYSA8IDBcblx0Ly9iZXNpZGVzLCB0aGUgc3BlY2lmaWNhdGlvbiBzYXlzIHRoYXQgbm8gZWxlbWVudCBpcyBtYXRjaGVkIHdoZW4gYSBhbmQgYiBhcmUgMFxuXHRpZihiIDwgMCAmJiBhIDw9IDApIHJldHVybiBmYWxzZUZ1bmM7XG5cblx0Ly93aGVuIGEgaXMgaW4gdGhlIHJhbmdlIC0xLi4xLCBpdCBtYXRjaGVzIGFueSBlbGVtZW50IChzbyBvbmx5IGIgaXMgY2hlY2tlZClcblx0aWYoYSA9PT0tMSkgcmV0dXJuIGZ1bmN0aW9uKHBvcyl7IHJldHVybiBwb3MgPD0gYjsgfTtcblx0aWYoYSA9PT0gMCkgcmV0dXJuIGZ1bmN0aW9uKHBvcyl7IHJldHVybiBwb3MgPT09IGI7IH07XG5cdC8vd2hlbiBiIDw9IDAgYW5kIGEgPT09IDEsIHRoZXkgbWF0Y2ggYW55IGVsZW1lbnRcblx0aWYoYSA9PT0gMSkgcmV0dXJuIGIgPCAwID8gdHJ1ZUZ1bmMgOiBmdW5jdGlvbihwb3MpeyByZXR1cm4gcG9zID49IGI7IH07XG5cblx0Ly93aGVuIGEgPiAwLCBtb2R1bG8gY2FuIGJlIHVzZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgYSBtYXRjaFxuXHR2YXIgYk1vZCA9IGIgJSBhO1xuXHRpZihiTW9kIDwgMCkgYk1vZCArPSBhO1xuXG5cdGlmKGEgPiAxKXtcblx0XHRyZXR1cm4gZnVuY3Rpb24ocG9zKXtcblx0XHRcdHJldHVybiBwb3MgPj0gYiAmJiBwb3MgJSBhID09PSBiTW9kO1xuXHRcdH07XG5cdH1cblxuXHRhICo9IC0xOyAvL21ha2UgYGFgIHBvc2l0aXZlXG5cblx0cmV0dXJuIGZ1bmN0aW9uKHBvcyl7XG5cdFx0cmV0dXJuIHBvcyA8PSBiICYmIHBvcyAlIGEgPT09IGJNb2Q7XG5cdH07XG59IiwidmFyIHBhcnNlID0gcmVxdWlyZShcIi4vcGFyc2UuanNcIiksXG4gICAgY29tcGlsZSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbnRoQ2hlY2soZm9ybXVsYSl7XG5cdHJldHVybiBjb21waWxlKHBhcnNlKGZvcm11bGEpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5tb2R1bGUuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZTsiLCJtb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xuXG4vL2ZvbGxvd2luZyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jbnRoLWNoaWxkLXBzZXVkb1xuXG4vL1sgWyctJ3wnKyddPyBJTlRFR0VSPyB7Tn0gWyBTKiBbJy0nfCcrJ10gUyogSU5URUdFUiBdP1xudmFyIHJlX250aEVsZW1lbnQgPSAvXihbK1xcLV0/XFxkKm4pP1xccyooPzooWytcXC1dPylcXHMqKFxcZCspKT8kLztcblxuLypcblx0cGFyc2VzIGEgbnRoLWNoZWNrIGZvcm11bGEsIHJldHVybnMgYW4gYXJyYXkgb2YgdHdvIG51bWJlcnNcbiovXG5mdW5jdGlvbiBwYXJzZShmb3JtdWxhKXtcblx0Zm9ybXVsYSA9IGZvcm11bGEudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cblx0aWYoZm9ybXVsYSA9PT0gXCJldmVuXCIpe1xuXHRcdHJldHVybiBbMiwgMF07XG5cdH0gZWxzZSBpZihmb3JtdWxhID09PSBcIm9kZFwiKXtcblx0XHRyZXR1cm4gWzIsIDFdO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBwYXJzZWQgPSBmb3JtdWxhLm1hdGNoKHJlX250aEVsZW1lbnQpO1xuXG5cdFx0aWYoIXBhcnNlZCl7XG5cdFx0XHR0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJuLXRoIHJ1bGUgY291bGRuJ3QgYmUgcGFyc2VkICgnXCIgKyBmb3JtdWxhICsgXCInKVwiKTtcblx0XHR9XG5cblx0XHR2YXIgYTtcblxuXHRcdGlmKHBhcnNlZFsxXSl7XG5cdFx0XHRhID0gcGFyc2VJbnQocGFyc2VkWzFdLCAxMCk7XG5cdFx0XHRpZihpc05hTihhKSl7XG5cdFx0XHRcdGlmKHBhcnNlZFsxXS5jaGFyQXQoMCkgPT09IFwiLVwiKSBhID0gLTE7XG5cdFx0XHRcdGVsc2UgYSA9IDE7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGEgPSAwO1xuXG5cdFx0cmV0dXJuIFtcblx0XHRcdGEsXG5cdFx0XHRwYXJzZWRbM10gPyBwYXJzZUludCgocGFyc2VkWzJdIHx8IFwiXCIpICsgcGFyc2VkWzNdLCAxMCkgOiAwXG5cdFx0XTtcblx0fVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IG5leHRUaWNrO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLm5leHRUaWNrO1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcIilcbiIsIi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxudmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5mb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzc05leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59IiwiLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbTtcbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbiAgfSBjYXRjaCAoXykge30gZmluYWxseSB7XG4gICAgaWYgKCFTdHJlYW0pIFN0cmVhbSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiAgfVxufSkoKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gICAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gICAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAgIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+IH50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBidWZmZXJTaGltLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBfZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIF9lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNraXBBZGQ7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgc2tpcEFkZCA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIGNodW5rLmxlbmd0aCA9PT0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhZGRUb0Zyb250KSBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIERvbid0IGFkZCB0byB0aGUgYnVmZmVyIGlmIHdlJ3ZlIGRlY29kZWQgdG8gYW4gZW1wdHkgc3RyaW5nIGNodW5rIGFuZFxuICAgICAgLy8gd2UncmUgbm90IGluIG9iamVjdCBtb2RlXG4gICAgICBpZiAoIXNraXBBZGQpIHtcbiAgICAgICAgLy8gaWYgd2Ugd2FudCB0aGUgZGF0YSBub3csIGp1c3QgZW1pdCBpdC5cbiAgICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHByb2Nlc3NOZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3NOZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzTmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uIChldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gYnVmZmVyU2hpbS5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCIvLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0aGlzLndyaXRlZW5jb2RpbmcgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKHRoaXMpO1xuXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub25jZSgncHJlZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgICB9KTtlbHNlIGRvbmUoc3RyZWFtKTtcbiAgfSk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHByb2Nlc3NOZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtO1xuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBTdHJlYW0gPSByZXF1aXJlKCdzdCcgKyAncmVhbScpO1xuICB9IGNhdGNoIChfKSB7fSBmaW5hbGx5IHtcbiAgICBpZiAoIVN0cmVhbSkgU3RyZWFtID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuICB9XG59KSgpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGJ1ZmZlclNoaW0gPSByZXF1aXJlKCdidWZmZXItc2hpbXMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfiB+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuICAvLyBBbHdheXMgdGhyb3cgZXJyb3IgaWYgYSBudWxsIGlzIHdyaXR0ZW5cbiAgLy8gaWYgd2UgYXJlIG5vdCBpbiBvYmplY3QgbW9kZSB0aGVuIHRocm93XG4gIC8vIGlmIGl0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBvciB1bmRlZmluZWQuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAodmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gYnVmZmVyU2hpbS5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcbiAgaWYgKHN5bmMpIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO2Vsc2UgY2IoZXIpO1xuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCkge1xuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzc05leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcblxuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICB2YXIgZW50cnkgPSBfdGhpcy5lbnRyeTtcbiAgICBfdGhpcy5lbnRyeSA9IG51bGw7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgICAgY2IoZXJyKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBfdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gX3RoaXM7XG4gICAgfVxuICB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYnVmZmVyU2hpbSA9IHJlcXVpcmUoJ2J1ZmZlci1zaGltcycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyTGlzdDtcblxuZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgdGhpcy5oZWFkID0gbnVsbDtcbiAgdGhpcy50YWlsID0gbnVsbDtcbiAgdGhpcy5sZW5ndGggPSAwO1xufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHYpIHtcbiAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgdGhpcy50YWlsID0gZW50cnk7XG4gICsrdGhpcy5sZW5ndGg7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKHYpIHtcbiAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgdGhpcy5oZWFkID0gZW50cnk7XG4gICsrdGhpcy5sZW5ndGg7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gIC0tdGhpcy5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgdGhpcy5sZW5ndGggPSAwO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIChzKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHJldCArPSBzICsgcC5kYXRhO1xuICB9cmV0dXJuIHJldDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIChuKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGJ1ZmZlclNoaW0uYWxsb2MoMCk7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICB2YXIgcmV0ID0gYnVmZmVyU2hpbS5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKHApIHtcbiAgICBwLmRhdGEuY29weShyZXQsIGkpO1xuICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICBwID0gcC5uZXh0O1xuICB9XG4gIHJldHVybiByZXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanNcIilcbiIsInZhciBTdHJlYW0gPSAoZnVuY3Rpb24gKCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ3N0JyArICdyZWFtJyk7IC8vIGhhY2sgdG8gZml4IGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBpc3N1ZSB3aGVuIHVzZWQgd2l0aCBicm93c2VyaWZ5XG4gIH0gY2F0Y2goXyl7fVxufSgpKTtcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gU3RyZWFtIHx8IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuXG5pZiAoIXByb2Nlc3MuYnJvd3NlciAmJiBwcm9jZXNzLmVudi5SRUFEQUJMRV9TVFJFQU0gPT09ICdkaXNhYmxlJyAmJiBTdHJlYW0pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1wiKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV93cml0YWJsZS5qc1wiKVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGlzQnVmZmVyRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH1cblxuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4vL1xuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbi8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cbnZhciBTdHJpbmdEZWNvZGVyID0gZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XG4gIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cbiIsInZhciBzaSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicsIHRpY2s7XG5pZiAoc2kpIHtcbiAgdGljayA9IGZ1bmN0aW9uIChmbikgeyBzZXRJbW1lZGlhdGUoZm4pOyB9O1xufSBlbHNlIHtcbiAgdGljayA9IGZ1bmN0aW9uIChmbikgeyBzZXRUaW1lb3V0KGZuLCAwKTsgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0aWNrOyIsIi8qXG5BdXRob3I6IEdlcmFpbnQgTHVmZiBhbmQgb3RoZXJzXG5ZZWFyOiAyMDEzXG5cblRoaXMgY29kZSBpcyByZWxlYXNlZCBpbnRvIHRoZSBcInB1YmxpYyBkb21haW5cIiBieSBpdHMgYXV0aG9yKHMpLiAgQW55Ym9keSBtYXkgdXNlLCBhbHRlciBhbmQgZGlzdHJpYnV0ZSB0aGUgY29kZSB3aXRob3V0IHJlc3RyaWN0aW9uLiAgVGhlIGF1dGhvciBtYWtlcyBubyBndWFyYW50ZWVzLCBhbmQgdGFrZXMgbm8gbGlhYmlsaXR5IG9mIGFueSBraW5kIGZvciB1c2Ugb2YgdGhpcyBjb2RlLlxuXG5JZiB5b3UgZmluZCBhIGJ1ZyBvciBtYWtlIGFuIGltcHJvdmVtZW50LCBpdCB3b3VsZCBiZSBjb3VydGVvdXMgdG8gbGV0IHRoZSBhdXRob3Iga25vdywgYnV0IGl0IGlzIG5vdCBjb21wdWxzb3J5LlxuKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyl7XG4gICAgLy8gQ29tbW9uSlMuIERlZmluZSBleHBvcnQuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgZ2xvYmFsLnR2NCA9IGZhY3RvcnkoKTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9rZXlzP3JlZGlyZWN0bG9jYWxlPWVuLVVTJnJlZGlyZWN0c2x1Zz1KYXZhU2NyaXB0JTJGUmVmZXJlbmNlJTJGR2xvYmFsX09iamVjdHMlMkZPYmplY3QlMkZrZXlzXG5pZiAoIU9iamVjdC5rZXlzKSB7XG5cdE9iamVjdC5rZXlzID0gKGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuXHRcdFx0aGFzRG9udEVudW1CdWcgPSAhKHt0b1N0cmluZzogbnVsbH0pLnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpLFxuXHRcdFx0ZG9udEVudW1zID0gW1xuXHRcdFx0XHQndG9TdHJpbmcnLFxuXHRcdFx0XHQndG9Mb2NhbGVTdHJpbmcnLFxuXHRcdFx0XHQndmFsdWVPZicsXG5cdFx0XHRcdCdoYXNPd25Qcm9wZXJ0eScsXG5cdFx0XHRcdCdpc1Byb3RvdHlwZU9mJyxcblx0XHRcdFx0J3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcblx0XHRcdFx0J2NvbnN0cnVjdG9yJ1xuXHRcdFx0XSxcblx0XHRcdGRvbnRFbnVtc0xlbmd0aCA9IGRvbnRFbnVtcy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0aWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmogIT09ICdmdW5jdGlvbicgfHwgb2JqID09PSBudWxsKSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBub24tb2JqZWN0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciByZXN1bHQgPSBbXTtcblxuXHRcdFx0Zm9yICh2YXIgcHJvcCBpbiBvYmopIHtcblx0XHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKHByb3ApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoYXNEb250RW51bUJ1Zykge1xuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGkgPCBkb250RW51bXNMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgZG9udEVudW1zW2ldKSkge1xuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goZG9udEVudW1zW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblx0fSkoKTtcbn1cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGVcbmlmICghT2JqZWN0LmNyZWF0ZSkge1xuXHRPYmplY3QuY3JlYXRlID0gKGZ1bmN0aW9uKCl7XG5cdFx0ZnVuY3Rpb24gRigpe31cblxuXHRcdHJldHVybiBmdW5jdGlvbihvKXtcblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignT2JqZWN0LmNyZWF0ZSBpbXBsZW1lbnRhdGlvbiBvbmx5IGFjY2VwdHMgb25lIHBhcmFtZXRlci4nKTtcblx0XHRcdH1cblx0XHRcdEYucHJvdG90eXBlID0gbztcblx0XHRcdHJldHVybiBuZXcgRigpO1xuXHRcdH07XG5cdH0pKCk7XG59XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5P3JlZGlyZWN0bG9jYWxlPWVuLVVTJnJlZGlyZWN0c2x1Zz1KYXZhU2NyaXB0JTJGUmVmZXJlbmNlJTJGR2xvYmFsX09iamVjdHMlMkZBcnJheSUyRmlzQXJyYXlcbmlmKCFBcnJheS5pc0FycmF5KSB7XG5cdEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbiAodkFyZykge1xuXHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodkFyZykgPT09IFwiW29iamVjdCBBcnJheV1cIjtcblx0fTtcbn1cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2Y/cmVkaXJlY3Rsb2NhbGU9ZW4tVVMmcmVkaXJlY3RzbHVnPUphdmFTY3JpcHQlMkZSZWZlcmVuY2UlMkZHbG9iYWxfT2JqZWN0cyUyRkFycmF5JTJGaW5kZXhPZlxuaWYgKCFBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuXHRBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8gKSB7XG5cdFx0aWYgKHRoaXMgPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblx0XHR9XG5cdFx0dmFyIHQgPSBPYmplY3QodGhpcyk7XG5cdFx0dmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG5cdFx0aWYgKGxlbiA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH1cblx0XHR2YXIgbiA9IDA7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRuID0gTnVtYmVyKGFyZ3VtZW50c1sxXSk7XG5cdFx0XHRpZiAobiAhPT0gbikgeyAvLyBzaG9ydGN1dCBmb3IgdmVyaWZ5aW5nIGlmIGl0J3MgTmFOXG5cdFx0XHRcdG4gPSAwO1xuXHRcdFx0fSBlbHNlIGlmIChuICE9PSAwICYmIG4gIT09IEluZmluaXR5ICYmIG4gIT09IC1JbmZpbml0eSkge1xuXHRcdFx0XHRuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobiA+PSBsZW4pIHtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9XG5cdFx0dmFyIGsgPSBuID49IDAgPyBuIDogTWF0aC5tYXgobGVuIC0gTWF0aC5hYnMobiksIDApO1xuXHRcdGZvciAoOyBrIDwgbGVuOyBrKyspIHtcblx0XHRcdGlmIChrIGluIHQgJiYgdFtrXSA9PT0gc2VhcmNoRWxlbWVudCkge1xuXHRcdFx0XHRyZXR1cm4gaztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9O1xufVxuXG4vLyBHcnVuZ2V5IE9iamVjdC5pc0Zyb3plbiBoYWNrXG5pZiAoIU9iamVjdC5pc0Zyb3plbikge1xuXHRPYmplY3QuaXNGcm96ZW4gPSBmdW5jdGlvbiAob2JqKSB7XG5cdFx0dmFyIGtleSA9IFwidHY0X3Rlc3RfZnJvemVuX2tleVwiO1xuXHRcdHdoaWxlIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0a2V5ICs9IE1hdGgucmFuZG9tKCk7XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRvYmpba2V5XSA9IHRydWU7XG5cdFx0XHRkZWxldGUgb2JqW2tleV07XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9O1xufVxuLy8gQmFzZWQgb246IGh0dHBzOi8vZ2l0aHViLmNvbS9nZXJhaW50bHVmZi91cmktdGVtcGxhdGVzLCBidXQgd2l0aCBhbGwgdGhlIGRlLXN1YnN0aXR1dGlvbiBzdHVmZiByZW1vdmVkXG5cbnZhciB1cmlUZW1wbGF0ZUdsb2JhbE1vZGlmaWVycyA9IHtcblx0XCIrXCI6IHRydWUsXG5cdFwiI1wiOiB0cnVlLFxuXHRcIi5cIjogdHJ1ZSxcblx0XCIvXCI6IHRydWUsXG5cdFwiO1wiOiB0cnVlLFxuXHRcIj9cIjogdHJ1ZSxcblx0XCImXCI6IHRydWVcbn07XG52YXIgdXJpVGVtcGxhdGVTdWZmaWNlcyA9IHtcblx0XCIqXCI6IHRydWVcbn07XG5cbmZ1bmN0aW9uIG5vdFJlYWxseVBlcmNlbnRFbmNvZGUoc3RyaW5nKSB7XG5cdHJldHVybiBlbmNvZGVVUkkoc3RyaW5nKS5yZXBsYWNlKC8lMjVbMC05XVswLTldL2csIGZ1bmN0aW9uIChkb3VibGVFbmNvZGVkKSB7XG5cdFx0cmV0dXJuIFwiJVwiICsgZG91YmxlRW5jb2RlZC5zdWJzdHJpbmcoMyk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiB1cmlUZW1wbGF0ZVN1YnN0aXR1dGlvbihzcGVjKSB7XG5cdHZhciBtb2RpZmllciA9IFwiXCI7XG5cdGlmICh1cmlUZW1wbGF0ZUdsb2JhbE1vZGlmaWVyc1tzcGVjLmNoYXJBdCgwKV0pIHtcblx0XHRtb2RpZmllciA9IHNwZWMuY2hhckF0KDApO1xuXHRcdHNwZWMgPSBzcGVjLnN1YnN0cmluZygxKTtcblx0fVxuXHR2YXIgc2VwYXJhdG9yID0gXCJcIjtcblx0dmFyIHByZWZpeCA9IFwiXCI7XG5cdHZhciBzaG91bGRFc2NhcGUgPSB0cnVlO1xuXHR2YXIgc2hvd1ZhcmlhYmxlcyA9IGZhbHNlO1xuXHR2YXIgdHJpbUVtcHR5U3RyaW5nID0gZmFsc2U7XG5cdGlmIChtb2RpZmllciA9PT0gJysnKSB7XG5cdFx0c2hvdWxkRXNjYXBlID0gZmFsc2U7XG5cdH0gZWxzZSBpZiAobW9kaWZpZXIgPT09IFwiLlwiKSB7XG5cdFx0cHJlZml4ID0gXCIuXCI7XG5cdFx0c2VwYXJhdG9yID0gXCIuXCI7XG5cdH0gZWxzZSBpZiAobW9kaWZpZXIgPT09IFwiL1wiKSB7XG5cdFx0cHJlZml4ID0gXCIvXCI7XG5cdFx0c2VwYXJhdG9yID0gXCIvXCI7XG5cdH0gZWxzZSBpZiAobW9kaWZpZXIgPT09ICcjJykge1xuXHRcdHByZWZpeCA9IFwiI1wiO1xuXHRcdHNob3VsZEVzY2FwZSA9IGZhbHNlO1xuXHR9IGVsc2UgaWYgKG1vZGlmaWVyID09PSAnOycpIHtcblx0XHRwcmVmaXggPSBcIjtcIjtcblx0XHRzZXBhcmF0b3IgPSBcIjtcIjtcblx0XHRzaG93VmFyaWFibGVzID0gdHJ1ZTtcblx0XHR0cmltRW1wdHlTdHJpbmcgPSB0cnVlO1xuXHR9IGVsc2UgaWYgKG1vZGlmaWVyID09PSAnPycpIHtcblx0XHRwcmVmaXggPSBcIj9cIjtcblx0XHRzZXBhcmF0b3IgPSBcIiZcIjtcblx0XHRzaG93VmFyaWFibGVzID0gdHJ1ZTtcblx0fSBlbHNlIGlmIChtb2RpZmllciA9PT0gJyYnKSB7XG5cdFx0cHJlZml4ID0gXCImXCI7XG5cdFx0c2VwYXJhdG9yID0gXCImXCI7XG5cdFx0c2hvd1ZhcmlhYmxlcyA9IHRydWU7XG5cdH1cblxuXHR2YXIgdmFyTmFtZXMgPSBbXTtcblx0dmFyIHZhckxpc3QgPSBzcGVjLnNwbGl0KFwiLFwiKTtcblx0dmFyIHZhclNwZWNzID0gW107XG5cdHZhciB2YXJTcGVjTWFwID0ge307XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdmFyTGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciB2YXJOYW1lID0gdmFyTGlzdFtpXTtcblx0XHR2YXIgdHJ1bmNhdGUgPSBudWxsO1xuXHRcdGlmICh2YXJOYW1lLmluZGV4T2YoXCI6XCIpICE9PSAtMSkge1xuXHRcdFx0dmFyIHBhcnRzID0gdmFyTmFtZS5zcGxpdChcIjpcIik7XG5cdFx0XHR2YXJOYW1lID0gcGFydHNbMF07XG5cdFx0XHR0cnVuY2F0ZSA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7XG5cdFx0fVxuXHRcdHZhciBzdWZmaWNlcyA9IHt9O1xuXHRcdHdoaWxlICh1cmlUZW1wbGF0ZVN1ZmZpY2VzW3Zhck5hbWUuY2hhckF0KHZhck5hbWUubGVuZ3RoIC0gMSldKSB7XG5cdFx0XHRzdWZmaWNlc1t2YXJOYW1lLmNoYXJBdCh2YXJOYW1lLmxlbmd0aCAtIDEpXSA9IHRydWU7XG5cdFx0XHR2YXJOYW1lID0gdmFyTmFtZS5zdWJzdHJpbmcoMCwgdmFyTmFtZS5sZW5ndGggLSAxKTtcblx0XHR9XG5cdFx0dmFyIHZhclNwZWMgPSB7XG5cdFx0XHR0cnVuY2F0ZTogdHJ1bmNhdGUsXG5cdFx0XHRuYW1lOiB2YXJOYW1lLFxuXHRcdFx0c3VmZmljZXM6IHN1ZmZpY2VzXG5cdFx0fTtcblx0XHR2YXJTcGVjcy5wdXNoKHZhclNwZWMpO1xuXHRcdHZhclNwZWNNYXBbdmFyTmFtZV0gPSB2YXJTcGVjO1xuXHRcdHZhck5hbWVzLnB1c2godmFyTmFtZSk7XG5cdH1cblx0dmFyIHN1YkZ1bmN0aW9uID0gZnVuY3Rpb24gKHZhbHVlRnVuY3Rpb24pIHtcblx0XHR2YXIgcmVzdWx0ID0gXCJcIjtcblx0XHR2YXIgc3RhcnRJbmRleCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2YXJTcGVjcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHZhclNwZWMgPSB2YXJTcGVjc1tpXTtcblx0XHRcdHZhciB2YWx1ZSA9IHZhbHVlRnVuY3Rpb24odmFyU3BlYy5uYW1lKTtcblx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHx8ICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDApKSB7XG5cdFx0XHRcdHN0YXJ0SW5kZXgrKztcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaSA9PT0gc3RhcnRJbmRleCkge1xuXHRcdFx0XHRyZXN1bHQgKz0gcHJlZml4O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0ICs9IChzZXBhcmF0b3IgfHwgXCIsXCIpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdGlmIChzaG93VmFyaWFibGVzKSB7XG5cdFx0XHRcdFx0cmVzdWx0ICs9IHZhclNwZWMubmFtZSArIFwiPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRpZiAoaiA+IDApIHtcblx0XHRcdFx0XHRcdHJlc3VsdCArPSB2YXJTcGVjLnN1ZmZpY2VzWycqJ10gPyAoc2VwYXJhdG9yIHx8IFwiLFwiKSA6IFwiLFwiO1xuXHRcdFx0XHRcdFx0aWYgKHZhclNwZWMuc3VmZmljZXNbJyonXSAmJiBzaG93VmFyaWFibGVzKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdCArPSB2YXJTcGVjLm5hbWUgKyBcIj1cIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0ICs9IHNob3VsZEVzY2FwZSA/IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZVtqXSkucmVwbGFjZSgvIS9nLCBcIiUyMVwiKSA6IG5vdFJlYWxseVBlcmNlbnRFbmNvZGUodmFsdWVbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuXHRcdFx0XHRpZiAoc2hvd1ZhcmlhYmxlcyAmJiAhdmFyU3BlYy5zdWZmaWNlc1snKiddKSB7XG5cdFx0XHRcdFx0cmVzdWx0ICs9IHZhclNwZWMubmFtZSArIFwiPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBmaXJzdCA9IHRydWU7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmICghZmlyc3QpIHtcblx0XHRcdFx0XHRcdHJlc3VsdCArPSB2YXJTcGVjLnN1ZmZpY2VzWycqJ10gPyAoc2VwYXJhdG9yIHx8IFwiLFwiKSA6IFwiLFwiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmaXJzdCA9IGZhbHNlO1xuXHRcdFx0XHRcdHJlc3VsdCArPSBzaG91bGRFc2NhcGUgPyBlbmNvZGVVUklDb21wb25lbnQoa2V5KS5yZXBsYWNlKC8hL2csIFwiJTIxXCIpIDogbm90UmVhbGx5UGVyY2VudEVuY29kZShrZXkpO1xuXHRcdFx0XHRcdHJlc3VsdCArPSB2YXJTcGVjLnN1ZmZpY2VzWycqJ10gPyAnPScgOiBcIixcIjtcblx0XHRcdFx0XHRyZXN1bHQgKz0gc2hvdWxkRXNjYXBlID8gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlW2tleV0pLnJlcGxhY2UoLyEvZywgXCIlMjFcIikgOiBub3RSZWFsbHlQZXJjZW50RW5jb2RlKHZhbHVlW2tleV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoc2hvd1ZhcmlhYmxlcykge1xuXHRcdFx0XHRcdHJlc3VsdCArPSB2YXJTcGVjLm5hbWU7XG5cdFx0XHRcdFx0aWYgKCF0cmltRW1wdHlTdHJpbmcgfHwgdmFsdWUgIT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdHJlc3VsdCArPSBcIj1cIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHZhclNwZWMudHJ1bmNhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHZhclNwZWMudHJ1bmNhdGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc3VsdCArPSBzaG91bGRFc2NhcGUgPyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpLnJlcGxhY2UoLyEvZywgXCIlMjFcIik6IG5vdFJlYWxseVBlcmNlbnRFbmNvZGUodmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXHRzdWJGdW5jdGlvbi52YXJOYW1lcyA9IHZhck5hbWVzO1xuXHRyZXR1cm4ge1xuXHRcdHByZWZpeDogcHJlZml4LFxuXHRcdHN1YnN0aXR1dGlvbjogc3ViRnVuY3Rpb25cblx0fTtcbn1cblxuZnVuY3Rpb24gVXJpVGVtcGxhdGUodGVtcGxhdGUpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFVyaVRlbXBsYXRlKSkge1xuXHRcdHJldHVybiBuZXcgVXJpVGVtcGxhdGUodGVtcGxhdGUpO1xuXHR9XG5cdHZhciBwYXJ0cyA9IHRlbXBsYXRlLnNwbGl0KFwie1wiKTtcblx0dmFyIHRleHRQYXJ0cyA9IFtwYXJ0cy5zaGlmdCgpXTtcblx0dmFyIHByZWZpeGVzID0gW107XG5cdHZhciBzdWJzdGl0dXRpb25zID0gW107XG5cdHZhciB2YXJOYW1lcyA9IFtdO1xuXHR3aGlsZSAocGFydHMubGVuZ3RoID4gMCkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHMuc2hpZnQoKTtcblx0XHR2YXIgc3BlYyA9IHBhcnQuc3BsaXQoXCJ9XCIpWzBdO1xuXHRcdHZhciByZW1haW5kZXIgPSBwYXJ0LnN1YnN0cmluZyhzcGVjLmxlbmd0aCArIDEpO1xuXHRcdHZhciBmdW5jcyA9IHVyaVRlbXBsYXRlU3Vic3RpdHV0aW9uKHNwZWMpO1xuXHRcdHN1YnN0aXR1dGlvbnMucHVzaChmdW5jcy5zdWJzdGl0dXRpb24pO1xuXHRcdHByZWZpeGVzLnB1c2goZnVuY3MucHJlZml4KTtcblx0XHR0ZXh0UGFydHMucHVzaChyZW1haW5kZXIpO1xuXHRcdHZhck5hbWVzID0gdmFyTmFtZXMuY29uY2F0KGZ1bmNzLnN1YnN0aXR1dGlvbi52YXJOYW1lcyk7XG5cdH1cblx0dGhpcy5maWxsID0gZnVuY3Rpb24gKHZhbHVlRnVuY3Rpb24pIHtcblx0XHR2YXIgcmVzdWx0ID0gdGV4dFBhcnRzWzBdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic3RpdHV0aW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHN1YnN0aXR1dGlvbiA9IHN1YnN0aXR1dGlvbnNbaV07XG5cdFx0XHRyZXN1bHQgKz0gc3Vic3RpdHV0aW9uKHZhbHVlRnVuY3Rpb24pO1xuXHRcdFx0cmVzdWx0ICs9IHRleHRQYXJ0c1tpICsgMV07XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cdHRoaXMudmFyTmFtZXMgPSB2YXJOYW1lcztcblx0dGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xufVxuVXJpVGVtcGxhdGUucHJvdG90eXBlID0ge1xuXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnRlbXBsYXRlO1xuXHR9LFxuXHRmaWxsRnJvbU9iamVjdDogZnVuY3Rpb24gKG9iaikge1xuXHRcdHJldHVybiB0aGlzLmZpbGwoZnVuY3Rpb24gKHZhck5hbWUpIHtcblx0XHRcdHJldHVybiBvYmpbdmFyTmFtZV07XG5cdFx0fSk7XG5cdH1cbn07XG52YXIgVmFsaWRhdG9yQ29udGV4dCA9IGZ1bmN0aW9uIFZhbGlkYXRvckNvbnRleHQocGFyZW50LCBjb2xsZWN0TXVsdGlwbGUsIGVycm9yUmVwb3J0ZXIsIGNoZWNrUmVjdXJzaXZlLCB0cmFja1Vua25vd25Qcm9wZXJ0aWVzKSB7XG5cdHRoaXMubWlzc2luZyA9IFtdO1xuXHR0aGlzLm1pc3NpbmdNYXAgPSB7fTtcblx0dGhpcy5mb3JtYXRWYWxpZGF0b3JzID0gcGFyZW50ID8gT2JqZWN0LmNyZWF0ZShwYXJlbnQuZm9ybWF0VmFsaWRhdG9ycykgOiB7fTtcblx0dGhpcy5zY2hlbWFzID0gcGFyZW50ID8gT2JqZWN0LmNyZWF0ZShwYXJlbnQuc2NoZW1hcykgOiB7fTtcblx0dGhpcy5jb2xsZWN0TXVsdGlwbGUgPSBjb2xsZWN0TXVsdGlwbGU7XG5cdHRoaXMuZXJyb3JzID0gW107XG5cdHRoaXMuaGFuZGxlRXJyb3IgPSBjb2xsZWN0TXVsdGlwbGUgPyB0aGlzLmNvbGxlY3RFcnJvciA6IHRoaXMucmV0dXJuRXJyb3I7XG5cdGlmIChjaGVja1JlY3Vyc2l2ZSkge1xuXHRcdHRoaXMuY2hlY2tSZWN1cnNpdmUgPSB0cnVlO1xuXHRcdHRoaXMuc2Nhbm5lZCA9IFtdO1xuXHRcdHRoaXMuc2Nhbm5lZEZyb3plbiA9IFtdO1xuXHRcdHRoaXMuc2Nhbm5lZEZyb3plblNjaGVtYXMgPSBbXTtcblx0XHR0aGlzLnNjYW5uZWRGcm96ZW5WYWxpZGF0aW9uRXJyb3JzID0gW107XG5cdFx0dGhpcy52YWxpZGF0ZWRTY2hlbWFzS2V5ID0gJ3R2NF92YWxpZGF0aW9uX2lkJztcblx0XHR0aGlzLnZhbGlkYXRpb25FcnJvcnNLZXkgPSAndHY0X3ZhbGlkYXRpb25fZXJyb3JzX2lkJztcblx0fVxuXHRpZiAodHJhY2tVbmtub3duUHJvcGVydGllcykge1xuXHRcdHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcyA9IHRydWU7XG5cdFx0dGhpcy5rbm93blByb3BlcnR5UGF0aHMgPSB7fTtcblx0XHR0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzID0ge307XG5cdH1cblx0dGhpcy5lcnJvclJlcG9ydGVyID0gZXJyb3JSZXBvcnRlciB8fCBkZWZhdWx0RXJyb3JSZXBvcnRlcignZW4nKTtcblx0aWYgKHR5cGVvZiB0aGlzLmVycm9yUmVwb3J0ZXIgPT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdkZWJ1ZycpO1xuXHR9XG5cdHRoaXMuZGVmaW5lZEtleXdvcmRzID0ge307XG5cdGlmIChwYXJlbnQpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gcGFyZW50LmRlZmluZWRLZXl3b3Jkcykge1xuXHRcdFx0dGhpcy5kZWZpbmVkS2V5d29yZHNba2V5XSA9IHBhcmVudC5kZWZpbmVkS2V5d29yZHNba2V5XS5zbGljZSgwKTtcblx0XHR9XG5cdH1cbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5kZWZpbmVLZXl3b3JkID0gZnVuY3Rpb24gKGtleXdvcmQsIGtleXdvcmRGdW5jdGlvbikge1xuXHR0aGlzLmRlZmluZWRLZXl3b3Jkc1trZXl3b3JkXSA9IHRoaXMuZGVmaW5lZEtleXdvcmRzW2tleXdvcmRdIHx8IFtdO1xuXHR0aGlzLmRlZmluZWRLZXl3b3Jkc1trZXl3b3JkXS5wdXNoKGtleXdvcmRGdW5jdGlvbik7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRXJyb3IgPSBmdW5jdGlvbiAoY29kZSwgbWVzc2FnZVBhcmFtcywgZGF0YVBhdGgsIHNjaGVtYVBhdGgsIHN1YkVycm9ycywgZGF0YSwgc2NoZW1hKSB7XG5cdHZhciBlcnJvciA9IG5ldyBWYWxpZGF0aW9uRXJyb3IoY29kZSwgbWVzc2FnZVBhcmFtcywgZGF0YVBhdGgsIHNjaGVtYVBhdGgsIHN1YkVycm9ycyk7XG5cdGVycm9yLm1lc3NhZ2UgPSB0aGlzLmVycm9yUmVwb3J0ZXIoZXJyb3IsIGRhdGEsIHNjaGVtYSk7XG5cdHJldHVybiBlcnJvcjtcbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5yZXR1cm5FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuXHRyZXR1cm4gZXJyb3I7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuY29sbGVjdEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG5cdGlmIChlcnJvcikge1xuXHRcdHRoaXMuZXJyb3JzLnB1c2goZXJyb3IpO1xuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnByZWZpeEVycm9ycyA9IGZ1bmN0aW9uIChzdGFydEluZGV4LCBkYXRhUGF0aCwgc2NoZW1hUGF0aCkge1xuXHRmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRoaXMuZXJyb3JzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dGhpcy5lcnJvcnNbaV0gPSB0aGlzLmVycm9yc1tpXS5wcmVmaXhXaXRoKGRhdGFQYXRoLCBzY2hlbWFQYXRoKTtcblx0fVxuXHRyZXR1cm4gdGhpcztcbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5iYW5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uIChkYXRhLCBzY2hlbWEpIHtcblx0Zm9yICh2YXIgdW5rbm93blBhdGggaW4gdGhpcy51bmtub3duUHJvcGVydHlQYXRocykge1xuXHRcdHZhciBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5VTktOT1dOX1BST1BFUlRZLCB7cGF0aDogdW5rbm93blBhdGh9LCB1bmtub3duUGF0aCwgXCJcIiwgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHR2YXIgcmVzdWx0ID0gdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG5cdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5hZGRGb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0LCB2YWxpZGF0b3IpIHtcblx0aWYgKHR5cGVvZiBmb3JtYXQgPT09ICdvYmplY3QnKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIGZvcm1hdCkge1xuXHRcdFx0dGhpcy5hZGRGb3JtYXQoa2V5LCBmb3JtYXRba2V5XSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHRoaXMuZm9ybWF0VmFsaWRhdG9yc1tmb3JtYXRdID0gdmFsaWRhdG9yO1xufTtcblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnJlc29sdmVSZWZzID0gZnVuY3Rpb24gKHNjaGVtYSwgdXJsSGlzdG9yeSkge1xuXHRpZiAoc2NoZW1hWyckcmVmJ10gIT09IHVuZGVmaW5lZCkge1xuXHRcdHVybEhpc3RvcnkgPSB1cmxIaXN0b3J5IHx8IHt9O1xuXHRcdGlmICh1cmxIaXN0b3J5W3NjaGVtYVsnJHJlZiddXSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5DSVJDVUxBUl9SRUZFUkVOQ0UsIHt1cmxzOiBPYmplY3Qua2V5cyh1cmxIaXN0b3J5KS5qb2luKCcsICcpfSwgJycsICcnLCBudWxsLCB1bmRlZmluZWQsIHNjaGVtYSk7XG5cdFx0fVxuXHRcdHVybEhpc3Rvcnlbc2NoZW1hWyckcmVmJ11dID0gdHJ1ZTtcblx0XHRzY2hlbWEgPSB0aGlzLmdldFNjaGVtYShzY2hlbWFbJyRyZWYnXSwgdXJsSGlzdG9yeSk7XG5cdH1cblx0cmV0dXJuIHNjaGVtYTtcbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5nZXRTY2hlbWEgPSBmdW5jdGlvbiAodXJsLCB1cmxIaXN0b3J5KSB7XG5cdHZhciBzY2hlbWE7XG5cdGlmICh0aGlzLnNjaGVtYXNbdXJsXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0c2NoZW1hID0gdGhpcy5zY2hlbWFzW3VybF07XG5cdFx0cmV0dXJuIHRoaXMucmVzb2x2ZVJlZnMoc2NoZW1hLCB1cmxIaXN0b3J5KTtcblx0fVxuXHR2YXIgYmFzZVVybCA9IHVybDtcblx0dmFyIGZyYWdtZW50ID0gXCJcIjtcblx0aWYgKHVybC5pbmRleE9mKCcjJykgIT09IC0xKSB7XG5cdFx0ZnJhZ21lbnQgPSB1cmwuc3Vic3RyaW5nKHVybC5pbmRleE9mKFwiI1wiKSArIDEpO1xuXHRcdGJhc2VVcmwgPSB1cmwuc3Vic3RyaW5nKDAsIHVybC5pbmRleE9mKFwiI1wiKSk7XG5cdH1cblx0aWYgKHR5cGVvZiB0aGlzLnNjaGVtYXNbYmFzZVVybF0gPT09ICdvYmplY3QnKSB7XG5cdFx0c2NoZW1hID0gdGhpcy5zY2hlbWFzW2Jhc2VVcmxdO1xuXHRcdHZhciBwb2ludGVyUGF0aCA9IGRlY29kZVVSSUNvbXBvbmVudChmcmFnbWVudCk7XG5cdFx0aWYgKHBvaW50ZXJQYXRoID09PSBcIlwiKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXNvbHZlUmVmcyhzY2hlbWEsIHVybEhpc3RvcnkpO1xuXHRcdH0gZWxzZSBpZiAocG9pbnRlclBhdGguY2hhckF0KDApICE9PSBcIi9cIikge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dmFyIHBhcnRzID0gcG9pbnRlclBhdGguc3BsaXQoXCIvXCIpLnNsaWNlKDEpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBjb21wb25lbnQgPSBwYXJ0c1tpXS5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpO1xuXHRcdFx0aWYgKHNjaGVtYVtjb21wb25lbnRdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0c2NoZW1hID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHNjaGVtYSA9IHNjaGVtYVtjb21wb25lbnRdO1xuXHRcdH1cblx0XHRpZiAoc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiB0aGlzLnJlc29sdmVSZWZzKHNjaGVtYSwgdXJsSGlzdG9yeSk7XG5cdFx0fVxuXHR9XG5cdGlmICh0aGlzLm1pc3NpbmdbYmFzZVVybF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdHRoaXMubWlzc2luZy5wdXNoKGJhc2VVcmwpO1xuXHRcdHRoaXMubWlzc2luZ1tiYXNlVXJsXSA9IGJhc2VVcmw7XG5cdFx0dGhpcy5taXNzaW5nTWFwW2Jhc2VVcmxdID0gYmFzZVVybDtcblx0fVxufTtcblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnNlYXJjaFNjaGVtYXMgPSBmdW5jdGlvbiAoc2NoZW1hLCB1cmwpIHtcblx0aWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2NoZW1hLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLnNlYXJjaFNjaGVtYXMoc2NoZW1hW2ldLCB1cmwpO1xuXHRcdH1cblx0fSBlbHNlIGlmIChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIikge1xuXHRcdGlmICh0eXBlb2Ygc2NoZW1hLmlkID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRpZiAoaXNUcnVzdGVkVXJsKHVybCwgc2NoZW1hLmlkKSkge1xuXHRcdFx0XHRpZiAodGhpcy5zY2hlbWFzW3NjaGVtYS5pZF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRoaXMuc2NoZW1hc1tzY2hlbWEuaWRdID0gc2NoZW1hO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAodmFyIGtleSBpbiBzY2hlbWEpIHtcblx0XHRcdGlmIChrZXkgIT09IFwiZW51bVwiKSB7XG5cdFx0XHRcdGlmICh0eXBlb2Ygc2NoZW1hW2tleV0gPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0XHR0aGlzLnNlYXJjaFNjaGVtYXMoc2NoZW1hW2tleV0sIHVybCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoa2V5ID09PSBcIiRyZWZcIikge1xuXHRcdFx0XHRcdHZhciB1cmkgPSBnZXREb2N1bWVudFVyaShzY2hlbWFba2V5XSk7XG5cdFx0XHRcdFx0aWYgKHVyaSAmJiB0aGlzLnNjaGVtYXNbdXJpXSA9PT0gdW5kZWZpbmVkICYmIHRoaXMubWlzc2luZ01hcFt1cmldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHRoaXMubWlzc2luZ01hcFt1cmldID0gdXJpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLmFkZFNjaGVtYSA9IGZ1bmN0aW9uICh1cmwsIHNjaGVtYSkge1xuXHQvL292ZXJsb2FkXG5cdGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJyB8fCB0eXBlb2Ygc2NoZW1hID09PSAndW5kZWZpbmVkJykge1xuXHRcdGlmICh0eXBlb2YgdXJsID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdXJsLmlkID09PSAnc3RyaW5nJykge1xuXHRcdFx0c2NoZW1hID0gdXJsO1xuXHRcdFx0dXJsID0gc2NoZW1hLmlkO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblx0aWYgKHVybCA9PT0gZ2V0RG9jdW1lbnRVcmkodXJsKSArIFwiI1wiKSB7XG5cdFx0Ly8gUmVtb3ZlIGVtcHR5IGZyYWdtZW50XG5cdFx0dXJsID0gZ2V0RG9jdW1lbnRVcmkodXJsKTtcblx0fVxuXHR0aGlzLnNjaGVtYXNbdXJsXSA9IHNjaGVtYTtcblx0ZGVsZXRlIHRoaXMubWlzc2luZ01hcFt1cmxdO1xuXHRub3JtU2NoZW1hKHNjaGVtYSwgdXJsKTtcblx0dGhpcy5zZWFyY2hTY2hlbWFzKHNjaGVtYSwgdXJsKTtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLmdldFNjaGVtYU1hcCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIG1hcCA9IHt9O1xuXHRmb3IgKHZhciBrZXkgaW4gdGhpcy5zY2hlbWFzKSB7XG5cdFx0bWFwW2tleV0gPSB0aGlzLnNjaGVtYXNba2V5XTtcblx0fVxuXHRyZXR1cm4gbWFwO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuZ2V0U2NoZW1hVXJpcyA9IGZ1bmN0aW9uIChmaWx0ZXJSZWdFeHApIHtcblx0dmFyIGxpc3QgPSBbXTtcblx0Zm9yICh2YXIga2V5IGluIHRoaXMuc2NoZW1hcykge1xuXHRcdGlmICghZmlsdGVyUmVnRXhwIHx8IGZpbHRlclJlZ0V4cC50ZXN0KGtleSkpIHtcblx0XHRcdGxpc3QucHVzaChrZXkpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbGlzdDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLmdldE1pc3NpbmdVcmlzID0gZnVuY3Rpb24gKGZpbHRlclJlZ0V4cCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXHRmb3IgKHZhciBrZXkgaW4gdGhpcy5taXNzaW5nTWFwKSB7XG5cdFx0aWYgKCFmaWx0ZXJSZWdFeHAgfHwgZmlsdGVyUmVnRXhwLnRlc3Qoa2V5KSkge1xuXHRcdFx0bGlzdC5wdXNoKGtleSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBsaXN0O1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuZHJvcFNjaGVtYXMgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuc2NoZW1hcyA9IHt9O1xuXHR0aGlzLnJlc2V0KCk7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMubWlzc2luZyA9IFtdO1xuXHR0aGlzLm1pc3NpbmdNYXAgPSB7fTtcblx0dGhpcy5lcnJvcnMgPSBbXTtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlQWxsID0gZnVuY3Rpb24gKGRhdGEsIHNjaGVtYSwgZGF0YVBhdGhQYXJ0cywgc2NoZW1hUGF0aFBhcnRzLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0dmFyIHRvcExldmVsO1xuXHRzY2hlbWEgPSB0aGlzLnJlc29sdmVSZWZzKHNjaGVtYSk7XG5cdGlmICghc2NoZW1hKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgVmFsaWRhdGlvbkVycm9yKSB7XG5cdFx0dGhpcy5lcnJvcnMucHVzaChzY2hlbWEpO1xuXHRcdHJldHVybiBzY2hlbWE7XG5cdH1cblxuXHR2YXIgc3RhcnRFcnJvckNvdW50ID0gdGhpcy5lcnJvcnMubGVuZ3RoO1xuXHR2YXIgZnJvemVuSW5kZXgsIHNjYW5uZWRGcm96ZW5TY2hlbWFJbmRleCA9IG51bGwsIHNjYW5uZWRTY2hlbWFzSW5kZXggPSBudWxsO1xuXHRpZiAodGhpcy5jaGVja1JlY3Vyc2l2ZSAmJiBkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuXHRcdHRvcExldmVsID0gIXRoaXMuc2Nhbm5lZC5sZW5ndGg7XG5cdFx0aWYgKGRhdGFbdGhpcy52YWxpZGF0ZWRTY2hlbWFzS2V5XSkge1xuXHRcdFx0dmFyIHNjaGVtYUluZGV4ID0gZGF0YVt0aGlzLnZhbGlkYXRlZFNjaGVtYXNLZXldLmluZGV4T2Yoc2NoZW1hKTtcblx0XHRcdGlmIChzY2hlbWFJbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0dGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycy5jb25jYXQoZGF0YVt0aGlzLnZhbGlkYXRpb25FcnJvcnNLZXldW3NjaGVtYUluZGV4XSk7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoT2JqZWN0LmlzRnJvemVuKGRhdGEpKSB7XG5cdFx0XHRmcm96ZW5JbmRleCA9IHRoaXMuc2Nhbm5lZEZyb3plbi5pbmRleE9mKGRhdGEpO1xuXHRcdFx0aWYgKGZyb3plbkluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHR2YXIgZnJvemVuU2NoZW1hSW5kZXggPSB0aGlzLnNjYW5uZWRGcm96ZW5TY2hlbWFzW2Zyb3plbkluZGV4XS5pbmRleE9mKHNjaGVtYSk7XG5cdFx0XHRcdGlmIChmcm96ZW5TY2hlbWFJbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0XHR0aGlzLmVycm9ycyA9IHRoaXMuZXJyb3JzLmNvbmNhdCh0aGlzLnNjYW5uZWRGcm96ZW5WYWxpZGF0aW9uRXJyb3JzW2Zyb3plbkluZGV4XVtmcm96ZW5TY2hlbWFJbmRleF0pO1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuc2Nhbm5lZC5wdXNoKGRhdGEpO1xuXHRcdGlmIChPYmplY3QuaXNGcm96ZW4oZGF0YSkpIHtcblx0XHRcdGlmIChmcm96ZW5JbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0ZnJvemVuSW5kZXggPSB0aGlzLnNjYW5uZWRGcm96ZW4ubGVuZ3RoO1xuXHRcdFx0XHR0aGlzLnNjYW5uZWRGcm96ZW4ucHVzaChkYXRhKTtcblx0XHRcdFx0dGhpcy5zY2FubmVkRnJvemVuU2NoZW1hcy5wdXNoKFtdKTtcblx0XHRcdH1cblx0XHRcdHNjYW5uZWRGcm96ZW5TY2hlbWFJbmRleCA9IHRoaXMuc2Nhbm5lZEZyb3plblNjaGVtYXNbZnJvemVuSW5kZXhdLmxlbmd0aDtcblx0XHRcdHRoaXMuc2Nhbm5lZEZyb3plblNjaGVtYXNbZnJvemVuSW5kZXhdW3NjYW5uZWRGcm96ZW5TY2hlbWFJbmRleF0gPSBzY2hlbWE7XG5cdFx0XHR0aGlzLnNjYW5uZWRGcm96ZW5WYWxpZGF0aW9uRXJyb3JzW2Zyb3plbkluZGV4XVtzY2FubmVkRnJvemVuU2NoZW1hSW5kZXhdID0gW107XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICghZGF0YVt0aGlzLnZhbGlkYXRlZFNjaGVtYXNLZXldKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGEsIHRoaXMudmFsaWRhdGVkU2NoZW1hc0tleSwge1xuXHRcdFx0XHRcdFx0dmFsdWU6IFtdLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGEsIHRoaXMudmFsaWRhdGlvbkVycm9yc0tleSwge1xuXHRcdFx0XHRcdFx0dmFsdWU6IFtdLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHQvL0lFIDcvOCB3b3JrYXJvdW5kXG5cdFx0XHRcdFx0ZGF0YVt0aGlzLnZhbGlkYXRlZFNjaGVtYXNLZXldID0gW107XG5cdFx0XHRcdFx0ZGF0YVt0aGlzLnZhbGlkYXRpb25FcnJvcnNLZXldID0gW107XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHNjYW5uZWRTY2hlbWFzSW5kZXggPSBkYXRhW3RoaXMudmFsaWRhdGVkU2NoZW1hc0tleV0ubGVuZ3RoO1xuXHRcdFx0ZGF0YVt0aGlzLnZhbGlkYXRlZFNjaGVtYXNLZXldW3NjYW5uZWRTY2hlbWFzSW5kZXhdID0gc2NoZW1hO1xuXHRcdFx0ZGF0YVt0aGlzLnZhbGlkYXRpb25FcnJvcnNLZXldW3NjYW5uZWRTY2hlbWFzSW5kZXhdID0gW107XG5cdFx0fVxuXHR9XG5cblx0dmFyIGVycm9yQ291bnQgPSB0aGlzLmVycm9ycy5sZW5ndGg7XG5cdHZhciBlcnJvciA9IHRoaXMudmFsaWRhdGVCYXNpYyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlTnVtZXJpYyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlU3RyaW5nKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVBcnJheShkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlT2JqZWN0KGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVDb21iaW5hdGlvbnMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZUh5cGVybWVkaWEoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZUZvcm1hdChkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlRGVmaW5lZEtleXdvcmRzKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IG51bGw7XG5cblx0aWYgKHRvcExldmVsKSB7XG5cdFx0d2hpbGUgKHRoaXMuc2Nhbm5lZC5sZW5ndGgpIHtcblx0XHRcdHZhciBpdGVtID0gdGhpcy5zY2FubmVkLnBvcCgpO1xuXHRcdFx0ZGVsZXRlIGl0ZW1bdGhpcy52YWxpZGF0ZWRTY2hlbWFzS2V5XTtcblx0XHR9XG5cdFx0dGhpcy5zY2FubmVkRnJvemVuID0gW107XG5cdFx0dGhpcy5zY2FubmVkRnJvemVuU2NoZW1hcyA9IFtdO1xuXHR9XG5cblx0aWYgKGVycm9yIHx8IGVycm9yQ291bnQgIT09IHRoaXMuZXJyb3JzLmxlbmd0aCkge1xuXHRcdHdoaWxlICgoZGF0YVBhdGhQYXJ0cyAmJiBkYXRhUGF0aFBhcnRzLmxlbmd0aCkgfHwgKHNjaGVtYVBhdGhQYXJ0cyAmJiBzY2hlbWFQYXRoUGFydHMubGVuZ3RoKSkge1xuXHRcdFx0dmFyIGRhdGFQYXJ0ID0gKGRhdGFQYXRoUGFydHMgJiYgZGF0YVBhdGhQYXJ0cy5sZW5ndGgpID8gXCJcIiArIGRhdGFQYXRoUGFydHMucG9wKCkgOiBudWxsO1xuXHRcdFx0dmFyIHNjaGVtYVBhcnQgPSAoc2NoZW1hUGF0aFBhcnRzICYmIHNjaGVtYVBhdGhQYXJ0cy5sZW5ndGgpID8gXCJcIiArIHNjaGVtYVBhdGhQYXJ0cy5wb3AoKSA6IG51bGw7XG5cdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0ZXJyb3IgPSBlcnJvci5wcmVmaXhXaXRoKGRhdGFQYXJ0LCBzY2hlbWFQYXJ0KTtcblx0XHRcdH1cblx0XHRcdHRoaXMucHJlZml4RXJyb3JzKGVycm9yQ291bnQsIGRhdGFQYXJ0LCBzY2hlbWFQYXJ0KTtcblx0XHR9XG5cdH1cblxuXHRpZiAoc2Nhbm5lZEZyb3plblNjaGVtYUluZGV4ICE9PSBudWxsKSB7XG5cdFx0dGhpcy5zY2FubmVkRnJvemVuVmFsaWRhdGlvbkVycm9yc1tmcm96ZW5JbmRleF1bc2Nhbm5lZEZyb3plblNjaGVtYUluZGV4XSA9IHRoaXMuZXJyb3JzLnNsaWNlKHN0YXJ0RXJyb3JDb3VudCk7XG5cdH0gZWxzZSBpZiAoc2Nhbm5lZFNjaGVtYXNJbmRleCAhPT0gbnVsbCkge1xuXHRcdGRhdGFbdGhpcy52YWxpZGF0aW9uRXJyb3JzS2V5XVtzY2FubmVkU2NoZW1hc0luZGV4XSA9IHRoaXMuZXJyb3JzLnNsaWNlKHN0YXJ0RXJyb3JDb3VudCk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiAoZGF0YSwgc2NoZW1hKSB7XG5cdGlmICh0eXBlb2Ygc2NoZW1hLmZvcm1hdCAhPT0gJ3N0cmluZycgfHwgIXRoaXMuZm9ybWF0VmFsaWRhdG9yc1tzY2hlbWEuZm9ybWF0XSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHZhciBlcnJvck1lc3NhZ2UgPSB0aGlzLmZvcm1hdFZhbGlkYXRvcnNbc2NoZW1hLmZvcm1hdF0uY2FsbChudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRpZiAodHlwZW9mIGVycm9yTWVzc2FnZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVycm9yTWVzc2FnZSA9PT0gJ251bWJlcicpIHtcblx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLkZPUk1BVF9DVVNUT00sIHttZXNzYWdlOiBlcnJvck1lc3NhZ2V9LCAnJywgJy9mb3JtYXQnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHR9IGVsc2UgaWYgKGVycm9yTWVzc2FnZSAmJiB0eXBlb2YgZXJyb3JNZXNzYWdlID09PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuRk9STUFUX0NVU1RPTSwge21lc3NhZ2U6IGVycm9yTWVzc2FnZS5tZXNzYWdlIHx8IFwiP1wifSwgZXJyb3JNZXNzYWdlLmRhdGFQYXRoIHx8ICcnLCBlcnJvck1lc3NhZ2Uuc2NoZW1hUGF0aCB8fCBcIi9mb3JtYXRcIiwgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZURlZmluZWRLZXl3b3JkcyA9IGZ1bmN0aW9uIChkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCkge1xuXHRmb3IgKHZhciBrZXkgaW4gdGhpcy5kZWZpbmVkS2V5d29yZHMpIHtcblx0XHRpZiAodHlwZW9mIHNjaGVtYVtrZXldID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdHZhciB2YWxpZGF0aW9uRnVuY3Rpb25zID0gdGhpcy5kZWZpbmVkS2V5d29yZHNba2V5XTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbGlkYXRpb25GdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBmdW5jID0gdmFsaWRhdGlvbkZ1bmN0aW9uc1tpXTtcblx0XHRcdHZhciByZXN1bHQgPSBmdW5jKGRhdGEsIHNjaGVtYVtrZXldLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCk7XG5cdFx0XHRpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHJlc3VsdCA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5LRVlXT1JEX0NVU1RPTSwge2tleToga2V5LCBtZXNzYWdlOiByZXN1bHR9LCAnJywgJycsIG51bGwsIGRhdGEsIHNjaGVtYSkucHJlZml4V2l0aChudWxsLCBrZXkpO1xuXHRcdFx0fSBlbHNlIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0dmFyIGNvZGUgPSByZXN1bHQuY29kZTtcblx0XHRcdFx0aWYgKHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdGlmICghRXJyb3JDb2Rlc1tjb2RlXSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmRlZmluZWQgZXJyb3IgY29kZSAodXNlIGRlZmluZUVycm9yKTogJyArIGNvZGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb2RlID0gRXJyb3JDb2Rlc1tjb2RlXTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgY29kZSAhPT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRjb2RlID0gRXJyb3JDb2Rlcy5LRVlXT1JEX0NVU1RPTTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgbWVzc2FnZVBhcmFtcyA9ICh0eXBlb2YgcmVzdWx0Lm1lc3NhZ2UgPT09ICdvYmplY3QnKSA/IHJlc3VsdC5tZXNzYWdlIDoge2tleToga2V5LCBtZXNzYWdlOiByZXN1bHQubWVzc2FnZSB8fCBcIj9cIn07XG5cdFx0XHRcdHZhciBzY2hlbWFQYXRoID0gcmVzdWx0LnNjaGVtYVBhdGggfHwgKFwiL1wiICsga2V5LnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoY29kZSwgbWVzc2FnZVBhcmFtcywgcmVzdWx0LmRhdGFQYXRoIHx8IG51bGwsIHNjaGVtYVBhdGgsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuZnVuY3Rpb24gcmVjdXJzaXZlQ29tcGFyZShBLCBCKSB7XG5cdGlmIChBID09PSBCKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKEEgJiYgQiAmJiB0eXBlb2YgQSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgQiA9PT0gXCJvYmplY3RcIikge1xuXHRcdGlmIChBcnJheS5pc0FycmF5KEEpICE9PSBBcnJheS5pc0FycmF5KEIpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KEEpKSB7XG5cdFx0XHRpZiAoQS5sZW5ndGggIT09IEIubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgQS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoIXJlY3Vyc2l2ZUNvbXBhcmUoQVtpXSwgQltpXSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGtleTtcblx0XHRcdGZvciAoa2V5IGluIEEpIHtcblx0XHRcdFx0aWYgKEJba2V5XSA9PT0gdW5kZWZpbmVkICYmIEFba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGtleSBpbiBCKSB7XG5cdFx0XHRcdGlmIChBW2tleV0gPT09IHVuZGVmaW5lZCAmJiBCW2tleV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Zm9yIChrZXkgaW4gQSkge1xuXHRcdFx0XHRpZiAoIXJlY3Vyc2l2ZUNvbXBhcmUoQVtrZXldLCBCW2tleV0pKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVCYXNpYyA9IGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0dmFyIGVycm9yO1xuXHRpZiAoZXJyb3IgPSB0aGlzLnZhbGlkYXRlVHlwZShkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCkpIHtcblx0XHRyZXR1cm4gZXJyb3IucHJlZml4V2l0aChudWxsLCBcInR5cGVcIik7XG5cdH1cblx0aWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUVudW0oZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpKSB7XG5cdFx0cmV0dXJuIGVycm9yLnByZWZpeFdpdGgobnVsbCwgXCJ0eXBlXCIpO1xuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVUeXBlID0gZnVuY3Rpb24gdmFsaWRhdGVUeXBlKGRhdGEsIHNjaGVtYSkge1xuXHRpZiAoc2NoZW1hLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHZhciBkYXRhVHlwZSA9IHR5cGVvZiBkYXRhO1xuXHRpZiAoZGF0YSA9PT0gbnVsbCkge1xuXHRcdGRhdGFUeXBlID0gXCJudWxsXCI7XG5cdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuXHRcdGRhdGFUeXBlID0gXCJhcnJheVwiO1xuXHR9XG5cdHZhciBhbGxvd2VkVHlwZXMgPSBzY2hlbWEudHlwZTtcblx0aWYgKCFBcnJheS5pc0FycmF5KGFsbG93ZWRUeXBlcykpIHtcblx0XHRhbGxvd2VkVHlwZXMgPSBbYWxsb3dlZFR5cGVzXTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYWxsb3dlZFR5cGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHR5cGUgPSBhbGxvd2VkVHlwZXNbaV07XG5cdFx0aWYgKHR5cGUgPT09IGRhdGFUeXBlIHx8ICh0eXBlID09PSBcImludGVnZXJcIiAmJiBkYXRhVHlwZSA9PT0gXCJudW1iZXJcIiAmJiAoZGF0YSAlIDEgPT09IDApKSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuSU5WQUxJRF9UWVBFLCB7dHlwZTogZGF0YVR5cGUsIGV4cGVjdGVkOiBhbGxvd2VkVHlwZXMuam9pbihcIi9cIil9LCAnJywgJycsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZUVudW0gPSBmdW5jdGlvbiB2YWxpZGF0ZUVudW0oZGF0YSwgc2NoZW1hKSB7XG5cdGlmIChzY2hlbWFbXCJlbnVtXCJdID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYVtcImVudW1cIl0ubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgZW51bVZhbCA9IHNjaGVtYVtcImVudW1cIl1baV07XG5cdFx0aWYgKHJlY3Vyc2l2ZUNvbXBhcmUoZGF0YSwgZW51bVZhbCkpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLkVOVU1fTUlTTUFUQ0gsIHt2YWx1ZTogKHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJykgPyBKU09OLnN0cmluZ2lmeShkYXRhKSA6IGRhdGF9LCAnJywgJycsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZU51bWVyaWMgPSBmdW5jdGlvbiB2YWxpZGF0ZU51bWVyaWMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0cmV0dXJuIHRoaXMudmFsaWRhdGVNdWx0aXBsZU9mKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVNaW5NYXgoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZU5hTihkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCBudWxsO1xufTtcblxudmFyIENMT1NFX0VOT1VHSF9MT1cgPSBNYXRoLnBvdygyLCAtNTEpO1xudmFyIENMT1NFX0VOT1VHSF9ISUdIID0gMSAtIENMT1NFX0VOT1VHSF9MT1c7XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZU11bHRpcGxlT2YgPSBmdW5jdGlvbiB2YWxpZGF0ZU11bHRpcGxlT2YoZGF0YSwgc2NoZW1hKSB7XG5cdHZhciBtdWx0aXBsZU9mID0gc2NoZW1hLm11bHRpcGxlT2YgfHwgc2NoZW1hLmRpdmlzaWJsZUJ5O1xuXHRpZiAobXVsdGlwbGVPZiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0aWYgKHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiKSB7XG5cdFx0dmFyIHJlbWFpbmRlciA9IChkYXRhL211bHRpcGxlT2YpJTE7XG5cdFx0aWYgKHJlbWFpbmRlciA+PSBDTE9TRV9FTk9VR0hfTE9XICYmIHJlbWFpbmRlciA8IENMT1NFX0VOT1VHSF9ISUdIKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk5VTUJFUl9NVUxUSVBMRV9PRiwge3ZhbHVlOiBkYXRhLCBtdWx0aXBsZU9mOiBtdWx0aXBsZU9mfSwgJycsICcnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlTWluTWF4ID0gZnVuY3Rpb24gdmFsaWRhdGVNaW5NYXgoZGF0YSwgc2NoZW1hKSB7XG5cdGlmICh0eXBlb2YgZGF0YSAhPT0gXCJudW1iZXJcIikge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdGlmIChzY2hlbWEubWluaW11bSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGRhdGEgPCBzY2hlbWEubWluaW11bSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5OVU1CRVJfTUlOSU1VTSwge3ZhbHVlOiBkYXRhLCBtaW5pbXVtOiBzY2hlbWEubWluaW11bX0sICcnLCAnL21pbmltdW0nLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdH1cblx0XHRpZiAoc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0gJiYgZGF0YSA9PT0gc2NoZW1hLm1pbmltdW0pIHtcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuTlVNQkVSX01JTklNVU1fRVhDTFVTSVZFLCB7dmFsdWU6IGRhdGEsIG1pbmltdW06IHNjaGVtYS5taW5pbXVtfSwgJycsICcvZXhjbHVzaXZlTWluaW11bScsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0fVxuXHR9XG5cdGlmIChzY2hlbWEubWF4aW11bSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGRhdGEgPiBzY2hlbWEubWF4aW11bSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5OVU1CRVJfTUFYSU1VTSwge3ZhbHVlOiBkYXRhLCBtYXhpbXVtOiBzY2hlbWEubWF4aW11bX0sICcnLCAnL21heGltdW0nLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdH1cblx0XHRpZiAoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0gJiYgZGF0YSA9PT0gc2NoZW1hLm1heGltdW0pIHtcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuTlVNQkVSX01BWElNVU1fRVhDTFVTSVZFLCB7dmFsdWU6IGRhdGEsIG1heGltdW06IHNjaGVtYS5tYXhpbXVtfSwgJycsICcvZXhjbHVzaXZlTWF4aW11bScsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVOYU4gPSBmdW5jdGlvbiB2YWxpZGF0ZU5hTihkYXRhLCBzY2hlbWEpIHtcblx0aWYgKHR5cGVvZiBkYXRhICE9PSBcIm51bWJlclwiKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0aWYgKGlzTmFOKGRhdGEpID09PSB0cnVlIHx8IGRhdGEgPT09IEluZmluaXR5IHx8IGRhdGEgPT09IC1JbmZpbml0eSkge1xuXHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuTlVNQkVSX05PVF9BX05VTUJFUiwge3ZhbHVlOiBkYXRhfSwgJycsICcvdHlwZScsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZVN0cmluZyA9IGZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdHJldHVybiB0aGlzLnZhbGlkYXRlU3RyaW5nTGVuZ3RoKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVTdHJpbmdQYXR0ZXJuKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZVN0cmluZ0xlbmd0aCA9IGZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nTGVuZ3RoKGRhdGEsIHNjaGVtYSkge1xuXHRpZiAodHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRpZiAoc2NoZW1hLm1pbkxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGRhdGEubGVuZ3RoIDwgc2NoZW1hLm1pbkxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5TVFJJTkdfTEVOR1RIX1NIT1JULCB7bGVuZ3RoOiBkYXRhLmxlbmd0aCwgbWluaW11bTogc2NoZW1hLm1pbkxlbmd0aH0sICcnLCAnL21pbkxlbmd0aCcsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0fVxuXHR9XG5cdGlmIChzY2hlbWEubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoZGF0YS5sZW5ndGggPiBzY2hlbWEubWF4TGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLlNUUklOR19MRU5HVEhfTE9ORywge2xlbmd0aDogZGF0YS5sZW5ndGgsIG1heGltdW06IHNjaGVtYS5tYXhMZW5ndGh9LCAnJywgJy9tYXhMZW5ndGgnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlU3RyaW5nUGF0dGVybiA9IGZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nUGF0dGVybihkYXRhLCBzY2hlbWEpIHtcblx0aWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiIHx8ICh0eXBlb2Ygc2NoZW1hLnBhdHRlcm4gIT09IFwic3RyaW5nXCIgJiYgIShzY2hlbWEucGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dmFyIHJlZ2V4cDtcblx0aWYgKHNjaGVtYS5wYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdCAgcmVnZXhwID0gc2NoZW1hLnBhdHRlcm47XG5cdH1cblx0ZWxzZSB7XG5cdCAgdmFyIGJvZHksIGZsYWdzID0gJyc7XG5cdCAgLy8gQ2hlY2sgZm9yIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsc1xuXHQgIC8vIEBzZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTcuOC41XG5cdCAgdmFyIGxpdGVyYWwgPSBzY2hlbWEucGF0dGVybi5tYXRjaCgvXlxcLyguKylcXC8oW2ltZ10qKSQvKTtcblx0ICBpZiAobGl0ZXJhbCkge1xuXHQgICAgYm9keSA9IGxpdGVyYWxbMV07XG5cdCAgICBmbGFncyA9IGxpdGVyYWxbMl07XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHQgICAgYm9keSA9IHNjaGVtYS5wYXR0ZXJuO1xuXHQgIH1cblx0ICByZWdleHAgPSBuZXcgUmVnRXhwKGJvZHksIGZsYWdzKTtcblx0fVxuXHRpZiAoIXJlZ2V4cC50ZXN0KGRhdGEpKSB7XG5cdFx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5TVFJJTkdfUEFUVEVSTiwge3BhdHRlcm46IHNjaGVtYS5wYXR0ZXJufSwgJycsICcvcGF0dGVybicsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZUFycmF5ID0gZnVuY3Rpb24gdmFsaWRhdGVBcnJheShkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCkge1xuXHRpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRyZXR1cm4gdGhpcy52YWxpZGF0ZUFycmF5TGVuZ3RoKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVBcnJheVVuaXF1ZUl0ZW1zKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVBcnJheUl0ZW1zKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZUFycmF5TGVuZ3RoID0gZnVuY3Rpb24gdmFsaWRhdGVBcnJheUxlbmd0aChkYXRhLCBzY2hlbWEpIHtcblx0dmFyIGVycm9yO1xuXHRpZiAoc2NoZW1hLm1pbkl0ZW1zICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoZGF0YS5sZW5ndGggPCBzY2hlbWEubWluSXRlbXMpIHtcblx0XHRcdGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLkFSUkFZX0xFTkdUSF9TSE9SVCwge2xlbmd0aDogZGF0YS5sZW5ndGgsIG1pbmltdW06IHNjaGVtYS5taW5JdGVtc30sICcnLCAnL21pbkl0ZW1zJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHRcdGlmICh0aGlzLmhhbmRsZUVycm9yKGVycm9yKSkge1xuXHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGlmIChzY2hlbWEubWF4SXRlbXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChkYXRhLmxlbmd0aCA+IHNjaGVtYS5tYXhJdGVtcykge1xuXHRcdFx0ZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuQVJSQVlfTEVOR1RIX0xPTkcsIHtsZW5ndGg6IGRhdGEubGVuZ3RoLCBtYXhpbXVtOiBzY2hlbWEubWF4SXRlbXN9LCAnJywgJy9tYXhJdGVtcycsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0XHRpZiAodGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlQXJyYXlVbmlxdWVJdGVtcyA9IGZ1bmN0aW9uIHZhbGlkYXRlQXJyYXlVbmlxdWVJdGVtcyhkYXRhLCBzY2hlbWEpIHtcblx0aWYgKHNjaGVtYS51bmlxdWVJdGVtcykge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0Zm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgZGF0YS5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRpZiAocmVjdXJzaXZlQ29tcGFyZShkYXRhW2ldLCBkYXRhW2pdKSkge1xuXHRcdFx0XHRcdHZhciBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5BUlJBWV9VTklRVUUsIHttYXRjaDE6IGksIG1hdGNoMjogan0sICcnLCAnL3VuaXF1ZUl0ZW1zJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHRcdFx0XHRpZiAodGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZUFycmF5SXRlbXMgPSBmdW5jdGlvbiB2YWxpZGF0ZUFycmF5SXRlbXMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0aWYgKHNjaGVtYS5pdGVtcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dmFyIGVycm9yLCBpO1xuXHRpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpKSB7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChpIDwgc2NoZW1hLml0ZW1zLmxlbmd0aCkge1xuXHRcdFx0XHRpZiAoZXJyb3IgPSB0aGlzLnZhbGlkYXRlQWxsKGRhdGFbaV0sIHNjaGVtYS5pdGVtc1tpXSwgW2ldLCBbXCJpdGVtc1wiLCBpXSwgZGF0YVBvaW50ZXJQYXRoICsgXCIvXCIgKyBpKSkge1xuXHRcdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChzY2hlbWEuYWRkaXRpb25hbEl0ZW1zICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zID09PSBcImJvb2xlYW5cIikge1xuXHRcdFx0XHRcdGlmICghc2NoZW1hLmFkZGl0aW9uYWxJdGVtcykge1xuXHRcdFx0XHRcdFx0ZXJyb3IgPSAodGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLkFSUkFZX0FERElUSU9OQUxfSVRFTVMsIHt9LCAnLycgKyBpLCAnL2FkZGl0aW9uYWxJdGVtcycsIG51bGwsIGRhdGEsIHNjaGVtYSkpO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoZXJyb3IgPSB0aGlzLnZhbGlkYXRlQWxsKGRhdGFbaV0sIHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMsIFtpXSwgW1wiYWRkaXRpb25hbEl0ZW1zXCJdLCBkYXRhUG9pbnRlclBhdGggKyBcIi9cIiArIGkpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoZXJyb3IgPSB0aGlzLnZhbGlkYXRlQWxsKGRhdGFbaV0sIHNjaGVtYS5pdGVtcywgW2ldLCBbXCJpdGVtc1wiXSwgZGF0YVBvaW50ZXJQYXRoICsgXCIvXCIgKyBpKSkge1xuXHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVPYmplY3QgPSBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCkge1xuXHRpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIgfHwgZGF0YSA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0cmV0dXJuIHRoaXMudmFsaWRhdGVPYmplY3RNaW5NYXhQcm9wZXJ0aWVzKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVPYmplY3RSZXF1aXJlZFByb3BlcnRpZXMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZU9iamVjdFByb3BlcnRpZXMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZU9iamVjdERlcGVuZGVuY2llcyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVPYmplY3RNaW5NYXhQcm9wZXJ0aWVzID0gZnVuY3Rpb24gdmFsaWRhdGVPYmplY3RNaW5NYXhQcm9wZXJ0aWVzKGRhdGEsIHNjaGVtYSkge1xuXHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuXHR2YXIgZXJyb3I7XG5cdGlmIChzY2hlbWEubWluUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGtleXMubGVuZ3RoIDwgc2NoZW1hLm1pblByb3BlcnRpZXMpIHtcblx0XHRcdGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk9CSkVDVF9QUk9QRVJUSUVTX01JTklNVU0sIHtwcm9wZXJ0eUNvdW50OiBrZXlzLmxlbmd0aCwgbWluaW11bTogc2NoZW1hLm1pblByb3BlcnRpZXN9LCAnJywgJy9taW5Qcm9wZXJ0aWVzJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHRcdGlmICh0aGlzLmhhbmRsZUVycm9yKGVycm9yKSkge1xuXHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGlmIChzY2hlbWEubWF4UHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGtleXMubGVuZ3RoID4gc2NoZW1hLm1heFByb3BlcnRpZXMpIHtcblx0XHRcdGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk9CSkVDVF9QUk9QRVJUSUVTX01BWElNVU0sIHtwcm9wZXJ0eUNvdW50OiBrZXlzLmxlbmd0aCwgbWF4aW11bTogc2NoZW1hLm1heFByb3BlcnRpZXN9LCAnJywgJy9tYXhQcm9wZXJ0aWVzJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHRcdGlmICh0aGlzLmhhbmRsZUVycm9yKGVycm9yKSkge1xuXHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVPYmplY3RSZXF1aXJlZFByb3BlcnRpZXMgPSBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdFJlcXVpcmVkUHJvcGVydGllcyhkYXRhLCBzY2hlbWEpIHtcblx0aWYgKHNjaGVtYS5yZXF1aXJlZCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzY2hlbWEucmVxdWlyZWQubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSBzY2hlbWEucmVxdWlyZWRbaV07XG5cdFx0XHRpZiAoZGF0YVtrZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dmFyIGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk9CSkVDVF9SRVFVSVJFRCwge2tleToga2V5fSwgJycsICcvcmVxdWlyZWQvJyArIGksIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0XHRcdGlmICh0aGlzLmhhbmRsZUVycm9yKGVycm9yKSkge1xuXHRcdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlT2JqZWN0UHJvcGVydGllcyA9IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0UHJvcGVydGllcyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCkge1xuXHR2YXIgZXJyb3I7XG5cdGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG5cdFx0dmFyIGtleVBvaW50ZXJQYXRoID0gZGF0YVBvaW50ZXJQYXRoICsgXCIvXCIgKyBrZXkucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XG5cdFx0dmFyIGZvdW5kTWF0Y2ggPSBmYWxzZTtcblx0XHRpZiAoc2NoZW1hLnByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCAmJiBzY2hlbWEucHJvcGVydGllc1trZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGZvdW5kTWF0Y2ggPSB0cnVlO1xuXHRcdFx0aWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhW2tleV0sIHNjaGVtYS5wcm9wZXJ0aWVzW2tleV0sIFtrZXldLCBbXCJwcm9wZXJ0aWVzXCIsIGtleV0sIGtleVBvaW50ZXJQYXRoKSkge1xuXHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzY2hlbWEucGF0dGVyblByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Zm9yICh2YXIgcGF0dGVybktleSBpbiBzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpIHtcblx0XHRcdFx0dmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAocGF0dGVybktleSk7XG5cdFx0XHRcdGlmIChyZWdleHAudGVzdChrZXkpKSB7XG5cdFx0XHRcdFx0Zm91bmRNYXRjaCA9IHRydWU7XG5cdFx0XHRcdFx0aWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhW2tleV0sIHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllc1twYXR0ZXJuS2V5XSwgW2tleV0sIFtcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsIHBhdHRlcm5LZXldLCBrZXlQb2ludGVyUGF0aCkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFmb3VuZE1hdGNoKSB7XG5cdFx0XHRpZiAoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcykge1xuXHRcdFx0XHRcdHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzW2tleVBvaW50ZXJQYXRoXSA9IHRydWU7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMudW5rbm93blByb3BlcnR5UGF0aHNba2V5UG9pbnRlclBhdGhdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlb2Ygc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBcImJvb2xlYW5cIikge1xuXHRcdFx0XHRcdGlmICghc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSB7XG5cdFx0XHRcdFx0XHRlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5PQkpFQ1RfQURESVRJT05BTF9QUk9QRVJUSUVTLCB7a2V5OiBrZXl9LCAnJywgJy9hZGRpdGlvbmFsUHJvcGVydGllcycsIG51bGwsIGRhdGEsIHNjaGVtYSkucHJlZml4V2l0aChrZXksIG51bGwpO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhW2tleV0sIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcywgW2tleV0sIFtcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCJdLCBrZXlQb2ludGVyUGF0aCkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodGhpcy50cmFja1Vua25vd25Qcm9wZXJ0aWVzICYmICF0aGlzLmtub3duUHJvcGVydHlQYXRoc1trZXlQb2ludGVyUGF0aF0pIHtcblx0XHRcdFx0dGhpcy51bmtub3duUHJvcGVydHlQYXRoc1trZXlQb2ludGVyUGF0aF0gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodGhpcy50cmFja1Vua25vd25Qcm9wZXJ0aWVzKSB7XG5cdFx0XHR0aGlzLmtub3duUHJvcGVydHlQYXRoc1trZXlQb2ludGVyUGF0aF0gPSB0cnVlO1xuXHRcdFx0ZGVsZXRlIHRoaXMudW5rbm93blByb3BlcnR5UGF0aHNba2V5UG9pbnRlclBhdGhdO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlT2JqZWN0RGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gdmFsaWRhdGVPYmplY3REZXBlbmRlbmNpZXMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0dmFyIGVycm9yO1xuXHRpZiAoc2NoZW1hLmRlcGVuZGVuY2llcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Zm9yICh2YXIgZGVwS2V5IGluIHNjaGVtYS5kZXBlbmRlbmNpZXMpIHtcblx0XHRcdGlmIChkYXRhW2RlcEtleV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR2YXIgZGVwID0gc2NoZW1hLmRlcGVuZGVuY2llc1tkZXBLZXldO1xuXHRcdFx0XHRpZiAodHlwZW9mIGRlcCA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdGlmIChkYXRhW2RlcF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0ZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuT0JKRUNUX0RFUEVOREVOQ1lfS0VZLCB7a2V5OiBkZXBLZXksIG1pc3Npbmc6IGRlcH0sICcnLCAnJywgbnVsbCwgZGF0YSwgc2NoZW1hKS5wcmVmaXhXaXRoKG51bGwsIGRlcEtleSkucHJlZml4V2l0aChudWxsLCBcImRlcGVuZGVuY2llc1wiKTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLmhhbmRsZUVycm9yKGVycm9yKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGVwKSkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgcmVxdWlyZWRLZXkgPSBkZXBbaV07XG5cdFx0XHRcdFx0XHRpZiAoZGF0YVtyZXF1aXJlZEtleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5PQkpFQ1RfREVQRU5ERU5DWV9LRVksIHtrZXk6IGRlcEtleSwgbWlzc2luZzogcmVxdWlyZWRLZXl9LCAnJywgJy8nICsgaSwgbnVsbCwgZGF0YSwgc2NoZW1hKS5wcmVmaXhXaXRoKG51bGwsIGRlcEtleSkucHJlZml4V2l0aChudWxsLCBcImRlcGVuZGVuY2llc1wiKTtcblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChlcnJvciA9IHRoaXMudmFsaWRhdGVBbGwoZGF0YSwgZGVwLCBbXSwgW1wiZGVwZW5kZW5jaWVzXCIsIGRlcEtleV0sIGRhdGFQb2ludGVyUGF0aCkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZUNvbWJpbmF0aW9ucyA9IGZ1bmN0aW9uIHZhbGlkYXRlQ29tYmluYXRpb25zKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdHJldHVybiB0aGlzLnZhbGlkYXRlQWxsT2YoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZUFueU9mKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVPbmVPZihkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlTm90KGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZUFsbE9mID0gZnVuY3Rpb24gdmFsaWRhdGVBbGxPZihkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCkge1xuXHRpZiAoc2NoZW1hLmFsbE9mID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR2YXIgZXJyb3I7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc2NoZW1hLmFsbE9mLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHN1YlNjaGVtYSA9IHNjaGVtYS5hbGxPZltpXTtcblx0XHRpZiAoZXJyb3IgPSB0aGlzLnZhbGlkYXRlQWxsKGRhdGEsIHN1YlNjaGVtYSwgW10sIFtcImFsbE9mXCIsIGldLCBkYXRhUG9pbnRlclBhdGgpKSB7XG5cdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVBbnlPZiA9IGZ1bmN0aW9uIHZhbGlkYXRlQW55T2YoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0aWYgKHNjaGVtYS5hbnlPZiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dmFyIGVycm9ycyA9IFtdO1xuXHR2YXIgc3RhcnRFcnJvckNvdW50ID0gdGhpcy5lcnJvcnMubGVuZ3RoO1xuXHR2YXIgb2xkVW5rbm93blByb3BlcnR5UGF0aHMsIG9sZEtub3duUHJvcGVydHlQYXRocztcblx0aWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcykge1xuXHRcdG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzID0gdGhpcy51bmtub3duUHJvcGVydHlQYXRocztcblx0XHRvbGRLbm93blByb3BlcnR5UGF0aHMgPSB0aGlzLmtub3duUHJvcGVydHlQYXRocztcblx0fVxuXHR2YXIgZXJyb3JBdEVuZCA9IHRydWU7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc2NoZW1hLmFueU9mLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcykge1xuXHRcdFx0dGhpcy51bmtub3duUHJvcGVydHlQYXRocyA9IHt9O1xuXHRcdFx0dGhpcy5rbm93blByb3BlcnR5UGF0aHMgPSB7fTtcblx0XHR9XG5cdFx0dmFyIHN1YlNjaGVtYSA9IHNjaGVtYS5hbnlPZltpXTtcblxuXHRcdHZhciBlcnJvckNvdW50ID0gdGhpcy5lcnJvcnMubGVuZ3RoO1xuXHRcdHZhciBlcnJvciA9IHRoaXMudmFsaWRhdGVBbGwoZGF0YSwgc3ViU2NoZW1hLCBbXSwgW1wiYW55T2ZcIiwgaV0sIGRhdGFQb2ludGVyUGF0aCk7XG5cblx0XHRpZiAoZXJyb3IgPT09IG51bGwgJiYgZXJyb3JDb3VudCA9PT0gdGhpcy5lcnJvcnMubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLmVycm9ycyA9IHRoaXMuZXJyb3JzLnNsaWNlKDAsIHN0YXJ0RXJyb3JDb3VudCk7XG5cblx0XHRcdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRcdFx0Zm9yICh2YXIga25vd25LZXkgaW4gdGhpcy5rbm93blByb3BlcnR5UGF0aHMpIHtcblx0XHRcdFx0XHRvbGRLbm93blByb3BlcnR5UGF0aHNba25vd25LZXldID0gdHJ1ZTtcblx0XHRcdFx0XHRkZWxldGUgb2xkVW5rbm93blByb3BlcnR5UGF0aHNba25vd25LZXldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAodmFyIHVua25vd25LZXkgaW4gdGhpcy51bmtub3duUHJvcGVydHlQYXRocykge1xuXHRcdFx0XHRcdGlmICghb2xkS25vd25Qcm9wZXJ0eVBhdGhzW3Vua25vd25LZXldKSB7XG5cdFx0XHRcdFx0XHRvbGRVbmtub3duUHJvcGVydHlQYXRoc1t1bmtub3duS2V5XSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFdlIG5lZWQgdG8gY29udGludWUgbG9vcGluZyBzbyB3ZSBjYXRjaCBhbGwgdGhlIHByb3BlcnR5IGRlZmluaXRpb25zLCBidXQgd2UgZG9uJ3Qgd2FudCB0byByZXR1cm4gYW4gZXJyb3Jcblx0XHRcdFx0ZXJyb3JBdEVuZCA9IGZhbHNlO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdGlmIChlcnJvcikge1xuXHRcdFx0ZXJyb3JzLnB1c2goZXJyb3IucHJlZml4V2l0aChudWxsLCBcIlwiICsgaSkucHJlZml4V2l0aChudWxsLCBcImFueU9mXCIpKTtcblx0XHR9XG5cdH1cblx0aWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcykge1xuXHRcdHRoaXMudW5rbm93blByb3BlcnR5UGF0aHMgPSBvbGRVbmtub3duUHJvcGVydHlQYXRocztcblx0XHR0aGlzLmtub3duUHJvcGVydHlQYXRocyA9IG9sZEtub3duUHJvcGVydHlQYXRocztcblx0fVxuXHRpZiAoZXJyb3JBdEVuZCkge1xuXHRcdGVycm9ycyA9IGVycm9ycy5jb25jYXQodGhpcy5lcnJvcnMuc2xpY2Uoc3RhcnRFcnJvckNvdW50KSk7XG5cdFx0dGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycy5zbGljZSgwLCBzdGFydEVycm9yQ291bnQpO1xuXHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuQU5ZX09GX01JU1NJTkcsIHt9LCBcIlwiLCBcIi9hbnlPZlwiLCBlcnJvcnMsIGRhdGEsIHNjaGVtYSk7XG5cdH1cbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlT25lT2YgPSBmdW5jdGlvbiB2YWxpZGF0ZU9uZU9mKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdGlmIChzY2hlbWEub25lT2YgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHZhciB2YWxpZEluZGV4ID0gbnVsbDtcblx0dmFyIGVycm9ycyA9IFtdO1xuXHR2YXIgc3RhcnRFcnJvckNvdW50ID0gdGhpcy5lcnJvcnMubGVuZ3RoO1xuXHR2YXIgb2xkVW5rbm93blByb3BlcnR5UGF0aHMsIG9sZEtub3duUHJvcGVydHlQYXRocztcblx0aWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcykge1xuXHRcdG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzID0gdGhpcy51bmtub3duUHJvcGVydHlQYXRocztcblx0XHRvbGRLbm93blByb3BlcnR5UGF0aHMgPSB0aGlzLmtub3duUHJvcGVydHlQYXRocztcblx0fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYS5vbmVPZi5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRcdHRoaXMudW5rbm93blByb3BlcnR5UGF0aHMgPSB7fTtcblx0XHRcdHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzID0ge307XG5cdFx0fVxuXHRcdHZhciBzdWJTY2hlbWEgPSBzY2hlbWEub25lT2ZbaV07XG5cblx0XHR2YXIgZXJyb3JDb3VudCA9IHRoaXMuZXJyb3JzLmxlbmd0aDtcblx0XHR2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRlQWxsKGRhdGEsIHN1YlNjaGVtYSwgW10sIFtcIm9uZU9mXCIsIGldLCBkYXRhUG9pbnRlclBhdGgpO1xuXG5cdFx0aWYgKGVycm9yID09PSBudWxsICYmIGVycm9yQ291bnQgPT09IHRoaXMuZXJyb3JzLmxlbmd0aCkge1xuXHRcdFx0aWYgKHZhbGlkSW5kZXggPT09IG51bGwpIHtcblx0XHRcdFx0dmFsaWRJbmRleCA9IGk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmVycm9ycyA9IHRoaXMuZXJyb3JzLnNsaWNlKDAsIHN0YXJ0RXJyb3JDb3VudCk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuT05FX09GX01VTFRJUExFLCB7aW5kZXgxOiB2YWxpZEluZGV4LCBpbmRleDI6IGl9LCBcIlwiLCBcIi9vbmVPZlwiLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcykge1xuXHRcdFx0XHRmb3IgKHZhciBrbm93bktleSBpbiB0aGlzLmtub3duUHJvcGVydHlQYXRocykge1xuXHRcdFx0XHRcdG9sZEtub3duUHJvcGVydHlQYXRoc1trbm93bktleV0gPSB0cnVlO1xuXHRcdFx0XHRcdGRlbGV0ZSBvbGRVbmtub3duUHJvcGVydHlQYXRoc1trbm93bktleV07XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICh2YXIgdW5rbm93bktleSBpbiB0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzKSB7XG5cdFx0XHRcdFx0aWYgKCFvbGRLbm93blByb3BlcnR5UGF0aHNbdW5rbm93bktleV0pIHtcblx0XHRcdFx0XHRcdG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzW3Vua25vd25LZXldID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGVycm9yKSB7XG5cdFx0XHRlcnJvcnMucHVzaChlcnJvcik7XG5cdFx0fVxuXHR9XG5cdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHR0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzID0gb2xkVW5rbm93blByb3BlcnR5UGF0aHM7XG5cdFx0dGhpcy5rbm93blByb3BlcnR5UGF0aHMgPSBvbGRLbm93blByb3BlcnR5UGF0aHM7XG5cdH1cblx0aWYgKHZhbGlkSW5kZXggPT09IG51bGwpIHtcblx0XHRlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHRoaXMuZXJyb3JzLnNsaWNlKHN0YXJ0RXJyb3JDb3VudCkpO1xuXHRcdHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMuc2xpY2UoMCwgc3RhcnRFcnJvckNvdW50KTtcblx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk9ORV9PRl9NSVNTSU5HLCB7fSwgXCJcIiwgXCIvb25lT2ZcIiwgZXJyb3JzLCBkYXRhLCBzY2hlbWEpO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMuc2xpY2UoMCwgc3RhcnRFcnJvckNvdW50KTtcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlTm90ID0gZnVuY3Rpb24gdmFsaWRhdGVOb3QoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0aWYgKHNjaGVtYS5ub3QgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHZhciBvbGRFcnJvckNvdW50ID0gdGhpcy5lcnJvcnMubGVuZ3RoO1xuXHR2YXIgb2xkVW5rbm93blByb3BlcnR5UGF0aHMsIG9sZEtub3duUHJvcGVydHlQYXRocztcblx0aWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcykge1xuXHRcdG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzID0gdGhpcy51bmtub3duUHJvcGVydHlQYXRocztcblx0XHRvbGRLbm93blByb3BlcnR5UGF0aHMgPSB0aGlzLmtub3duUHJvcGVydHlQYXRocztcblx0XHR0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzID0ge307XG5cdFx0dGhpcy5rbm93blByb3BlcnR5UGF0aHMgPSB7fTtcblx0fVxuXHR2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRlQWxsKGRhdGEsIHNjaGVtYS5ub3QsIG51bGwsIG51bGwsIGRhdGFQb2ludGVyUGF0aCk7XG5cdHZhciBub3RFcnJvcnMgPSB0aGlzLmVycm9ycy5zbGljZShvbGRFcnJvckNvdW50KTtcblx0dGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycy5zbGljZSgwLCBvbGRFcnJvckNvdW50KTtcblx0aWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcykge1xuXHRcdHRoaXMudW5rbm93blByb3BlcnR5UGF0aHMgPSBvbGRVbmtub3duUHJvcGVydHlQYXRocztcblx0XHR0aGlzLmtub3duUHJvcGVydHlQYXRocyA9IG9sZEtub3duUHJvcGVydHlQYXRocztcblx0fVxuXHRpZiAoZXJyb3IgPT09IG51bGwgJiYgbm90RXJyb3JzLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuTk9UX1BBU1NFRCwge30sIFwiXCIsIFwiL25vdFwiLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVIeXBlcm1lZGlhID0gZnVuY3Rpb24gdmFsaWRhdGVDb21iaW5hdGlvbnMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0aWYgKCFzY2hlbWEubGlua3MpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR2YXIgZXJyb3I7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc2NoZW1hLmxpbmtzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGxkbyA9IHNjaGVtYS5saW5rc1tpXTtcblx0XHRpZiAobGRvLnJlbCA9PT0gXCJkZXNjcmliZWRieVwiKSB7XG5cdFx0XHR2YXIgdGVtcGxhdGUgPSBuZXcgVXJpVGVtcGxhdGUobGRvLmhyZWYpO1xuXHRcdFx0dmFyIGFsbFByZXNlbnQgPSB0cnVlO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB0ZW1wbGF0ZS52YXJOYW1lcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRpZiAoISh0ZW1wbGF0ZS52YXJOYW1lc1tqXSBpbiBkYXRhKSkge1xuXHRcdFx0XHRcdGFsbFByZXNlbnQgPSBmYWxzZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFsbFByZXNlbnQpIHtcblx0XHRcdFx0dmFyIHNjaGVtYVVybCA9IHRlbXBsYXRlLmZpbGxGcm9tT2JqZWN0KGRhdGEpO1xuXHRcdFx0XHR2YXIgc3ViU2NoZW1hID0ge1wiJHJlZlwiOiBzY2hlbWFVcmx9O1xuXHRcdFx0XHRpZiAoZXJyb3IgPSB0aGlzLnZhbGlkYXRlQWxsKGRhdGEsIHN1YlNjaGVtYSwgW10sIFtcImxpbmtzXCIsIGldLCBkYXRhUG9pbnRlclBhdGgpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBwYXJzZVVSSSgpIGFuZCByZXNvbHZlVXJsKCkgYXJlIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTA4ODg1MFxuLy8gICAtICByZWxlYXNlZCBhcyBwdWJsaWMgZG9tYWluIGJ5IGF1dGhvciAoXCJZYWZmbGVcIikgLSBzZWUgY29tbWVudHMgb24gZ2lzdFxuXG5mdW5jdGlvbiBwYXJzZVVSSSh1cmwpIHtcblx0dmFyIG0gPSBTdHJpbmcodXJsKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJykubWF0Y2goL14oW146XFwvPyNdKzopPyhcXC9cXC8oPzpbXjpAXSooPzo6W146QF0qKT9AKT8oKFteOlxcLz8jXSopKD86OihcXGQqKSk/KSk/KFtePyNdKikoXFw/W14jXSopPygjW1xcc1xcU10qKT8vKTtcblx0Ly8gYXV0aG9yaXR5ID0gJy8vJyArIHVzZXIgKyAnOicgKyBwYXNzICdAJyArIGhvc3RuYW1lICsgJzonIHBvcnRcblx0cmV0dXJuIChtID8ge1xuXHRcdGhyZWYgICAgIDogbVswXSB8fCAnJyxcblx0XHRwcm90b2NvbCA6IG1bMV0gfHwgJycsXG5cdFx0YXV0aG9yaXR5OiBtWzJdIHx8ICcnLFxuXHRcdGhvc3QgICAgIDogbVszXSB8fCAnJyxcblx0XHRob3N0bmFtZSA6IG1bNF0gfHwgJycsXG5cdFx0cG9ydCAgICAgOiBtWzVdIHx8ICcnLFxuXHRcdHBhdGhuYW1lIDogbVs2XSB8fCAnJyxcblx0XHRzZWFyY2ggICA6IG1bN10gfHwgJycsXG5cdFx0aGFzaCAgICAgOiBtWzhdIHx8ICcnXG5cdH0gOiBudWxsKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVVybChiYXNlLCBocmVmKSB7Ly8gUkZDIDM5ODZcblxuXHRmdW5jdGlvbiByZW1vdmVEb3RTZWdtZW50cyhpbnB1dCkge1xuXHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHRpbnB1dC5yZXBsYWNlKC9eKFxcLlxcLj8oXFwvfCQpKSsvLCAnJylcblx0XHRcdC5yZXBsYWNlKC9cXC8oXFwuKFxcL3wkKSkrL2csICcvJylcblx0XHRcdC5yZXBsYWNlKC9cXC9cXC5cXC4kLywgJy8uLi8nKVxuXHRcdFx0LnJlcGxhY2UoL1xcLz9bXlxcL10qL2csIGZ1bmN0aW9uIChwKSB7XG5cdFx0XHRcdGlmIChwID09PSAnLy4uJykge1xuXHRcdFx0XHRcdG91dHB1dC5wb3AoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvdXRwdXQucHVzaChwKTtcblx0XHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBvdXRwdXQuam9pbignJykucmVwbGFjZSgvXlxcLy8sIGlucHV0LmNoYXJBdCgwKSA9PT0gJy8nID8gJy8nIDogJycpO1xuXHR9XG5cblx0aHJlZiA9IHBhcnNlVVJJKGhyZWYgfHwgJycpO1xuXHRiYXNlID0gcGFyc2VVUkkoYmFzZSB8fCAnJyk7XG5cblx0cmV0dXJuICFocmVmIHx8ICFiYXNlID8gbnVsbCA6IChocmVmLnByb3RvY29sIHx8IGJhc2UucHJvdG9jb2wpICtcblx0XHQoaHJlZi5wcm90b2NvbCB8fCBocmVmLmF1dGhvcml0eSA/IGhyZWYuYXV0aG9yaXR5IDogYmFzZS5hdXRob3JpdHkpICtcblx0XHRyZW1vdmVEb3RTZWdtZW50cyhocmVmLnByb3RvY29sIHx8IGhyZWYuYXV0aG9yaXR5IHx8IGhyZWYucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycgPyBocmVmLnBhdGhuYW1lIDogKGhyZWYucGF0aG5hbWUgPyAoKGJhc2UuYXV0aG9yaXR5ICYmICFiYXNlLnBhdGhuYW1lID8gJy8nIDogJycpICsgYmFzZS5wYXRobmFtZS5zbGljZSgwLCBiYXNlLnBhdGhuYW1lLmxhc3RJbmRleE9mKCcvJykgKyAxKSArIGhyZWYucGF0aG5hbWUpIDogYmFzZS5wYXRobmFtZSkpICtcblx0XHQoaHJlZi5wcm90b2NvbCB8fCBocmVmLmF1dGhvcml0eSB8fCBocmVmLnBhdGhuYW1lID8gaHJlZi5zZWFyY2ggOiAoaHJlZi5zZWFyY2ggfHwgYmFzZS5zZWFyY2gpKSArXG5cdFx0aHJlZi5oYXNoO1xufVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudFVyaSh1cmkpIHtcblx0cmV0dXJuIHVyaS5zcGxpdCgnIycpWzBdO1xufVxuZnVuY3Rpb24gbm9ybVNjaGVtYShzY2hlbWEsIGJhc2VVcmkpIHtcblx0aWYgKHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09PSBcIm9iamVjdFwiKSB7XG5cdFx0aWYgKGJhc2VVcmkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0YmFzZVVyaSA9IHNjaGVtYS5pZDtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEuaWQgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdGJhc2VVcmkgPSByZXNvbHZlVXJsKGJhc2VVcmksIHNjaGVtYS5pZCk7XG5cdFx0XHRzY2hlbWEuaWQgPSBiYXNlVXJpO1xuXHRcdH1cblx0XHRpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRub3JtU2NoZW1hKHNjaGVtYVtpXSwgYmFzZVVyaSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0eXBlb2Ygc2NoZW1hWyckcmVmJ10gPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0c2NoZW1hWyckcmVmJ10gPSByZXNvbHZlVXJsKGJhc2VVcmksIHNjaGVtYVsnJHJlZiddKTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGtleSBpbiBzY2hlbWEpIHtcblx0XHRcdFx0aWYgKGtleSAhPT0gXCJlbnVtXCIpIHtcblx0XHRcdFx0XHRub3JtU2NoZW1hKHNjaGVtYVtrZXldLCBiYXNlVXJpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0RXJyb3JSZXBvcnRlcihsYW5ndWFnZSkge1xuXHRsYW5ndWFnZSA9IGxhbmd1YWdlIHx8ICdlbic7XG5cblx0dmFyIGVycm9yTWVzc2FnZXMgPSBsYW5ndWFnZXNbbGFuZ3VhZ2VdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHR2YXIgbWVzc2FnZVRlbXBsYXRlID0gZXJyb3JNZXNzYWdlc1tlcnJvci5jb2RlXSB8fCBFcnJvck1lc3NhZ2VzRGVmYXVsdFtlcnJvci5jb2RlXTtcblx0XHRpZiAodHlwZW9mIG1lc3NhZ2VUZW1wbGF0ZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBcIlVua25vd24gZXJyb3IgY29kZSBcIiArIGVycm9yLmNvZGUgKyBcIjogXCIgKyBKU09OLnN0cmluZ2lmeShlcnJvci5tZXNzYWdlUGFyYW1zKTtcblx0XHR9XG5cdFx0dmFyIG1lc3NhZ2VQYXJhbXMgPSBlcnJvci5wYXJhbXM7XG5cdFx0Ly8gQWRhcHRlZCBmcm9tIENyb2NrZm9yZCdzIHN1cHBsYW50KClcblx0XHRyZXR1cm4gbWVzc2FnZVRlbXBsYXRlLnJlcGxhY2UoL1xceyhbXnt9XSopXFx9L2csIGZ1bmN0aW9uICh3aG9sZSwgdmFyTmFtZSkge1xuXHRcdFx0dmFyIHN1YlZhbHVlID0gbWVzc2FnZVBhcmFtc1t2YXJOYW1lXTtcblx0XHRcdHJldHVybiB0eXBlb2Ygc3ViVmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBzdWJWYWx1ZSA9PT0gJ251bWJlcicgPyBzdWJWYWx1ZSA6IHdob2xlO1xuXHRcdH0pO1xuXHR9O1xufVxuXG52YXIgRXJyb3JDb2RlcyA9IHtcblx0SU5WQUxJRF9UWVBFOiAwLFxuXHRFTlVNX01JU01BVENIOiAxLFxuXHRBTllfT0ZfTUlTU0lORzogMTAsXG5cdE9ORV9PRl9NSVNTSU5HOiAxMSxcblx0T05FX09GX01VTFRJUExFOiAxMixcblx0Tk9UX1BBU1NFRDogMTMsXG5cdC8vIE51bWVyaWMgZXJyb3JzXG5cdE5VTUJFUl9NVUxUSVBMRV9PRjogMTAwLFxuXHROVU1CRVJfTUlOSU1VTTogMTAxLFxuXHROVU1CRVJfTUlOSU1VTV9FWENMVVNJVkU6IDEwMixcblx0TlVNQkVSX01BWElNVU06IDEwMyxcblx0TlVNQkVSX01BWElNVU1fRVhDTFVTSVZFOiAxMDQsXG5cdE5VTUJFUl9OT1RfQV9OVU1CRVI6IDEwNSxcblx0Ly8gU3RyaW5nIGVycm9yc1xuXHRTVFJJTkdfTEVOR1RIX1NIT1JUOiAyMDAsXG5cdFNUUklOR19MRU5HVEhfTE9ORzogMjAxLFxuXHRTVFJJTkdfUEFUVEVSTjogMjAyLFxuXHQvLyBPYmplY3QgZXJyb3JzXG5cdE9CSkVDVF9QUk9QRVJUSUVTX01JTklNVU06IDMwMCxcblx0T0JKRUNUX1BST1BFUlRJRVNfTUFYSU1VTTogMzAxLFxuXHRPQkpFQ1RfUkVRVUlSRUQ6IDMwMixcblx0T0JKRUNUX0FERElUSU9OQUxfUFJPUEVSVElFUzogMzAzLFxuXHRPQkpFQ1RfREVQRU5ERU5DWV9LRVk6IDMwNCxcblx0Ly8gQXJyYXkgZXJyb3JzXG5cdEFSUkFZX0xFTkdUSF9TSE9SVDogNDAwLFxuXHRBUlJBWV9MRU5HVEhfTE9ORzogNDAxLFxuXHRBUlJBWV9VTklRVUU6IDQwMixcblx0QVJSQVlfQURESVRJT05BTF9JVEVNUzogNDAzLFxuXHQvLyBDdXN0b20vdXNlci1kZWZpbmVkIGVycm9yc1xuXHRGT1JNQVRfQ1VTVE9NOiA1MDAsXG5cdEtFWVdPUkRfQ1VTVE9NOiA1MDEsXG5cdC8vIFNjaGVtYSBzdHJ1Y3R1cmVcblx0Q0lSQ1VMQVJfUkVGRVJFTkNFOiA2MDAsXG5cdC8vIE5vbi1zdGFuZGFyZCB2YWxpZGF0aW9uIG9wdGlvbnNcblx0VU5LTk9XTl9QUk9QRVJUWTogMTAwMFxufTtcbnZhciBFcnJvckNvZGVMb29rdXAgPSB7fTtcbmZvciAodmFyIGtleSBpbiBFcnJvckNvZGVzKSB7XG5cdEVycm9yQ29kZUxvb2t1cFtFcnJvckNvZGVzW2tleV1dID0ga2V5O1xufVxudmFyIEVycm9yTWVzc2FnZXNEZWZhdWx0ID0ge1xuXHRJTlZBTElEX1RZUEU6IFwiSW52YWxpZCB0eXBlOiB7dHlwZX0gKGV4cGVjdGVkIHtleHBlY3RlZH0pXCIsXG5cdEVOVU1fTUlTTUFUQ0g6IFwiTm8gZW51bSBtYXRjaCBmb3I6IHt2YWx1ZX1cIixcblx0QU5ZX09GX01JU1NJTkc6IFwiRGF0YSBkb2VzIG5vdCBtYXRjaCBhbnkgc2NoZW1hcyBmcm9tIFxcXCJhbnlPZlxcXCJcIixcblx0T05FX09GX01JU1NJTkc6IFwiRGF0YSBkb2VzIG5vdCBtYXRjaCBhbnkgc2NoZW1hcyBmcm9tIFxcXCJvbmVPZlxcXCJcIixcblx0T05FX09GX01VTFRJUExFOiBcIkRhdGEgaXMgdmFsaWQgYWdhaW5zdCBtb3JlIHRoYW4gb25lIHNjaGVtYSBmcm9tIFxcXCJvbmVPZlxcXCI6IGluZGljZXMge2luZGV4MX0gYW5kIHtpbmRleDJ9XCIsXG5cdE5PVF9QQVNTRUQ6IFwiRGF0YSBtYXRjaGVzIHNjaGVtYSBmcm9tIFxcXCJub3RcXFwiXCIsXG5cdC8vIE51bWVyaWMgZXJyb3JzXG5cdE5VTUJFUl9NVUxUSVBMRV9PRjogXCJWYWx1ZSB7dmFsdWV9IGlzIG5vdCBhIG11bHRpcGxlIG9mIHttdWx0aXBsZU9mfVwiLFxuXHROVU1CRVJfTUlOSU1VTTogXCJWYWx1ZSB7dmFsdWV9IGlzIGxlc3MgdGhhbiBtaW5pbXVtIHttaW5pbXVtfVwiLFxuXHROVU1CRVJfTUlOSU1VTV9FWENMVVNJVkU6IFwiVmFsdWUge3ZhbHVlfSBpcyBlcXVhbCB0byBleGNsdXNpdmUgbWluaW11bSB7bWluaW11bX1cIixcblx0TlVNQkVSX01BWElNVU06IFwiVmFsdWUge3ZhbHVlfSBpcyBncmVhdGVyIHRoYW4gbWF4aW11bSB7bWF4aW11bX1cIixcblx0TlVNQkVSX01BWElNVU1fRVhDTFVTSVZFOiBcIlZhbHVlIHt2YWx1ZX0gaXMgZXF1YWwgdG8gZXhjbHVzaXZlIG1heGltdW0ge21heGltdW19XCIsXG5cdE5VTUJFUl9OT1RfQV9OVU1CRVI6IFwiVmFsdWUge3ZhbHVlfSBpcyBub3QgYSB2YWxpZCBudW1iZXJcIixcblx0Ly8gU3RyaW5nIGVycm9yc1xuXHRTVFJJTkdfTEVOR1RIX1NIT1JUOiBcIlN0cmluZyBpcyB0b28gc2hvcnQgKHtsZW5ndGh9IGNoYXJzKSwgbWluaW11bSB7bWluaW11bX1cIixcblx0U1RSSU5HX0xFTkdUSF9MT05HOiBcIlN0cmluZyBpcyB0b28gbG9uZyAoe2xlbmd0aH0gY2hhcnMpLCBtYXhpbXVtIHttYXhpbXVtfVwiLFxuXHRTVFJJTkdfUEFUVEVSTjogXCJTdHJpbmcgZG9lcyBub3QgbWF0Y2ggcGF0dGVybjoge3BhdHRlcm59XCIsXG5cdC8vIE9iamVjdCBlcnJvcnNcblx0T0JKRUNUX1BST1BFUlRJRVNfTUlOSU1VTTogXCJUb28gZmV3IHByb3BlcnRpZXMgZGVmaW5lZCAoe3Byb3BlcnR5Q291bnR9KSwgbWluaW11bSB7bWluaW11bX1cIixcblx0T0JKRUNUX1BST1BFUlRJRVNfTUFYSU1VTTogXCJUb28gbWFueSBwcm9wZXJ0aWVzIGRlZmluZWQgKHtwcm9wZXJ0eUNvdW50fSksIG1heGltdW0ge21heGltdW19XCIsXG5cdE9CSkVDVF9SRVFVSVJFRDogXCJNaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5OiB7a2V5fVwiLFxuXHRPQkpFQ1RfQURESVRJT05BTF9QUk9QRVJUSUVTOiBcIkFkZGl0aW9uYWwgcHJvcGVydGllcyBub3QgYWxsb3dlZFwiLFxuXHRPQkpFQ1RfREVQRU5ERU5DWV9LRVk6IFwiRGVwZW5kZW5jeSBmYWlsZWQgLSBrZXkgbXVzdCBleGlzdDoge21pc3Npbmd9IChkdWUgdG8ga2V5OiB7a2V5fSlcIixcblx0Ly8gQXJyYXkgZXJyb3JzXG5cdEFSUkFZX0xFTkdUSF9TSE9SVDogXCJBcnJheSBpcyB0b28gc2hvcnQgKHtsZW5ndGh9KSwgbWluaW11bSB7bWluaW11bX1cIixcblx0QVJSQVlfTEVOR1RIX0xPTkc6IFwiQXJyYXkgaXMgdG9vIGxvbmcgKHtsZW5ndGh9KSwgbWF4aW11bSB7bWF4aW11bX1cIixcblx0QVJSQVlfVU5JUVVFOiBcIkFycmF5IGl0ZW1zIGFyZSBub3QgdW5pcXVlIChpbmRpY2VzIHttYXRjaDF9IGFuZCB7bWF0Y2gyfSlcIixcblx0QVJSQVlfQURESVRJT05BTF9JVEVNUzogXCJBZGRpdGlvbmFsIGl0ZW1zIG5vdCBhbGxvd2VkXCIsXG5cdC8vIEZvcm1hdCBlcnJvcnNcblx0Rk9STUFUX0NVU1RPTTogXCJGb3JtYXQgdmFsaWRhdGlvbiBmYWlsZWQgKHttZXNzYWdlfSlcIixcblx0S0VZV09SRF9DVVNUT006IFwiS2V5d29yZCBmYWlsZWQ6IHtrZXl9ICh7bWVzc2FnZX0pXCIsXG5cdC8vIFNjaGVtYSBzdHJ1Y3R1cmVcblx0Q0lSQ1VMQVJfUkVGRVJFTkNFOiBcIkNpcmN1bGFyICRyZWZzOiB7dXJsc31cIixcblx0Ly8gTm9uLXN0YW5kYXJkIHZhbGlkYXRpb24gb3B0aW9uc1xuXHRVTktOT1dOX1BST1BFUlRZOiBcIlVua25vd24gcHJvcGVydHkgKG5vdCBpbiBzY2hlbWEpXCJcbn07XG5cbmZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvcihjb2RlLCBwYXJhbXMsIGRhdGFQYXRoLCBzY2hlbWFQYXRoLCBzdWJFcnJvcnMpIHtcblx0RXJyb3IuY2FsbCh0aGlzKTtcblx0aWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBFcnJvciAoXCJObyBlcnJvciBjb2RlIHN1cHBsaWVkOiBcIiArIHNjaGVtYVBhdGgpO1xuXHR9XG5cdHRoaXMubWVzc2FnZSA9ICcnO1xuXHR0aGlzLnBhcmFtcyA9IHBhcmFtcztcblx0dGhpcy5jb2RlID0gY29kZTtcblx0dGhpcy5kYXRhUGF0aCA9IGRhdGFQYXRoIHx8IFwiXCI7XG5cdHRoaXMuc2NoZW1hUGF0aCA9IHNjaGVtYVBhdGggfHwgXCJcIjtcblx0dGhpcy5zdWJFcnJvcnMgPSBzdWJFcnJvcnMgfHwgbnVsbDtcblxuXHR2YXIgZXJyID0gbmV3IEVycm9yKHRoaXMubWVzc2FnZSk7XG5cdHRoaXMuc3RhY2sgPSBlcnIuc3RhY2sgfHwgZXJyLnN0YWNrdHJhY2U7XG5cdGlmICghdGhpcy5zdGFjaykge1xuXHRcdHRyeSB7XG5cdFx0XHR0aHJvdyBlcnI7XG5cdFx0fVxuXHRcdGNhdGNoKGVycikge1xuXHRcdFx0dGhpcy5zdGFjayA9IGVyci5zdGFjayB8fCBlcnIuc3RhY2t0cmFjZTtcblx0XHR9XG5cdH1cbn1cblZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5WYWxpZGF0aW9uRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVmFsaWRhdGlvbkVycm9yO1xuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ1ZhbGlkYXRpb25FcnJvcic7XG5cblZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUucHJlZml4V2l0aCA9IGZ1bmN0aW9uIChkYXRhUHJlZml4LCBzY2hlbWFQcmVmaXgpIHtcblx0aWYgKGRhdGFQcmVmaXggIT09IG51bGwpIHtcblx0XHRkYXRhUHJlZml4ID0gZGF0YVByZWZpeC5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFwvL2csIFwifjFcIik7XG5cdFx0dGhpcy5kYXRhUGF0aCA9IFwiL1wiICsgZGF0YVByZWZpeCArIHRoaXMuZGF0YVBhdGg7XG5cdH1cblx0aWYgKHNjaGVtYVByZWZpeCAhPT0gbnVsbCkge1xuXHRcdHNjaGVtYVByZWZpeCA9IHNjaGVtYVByZWZpeC5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFwvL2csIFwifjFcIik7XG5cdFx0dGhpcy5zY2hlbWFQYXRoID0gXCIvXCIgKyBzY2hlbWFQcmVmaXggKyB0aGlzLnNjaGVtYVBhdGg7XG5cdH1cblx0aWYgKHRoaXMuc3ViRXJyb3JzICE9PSBudWxsKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YkVycm9ycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5zdWJFcnJvcnNbaV0ucHJlZml4V2l0aChkYXRhUHJlZml4LCBzY2hlbWFQcmVmaXgpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGlzVHJ1c3RlZFVybChiYXNlVXJsLCB0ZXN0VXJsKSB7XG5cdGlmKHRlc3RVcmwuc3Vic3RyaW5nKDAsIGJhc2VVcmwubGVuZ3RoKSA9PT0gYmFzZVVybCl7XG5cdFx0dmFyIHJlbWFpbmRlciA9IHRlc3RVcmwuc3Vic3RyaW5nKGJhc2VVcmwubGVuZ3RoKTtcblx0XHRpZiAoKHRlc3RVcmwubGVuZ3RoID4gMCAmJiB0ZXN0VXJsLmNoYXJBdChiYXNlVXJsLmxlbmd0aCAtIDEpID09PSBcIi9cIilcblx0XHRcdHx8IHJlbWFpbmRlci5jaGFyQXQoMCkgPT09IFwiI1wiXG5cdFx0XHR8fCByZW1haW5kZXIuY2hhckF0KDApID09PSBcIj9cIikge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxudmFyIGxhbmd1YWdlcyA9IHt9O1xuZnVuY3Rpb24gY3JlYXRlQXBpKGxhbmd1YWdlKSB7XG5cdHZhciBnbG9iYWxDb250ZXh0ID0gbmV3IFZhbGlkYXRvckNvbnRleHQoKTtcblx0dmFyIGN1cnJlbnRMYW5ndWFnZTtcblx0dmFyIGN1c3RvbUVycm9yUmVwb3J0ZXI7XG5cdHZhciBhcGkgPSB7XG5cdFx0c2V0RXJyb3JSZXBvcnRlcjogZnVuY3Rpb24gKHJlcG9ydGVyKSB7XG5cdFx0XHRpZiAodHlwZW9mIHJlcG9ydGVyID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5sYW5ndWFnZShyZXBvcnRlcik7XG5cdFx0XHR9XG5cdFx0XHRjdXN0b21FcnJvclJlcG9ydGVyID0gcmVwb3J0ZXI7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcdGFkZEZvcm1hdDogZnVuY3Rpb24gKCkge1xuXHRcdFx0Z2xvYmFsQ29udGV4dC5hZGRGb3JtYXQuYXBwbHkoZ2xvYmFsQ29udGV4dCwgYXJndW1lbnRzKTtcblx0XHR9LFxuXHRcdGxhbmd1YWdlOiBmdW5jdGlvbiAoY29kZSkge1xuXHRcdFx0aWYgKCFjb2RlKSB7XG5cdFx0XHRcdHJldHVybiBjdXJyZW50TGFuZ3VhZ2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWxhbmd1YWdlc1tjb2RlXSkge1xuXHRcdFx0XHRjb2RlID0gY29kZS5zcGxpdCgnLScpWzBdOyAvLyBmYWxsIGJhY2sgdG8gYmFzZSBsYW5ndWFnZVxuXHRcdFx0fVxuXHRcdFx0aWYgKGxhbmd1YWdlc1tjb2RlXSkge1xuXHRcdFx0XHRjdXJyZW50TGFuZ3VhZ2UgPSBjb2RlO1xuXHRcdFx0XHRyZXR1cm4gY29kZTsgLy8gc28geW91IGNhbiB0ZWxsIGlmIGZhbGwtYmFjayBoYXMgaGFwcGVuZWRcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFkZExhbmd1YWdlOiBmdW5jdGlvbiAoY29kZSwgbWVzc2FnZU1hcCkge1xuXHRcdFx0dmFyIGtleTtcblx0XHRcdGZvciAoa2V5IGluIEVycm9yQ29kZXMpIHtcblx0XHRcdFx0aWYgKG1lc3NhZ2VNYXBba2V5XSAmJiAhbWVzc2FnZU1hcFtFcnJvckNvZGVzW2tleV1dKSB7XG5cdFx0XHRcdFx0bWVzc2FnZU1hcFtFcnJvckNvZGVzW2tleV1dID0gbWVzc2FnZU1hcFtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YXIgcm9vdENvZGUgPSBjb2RlLnNwbGl0KCctJylbMF07XG5cdFx0XHRpZiAoIWxhbmd1YWdlc1tyb290Q29kZV0pIHsgLy8gdXNlIGZvciBiYXNlIGxhbmd1YWdlIGlmIG5vdCB5ZXQgZGVmaW5lZFxuXHRcdFx0XHRsYW5ndWFnZXNbY29kZV0gPSBtZXNzYWdlTWFwO1xuXHRcdFx0XHRsYW5ndWFnZXNbcm9vdENvZGVdID0gbWVzc2FnZU1hcDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxhbmd1YWdlc1tjb2RlXSA9IE9iamVjdC5jcmVhdGUobGFuZ3VhZ2VzW3Jvb3RDb2RlXSk7XG5cdFx0XHRcdGZvciAoa2V5IGluIG1lc3NhZ2VNYXApIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mIGxhbmd1YWdlc1tyb290Q29kZV1ba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRcdGxhbmd1YWdlc1tyb290Q29kZV1ba2V5XSA9IG1lc3NhZ2VNYXBba2V5XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGFuZ3VhZ2VzW2NvZGVdW2tleV0gPSBtZXNzYWdlTWFwW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cdFx0ZnJlc2hBcGk6IGZ1bmN0aW9uIChsYW5ndWFnZSkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IGNyZWF0ZUFwaSgpO1xuXHRcdFx0aWYgKGxhbmd1YWdlKSB7XG5cdFx0XHRcdHJlc3VsdC5sYW5ndWFnZShsYW5ndWFnZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cdFx0dmFsaWRhdGU6IGZ1bmN0aW9uIChkYXRhLCBzY2hlbWEsIGNoZWNrUmVjdXJzaXZlLCBiYW5Vbmtub3duUHJvcGVydGllcykge1xuXHRcdFx0dmFyIGRlZiA9IGRlZmF1bHRFcnJvclJlcG9ydGVyKGN1cnJlbnRMYW5ndWFnZSk7XG5cdFx0XHR2YXIgZXJyb3JSZXBvcnRlciA9IGN1c3RvbUVycm9yUmVwb3J0ZXIgPyBmdW5jdGlvbiAoZXJyb3IsIGRhdGEsIHNjaGVtYSkge1xuXHRcdFx0XHRyZXR1cm4gY3VzdG9tRXJyb3JSZXBvcnRlcihlcnJvciwgZGF0YSwgc2NoZW1hKSB8fCBkZWYoZXJyb3IsIGRhdGEsIHNjaGVtYSk7XG5cdFx0XHR9IDogZGVmO1xuXHRcdFx0dmFyIGNvbnRleHQgPSBuZXcgVmFsaWRhdG9yQ29udGV4dChnbG9iYWxDb250ZXh0LCBmYWxzZSwgZXJyb3JSZXBvcnRlciwgY2hlY2tSZWN1cnNpdmUsIGJhblVua25vd25Qcm9wZXJ0aWVzKTtcblx0XHRcdGlmICh0eXBlb2Ygc2NoZW1hID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHNjaGVtYSA9IHtcIiRyZWZcIjogc2NoZW1hfTtcblx0XHRcdH1cblx0XHRcdGNvbnRleHQuYWRkU2NoZW1hKFwiXCIsIHNjaGVtYSk7XG5cdFx0XHR2YXIgZXJyb3IgPSBjb250ZXh0LnZhbGlkYXRlQWxsKGRhdGEsIHNjaGVtYSwgbnVsbCwgbnVsbCwgXCJcIik7XG5cdFx0XHRpZiAoIWVycm9yICYmIGJhblVua25vd25Qcm9wZXJ0aWVzKSB7XG5cdFx0XHRcdGVycm9yID0gY29udGV4dC5iYW5Vbmtub3duUHJvcGVydGllcyhkYXRhLCBzY2hlbWEpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5lcnJvciA9IGVycm9yO1xuXHRcdFx0dGhpcy5taXNzaW5nID0gY29udGV4dC5taXNzaW5nO1xuXHRcdFx0dGhpcy52YWxpZCA9IChlcnJvciA9PT0gbnVsbCk7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWxpZDtcblx0XHR9LFxuXHRcdHZhbGlkYXRlUmVzdWx0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0ge307XG5cdFx0XHR0aGlzLnZhbGlkYXRlLmFwcGx5KHJlc3VsdCwgYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblx0XHR2YWxpZGF0ZU11bHRpcGxlOiBmdW5jdGlvbiAoZGF0YSwgc2NoZW1hLCBjaGVja1JlY3Vyc2l2ZSwgYmFuVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRcdHZhciBkZWYgPSBkZWZhdWx0RXJyb3JSZXBvcnRlcihjdXJyZW50TGFuZ3VhZ2UpO1xuXHRcdFx0dmFyIGVycm9yUmVwb3J0ZXIgPSBjdXN0b21FcnJvclJlcG9ydGVyID8gZnVuY3Rpb24gKGVycm9yLCBkYXRhLCBzY2hlbWEpIHtcblx0XHRcdFx0cmV0dXJuIGN1c3RvbUVycm9yUmVwb3J0ZXIoZXJyb3IsIGRhdGEsIHNjaGVtYSkgfHwgZGVmKGVycm9yLCBkYXRhLCBzY2hlbWEpO1xuXHRcdFx0fSA6IGRlZjtcblx0XHRcdHZhciBjb250ZXh0ID0gbmV3IFZhbGlkYXRvckNvbnRleHQoZ2xvYmFsQ29udGV4dCwgdHJ1ZSwgZXJyb3JSZXBvcnRlciwgY2hlY2tSZWN1cnNpdmUsIGJhblVua25vd25Qcm9wZXJ0aWVzKTtcblx0XHRcdGlmICh0eXBlb2Ygc2NoZW1hID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHNjaGVtYSA9IHtcIiRyZWZcIjogc2NoZW1hfTtcblx0XHRcdH1cblx0XHRcdGNvbnRleHQuYWRkU2NoZW1hKFwiXCIsIHNjaGVtYSk7XG5cdFx0XHRjb250ZXh0LnZhbGlkYXRlQWxsKGRhdGEsIHNjaGVtYSwgbnVsbCwgbnVsbCwgXCJcIik7XG5cdFx0XHRpZiAoYmFuVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRcdFx0Y29udGV4dC5iYW5Vbmtub3duUHJvcGVydGllcyhkYXRhLCBzY2hlbWEpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHJlc3VsdCA9IHt9O1xuXHRcdFx0cmVzdWx0LmVycm9ycyA9IGNvbnRleHQuZXJyb3JzO1xuXHRcdFx0cmVzdWx0Lm1pc3NpbmcgPSBjb250ZXh0Lm1pc3Npbmc7XG5cdFx0XHRyZXN1bHQudmFsaWQgPSAocmVzdWx0LmVycm9ycy5sZW5ndGggPT09IDApO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXHRcdGFkZFNjaGVtYTogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGdsb2JhbENvbnRleHQuYWRkU2NoZW1hLmFwcGx5KGdsb2JhbENvbnRleHQsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblx0XHRnZXRTY2hlbWE6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBnbG9iYWxDb250ZXh0LmdldFNjaGVtYS5hcHBseShnbG9iYWxDb250ZXh0LCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cdFx0Z2V0U2NoZW1hTWFwOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZ2xvYmFsQ29udGV4dC5nZXRTY2hlbWFNYXAuYXBwbHkoZ2xvYmFsQ29udGV4dCwgYXJndW1lbnRzKTtcblx0XHR9LFxuXHRcdGdldFNjaGVtYVVyaXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBnbG9iYWxDb250ZXh0LmdldFNjaGVtYVVyaXMuYXBwbHkoZ2xvYmFsQ29udGV4dCwgYXJndW1lbnRzKTtcblx0XHR9LFxuXHRcdGdldE1pc3NpbmdVcmlzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZ2xvYmFsQ29udGV4dC5nZXRNaXNzaW5nVXJpcy5hcHBseShnbG9iYWxDb250ZXh0LCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cdFx0ZHJvcFNjaGVtYXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGdsb2JhbENvbnRleHQuZHJvcFNjaGVtYXMuYXBwbHkoZ2xvYmFsQ29udGV4dCwgYXJndW1lbnRzKTtcblx0XHR9LFxuXHRcdGRlZmluZUtleXdvcmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGdsb2JhbENvbnRleHQuZGVmaW5lS2V5d29yZC5hcHBseShnbG9iYWxDb250ZXh0LCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cdFx0ZGVmaW5lRXJyb3I6IGZ1bmN0aW9uIChjb2RlTmFtZSwgY29kZU51bWJlciwgZGVmYXVsdE1lc3NhZ2UpIHtcblx0XHRcdGlmICh0eXBlb2YgY29kZU5hbWUgIT09ICdzdHJpbmcnIHx8ICEvXltBLVpdKyhfW0EtWl0rKSokLy50ZXN0KGNvZGVOYW1lKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvZGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nIGluIFVQUEVSX0NBU0VfV0lUSF9VTkRFUlNDT1JFUycpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBjb2RlTnVtYmVyICE9PSAnbnVtYmVyJyB8fCBjb2RlTnVtYmVyJTEgIT09IDAgfHwgY29kZU51bWJlciA8IDEwMDAwKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignQ29kZSBudW1iZXIgbXVzdCBiZSBhbiBpbnRlZ2VyID4gMTAwMDAnKTtcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2YgRXJyb3JDb2Rlc1tjb2RlTmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXJyb3IgYWxyZWFkeSBkZWZpbmVkOiAnICsgY29kZU5hbWUgKyAnIGFzICcgKyBFcnJvckNvZGVzW2NvZGVOYW1lXSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIEVycm9yQ29kZUxvb2t1cFtjb2RlTnVtYmVyXSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFcnJvciBjb2RlIGFscmVhZHkgdXNlZDogJyArIEVycm9yQ29kZUxvb2t1cFtjb2RlTnVtYmVyXSArICcgYXMgJyArIGNvZGVOdW1iZXIpO1xuXHRcdFx0fVxuXHRcdFx0RXJyb3JDb2Rlc1tjb2RlTmFtZV0gPSBjb2RlTnVtYmVyO1xuXHRcdFx0RXJyb3JDb2RlTG9va3VwW2NvZGVOdW1iZXJdID0gY29kZU5hbWU7XG5cdFx0XHRFcnJvck1lc3NhZ2VzRGVmYXVsdFtjb2RlTmFtZV0gPSBFcnJvck1lc3NhZ2VzRGVmYXVsdFtjb2RlTnVtYmVyXSA9IGRlZmF1bHRNZXNzYWdlO1xuXHRcdFx0Zm9yICh2YXIgbGFuZ0NvZGUgaW4gbGFuZ3VhZ2VzKSB7XG5cdFx0XHRcdHZhciBsYW5ndWFnZSA9IGxhbmd1YWdlc1tsYW5nQ29kZV07XG5cdFx0XHRcdGlmIChsYW5ndWFnZVtjb2RlTmFtZV0pIHtcblx0XHRcdFx0XHRsYW5ndWFnZVtjb2RlTnVtYmVyXSA9IGxhbmd1YWdlW2NvZGVOdW1iZXJdIHx8IGxhbmd1YWdlW2NvZGVOYW1lXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGdsb2JhbENvbnRleHQucmVzZXQoKTtcblx0XHRcdHRoaXMuZXJyb3IgPSBudWxsO1xuXHRcdFx0dGhpcy5taXNzaW5nID0gW107XG5cdFx0XHR0aGlzLnZhbGlkID0gdHJ1ZTtcblx0XHR9LFxuXHRcdG1pc3Npbmc6IFtdLFxuXHRcdGVycm9yOiBudWxsLFxuXHRcdHZhbGlkOiB0cnVlLFxuXHRcdG5vcm1TY2hlbWE6IG5vcm1TY2hlbWEsXG5cdFx0cmVzb2x2ZVVybDogcmVzb2x2ZVVybCxcblx0XHRnZXREb2N1bWVudFVyaTogZ2V0RG9jdW1lbnRVcmksXG5cdFx0ZXJyb3JDb2RlczogRXJyb3JDb2Rlc1xuXHR9O1xuXHRhcGkubGFuZ3VhZ2UobGFuZ3VhZ2UgfHwgJ2VuJyk7XG5cdHJldHVybiBhcGk7XG59XG5cbnZhciB0djQgPSBjcmVhdGVBcGkoKTtcbnR2NC5hZGRMYW5ndWFnZSgnZW4tZ2InLCBFcnJvck1lc3NhZ2VzRGVmYXVsdCk7XG5cbi8vbGVnYWN5IHByb3BlcnR5XG50djQudHY0ID0gdHY0O1xuXG5yZXR1cm4gdHY0OyAvLyB1c2VkIGJ5IF9oZWFkZXIuanMgdG8gZ2xvYmFsaXNlLlxuXG59KSk7IiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwiJ3VzZSBzdHJpY3QnXHJcblxyXG4vLyBzZXR1cCB0aGUgZHJha2UgKGRyYWd1bGEgaW5zdGFuY2UpIGZvciBvdXIgY29tcG9zZXIgZHJhZyBkcm9wIHJlcXVpcmVtZW50c1xyXG5jb25zdCBEcmFrZSA9IGRlcHMgPT4ge1xyXG4gIGNvbnN0IGNsb25lU2VsZWN0b3IgPSAnLmNvbXBvc2VyLW5vZGVfX3Rvb2xiYXIgW2RhdGEtZHJhZ3NvdXJjZT1cImNvbXBvc2VyXCJdJ1xyXG4gIGNvbnN0IGNvbnRhaW5lclNlbGVjdG9yID0gJ1tkYXRhLWRyYWdzb3VyY2U9XCJjb21wb3NlclwiXSdcclxuICBjb25zdCB7IHVwZGF0ZU5vZGUsIGRyYWd1bGEsIGZpbmQsIG9uZHJvcCB9ID0gZGVwc1xyXG5cclxuICBjb25zdCBpc0NvbnRhaW5lciA9IGVsID0+IGVsLm1hdGNoZXMoIGNvbnRhaW5lclNlbGVjdG9yIClcclxuXHJcbiAgY29uc3QgYWNjZXB0cyA9ICggZWwsIGNvbnRhaW5lckVsICkgPT4ge1xyXG4gICAgbGV0IGFjY2VwdHMgPSBjb250YWluZXJFbC5tYXRjaGVzKCBjb250YWluZXJTZWxlY3RvciApXHJcblxyXG4gICAgaWYoIGFjY2VwdHMgKXtcclxuICAgICAgYWNjZXB0cyA9ICFjb250YWluZXJFbC5tYXRjaGVzKCBjbG9uZVNlbGVjdG9yIClcclxuICAgIH1cclxuXHJcbiAgICBpZiggYWNjZXB0cyApe1xyXG4gICAgICBjb25zdCBub2RlID0gZmluZC5lbE5vZGUoIGVsIClcclxuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGZpbmQuY29udGFpbmVyRWxOb2RlKCBjb250YWluZXJFbCApXHJcblxyXG4gICAgICBpZiggbm9kZSA9PT0gcGFyZW50Tm9kZSApIHJldHVybiBmYWxzZVxyXG5cclxuICAgICAgYWNjZXB0cyA9IHBhcmVudE5vZGUuYWNjZXB0cyggbm9kZSApXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFjY2VwdHNcclxuICB9XHJcblxyXG4gIGNvbnN0IG9wdGlvbnMgPSB7IGlzQ29udGFpbmVyLCBhY2NlcHRzIH1cclxuXHJcbiAgY29uc3QgZHJha2UgPSBkcmFndWxhKCBvcHRpb25zIClcclxuXHJcbiAgZHJha2Uub24oICdkcm9wJywgKCBlbCwgY29udGFpbmVyRWwsIHNvdXJjZUNvbnRhaW5lckVsLCBuZXh0RWwgKSA9PiB7XHJcbiAgICBjb25zdCBub2RlID0gZmluZC5lbE5vZGUoIGVsIClcclxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBmaW5kLmNvbnRhaW5lckVsTm9kZSggY29udGFpbmVyRWwgKVxyXG5cclxuICAgIGlmKCBuZXh0RWwgKXtcclxuICAgICAgY29uc3QgcmVmZXJlbmNlTm9kZSA9IGZpbmQuZWxOb2RlKCBuZXh0RWwgKVxyXG4gICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSggbm9kZSwgcmVmZXJlbmNlTm9kZSApXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwYXJlbnROb2RlLmFwcGVuZCggbm9kZSApXHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlTm9kZSggbm9kZSApXHJcblxyXG4gICAgb25kcm9wKCBub2RlLCBwYXJlbnROb2RlLCBlbCwgY29udGFpbmVyRWwsIHNvdXJjZUNvbnRhaW5lckVsLCBuZXh0RWwgKVxyXG4gIH0pXHJcblxyXG4gIHJldHVybiBkcmFrZVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERyYWtlXHJcbiIsIid1c2Ugc3RyaWN0J1xyXG5cclxuLy8gZnVuY3Rpb25zIGZvciBmaW5kaW5nIGRpZmZlcmVudCB0cmVlIG5vZGUgdHlwZXMgaW4gdGhlIGNvbXBvc2VyIERPTVxyXG5jb25zdCBGaW5kID0gaWRNYXAgPT4ge1xyXG4gIGNvbnN0IG5vZGVFbCA9IGVsID0+IGVsLnF1ZXJ5U2VsZWN0b3IoICcuY29tcG9zZXItbm9kZScgKVxyXG4gIGNvbnN0IGNvbnRhaW5lckVsID0gZWwgPT4gZWwuY2xvc2VzdCggJy5jb21wb3Nlci1ub2RlJyApXHJcbiAgY29uc3QgZWxOb2RlID0gZWwgPT4gaWRNYXAuZmluZEJ5SWQoIG5vZGVFbCggZWwgKS5pZCApXHJcbiAgY29uc3QgY29udGFpbmVyRWxOb2RlID0gZWwgPT4gaWRNYXAuZmluZEJ5SWQoIGNvbnRhaW5lckVsKCBlbCApLmlkIClcclxuXHJcbiAgcmV0dXJuIHsgbm9kZUVsLCBjb250YWluZXJFbCwgZWxOb2RlLCBjb250YWluZXJFbE5vZGUgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZpbmRcclxuIiwiJ3VzZSBzdHJpY3QnXHJcblxyXG4vKlxyXG4gIGNhY2hlIHRoYXQgbWFwcyBiZXR3ZWVuIHRyZWUgbm9kZXMgYW5kIHRoZWlyIERPTSByZXByZXNlbnRhdGlvbnMgdXNpbmcgdGhlIGlkXHJcbiAgYXR0cmlidXRlXHJcbiovXHJcbmNvbnN0IElkTWFwID0gdHJlZSA9PiB7XHJcbiAgY29uc3QgaWRNYXAgPSBuZXcgTWFwKClcclxuXHJcbiAgY29uc3QgZmluZEJ5SWQgPSBpZCA9PiB7XHJcbiAgICBpZiggaWRNYXAuaGFzKCBpZCApICkgcmV0dXJuIGlkTWFwLmdldCggaWQgKVxyXG5cclxuICAgIGNvbnN0IG5vZGUgPSB0cmVlLmZpbmQoIG4gPT4gbi5pZCgpID09PSBpZCApXHJcblxyXG4gICAgaWRNYXAuc2V0KCBpZCwgbm9kZSApXHJcblxyXG4gICAgcmV0dXJuIG5vZGVcclxuICB9XHJcblxyXG4gIGNvbnN0IHJlZnJlc2ggPSBub2RlID0+IHtcclxuICAgIG5vZGUud2FsayggbiA9PiBpZE1hcC5zZXQoIG4uaWQoKSwgbiApIClcclxuICB9XHJcblxyXG4gIHJlZnJlc2goIHRyZWUgKVxyXG5cclxuICByZXR1cm4gT2JqZWN0LmFzc2lnbiggaWRNYXAsIHsgZmluZEJ5SWQsIHJlZnJlc2ggfSApXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSWRNYXBcclxuIiwiJ3VzZSBzdHJpY3QnXHJcblxyXG5jb25zdCBkcmFndWxhID0gcmVxdWlyZSggJ2RyYWd1bGEnIClcclxuY29uc3QgbW9ycGhkb20gPSByZXF1aXJlKCAnbW9ycGhkb20nIClcclxuY29uc3QgSWRNYXAgPSByZXF1aXJlKCAnLi9pZG1hcCcgKVxyXG5jb25zdCBEcmFrZSA9IHJlcXVpcmUoICcuL2RyYWtlJyApXHJcbmNvbnN0IEZpbmQgPSByZXF1aXJlKCAnLi9maW5kJyApXHJcblxyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICBkb2N1bWVudDogdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93LmRvY3VtZW50LFxyXG4gIGRyYWd1bGEsXHJcbiAgbW9ycGhkb20sXHJcbiAgc2VsZWN0b3I6ICcuY29tcG9zZXInXHJcbn1cclxuXHJcbmNvbnN0IHZhbGlkYXRlT2JqID0gKCBvYmosIG5hbWUsIHR5cGVOYW1lICkgPT4ge1xyXG4gIGlmKCB0eXBlb2Ygb2JqICE9PSB0eXBlTmFtZSApXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoIGBBICR7IG5hbWUgfSAkeyB0eXBlTmFtZSB9IGlzIHJlcXVpcmVkYCApXHJcbn1cclxuXHJcbi8qXHJcbiAgVE9ET1xyXG5cclxuICAqIHRoZSBleHBhbmQvY29sbGFwc2UgY2hpbGRyZW4gYWN0aW9ucyBzaG91bGQgYmUgZGlzYWJsZWQgaWYgdGhhdCBhY3Rpb24gaXNcclxuICAgIG5vdCBwb3NzaWJsZSBvciBuZWNlc3NhcnlcclxuICAqIHRoZSB0cmVlIG9yIG9wdGlvbnMgb3Igc29tZXRoaW5nIHNob3VsZCBiZSBhYmxlIHRvIG92ZXJyaWRlIHRoZSBhY3Rpb25zXHJcbiAgICBlZyBub3QgYWxsIG5vZGVzIG1heSBoYXZlIGFsbCBhY3Rpb25zXHJcblxyXG4qL1xyXG5jb25zdCBDb21wb3NlciA9ICggdHJlZSwgcmVuZGVyTm9kZSwgb3B0aW9ucyApID0+IHtcclxuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbigge30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zIClcclxuXHJcbiAgY29uc3QgeyBkb2N1bWVudCwgZHJhZ3VsYSwgbW9ycGhkb20sIHNlbGVjdG9yIH0gPSBvcHRpb25zXHJcblxyXG4gIHZhbGlkYXRlT2JqKCBkb2N1bWVudCwgJ2RvY3VtZW50JywgJ29iamVjdCcgKVxyXG4gIHZhbGlkYXRlT2JqKCByZW5kZXJOb2RlLCAncmVuZGVyTm9kZScsICdmdW5jdGlvbicgKVxyXG4gIHZhbGlkYXRlT2JqKCBzZWxlY3RvciwgJ3NlbGVjdG9yJywgJ3N0cmluZycgKVxyXG5cclxuICBjb25zdCBpZE1hcCA9IElkTWFwKCB0cmVlIClcclxuICBjb25zdCBmaW5kID0gRmluZCggaWRNYXAgKVxyXG5cclxuICBjb25zdCBjb21wb3NlclZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCBzZWxlY3RvciApXHJcblxyXG4gIGNvbnN0IGluaXRpYWxEb20gPSByZW5kZXJOb2RlKCB0cmVlIClcclxuXHJcbiAgbW9ycGhkb20oIGNvbXBvc2VyVmlldywgaW5pdGlhbERvbS5zdHJpbmdpZnkoKSApXHJcblxyXG4gIC8qXHJcbiAgIFRPRE8gdGhlIGZ1bmN0aW9ucyBzaG91bGQgdGFrZSB0aGUgYWN0dWFsIGVsIG5vZGUsIG5vdCB0aGUgY2xpY2tlZCBub2RlLCBhbnlcclxuICAgbG9naWMgaW5zaWRlIHRoZSB2YXJpb3VzIGZucyBiZWxvdyBmb3IgZmluZGluZyB0aGUgZWwgbm9kZSBzaG91bGQgYmUgbW92ZWRcclxuICAgaGVyZVxyXG4gICovXHJcbiAgY29uc3QgY2xpY2tIYW5kbGVyID0ge1xyXG4gICAgJy5jb21wb3Nlci1ub2RlX190aXRsZSwgLmNvbXBvc2VyLW5vZGVfX2FjdGlvbiA+IGknOlxyXG4gICAgICBlbCA9PiBlbC5wYXJlbnROb2RlLFxyXG5cclxuICAgICcuY29tcG9zZXItbm9kZV9fdG9vbGJhcic6IGVsID0+IHtcclxuICAgICAgdG9nZ2xlRWwoIGVsIClcclxuICAgIH0sXHJcblxyXG4gICAgJy5jb21wb3Nlci1ub2RlX19kZWxldGUnOiBlbCA9PiB7XHJcbiAgICAgIGNvbnN0IHNob3VsZERlbGV0ZSA9IHdpbmRvdy5jb25maXJtKCAnQXJlIHlvdSBzdXJlPycgKVxyXG5cclxuICAgICAgaWYoIHNob3VsZERlbGV0ZSApXHJcbiAgICAgICAgcmVtb3ZlRWwoIGVsIClcclxuICAgIH0sXHJcblxyXG4gICAgJy5jb21wb3Nlci1ub2RlX19jb2xsYXBzZS1jaGlsZHJlbic6IGVsID0+IHtcclxuICAgICAgY29sbGFwc2VFbENoaWxkcmVuKCBlbCApXHJcbiAgICB9LFxyXG5cclxuICAgICcuY29tcG9zZXItbm9kZV9fZXhwYW5kLWNoaWxkcmVuJzogZWwgPT4ge1xyXG4gICAgICBleHBhbmRFbENoaWxkcmVuKCBlbCApXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBjbGlja1NlbGVjdG9ycyA9IE9iamVjdC5rZXlzKCBjbGlja0hhbmRsZXIgKVxyXG5cclxuICBjb25zdCBoYW5kbGVDbGljayA9IGVsID0+IHtcclxuICAgIGNvbnN0IHNlbGVjdG9yID0gY2xpY2tTZWxlY3RvcnMuZmluZCggc2VsID0+IGVsLm1hdGNoZXMoIHNlbCApIClcclxuXHJcbiAgICBpZiggc2VsZWN0b3IgKXtcclxuICAgICAgZWwgPSBjbGlja0hhbmRsZXJbIHNlbGVjdG9yIF0oIGVsIClcclxuICAgIH1cclxuXHJcbiAgICBpZiggZWwgKVxyXG4gICAgICBoYW5kbGVDbGljayggZWwgKVxyXG4gIH1cclxuXHJcbiAgY29tcG9zZXJWaWV3LmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIGUgPT4ge1xyXG4gICAgaGFuZGxlQ2xpY2soIGUudGFyZ2V0IClcclxuICB9KVxyXG5cclxuICBjb25zdCB0b2dnbGVFbCA9IGVsID0+IHtcclxuICAgIGNvbnN0IGlzTm9kZSA9IGVsLnBhcmVudE5vZGUubWF0Y2hlcyggJy5jb21wb3Nlci1ub2RlJyApXHJcbiAgICBjb25zdCBrZXkgPSBpc05vZGUgPyAnaXNDb2xsYXBzZWQnIDogJ2lzQ2hpbGRyZW5Db2xsYXBzZWQnXHJcbiAgICBjb25zdCBjb2xsYXBzZWRDbGFzcyA9IGlzTm9kZSA/ICdjb21wb3Nlci1ub2RlLS1jb2xsYXBzZWQnIDogJ2NvbXBvc2VyLW5vZGVfX2NoaWxkcmVuLS1jb2xsYXBzZWQnXHJcblxyXG4gICAgZWwucGFyZW50Tm9kZS5jbGFzc0xpc3QudG9nZ2xlKCBjb2xsYXBzZWRDbGFzcyApXHJcblxyXG4gICAgY29uc3Qgbm9kZSA9IGlzTm9kZSA/XHJcbiAgICAgIGlkTWFwLmZpbmRCeUlkKCBlbC5wYXJlbnROb2RlLmlkICkgOlxyXG4gICAgICBmaW5kLmNvbnRhaW5lckVsTm9kZSggZWwucGFyZW50Tm9kZSApXHJcblxyXG4gICAgY29uc3QgaXNDb2xsYXBzZWQgPSBlbC5wYXJlbnROb2RlLm1hdGNoZXMoICcuY29tcG9zZXItbm9kZS0tY29sbGFwc2VkLCAuY29tcG9zZXItbm9kZV9fY2hpbGRyZW4tLWNvbGxhcHNlZCcgKVxyXG5cclxuICAgIHRvZ2dsZSggbm9kZSwga2V5LCBpc0NvbGxhcHNlZCApXHJcbiAgICB1cGRhdGVOb2RlKCBub2RlIClcclxuICB9XHJcblxyXG4gIGNvbnN0IGNvbGxhcHNlRWxDaGlsZHJlbiA9IGVsID0+IHtcclxuICAgIGNvbnN0IGNvbnRhaW5lckVsTm9kZSA9IGZpbmQuY29udGFpbmVyRWxOb2RlKCBlbCApXHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IGNvbnRhaW5lckVsTm9kZS5nZXRDaGlsZHJlbigpXHJcblxyXG4gICAgY2hpbGRyZW4uZm9yRWFjaCggbm9kZSA9PiB7XHJcbiAgICAgIHRvZ2dsZSggbm9kZSwgJ2lzQ29sbGFwc2VkJywgdHJ1ZSApXHJcbiAgICB9KVxyXG5cclxuICAgIHVwZGF0ZU5vZGUoIGNvbnRhaW5lckVsTm9kZSApXHJcbiAgfVxyXG5cclxuICBjb25zdCBleHBhbmRFbENoaWxkcmVuID0gZWwgPT4ge1xyXG4gICAgY29uc3QgY29udGFpbmVyRWxOb2RlID0gZmluZC5jb250YWluZXJFbE5vZGUoIGVsIClcclxuICAgIGNvbnN0IGNoaWxkcmVuID0gY29udGFpbmVyRWxOb2RlLmdldENoaWxkcmVuKClcclxuXHJcbiAgICBjaGlsZHJlbi5mb3JFYWNoKCBub2RlID0+IHtcclxuICAgICAgdG9nZ2xlKCBub2RlLCAnaXNDb2xsYXBzZWQnLCBmYWxzZSApXHJcbiAgICB9KVxyXG5cclxuICAgIHVwZGF0ZU5vZGUoIGNvbnRhaW5lckVsTm9kZSApXHJcbiAgfVxyXG5cclxuICBjb25zdCByZW1vdmVFbCA9IGVsID0+IHtcclxuICAgIGNvbnN0IG5vZGVFbCA9IGVsLmNsb3Nlc3QoICcuY29tcG9zZXItbm9kZScgKVxyXG4gICAgY29uc3QgaWQgPSBub2RlRWwuaWRcclxuICAgIGNvbnN0IG5vZGUgPSBpZE1hcC5maW5kQnlJZCggaWQgKVxyXG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUuZ2V0UGFyZW50KClcclxuXHJcbiAgICBub2RlLnJlbW92ZSgpXHJcbiAgICAvKlxyXG4gICAgICBJdCBtYXkgc2VlbSBhcyB0aG91Z2ggYnkganVzdCByZW1vdmluZyB0aGUgbm9kZSwgdGhlIHBhcmVudE5vZGUgd2lsbCBiZVxyXG4gICAgICByZWdlbmVyYXRlZCBjb3JyZWN0bHksIGhvd2V2ZXIgdGhpcyBpcyBub3QgdGhlIGNhc2Ugc29tZXRpbWVzLCBsaWtlIHdoZW5cclxuICAgICAgdGhlIG5vZGUgaXMgdGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBlbGVtZW50LiBOb3Qgc3VyZSBpZiBwcm9ibGVtIHdpdGhcclxuICAgICAgbW9ycGhkb20gb3IgaWYgSSd2ZSBtYWRlIHNvbWUgbWlzdGFrZW4gYXNzdW1wdGlvbiBzb21ld2hlcmUsIGJ1dCBpbiBhbnlcclxuICAgICAgY2FzZSBhbHNvIHJlbW92aW5nIHRoZSBub2RlJ3MgZWxlbWVudCByZXByZXNlbnRhdGlvbiBmcm9tIHRoZSBET00gZW5zdXJlc1xyXG4gICAgICB0aGF0IHRoaXMgd29ya3MgY29ycmVjdGx5LiBOb3QgcmVtb3ZpbmcgdGhlIERPTSBub2RlIGFuZCBjYWxsaW5nXHJcbiAgICAgIHVwZGF0ZU5vZGUgdHdpY2UgYWxzbyB3b3JrcyAtIGdvIGZpZ3VyZSA6L1xyXG4gICAgKi9cclxuICAgIG5vZGVFbC5yZW1vdmUoKVxyXG5cclxuICAgIHVwZGF0ZU5vZGUoIHBhcmVudE5vZGUgKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgdG9nZ2xlID0gKCBub2RlLCBrZXksIGlzQ29sbGFwc2VkICkgPT4ge1xyXG4gICAgbm9kZS5tZXRhKCBrZXksIGlzQ29sbGFwc2VkIClcclxuICB9XHJcblxyXG4gIGNvbnN0IHVwZGF0ZU5vZGUgPSBub2RlID0+IHtcclxuICAgIGNvbnN0IG5vZGVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBub2RlLmlkKCkgKVxyXG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUuZ2V0UGFyZW50KClcclxuXHJcbiAgICBsZXQgZGVwdGggPSAwXHJcbiAgICBsZXQgcGFyZW50RWxcclxuXHJcbiAgICBpZiggcGFyZW50Tm9kZSApe1xyXG4gICAgICBwYXJlbnRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBwYXJlbnROb2RlLmlkKCkgKVxyXG4gICAgICBkZXB0aCA9IHBhcmVudEVsLmRhdGFzZXQuZGVwdGggKiAxICsgMVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5ld0VsRG9tID0gcmVuZGVyTm9kZSggbm9kZSwgeyBkZXB0aCB9IClcclxuICAgIGNvbnN0IG5ld0VsSHRtbCA9IG5ld0VsRG9tLnN0cmluZ2lmeSgpXHJcblxyXG4gICAgbW9ycGhkb20oIG5vZGVFbCwgbmV3RWxIdG1sIClcclxuICB9XHJcblxyXG4gIGxldCBkcm9wSGFuZGxlclxyXG5cclxuICBjb25zdCBvbmRyb3AgPSAoIC4uLmFyZ3MgKSA9PiB7XHJcbiAgICBpZiggZHJvcEhhbmRsZXIgKSBkcm9wSGFuZGxlciggLi4uYXJncyApXHJcbiAgfVxyXG5cclxuICBjb25zdCBkcmFrZURlcHMgPSB7IGRyYWd1bGEsIHVwZGF0ZU5vZGUsIGZpbmQsIG9uZHJvcCB9XHJcblxyXG4gIGNvbnN0IGRyYWtlID0gRHJha2UoIGRyYWtlRGVwcyApXHJcblxyXG4gIGNvbnN0IGFwaSA9IHtcclxuICAgIHJlbW92ZTogKCkgPT4gY29tcG9zZXJWaWV3LmlubmVySFRNTCA9ICcnLFxyXG4gICAgdHJlZTogKCkgPT4gdHJlZSxcclxuICAgIGlkTWFwOiAoKSA9PiBpZE1hcCxcclxuICAgIGRyb3BIYW5kbGVyOiBoYW5kbGVyID0+IHtcclxuICAgICAgaWYoIHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nIClcclxuICAgICAgICBkcm9wSGFuZGxlciA9IGhhbmRsZXJcclxuXHJcbiAgICAgIHJldHVybiBkcm9wSGFuZGxlclxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFwaVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvc2VyXHJcbiIsIid1c2Ugc3RyaWN0J1xyXG5cclxuY29uc3QgQ29tcG9zZXIgPSByZXF1aXJlKCAnLi9jb21wb3NlcicgKVxyXG5cclxucmVxdWlyZSggJy4vcG9seWZpbGxzJyApXHJcblxyXG53aW5kb3cubW9qdWxlID0geyBDb21wb3NlciB9XHJcblxyXG4vKlxyXG5UT0RPIHRoaXMgaXMgdGVzdCBjb2RlIHRvIGdldCB0aGUgY29tcG9zZXIgdXAgYW5kIHJ1bm5pbmcsIG5lZWRzIHRvIGJlIGluaXQnZWRcclxucHJvcGVybHkgYXMgYW5kIHdoZXJlIG5lZWRlZFxyXG4qL1xyXG5cclxuLy9jb25zdCBUcmVlID0gcmVxdWlyZSggJzF0cmVlJyApXHJcbmNvbnN0IFRyZWVGYWN0b3J5ID0gcmVxdWlyZSggJzF0cmVlLWZhY3RvcnknIClcclxuXHJcbi8vaW4gcmVhbGl0eSB0aGlzIHdvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHRoZSBzcGVjaWZpYyB0cmVlIHR5cGUsIHRoaXMgaXMganVzdCBhXHJcbi8vaGFjayBmb3IgdGVzdGluZ1xyXG5jb25zdCBpc0VtcHR5UGx1Z2luID0gZm4gPT4ge1xyXG4gIGNvbnN0IGlzRW1wdHkgPSAoIGZuLCBub2RlICkgPT4ge1xyXG4gICAgY29uc3QgdmFsdWUgPSBmbi52YWx1ZSggbm9kZSApXHJcblxyXG4gICAgcmV0dXJuIHZhbHVlLm5vZGVUeXBlID09PSAnZmlsZScgfHwgdmFsdWUubm9kZVR5cGUgPT09ICd0ZXh0J1xyXG4gIH1cclxuXHJcbiAgaXNFbXB0eS5kZWYgPSBmbi5pc0VtcHR5LmRlZlxyXG5cclxuICByZXR1cm4gT2JqZWN0LmFzc2lnbiggZm4sIHsgaXNFbXB0eSB9IClcclxufVxyXG5cclxuY29uc3QgVHJlZSA9IFRyZWVGYWN0b3J5KCBpc0VtcHR5UGx1Z2luIClcclxuXHJcbmNvbnN0IGNvbXBvbmVudERlcGVuZGVuY2llcyA9IHJlcXVpcmUoICcuLi8uLi9kaXN0L2RlcGVuZGVuY2llcy5qc29uJyApXHJcbmNvbnN0IFJlbmRlck5vZGUgPSByZXF1aXJlKCAnLi4vY29tcG9zZXItdHJlZS9yZW5kZXJOb2RlJyApXHJcbmNvbnN0IHJlbmRlck5vZGUgPSBSZW5kZXJOb2RlKCBjb21wb25lbnREZXBlbmRlbmNpZXMgKVxyXG5cclxuY29uc3QgdHJlZVJhdyA9IGNvbXBvbmVudERlcGVuZGVuY2llcy5kYXRhc1sgJ2RhdGEtc21hbGwnIF1cclxuY29uc3QgdHJlZSA9IFRyZWUoIHRyZWVSYXcgKVxyXG5cclxuY29uc3QgY29tcG9zZXJBcGkgPSBDb21wb3NlciggdHJlZSwgcmVuZGVyTm9kZSApXHJcbiIsIihmdW5jdGlvbiAoRWxlbWVudFByb3RvKSB7XG5cdGlmICh0eXBlb2YgRWxlbWVudFByb3RvLm1hdGNoZXMgIT09ICdmdW5jdGlvbicpIHtcblx0XHRFbGVtZW50UHJvdG8ubWF0Y2hlcyA9IEVsZW1lbnRQcm90by5tc01hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50UHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnRQcm90by53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZnVuY3Rpb24gbWF0Y2hlcyhzZWxlY3Rvcikge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzO1xuXHRcdFx0dmFyIGVsZW1lbnRzID0gKGVsZW1lbnQuZG9jdW1lbnQgfHwgZWxlbWVudC5vd25lckRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblx0XHRcdHZhciBpbmRleCA9IDA7XG5cblx0XHRcdHdoaWxlIChlbGVtZW50c1tpbmRleF0gJiYgZWxlbWVudHNbaW5kZXhdICE9PSBlbGVtZW50KSB7XG5cdFx0XHRcdCsraW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBCb29sZWFuKGVsZW1lbnRzW2luZGV4XSk7XG5cdFx0fTtcblx0fVxuXG5cdGlmICh0eXBlb2YgRWxlbWVudFByb3RvLmNsb3Nlc3QgIT09ICdmdW5jdGlvbicpIHtcblx0XHRFbGVtZW50UHJvdG8uY2xvc2VzdCA9IGZ1bmN0aW9uIGNsb3Nlc3Qoc2VsZWN0b3IpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gdGhpcztcblxuXHRcdFx0d2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xuXHRcdFx0XHRpZiAoZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtZW50O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fVxufSkod2luZG93LkVsZW1lbnQucHJvdG90eXBlKTsiLCIndXNlIHN0cmljdCdcblxuY29uc3QgUmVuZGVyQ3NzID0gZGVwZW5kZW5jaWVzID0+IHtcbiAgY29uc3QgeyBzdHlsZXMgfSA9IGRlcGVuZGVuY2llc1xuXG4gIGNvbnN0IHJlbmRlckNzcyA9IHJvb3QgPT4ge1xuICAgIGxldCBjc3MgPSAnJ1xuXG4gICAgY29uc3QgYWxyZWFkeUFkZGVkID0gbmV3IFNldCgpXG5cbiAgICByb290LndhbGsoIG5vZGUgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBub2RlLnZhbHVlKClcbiAgICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSB2YWx1ZS5uYW1lXG5cbiAgICAgIGlmKCBhbHJlYWR5QWRkZWQuaGFzKCBjb21wb25lbnROYW1lICkgKVxuICAgICAgICByZXR1cm5cblxuICAgICAgYWxyZWFkeUFkZGVkLmFkZCggY29tcG9uZW50TmFtZSApXG5cbiAgICAgIGNvbnN0IHN0eWxlID0gc3R5bGVzWyBjb21wb25lbnROYW1lIF1cblxuICAgICAgaWYoIHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycgKXtcbiAgICAgICAgY3NzICs9IHN0eWxlXG4gICAgICAgIGNzcyArPSAnICdcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIGNzc1xuICB9XG5cbiAgcmV0dXJuIHJlbmRlckNzc1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlckNzc1xuIiwiJ3VzZSBzdHJpY3QnXHJcblxyXG5jb25zdCBUZW1wbGF0ZXMgPSByZXF1aXJlKCAnLi4vLi4vdGVtcGxhdGVzJyApXHJcbmNvbnN0IFJlbmRlckNzcyA9IHJlcXVpcmUoICcuL3JlbmRlckNzcycgKVxyXG5cclxuY29uc3QgUmVuZGVyTm9kZSA9IGRlcGVuZGVuY2llcyA9PiB7XHJcbiAgY29uc3QgcmVuZGVyQ3NzID0gUmVuZGVyQ3NzKCBkZXBlbmRlbmNpZXMgKVxyXG4gIGNvbnN0IHsgY29uZmlncyB9ID0gZGVwZW5kZW5jaWVzXHJcbiAgY29uc3QgeyByZW5kZXJDb21wb25lbnQgfSA9IFRlbXBsYXRlcyggZGVwZW5kZW5jaWVzIClcclxuXHJcbiAgY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcclxuICAgIGNvbnRhaW5lclNlbGVjdG9yOiBcIltkYXRhLWNvbnRhaW5lcl1cIlxyXG4gIH1cclxuXHJcbiAgY29uc3QgYWRkQ3NzVG9Eb2N1bWVudEhlYWQgPSBub2RlID0+IHtcclxuICAgIGNvbnN0IHZhbHVlID0gbm9kZS52YWx1ZSgpXHJcbiAgICBjb25zdCBjb21wb25lbnROYW1lID0gdmFsdWUubmFtZVxyXG4gICAgY29uc3QgY29tcG9uZW50TW9kZWwgPSB2YWx1ZS5tb2RlbFxyXG5cclxuICAgIGNvbnN0IGNzcyA9IHJlbmRlckNzcyggbm9kZSApXHJcblxyXG4gICAgaWYoICFBcnJheS5pc0FycmF5KCBjb21wb25lbnRNb2RlbC5oZWFkU3R5bGVzICkgKVxyXG4gICAgICBjb21wb25lbnRNb2RlbC5oZWFkU3R5bGVzID0gW11cclxuXHJcbiAgICBjb21wb25lbnRNb2RlbC5oZWFkU3R5bGVzLnB1c2goe1xyXG4gICAgICB0ZXh0OiBjc3NcclxuICAgIH0pXHJcblxyXG4gICAgbm9kZS52YWx1ZSggdmFsdWUgKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgcmVuZGVyTm9kZSA9IG5vZGUgPT4ge1xyXG4gICAgY29uc3QgdmFsdWUgPSBub2RlLnZhbHVlKClcclxuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSB2YWx1ZS5uYW1lXHJcbiAgICBjb25zdCBjb21wb25lbnRNb2RlbCA9IHZhbHVlLm1vZGVsXHJcblxyXG4gICAgaWYoIGNvbXBvbmVudE5hbWUgPT09ICdkb2N1bWVudCcgKXtcclxuICAgICAgYWRkQ3NzVG9Eb2N1bWVudEhlYWQoIG5vZGUgKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRvbSA9IHJlbmRlckNvbXBvbmVudCggY29tcG9uZW50TmFtZSwgY29tcG9uZW50TW9kZWwgKVxyXG4gICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbigge30sIGRlZmF1bHRDb25maWcsIGNvbmZpZ3NbIGNvbXBvbmVudE5hbWUgXSApXHJcbiAgICBjb25zdCBjaGlsZENvbnRhaW5lciA9IGRvbS5zZWxlY3QoIGNvbmZpZy5jb250YWluZXJTZWxlY3RvciApXHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKVxyXG5cclxuICAgIGlmKCBjaGlsZENvbnRhaW5lciAmJiBjaGlsZHJlbi5sZW5ndGggKXtcclxuICAgICAgY2hpbGRyZW4uZm9yRWFjaCggY2hpbGROb2RlID0+IHtcclxuICAgICAgICBjb25zdCBjaGlsZERvbSA9IHJlbmRlck5vZGUoIGNoaWxkTm9kZSApXHJcblxyXG4gICAgICAgIGlmKCBjaGlsZENvbnRhaW5lci5ub2RlTmFtZSgpID09PSAndWwnIHx8IGNoaWxkQ29udGFpbmVyLm5vZGVOYW1lKCkgPT09ICdvbCcgKXtcclxuICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIGRvbS5wYXJzZSBhbHdheXMgcmV0dXJucyBhIGZyYWdtZW50LCBiZWNhdXNlIHRoZSBodG1sIHN0cmluZyBjb3VsZFxyXG4gICAgICAgICAgICBjb250YWluIG11bHRpcGxlIGVsZW1lbnRzXHJcblxyXG4gICAgICAgICAgICBwZXJoYXBzIGlmIHdlIHNlZSBpdCBvbmx5IGhhcyBvbmUgZWxlbWVudCwgd2Ugc2hvdWxkIHJldHVybiB0aGF0XHJcbiAgICAgICAgICAgIHJhdGhlciB0aGFuIGEgZG9jdW1lbnRGcmFnbWVudCB3aXRoIGEgc2luZ2xlIGNoaWxkLCBidXQgY29udGludWUgdG9cclxuICAgICAgICAgICAgdXNlIGN1cnJlbnQgYmVoYXZpb3VyIGlmIHRoZSBmcmFnbWVudCBoYXMgbXVsdGlwbGUgY2hpbGRyZW4/XHJcbiAgICAgICAgICAqL1xyXG4gICAgICAgICAgY29uc3QgbGlOb2RlID0gZG9tLnBhcnNlKCAnPGxpPjwvbGk+JyApLnNlbGVjdCggJ2xpJyApXHJcblxyXG4gICAgICAgICAgbGlOb2RlLmFwcGVuZCggY2hpbGREb20gKVxyXG4gICAgICAgICAgY2hpbGRDb250YWluZXIuYXBwZW5kKCBsaU5vZGUgKVxyXG5cclxuICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hpbGRDb250YWluZXIuYXBwZW5kKCBjaGlsZERvbSApXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRvbVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlbmRlck5vZGVcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJOb2RlXHJcbiIsIid1c2Ugc3RyaWN0J1xyXG5cclxuY29uc3QgdHJlZVNjaGVtYSA9IHJlcXVpcmUoICcxdHJlZS1zY2hlbWEnIClcclxuY29uc3QgdHJlZUpzb24gPSByZXF1aXJlKCAnMXRyZWUtanNvbicgKVxyXG5jb25zdCB0cmFuc2Zvcm1NYXBwZXIgPSByZXF1aXJlKCAnbW9qdWxlLXRyYW5zZm9ybScgKVxyXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoICdtb2p1bGUtdXRpbHMnIClcclxuXHJcbmNvbnN0IHsgY2xvbmUgfSA9IHV0aWxzXHJcblxyXG5jb25zdCBtYXBDb21wb25lbnRzID0gKCBkZXBlbmRlbmNpZXMsIGNvbXBvbmVudE5hbWUsIG1vZGVsICkgPT4ge1xyXG4gIG1vZGVsID0gY2xvbmUoIG1vZGVsIClcclxuXHJcbiAgY29uc3QgbW9kZWxUcmVlID0gdHJlZUpzb24udG9UcmVlKCBtb2RlbCApXHJcblxyXG4gIGNvbnN0IHsgY29tcG9uZW50TmFtZXMsIHNjaGVtYXMsIHRyYW5zZm9ybXMgfSA9IGRlcGVuZGVuY2llc1xyXG5cclxuICBjb25zdCBzY2hlbWFOYW1lcyA9IE9iamVjdC5rZXlzKCBzY2hlbWFzIClcclxuXHJcbiAgY29uc3QgZmluZFJlZkNvbXBvbmVudHMgPSBzY2hlbWFOb2RlID0+XHJcbiAgICBzY2hlbWFOb2RlLmZpbmRBbGwoIG4gPT5cclxuICAgICAgY29tcG9uZW50TmFtZXMuaW5jbHVkZXMoIG4udmFsdWUoKS4kcmVmIClcclxuICAgIClcclxuXHJcbiAgY29uc3QgdHJhbnNmb3JtID0gdHJhbnNmb3Jtc1sgY29tcG9uZW50TmFtZSBdXHJcbiAgY29uc3QgY29tcG9uZW50U2NoZW1hID0gc2NoZW1hc1sgY29tcG9uZW50TmFtZSBdXHJcblxyXG4gIGlmKCB0cmFuc2Zvcm0gJiYgIWNvbXBvbmVudFNjaGVtYSApe1xyXG4gICAgcmV0dXJuIHRyYW5zZm9ybU1hcHBlciggbW9kZWwsIHRyYW5zZm9ybSApXHJcbiAgfVxyXG5cclxuICBpZiggIXRyYW5zZm9ybSAmJiAhY29tcG9uZW50U2NoZW1hICl7XHJcbiAgICByZXR1cm4gbW9kZWxcclxuICB9XHJcblxyXG4gIGNvbnN0IGNvbXBvbmVudFNjaGVtYVRyZWUgPSB0cmVlU2NoZW1hLnRvVHJlZSggY29tcG9uZW50U2NoZW1hIClcclxuICBjb25zdCByZWZDb21wb25lbnRzID0gZmluZFJlZkNvbXBvbmVudHMoIGNvbXBvbmVudFNjaGVtYVRyZWUgKVxyXG5cclxuICByZWZDb21wb25lbnRzLmZvckVhY2goIHJlZkNvbXBvbmVudE5vZGUgPT4ge1xyXG4gICAgY29uc3QgdmFsdWUgPSByZWZDb21wb25lbnROb2RlLnZhbHVlKClcclxuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSB2YWx1ZS4kcmVmXHJcbiAgICBjb25zdCBjb21wb25lbnRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1zWyBjb21wb25lbnROYW1lIF1cclxuXHJcbiAgICBpZiggIWNvbXBvbmVudFRyYW5zZm9ybSApIHJldHVyblxyXG5cclxuICAgIGNvbnN0IHJlZk5vZGVQYXRoID0gdHJlZVNjaGVtYS5wYXRoRnJvbU5vZGUoIHJlZkNvbXBvbmVudE5vZGUgKVxyXG4gICAgY29uc3QgbW9kZWxOb2RlID0gdHJlZUpzb24ubm9kZUZyb21QYXRoKCBtb2RlbFRyZWUsIHJlZk5vZGVQYXRoIClcclxuXHJcbiAgICBpZiggIW1vZGVsTm9kZSApIHJldHVyblxyXG5cclxuICAgIGNvbnN0IG1vZGVsTm9kZVZhbHVlID0gbW9kZWxOb2RlLnZhbHVlKClcclxuXHJcbiAgICBpZiggdmFsdWUuYXJyYXlJdGVtICl7XHJcbiAgICAgIGNvbnN0IG1vZGVsQXJyYXkgPSB0cmVlSnNvbi50b0pzb24oIG1vZGVsTm9kZSApXHJcblxyXG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IG1vZGVsQXJyYXkubWFwKCBpdGVtID0+XHJcbiAgICAgICAgbWFwQ29tcG9uZW50cyggZGVwZW5kZW5jaWVzLCBjb21wb25lbnROYW1lLCBpdGVtIClcclxuICAgICAgKVxyXG5cclxuICAgICAgY29uc3QgdHJhbnNmb3JtZWROb2RlID0gdHJlZUpzb24udG9UcmVlKCB0cmFuc2Zvcm1lZCApXHJcbiAgICAgIGNvbnN0IG1vZGVsTm9kZVBhcmVudCA9IG1vZGVsTm9kZS5nZXRQYXJlbnQoKVxyXG5cclxuICAgICAgaWYoIG1vZGVsTm9kZVZhbHVlLnByb3BlcnR5TmFtZSApe1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkTm9kZVZhbHVlID0gdHJhbnNmb3JtZWROb2RlLnZhbHVlKClcclxuICAgICAgICB0cmFuc2Zvcm1lZE5vZGVWYWx1ZS5wcm9wZXJ0eU5hbWUgPSBtb2RlbE5vZGVWYWx1ZS5wcm9wZXJ0eU5hbWVcclxuICAgICAgICB0cmFuc2Zvcm1lZE5vZGUudmFsdWUoIHRyYW5zZm9ybWVkTm9kZVZhbHVlIClcclxuICAgICAgfVxyXG5cclxuICAgICAgbW9kZWxOb2RlUGFyZW50LnJlcGxhY2VDaGlsZCggdHJhbnNmb3JtZWROb2RlLCBtb2RlbE5vZGUgIClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvciggJ05vbiBhcnJheWl0ZW0gbm90IGltcGxlbWVudGVkIHlldCcgKVxyXG4gICAgfVxyXG4gIH0pXHJcblxyXG4gIG1vZGVsID0gdHJlZUpzb24udG9Kc29uKCBtb2RlbFRyZWUgKVxyXG5cclxuICBpZiggdHJhbnNmb3JtIClcclxuICAgIG1vZGVsID0gdHJhbnNmb3JtTWFwcGVyKCBtb2RlbCwgdHJhbnNmb3JtIClcclxuXHJcbiAgcmV0dXJuIG1vZGVsXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbWFwQ29tcG9uZW50c1xyXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgVHJlZSA9IHJlcXVpcmUoICcxdHJlZScgKVxuY29uc3Qgbm9kZVRvTW9kZWwgPSByZXF1aXJlKCAnLi9kZWZhdWx0Tm9kZVRvTW9kZWwnIClcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGRlcHRoOiAwLFxuICBjcmVhdGVOb2RlOiBUcmVlLmNyZWF0ZVJvb3QsXG4gIGFsd2F5c1JlbmRlckNoaWxkcmVuOiBmYWxzZSxcbiAgbm9kZVRvTW9kZWxcbn1cblxuY29uc3Qgbm9kZVRvQ29tcG9zZXJOb2RlID0gKCBub2RlLCBvcHRpb25zICkgPT4ge1xuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbigge30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zIClcblxuICBjb25zdCB7IGRlcHRoLCBjcmVhdGVOb2RlLCBub2RlVG9Nb2RlbCwgYWx3YXlzUmVuZGVyQ2hpbGRyZW4gfSA9IG9wdGlvbnNcblxuICBjb25zdCBtb2RlbCA9IG5vZGVUb01vZGVsKCBub2RlLCB7IGRlcHRoIH0gKVxuXG4gIGNvbnN0IHZhbHVlID0ge1xuICAgIG5hbWU6ICdjb21wb3Nlci1ub2RlJyxcbiAgICBtb2RlbFxuICB9XG5cbiAgY29uc3QgY29tcG9uZW50Tm9kZSA9IGNyZWF0ZU5vZGUoIHZhbHVlIClcblxuICBjb25zdCBzaG91bGRSZW5kZXJDaGlsZHJlbiA9IGFsd2F5c1JlbmRlckNoaWxkcmVuIHx8ICFtb2RlbC5pc0NoaWxkcmVuQ29sbGFwc2VkXG5cbiAgaWYoIHNob3VsZFJlbmRlckNoaWxkcmVuICkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpXG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKCBjaGlsZE5vZGUgPT4ge1xuICAgICAgY29uc3QgY2hpbGRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHtcbiAgICAgICAgICBkZXB0aDogZGVwdGggKyAxXG4gICAgICAgIH1cbiAgICAgIClcblxuICAgICAgY29uc3QgY29tcG9uZW50Q2hpbGROb2RlID0gbm9kZVRvQ29tcG9zZXJOb2RlKCBjaGlsZE5vZGUsIGNoaWxkT3B0aW9ucyApXG5cbiAgICAgIGNvbXBvbmVudE5vZGUuYXBwZW5kKCBjb21wb25lbnRDaGlsZE5vZGUgKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gY29tcG9uZW50Tm9kZVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVRvQ29tcG9zZXJOb2RlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBlc2NhcGVIdG1sIH0gPSByZXF1aXJlKCAnbW9qdWxlLXV0aWxzJyApXG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBkZXB0aDogMFxufVxuXG5jb25zdCBub2RlVG9Nb2RlbCA9ICggbm9kZSwgb3B0aW9ucyApID0+IHtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oIHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyApXG5cbiAgY29uc3QgeyBkZXB0aCB9ID0gb3B0aW9uc1xuXG4gIGNvbnN0IHZhbHVlID0gbm9kZS52YWx1ZSgpXG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpXG5cbiAgY29uc3QgaWQgPSBub2RlLmlkKClcbiAgY29uc3QgbmFtZSA9IHZhbHVlLm5hbWUgfHwgJydcbiAgY29uc3QgdHJlZVR5cGUgPSAnMXRyZWUnXG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS5ub2RlVHlwZSgpXG4gIGNvbnN0IHRpdGxlID0gYCR7IGRlcHRoIH06ICR7IG5hbWUgfSAkeyBub2RlVHlwZSB9IFsgJHsgY2hpbGRyZW4ubGVuZ3RoIH0gXWBcbiAgY29uc3QgaXNFbXB0eSA9IG5vZGUuaXNFbXB0eSgpXG5cbiAgbGV0IGlzQ29sbGFwc2VkID0gbm9kZS5tZXRhKCAnaXNDb2xsYXBzZWQnIClcblxuICBpc0NvbGxhcHNlZCA9IHR5cGVvZiBpc0NvbGxhcHNlZCA9PT0gJ2Jvb2xlYW4nID8gaXNDb2xsYXBzZWQgOiBkZXB0aCA+IDBcblxuICBjb25zdCBpc0NoaWxkcmVuQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQgfHwgISFub2RlLm1ldGEoICdpc0NoaWxkcmVuQ29sbGFwc2VkJyApXG5cbiAgY29uc3QgcHJldmlldyA9IGVzY2FwZUh0bWwoIEpTT04uc3RyaW5naWZ5KCB2YWx1ZSApIClcbiAgY29uc3QgY2hpbGRyZW5UaXRsZSA9IGAkeyBkZXB0aCB9OiBjaGlsZHJlbmBcblxuICBjb25zdCBtb2RlbCA9IHtcbiAgICBpZCwgdGl0bGUsIHRyZWVUeXBlLCBub2RlVHlwZSwgZGVwdGgsIGlzRW1wdHksIGlzQ29sbGFwc2VkLFxuICAgIGlzQ2hpbGRyZW5Db2xsYXBzZWQsIHByZXZpZXcsIGNoaWxkcmVuVGl0bGVcbiAgfVxuXG4gIHJldHVybiBtb2RlbFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVUb01vZGVsXG4iLCIndXNlIHN0cmljdCdcclxuXHJcbmNvbnN0IFRyZWUgPSByZXF1aXJlKCAnMXRyZWUnIClcclxuY29uc3Qgbm9kZVRvTW9kZWwgPSByZXF1aXJlKCAnLi9kZWZhdWx0Tm9kZVRvTW9kZWwnIClcclxuY29uc3Qgbm9kZVRvQ29tcG9zZXJOb2RlID0gcmVxdWlyZSggJy4vZGVmYXVsdE5vZGVUb0NvbXBvc2VyTm9kZScgKVxyXG5jb25zdCBDb21wb25lbnRSZW5kZXJOb2RlID0gcmVxdWlyZSggJy4uL2NvbXBvbmVudHMvY29tcG9uZW50LXRyZWUvcmVuZGVyTm9kZScgKVxyXG5cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgZGVwdGg6IDAsXHJcbiAgY3JlYXRlTm9kZTogVHJlZS5jcmVhdGVSb290LFxyXG4gIG5vZGVUb01vZGVsLFxyXG4gIG5vZGVUb0NvbXBvc2VyTm9kZVxyXG59XHJcblxyXG5jb25zdCBSZW5kZXJOb2RlID0gZGVwZW5kZW5jaWVzID0+IHtcclxuICBjb25zdCBjb21wb25lbnRSZW5kZXJOb2RlID0gQ29tcG9uZW50UmVuZGVyTm9kZSggZGVwZW5kZW5jaWVzIClcclxuXHJcbiAgY29uc3QgcmVuZGVyTm9kZSA9ICggbm9kZSwgb3B0aW9ucyApID0+IHtcclxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKCB7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgKVxyXG5cclxuICAgIGNvbnN0IHsgbm9kZVRvTW9kZWwsIG5vZGVUb0NvbXBvc2VyTm9kZSwgZGVwdGgsIGNyZWF0ZU5vZGUgfSA9IG9wdGlvbnNcclxuXHJcbiAgICBjb25zdCB0b0NvbXBvc2VyTm9kZU9wdGlvbnMgPSB7IGRlcHRoLCBjcmVhdGVOb2RlLCBub2RlVG9Nb2RlbCB9XHJcbiAgICBjb25zdCBjb21wb3Nlck5vZGUgPSBub2RlVG9Db21wb3Nlck5vZGUoIG5vZGUsIHRvQ29tcG9zZXJOb2RlT3B0aW9ucyApXHJcbiAgICBjb25zdCBjb21wb25lbnROb2RlID0gY29tcG9uZW50UmVuZGVyTm9kZSggY29tcG9zZXJOb2RlIClcclxuXHJcbiAgICByZXR1cm4gY29tcG9uZW50Tm9kZVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlbmRlck5vZGVcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJOb2RlXHJcbiIsIid1c2Ugc3RyaWN0J1xyXG5cclxuY29uc3QgVGVtcGxhdGluZyA9IHJlcXVpcmUoICdtb2p1bGUtdGVtcGxhdGluZycgKVxyXG5jb25zdCBWYWxpZGF0b3IgPSByZXF1aXJlKCAnbXR5cGUtdHY0JyApXHJcbmNvbnN0IGNvbXBvbmVudFRyYW5zZm9ybU1hcHBlciA9IHJlcXVpcmUoICcuLi9jb21wb25lbnRzL2NvbXBvbmVudFRyYW5zZm9ybU1hcHBlcicgKVxyXG5cclxuY29uc3QgZW5zdXJlTW9kZWwgPSAoIHZhbGlkYXRvciwgbW9kZWwsIG5hbWUgKSA9PiB7XHJcbiAgY29uc3Qgc2NoZW1hTmFtZXMgPSB2YWxpZGF0b3IuZ2V0U2NoZW1hVXJpcygpXHJcblxyXG4gIGlmKCAhc2NoZW1hTmFtZXMuaW5jbHVkZXMoIG5hbWUgKSApIHJldHVyblxyXG5cclxuICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IudmFsaWRhdGVNdWx0aXBsZSggbW9kZWwsIG5hbWUgKVxyXG5cclxuICBpZiggcmVzdWx0LnZhbGlkICkgcmV0dXJuXHJcblxyXG4gIGNvbnN0IG1lc3NhZ2UgPSBgVGVtcGxhdGUgbW9kZWwgdmFsaWRhdGlvbiBmYWlsZWQgZm9yICR7IG5hbWUgfTogJHsgSlNPTi5zdHJpbmdpZnkoIHJlc3VsdC5lcnJvcnMgKSB9YFxyXG4gIHRocm93IG5ldyBFcnJvciggbWVzc2FnZSApXHJcbn1cclxuXHJcbmNvbnN0IFRlbXBsYXRlcyA9IGRlcGVuZGVuY2llcyA9PiB7XHJcbiAgY29uc3QgeyBjb21wb25lbnRzLCB0ZW1wbGF0ZXMsIGRlZmF1bHRNb2RlbHMsIHNjaGVtYXMgfSA9IGRlcGVuZGVuY2llc1xyXG5cclxuICBjb25zdCB0ZW1wbGF0aW5nID0gVGVtcGxhdGluZyggdGVtcGxhdGVzIClcclxuICBjb25zdCB2YWxpZGF0b3IgPSBWYWxpZGF0b3IoIHNjaGVtYXMgKVxyXG5cclxuICBjb25zdCByZW5kZXJDb21wb25lbnQgPSAoIG5hbWUsIG1vZGVsICkgPT4ge1xyXG4gICAgY29uc3QgdGVtcGxhdGVNb2RlbCA9IE9iamVjdC5hc3NpZ24oIHt9LCBkZWZhdWx0TW9kZWxzWyBuYW1lIF0gfHwge30sIG1vZGVsIClcclxuXHJcbiAgICBlbnN1cmVNb2RlbCggdmFsaWRhdG9yLCB0ZW1wbGF0ZU1vZGVsLCBuYW1lIClcclxuXHJcbiAgICBjb25zdCB2aWV3TW9kZWwgPSBjb21wb25lbnRUcmFuc2Zvcm1NYXBwZXIoIGRlcGVuZGVuY2llcywgbmFtZSwgdGVtcGxhdGVNb2RlbCApXHJcblxyXG4gICAgcmV0dXJuIHRlbXBsYXRpbmcoIG5hbWUsIHZpZXdNb2RlbCApXHJcbiAgfVxyXG5cclxuICAvL1RPRE8gSSBiZWxpZXZlIHRoYXQgdGhpcyBkb2Vzbid0IG5lZWQgdG8gdXNlIGNhbGxiYWNrcyBhbnltb3JlXHJcbiAgY29uc3QgcmVuZGVyVGVtcGxhdGUgPSAoIG5hbWUsIG1vZGVsLCBjYWxsYmFjayApID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRvY3VtZW50TW9kZWwgPSBPYmplY3QuYXNzaWduKCB7fSwgZGVmYXVsdE1vZGVscy5kb2N1bWVudCwgbW9kZWwgKVxyXG5cclxuICAgICAgaWYoIG5hbWUgIT09ICdkb2N1bWVudCcgKXtcclxuICAgICAgICBjb25zdCBib2R5ID0gcmVuZGVyQ29tcG9uZW50KCBuYW1lLCBtb2RlbCApLnN0cmluZ2lmeSgpXHJcblxyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oIGRvY3VtZW50TW9kZWwsIHsgYm9keSB9IClcclxuICAgICAgfVxyXG5cclxuICAgICAgZW5zdXJlTW9kZWwoIHZhbGlkYXRvciwgZG9jdW1lbnRNb2RlbCwgJ2RvY3VtZW50JyApXHJcblxyXG4gICAgICBjb25zdCB2aWV3TW9kZWwgPSBjb21wb25lbnRUcmFuc2Zvcm1NYXBwZXIoIGRlcGVuZGVuY2llcywgJ2RvY3VtZW50JywgZG9jdW1lbnRNb2RlbCApXHJcblxyXG4gICAgICBjb25zdCBkb20gPSB0ZW1wbGF0aW5nKCAnZG9jdW1lbnQnLCB2aWV3TW9kZWwgKVxyXG5cclxuICAgICAgY2FsbGJhY2soIG51bGwsIGRvbSApXHJcbiAgICB9IGNhdGNoKCBlICl7XHJcbiAgICAgIGNhbGxiYWNrKCBlIClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7IHJlbmRlclRlbXBsYXRlLCByZW5kZXJDb21wb25lbnQgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRlbXBsYXRlc1xyXG4iXX0=
