(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports={"styles":{"composer":".composer {\n  line-height: 2;\n  font-size: 1rem;\n}\n\n$toolbar-color: hsl( 210, 15%, 40% );\n$toolbar-children-color: hsl( 210, 85%, 37% );\n$toolbar-empty-color: hsl( 210, 10%, 88% );\n$main-color: hsl( 210, 5%, 95% );\n$children-color: hsl( 210, 95%, 95% );\n$action-color: hsl(210, 85%, 60% );\n$action-delete-color: hsl( 0, 83%, 50% );\n\n.composer-node__toolbar {\n  min-height: 3rem;\n\n  color: hsl( 210, 10%, 95% );\n  @include colorize-el( $toolbar-color );\n  box-shadow: 0.125rem 0.125rem 0.5rem rgba( 0, 0, 0, 0.25 );\n}\n\n.composer-node__title {\n  line-height: 3;\n  padding: 0 1rem;\n}\n\n.composer-node__children > .composer-node__toolbar {\n  @include colorize-el( $toolbar-children-color );\n  box-shadow: 0.125rem 0.125rem 0.5rem rgba( 0, 0, 0, 0.25 );\n}\n\n.composer-node--empty > .composer-node__toolbar {\n  color: hsl( 210, 85%, 15% );\n  @include colorize-el( $toolbar-empty-color );\n  box-shadow: 0.125rem 0.125rem 0.5rem rgba( 0, 0, 0, 0.25 );\n}\n\n.composer-node:not( [data-depth=\"0\"] ) > .composer-node__toolbar {\n  cursor: move;\n}\n\n.composer-node__view {\n  margin-bottom: 0.5rem;\n  overflow: hidden;\n  padding: 0.5rem;\n\n  color: #111;\n  background: #fff;\n  box-shadow: inset 0.03125rem 0.03125rem 0.125rem rgba( 0, 0, 0, 0.25 );\n}\n\n.composer-node__view:last-child {\n  margin-bottom: 0;\n}\n\n.composer-node__main {\n  padding: 0.75rem;\n  margin: 0.25rem;\n  margin-top: 0;\n\n  @include colorize-el-background( $main-color );\n  box-shadow: 0.125rem 0.125rem 0.5rem rgba( 0, 0, 0, 0.25 );\n}\n\n.composer-node--collapsed > .composer-node__main,\n.composer-node__children--collapsed > .composer-node__main {\n  height: 0;\n  margin: 0;\n  padding: 0;\n  border: 0;\n  overflow: hidden;\n}\n\n.composer-node__children {\n  overflow: hidden;\n\n  @include colorize-el-background( $children-color );\n  box-shadow: inset 0.125rem 0.125rem 0.5rem rgba( 0, 0, 0, 0.25 );\n}\n\n.composer-node__children > ul {\n  margin: 0;\n  padding: 0.5rem;\n  list-style: none;\n}\n\n.composer-node__children--collapsed > ul {\n  height: 0;\n  padding: 0;\n  overflow: hidden;\n}\n\n.composer-node__children > ul > li {\n  margin: 0;\n  padding: 0;\n}\n\n.composer-node__actions {\n  display: block;\n  float: right;\n}\n\n.composer-node__actions > li {\n  display: block;\n  float: left;\n}\n\n.composer-node__action {\n  display: block;\n  padding: 0;\n  font-size: 1rem;\n  line-height: 1.875rem;\n  width: 1.875rem;\n  margin: 0.5rem 0;\n  text-align: center;\n  cursor: default;\n\n  color: hsl( 210, 5%, 95% );\n  @include colorize-el( $action-color );\n  box-shadow: 0.0625rem 0.0625rem 0.25rem rgba( 0, 0, 0, 0.25 );\n}\n\n.composer-node__action--disabled {\n  opacity: 0.5;\n}\n\n.composer-node__actions > li:last-child .composer-node__action {\n  margin-right: 0.5rem;\n}\n\n.composer-node__delete {\n  color: hsl( 0, 5%, 95% );\n  @include colorize-el( $action-delete-color );\n  box-shadow: 0.0625rem 0.0625rem 0.25rem rgba( 0, 0, 0, 0.25 );\n}\n","document":"* {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n}\n\nhtml {\n  font-family: sans-serif;\n}\n\n.gu-unselectable {\n  list-style: none;\n}\n\n.gu-mirror {\n  position: fixed !important;\n  margin: 0 !important;\n  z-index: 9999 !important;\n  opacity: 0.8;\n  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=80)\";\n  filter: alpha(opacity=80);\n}\n\n.gu-hide {\n  display: none !important;\n}\n\n.gu-unselectable {\n  -webkit-user-select: none !important;\n  -moz-user-select: none !important;\n  -ms-user-select: none !important;\n  user-select: none !important;\n}\n\n.gu-transit {\n  opacity: 0.2;\n  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=20)\";\n  filter: alpha(opacity=20);\n}\n\n.ratio {\n  width: 4rem;\n  text-align: center;\n  position: relative;\n}\n\n.ratio .shim {\n  padding-bottom: 100%;\n}\n\n.ratio .viewport {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n\n$lighten-hue: 40deg;\n$darken-hue: 210deg;\n\n$adjust-hue: 20%;\n$adjust-saturation: 5%;\n$adjust-lightness: 5%;\n\n$adjust-hue-gradient-highlight: $adjust-hue / 2;\n$adjust-saturation-gradient-highlight: $adjust-saturation / 2;\n$adjust-lightness-gradient-highlight: $adjust-lightness / 2;\n\n@function shift-hue( $from-hue, $to-hue, $amount ){\n  $from-color: hsl( $from-hue, 100%, 50% );\n  $to-color: hsl( $to-hue, 100%, 50% );\n  $mixed: mix( $to-color, $from-color, $amount );\n  $new-hue: hue( $mixed );\n\n  @return $new-hue;\n}\n\n@function advanced-lighten( $from-color, $hue-amount, $saturation-amount, $lightness-amount ){\n  $hue: hue( $from-color );\n  $new-hue: shift-hue( $hue, $lighten-hue, $hue-amount );\n\n  $light-and-saturation: lighten(\n    desaturate(\n      $from-color,\n      $saturation-amount\n    ),\n    $lightness-amount\n  );\n\n  @return change-color( $light-and-saturation, $hue: $new-hue );\n}\n\n@function advanced-darken( $from-color, $hue-amount, $saturation-amount, $lightness-amount ){\n  $hue: hue( $from-color );\n  $new-hue: shift-hue( $hue, $darken-hue, $hue-amount );\n\n  $light-and-saturation: darken(\n    saturate(\n      $from-color,\n      $saturation-amount\n    ),\n    $lightness-amount\n  );\n\n  @return change-color( $light-and-saturation, $hue: $new-hue );\n}\n\n@mixin colorize-el-background( $base-color ){\n  $gradient-highlight: advanced-lighten(\n    $base-color,\n    $adjust-hue-gradient-highlight,\n    $adjust-lightness-gradient-highlight,\n    $adjust-saturation-gradient-highlight\n  );\n  $gradient-base: $base-color;\n  $gradient-shadow: advanced-darken(\n    $base-color,\n    $adjust-hue,\n    $adjust-lightness,\n    $adjust-saturation\n  );\n\n  background: linear-gradient(\n    to bottom,\n    $gradient-highlight,\n    $gradient-base,\n    $gradient-shadow\n  );\n}\n\n@mixin colorize-el( $base-color ){\n  $gradient-shadow: advanced-darken(\n    $base-color,\n    $adjust-hue,\n    $adjust-lightness,\n    $adjust-saturation\n  );\n\n  $border-highlight: advanced-lighten(\n    $base-color,\n    $adjust-hue,\n    $adjust-lightness,\n    $adjust-saturation\n  );\n  $border-shadow: advanced-darken(\n    $gradient-shadow,\n    $adjust-hue,\n    $adjust-lightness,\n    $adjust-saturation\n  );\n\n  $text-shadow: advanced-darken(\n    $border-shadow,\n    $adjust-hue,\n    $adjust-lightness,\n    $adjust-saturation\n  );\n\n  @include colorize-el-background( $base-color );\n  border: 0.0625rem solid $border-highlight;\n  border-bottom: 0.0625rem solid $border-shadow;\n  border-right: 0.0625rem solid $border-shadow;\n  text-shadow: 0.0625rem 0.0625rem 0 $text-shadow;\n}"},"templates":{"composer":{"value":{"nodeType":"documentFragment","_id":"documentfragment-0562659b3da6c60e3e5f70bb6d7d86a2"},"children":[{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer"},"_id":"element-849d5d801a9b2b36bade540237eec745"},"children":[]}]},"composer-node":{"value":{"nodeType":"documentFragment","_id":"documentfragment-83e25ac2ac4ca68ad1d3109fcba7d564"},"children":[{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer-node","data-tag":"nodeTag"},"_id":"element-ef44978563f9d81a42c22cade3929643"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-8a278ee92af7e6a683779f2b7c63e819"},"children":[]},{"value":{"nodeType":"element","tagName":"header","attributes":{"class":"composer-node__toolbar"},"_id":"element-cbc5d85165f681315eafb3b7edcb6502"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-323b65fe0b8ad06e7523ddbd6b808cc2"},"children":[]},{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__title","data-text":"title"},"_id":"element-4850aea48698a4416bff6554f52ca833"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-1b1da63e9692debe0fc790c60b3dbde6"},"children":[]},{"value":{"nodeType":"element","tagName":"ul","attributes":{"class":"composer-node__actions"},"_id":"element-5fd51ce2d0f892cbe622951a86866660"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-e0da6a40c0aa3bd42ec776abc30c1445"},"children":[]},{"value":{"nodeType":"element","tagName":"li","attributes":{},"_id":"element-8655d4caa09c9e8a36b9777cd9b9c112"},"children":[{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__action composer-node__delete"},"_id":"element-c3a5ab237ea9d5270023dc46adbd0610"},"children":[{"value":{"nodeType":"element","tagName":"i","attributes":{"class":"fa fa-trash fa-lg"},"_id":"element-42bff53b3a864ca8316c7a06a6755aa1"},"children":[]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-928a03f876f2b9e3111b4a06d8842820"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-ca83e473536304a114ebb44d060a2bfd"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n\r\n  ","_id":"text-6ba5b15246d69d56817c1e50e4cffe4b"},"children":[]},{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer-node__main"},"_id":"element-72e24211752240badcddf802b3907a15"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-9764b4141d30920c25d0ac00b6061bec"},"children":[]},{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer-node__view"},"_id":"element-75075fb07979cd37e802682a87f6555f"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-b1b53b5fb062cac72c45ce2157631789"},"children":[]},{"value":{"nodeType":"element","tagName":"code","attributes":{"data-html":"preview"},"_id":"element-a398551aac893c9d12e444c0f7734c17"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-74bcd9385b1385a6521aa00f56296544"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n\r\n    ","_id":"text-644dcd076ffd3446be5382b1b580c277"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-not":"isEmpty"},"_id":"element-e6cfd7ae7b780b66e48cce2ea28a6771"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-a8423214f081d009f95a3f0a5e024b80"},"children":[]},{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer-node__children","data-tag":"childWrapperTag"},"_id":"element-555148303a0e62c44865afd8ae4a6a06"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n        ","_id":"text-1c7937c5383762176a754e876a302c0e"},"children":[]},{"value":{"nodeType":"element","tagName":"header","attributes":{"class":"composer-node__toolbar"},"_id":"element-dbead6caf2bfa1c09bc7c8286aa9bc0e"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n          ","_id":"text-6736a9aa76cbf00fa61d96c4fb69afc8"},"children":[]},{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__title","data-text":"childrenTitle"},"_id":"element-ead791e6b23c4572203add7740632ac3"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n          ","_id":"text-dee8a171b04e4721d9bf78106d58411f"},"children":[]},{"value":{"nodeType":"element","tagName":"ul","attributes":{"class":"composer-node__actions"},"_id":"element-09ec9682b14012040ff84c439a97c62a"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n            ","_id":"text-17db7faf5c0030e0235e99857f193718"},"children":[]},{"value":{"nodeType":"element","tagName":"li","attributes":{},"_id":"element-3fecd7a2226fa148598396a7a27e2f2d"},"children":[{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__action composer-node__collapse-children"},"_id":"element-74b72340a27adfaff33d061e7fd0aa12"},"children":[{"value":{"nodeType":"element","tagName":"i","attributes":{"class":"fa fa-minus-square fa-lg"},"_id":"element-1d3709988767252f1743b3ade4eaecd3"},"children":[]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n            ","_id":"text-732dcebf1170c8066a742435fb71a31b"},"children":[]},{"value":{"nodeType":"element","tagName":"li","attributes":{},"_id":"element-0d7b5e238cf6852f3ea806ba2def3836"},"children":[{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__action composer-node__expand-children"},"_id":"element-de8d6c18cf0654d4312e211e3f782a3d"},"children":[{"value":{"nodeType":"element","tagName":"i","attributes":{"class":"fa fa-plus-square fa-lg"},"_id":"element-da1003de105a47c880eeb12027a23343"},"children":[]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n          ","_id":"text-0ad12a6f9dce489a541595fe52b41525"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n        ","_id":"text-a76f7136e02091e83c5428022a2ddbd6"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n        ","_id":"text-a57a01bcd73d41d5017c6b860ae2b754"},"children":[]},{"value":{"nodeType":"element","tagName":"ul","attributes":{"data-dragsource":"composer"},"_id":"element-e6447b0d32e24f4635e0cd7441be2b3a"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-4bedd2ffb7098a2f105e39e93da2bbaa"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-bf80f024a5b25d5f57e27f2e939a7360"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-b5535d5d56e9184157e9d0bf4aee6c0c"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-e0603f9e3f9021d715aca2e36cdad5bb"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-4493fd4207263f74b06afc6fb20cc81c"},"children":[]}]},"document":{"value":{"nodeType":"documentFragment","_id":"documentfragment-9a563fd42d9e9c6ec40a7917709a8ff4"},"children":[{"value":{"nodeType":"documentType","_id":"documentType-f57c6ef2ab3398e96ef8ac2f7f757c6d","name":"html","publicId":"","systemId":""},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-6be8ae7ea23601ff8951891c2268448d"},"children":[]},{"value":{"nodeType":"element","tagName":"html","attributes":{"class":"no-js","lang":"en"},"_id":"element-87c0f158f2b87f6b8b15a7979c1c38dc"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-c3710cbc89604b99e97b13e2fa2348f5"},"children":[]},{"value":{"nodeType":"element","tagName":"head","attributes":{},"_id":"element-5cb16929dc9465155c0b08a409c8996e"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-5712714af1316cee13418be5f0b7ae35"},"children":[]},{"value":{"nodeType":"element","tagName":"meta","attributes":{"charset":"utf-8"},"_id":"element-9e5311f3e9e04880707238a90dbcfd45"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-298383437e57c491397900bea8769c3e"},"children":[]},{"value":{"nodeType":"element","tagName":"meta","attributes":{"name":"viewport","content":"width=device-width, initial-scale=1.0"},"_id":"element-47b45a7f46f88562dd06631e07ae2622"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-dedcaaa9b458d483c9aa27b2855f53da"},"children":[]},{"value":{"nodeType":"element","tagName":"title","attributes":{"data-text":"documentTitle"},"_id":"element-f2ee43cd1671f5a5a81a9b6f3e2d7c32"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-60524e4f23f19c9dfff11d815dd0cea1"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-each":"headStyles"},"_id":"element-a931499b41fe25493c1f82f9e2969e4a"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-162bcb365d18f2c4aae24823e9710d56"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-include":"style"},"_id":"element-4d14b89df2a2950b525d71cd05c459a9"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-de6c16a583381b4511b0e15c421c1b65"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-b23fe0ad4f416b8eb28a4d4ae7381743"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-each":"headScripts"},"_id":"element-8a69cfb037b02eca617301c68fdaa929"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-21af9668188eca1f8d27c52a39783b92"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-include":"script"},"_id":"element-e65cb417b20b290fe3d09e732af0ee63"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-ebdd10809897be62b3cb6e68f3262b52"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-7a40a9c62f90c193bac1ae9980683195"},"children":[]}]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-388f585386f2fb9dba24dbe1c7d585bb"},"children":[]},{"value":{"nodeType":"element","tagName":"body","attributes":{},"_id":"element-b18c71a95f76fe45ed2fc407f8f92e64"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-09e1985066b3286c6cbbc65ace8aa821"},"children":[]},{"value":{"nodeType":"element","tagName":"div","attributes":{"data-container":"","data-html":"body"},"_id":"element-cfa674e1ce86bdc163d64314f5a4114b"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-ab18328162c26e2c26f142c4ed7dd0c4"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-each":"scripts"},"_id":"element-92648195a9014a9891bbc51af1a0e760"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-e955e9b33aa94350a9776b051dbe223e"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-include":"script"},"_id":"element-1603102779ccc2e210a35a5c5a71eef4"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-c8249e749ea5f72df8766f7924dad753"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-da8cb8379f9ae85bb56e2f8fcd37a9bd"},"children":[]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-7502b165ea81fab110333c9e328e8039"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-e03b8d9e6f7178c8e4e0102c19605a29"},"children":[]}]},"script":{"value":{"nodeType":"documentFragment","_id":"documentfragment-425abb6f54e84c72f5d187300d420374"},"children":[{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-if":"text"},"_id":"element-a0b47135351459d1c2de5d334eb41c3b"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-a2d26b7594276451d3cb09f1fd8df7dd"},"children":[]},{"value":{"nodeType":"element","tagName":"script","attributes":{"data-html":"text"},"_id":"element-22d293b89ee3e8b44cad6ab22ab34846"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-144d4bbb5a6a1c4b5dcda389b9a9fa95"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-1b14e2e54c8ea537d05181259c9ee15b"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-if":"src"},"_id":"element-0463eb61ab59f3a3a7347a8b57521454"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-bbf9402b724c926f049776a9b2898760"},"children":[]},{"value":{"nodeType":"element","tagName":"script","attributes":{"data-tag":"src"},"_id":"element-feb0eb0c316098071d8d77457a01fb25"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-97bd00c32793b7fc5d3a60304152b557"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-abd4daf06bb64916600882e607c1e35e"},"children":[]}]},"style":{"value":{"nodeType":"documentFragment","_id":"documentfragment-0fa02f7bf387cf7de8ba5c2c014a9de3"},"children":[{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-if":"text"},"_id":"element-2f8de7bcaad251da800a20b6a0460178"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-3df94149738e7c3a23d6bb4003660c1c"},"children":[]},{"value":{"nodeType":"element","tagName":"style","attributes":{"data-html":"text"},"_id":"element-04ab92322c9a139c4ce6592b21fc3484"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-0f28a1fbddf52723aca875c0543e21d9"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-0df7540ba43c4dfe054d6549d3e82b4b"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-if":"src"},"_id":"element-0158f8c95448ce2d742fa2f25e76c69b"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-388651138a5f9d2951220208f92bf828"},"children":[]},{"value":{"nodeType":"element","tagName":"link","attributes":{"rel":"stylesheet","data-tag":"src"},"_id":"element-00803944d00b366d09a9d1f8eafd38e2"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-0f102fbdac3ed8b7ea84b998c889fbbb"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-c49febbe0bbb626436d3da1e4876f88c"},"children":[]}]}},"schemas":{"composer-node":{"id":"composer-node","type":"object","properties":{"id":{"$ref":"nonEmptyString"},"title":{"$ref":"nonEmptyString"},"treeType":{"$ref":"nonEmptyString"},"nodeType":{"$ref":"nonEmptyString"},"depth":{"type":"integer"},"isEmpty":{"type":"boolean"},"isCollapsed":{"type":"boolean"},"isChildrenCollapsed":{"type":"boolean"},"preview":{"$ref":"nonEmptyString"},"childrenTitle":{"$ref":"nonEmptyString"}},"required":["id","title","treeType","nodeType","depth","preview","childrenTitle"]},"document":{"id":"document","type":"object","properties":{"documentTitle":{"$ref":"nonEmptyString"},"headStyles":{"type":"array","items":{"$ref":"style"}},"headScripts":{"type":"array","items":{"$ref":"script"}},"scripts":{"type":"array","items":{"$ref":"script"}}},"required":["documentTitle"]},"script":{"id":"script","$ref":"htmlResource"},"style":{"id":"style","$ref":"htmlResource"},"componentConfig":{"id":"componentConfig","type":"object","properties":{"containerSelector":{"$ref":"nonEmptyString"}}},"htmlResource":{"id":"htmlResource","oneOf":[{"$ref":"htmlResourceText"},{"$ref":"htmlResourceSrc"}]},"htmlResourceSrc":{"id":"htmlResourceSrc","type":"object","properties":{"src":{"type":"string"}},"required":["src"]},"htmlResourceText":{"id":"htmlResourceText","type":"object","properties":{"text":{"type":"string"}},"required":["text"]},"nonEmptyString":{"id":"nonEmptyString","type":"string","pattern":"^(?!\\s*$).+"}},"defaultModels":{"document":{"documentTitle":"New Document"}},"configs":{"composer":{"containerSelector":".composer"},"composer-node":{"containerSelector":".composer-node__children > ul"},"document":{"containerSelector":"body > [data-container]"}},"transforms":{"composer-node":{"nodeTag":[{"$if":[{"$value":"isCollapsed"},{"addClass":"composer-node--collapsed"}]},{"$if":[{"$value":"isEmpty"},{"addClass":"composer-node--empty"}]},{"attr":["id",{"$value":"id"}]},{"attr":["data-treeType",{"$value":"treeType"}]},{"attr":["data-nodeType",{"$value":"nodeType"}]},{"attr":["data-depth",{"$value":"depth"}]}],"childWrapperTag":[{"$if":[{"$value":"isChildrenCollapsed"},{"addClass":"composer-node__children--collapsed"}]},{"attr":["id",{"$value":"id"}]}]},"script":{"src":{"$if":[{"$value":"src"},{"attr":["src",{"$value":"src"}]}]}},"style":{"src":{"$if":[{"$value":"src"},{"attr":["href",{"$value":"src"}]}]}}},"componentNames":["composer","composer-node","document","script","style"],"components":{"composer":{"config":{"containerSelector":".composer"},"style":".composer {\n  line-height: 2;\n  font-size: 1rem;\n}\n\n$toolbar-color: hsl( 210, 15%, 40% );\n$toolbar-children-color: hsl( 210, 85%, 37% );\n$toolbar-empty-color: hsl( 210, 10%, 88% );\n$main-color: hsl( 210, 5%, 95% );\n$children-color: hsl( 210, 95%, 95% );\n$action-color: hsl(210, 85%, 60% );\n$action-delete-color: hsl( 0, 83%, 50% );\n\n.composer-node__toolbar {\n  min-height: 3rem;\n\n  color: hsl( 210, 10%, 95% );\n  @include colorize-el( $toolbar-color );\n  box-shadow: 0.125rem 0.125rem 0.5rem rgba( 0, 0, 0, 0.25 );\n}\n\n.composer-node__title {\n  line-height: 3;\n  padding: 0 1rem;\n}\n\n.composer-node__children > .composer-node__toolbar {\n  @include colorize-el( $toolbar-children-color );\n  box-shadow: 0.125rem 0.125rem 0.5rem rgba( 0, 0, 0, 0.25 );\n}\n\n.composer-node--empty > .composer-node__toolbar {\n  color: hsl( 210, 85%, 15% );\n  @include colorize-el( $toolbar-empty-color );\n  box-shadow: 0.125rem 0.125rem 0.5rem rgba( 0, 0, 0, 0.25 );\n}\n\n.composer-node:not( [data-depth=\"0\"] ) > .composer-node__toolbar {\n  cursor: move;\n}\n\n.composer-node__view {\n  margin-bottom: 0.5rem;\n  overflow: hidden;\n  padding: 0.5rem;\n\n  color: #111;\n  background: #fff;\n  box-shadow: inset 0.03125rem 0.03125rem 0.125rem rgba( 0, 0, 0, 0.25 );\n}\n\n.composer-node__view:last-child {\n  margin-bottom: 0;\n}\n\n.composer-node__main {\n  padding: 0.75rem;\n  margin: 0.25rem;\n  margin-top: 0;\n\n  @include colorize-el-background( $main-color );\n  box-shadow: 0.125rem 0.125rem 0.5rem rgba( 0, 0, 0, 0.25 );\n}\n\n.composer-node--collapsed > .composer-node__main,\n.composer-node__children--collapsed > .composer-node__main {\n  height: 0;\n  margin: 0;\n  padding: 0;\n  border: 0;\n  overflow: hidden;\n}\n\n.composer-node__children {\n  overflow: hidden;\n\n  @include colorize-el-background( $children-color );\n  box-shadow: inset 0.125rem 0.125rem 0.5rem rgba( 0, 0, 0, 0.25 );\n}\n\n.composer-node__children > ul {\n  margin: 0;\n  padding: 0.5rem;\n  list-style: none;\n}\n\n.composer-node__children--collapsed > ul {\n  height: 0;\n  padding: 0;\n  overflow: hidden;\n}\n\n.composer-node__children > ul > li {\n  margin: 0;\n  padding: 0;\n}\n\n.composer-node__actions {\n  display: block;\n  float: right;\n}\n\n.composer-node__actions > li {\n  display: block;\n  float: left;\n}\n\n.composer-node__action {\n  display: block;\n  padding: 0;\n  font-size: 1rem;\n  line-height: 1.875rem;\n  width: 1.875rem;\n  margin: 0.5rem 0;\n  text-align: center;\n  cursor: default;\n\n  color: hsl( 210, 5%, 95% );\n  @include colorize-el( $action-color );\n  box-shadow: 0.0625rem 0.0625rem 0.25rem rgba( 0, 0, 0, 0.25 );\n}\n\n.composer-node__action--disabled {\n  opacity: 0.5;\n}\n\n.composer-node__actions > li:last-child .composer-node__action {\n  margin-right: 0.5rem;\n}\n\n.composer-node__delete {\n  color: hsl( 0, 5%, 95% );\n  @include colorize-el( $action-delete-color );\n  box-shadow: 0.0625rem 0.0625rem 0.25rem rgba( 0, 0, 0, 0.25 );\n}\n","template":{"value":{"nodeType":"documentFragment","_id":"documentfragment-0562659b3da6c60e3e5f70bb6d7d86a2"},"children":[{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer"},"_id":"element-849d5d801a9b2b36bade540237eec745"},"children":[]}]}},"composer-node":{"config":{"containerSelector":".composer-node__children > ul"},"schema":{"id":"composer-node","type":"object","properties":{"id":{"$ref":"nonEmptyString"},"title":{"$ref":"nonEmptyString"},"treeType":{"$ref":"nonEmptyString"},"nodeType":{"$ref":"nonEmptyString"},"depth":{"type":"integer"},"isEmpty":{"type":"boolean"},"isCollapsed":{"type":"boolean"},"isChildrenCollapsed":{"type":"boolean"},"preview":{"$ref":"nonEmptyString"},"childrenTitle":{"$ref":"nonEmptyString"}},"required":["id","title","treeType","nodeType","depth","preview","childrenTitle"]},"template":{"value":{"nodeType":"documentFragment","_id":"documentfragment-83e25ac2ac4ca68ad1d3109fcba7d564"},"children":[{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer-node","data-tag":"nodeTag"},"_id":"element-ef44978563f9d81a42c22cade3929643"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-8a278ee92af7e6a683779f2b7c63e819"},"children":[]},{"value":{"nodeType":"element","tagName":"header","attributes":{"class":"composer-node__toolbar"},"_id":"element-cbc5d85165f681315eafb3b7edcb6502"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-323b65fe0b8ad06e7523ddbd6b808cc2"},"children":[]},{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__title","data-text":"title"},"_id":"element-4850aea48698a4416bff6554f52ca833"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-1b1da63e9692debe0fc790c60b3dbde6"},"children":[]},{"value":{"nodeType":"element","tagName":"ul","attributes":{"class":"composer-node__actions"},"_id":"element-5fd51ce2d0f892cbe622951a86866660"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-e0da6a40c0aa3bd42ec776abc30c1445"},"children":[]},{"value":{"nodeType":"element","tagName":"li","attributes":{},"_id":"element-8655d4caa09c9e8a36b9777cd9b9c112"},"children":[{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__action composer-node__delete"},"_id":"element-c3a5ab237ea9d5270023dc46adbd0610"},"children":[{"value":{"nodeType":"element","tagName":"i","attributes":{"class":"fa fa-trash fa-lg"},"_id":"element-42bff53b3a864ca8316c7a06a6755aa1"},"children":[]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-928a03f876f2b9e3111b4a06d8842820"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-ca83e473536304a114ebb44d060a2bfd"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n\r\n  ","_id":"text-6ba5b15246d69d56817c1e50e4cffe4b"},"children":[]},{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer-node__main"},"_id":"element-72e24211752240badcddf802b3907a15"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-9764b4141d30920c25d0ac00b6061bec"},"children":[]},{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer-node__view"},"_id":"element-75075fb07979cd37e802682a87f6555f"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-b1b53b5fb062cac72c45ce2157631789"},"children":[]},{"value":{"nodeType":"element","tagName":"code","attributes":{"data-html":"preview"},"_id":"element-a398551aac893c9d12e444c0f7734c17"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-74bcd9385b1385a6521aa00f56296544"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n\r\n    ","_id":"text-644dcd076ffd3446be5382b1b580c277"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-not":"isEmpty"},"_id":"element-e6cfd7ae7b780b66e48cce2ea28a6771"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-a8423214f081d009f95a3f0a5e024b80"},"children":[]},{"value":{"nodeType":"element","tagName":"div","attributes":{"class":"composer-node__children","data-tag":"childWrapperTag"},"_id":"element-555148303a0e62c44865afd8ae4a6a06"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n        ","_id":"text-1c7937c5383762176a754e876a302c0e"},"children":[]},{"value":{"nodeType":"element","tagName":"header","attributes":{"class":"composer-node__toolbar"},"_id":"element-dbead6caf2bfa1c09bc7c8286aa9bc0e"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n          ","_id":"text-6736a9aa76cbf00fa61d96c4fb69afc8"},"children":[]},{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__title","data-text":"childrenTitle"},"_id":"element-ead791e6b23c4572203add7740632ac3"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n          ","_id":"text-dee8a171b04e4721d9bf78106d58411f"},"children":[]},{"value":{"nodeType":"element","tagName":"ul","attributes":{"class":"composer-node__actions"},"_id":"element-09ec9682b14012040ff84c439a97c62a"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n            ","_id":"text-17db7faf5c0030e0235e99857f193718"},"children":[]},{"value":{"nodeType":"element","tagName":"li","attributes":{},"_id":"element-3fecd7a2226fa148598396a7a27e2f2d"},"children":[{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__action composer-node__collapse-children"},"_id":"element-74b72340a27adfaff33d061e7fd0aa12"},"children":[{"value":{"nodeType":"element","tagName":"i","attributes":{"class":"fa fa-minus-square fa-lg"},"_id":"element-1d3709988767252f1743b3ade4eaecd3"},"children":[]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n            ","_id":"text-732dcebf1170c8066a742435fb71a31b"},"children":[]},{"value":{"nodeType":"element","tagName":"li","attributes":{},"_id":"element-0d7b5e238cf6852f3ea806ba2def3836"},"children":[{"value":{"nodeType":"element","tagName":"span","attributes":{"class":"composer-node__action composer-node__expand-children"},"_id":"element-de8d6c18cf0654d4312e211e3f782a3d"},"children":[{"value":{"nodeType":"element","tagName":"i","attributes":{"class":"fa fa-plus-square fa-lg"},"_id":"element-da1003de105a47c880eeb12027a23343"},"children":[]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n          ","_id":"text-0ad12a6f9dce489a541595fe52b41525"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n        ","_id":"text-a76f7136e02091e83c5428022a2ddbd6"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n        ","_id":"text-a57a01bcd73d41d5017c6b860ae2b754"},"children":[]},{"value":{"nodeType":"element","tagName":"ul","attributes":{"data-dragsource":"composer"},"_id":"element-e6447b0d32e24f4635e0cd7441be2b3a"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-4bedd2ffb7098a2f105e39e93da2bbaa"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-bf80f024a5b25d5f57e27f2e939a7360"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-b5535d5d56e9184157e9d0bf4aee6c0c"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-e0603f9e3f9021d715aca2e36cdad5bb"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-4493fd4207263f74b06afc6fb20cc81c"},"children":[]}]},"transform":{"nodeTag":[{"$if":[{"$value":"isCollapsed"},{"addClass":"composer-node--collapsed"}]},{"$if":[{"$value":"isEmpty"},{"addClass":"composer-node--empty"}]},{"attr":["id",{"$value":"id"}]},{"attr":["data-treeType",{"$value":"treeType"}]},{"attr":["data-nodeType",{"$value":"nodeType"}]},{"attr":["data-depth",{"$value":"depth"}]}],"childWrapperTag":[{"$if":[{"$value":"isChildrenCollapsed"},{"addClass":"composer-node__children--collapsed"}]},{"attr":["id",{"$value":"id"}]}]}},"document":{"config":{"containerSelector":"body > [data-container]"},"defaultModel":{"documentTitle":"New Document"},"schema":{"id":"document","type":"object","properties":{"documentTitle":{"$ref":"nonEmptyString"},"headStyles":{"type":"array","items":{"$ref":"style"}},"headScripts":{"type":"array","items":{"$ref":"script"}},"scripts":{"type":"array","items":{"$ref":"script"}}},"required":["documentTitle"]},"style":"* {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n}\n\nhtml {\n  font-family: sans-serif;\n}\n\n.gu-unselectable {\n  list-style: none;\n}\n\n.gu-mirror {\n  position: fixed !important;\n  margin: 0 !important;\n  z-index: 9999 !important;\n  opacity: 0.8;\n  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=80)\";\n  filter: alpha(opacity=80);\n}\n\n.gu-hide {\n  display: none !important;\n}\n\n.gu-unselectable {\n  -webkit-user-select: none !important;\n  -moz-user-select: none !important;\n  -ms-user-select: none !important;\n  user-select: none !important;\n}\n\n.gu-transit {\n  opacity: 0.2;\n  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=20)\";\n  filter: alpha(opacity=20);\n}\n\n.ratio {\n  width: 4rem;\n  text-align: center;\n  position: relative;\n}\n\n.ratio .shim {\n  padding-bottom: 100%;\n}\n\n.ratio .viewport {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n\n$lighten-hue: 40deg;\n$darken-hue: 210deg;\n\n$adjust-hue: 20%;\n$adjust-saturation: 5%;\n$adjust-lightness: 5%;\n\n$adjust-hue-gradient-highlight: $adjust-hue / 2;\n$adjust-saturation-gradient-highlight: $adjust-saturation / 2;\n$adjust-lightness-gradient-highlight: $adjust-lightness / 2;\n\n@function shift-hue( $from-hue, $to-hue, $amount ){\n  $from-color: hsl( $from-hue, 100%, 50% );\n  $to-color: hsl( $to-hue, 100%, 50% );\n  $mixed: mix( $to-color, $from-color, $amount );\n  $new-hue: hue( $mixed );\n\n  @return $new-hue;\n}\n\n@function advanced-lighten( $from-color, $hue-amount, $saturation-amount, $lightness-amount ){\n  $hue: hue( $from-color );\n  $new-hue: shift-hue( $hue, $lighten-hue, $hue-amount );\n\n  $light-and-saturation: lighten(\n    desaturate(\n      $from-color,\n      $saturation-amount\n    ),\n    $lightness-amount\n  );\n\n  @return change-color( $light-and-saturation, $hue: $new-hue );\n}\n\n@function advanced-darken( $from-color, $hue-amount, $saturation-amount, $lightness-amount ){\n  $hue: hue( $from-color );\n  $new-hue: shift-hue( $hue, $darken-hue, $hue-amount );\n\n  $light-and-saturation: darken(\n    saturate(\n      $from-color,\n      $saturation-amount\n    ),\n    $lightness-amount\n  );\n\n  @return change-color( $light-and-saturation, $hue: $new-hue );\n}\n\n@mixin colorize-el-background( $base-color ){\n  $gradient-highlight: advanced-lighten(\n    $base-color,\n    $adjust-hue-gradient-highlight,\n    $adjust-lightness-gradient-highlight,\n    $adjust-saturation-gradient-highlight\n  );\n  $gradient-base: $base-color;\n  $gradient-shadow: advanced-darken(\n    $base-color,\n    $adjust-hue,\n    $adjust-lightness,\n    $adjust-saturation\n  );\n\n  background: linear-gradient(\n    to bottom,\n    $gradient-highlight,\n    $gradient-base,\n    $gradient-shadow\n  );\n}\n\n@mixin colorize-el( $base-color ){\n  $gradient-shadow: advanced-darken(\n    $base-color,\n    $adjust-hue,\n    $adjust-lightness,\n    $adjust-saturation\n  );\n\n  $border-highlight: advanced-lighten(\n    $base-color,\n    $adjust-hue,\n    $adjust-lightness,\n    $adjust-saturation\n  );\n  $border-shadow: advanced-darken(\n    $gradient-shadow,\n    $adjust-hue,\n    $adjust-lightness,\n    $adjust-saturation\n  );\n\n  $text-shadow: advanced-darken(\n    $border-shadow,\n    $adjust-hue,\n    $adjust-lightness,\n    $adjust-saturation\n  );\n\n  @include colorize-el-background( $base-color );\n  border: 0.0625rem solid $border-highlight;\n  border-bottom: 0.0625rem solid $border-shadow;\n  border-right: 0.0625rem solid $border-shadow;\n  text-shadow: 0.0625rem 0.0625rem 0 $text-shadow;\n}","template":{"value":{"nodeType":"documentFragment","_id":"documentfragment-9a563fd42d9e9c6ec40a7917709a8ff4"},"children":[{"value":{"nodeType":"documentType","_id":"documentType-f57c6ef2ab3398e96ef8ac2f7f757c6d","name":"html","publicId":"","systemId":""},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-6be8ae7ea23601ff8951891c2268448d"},"children":[]},{"value":{"nodeType":"element","tagName":"html","attributes":{"class":"no-js","lang":"en"},"_id":"element-87c0f158f2b87f6b8b15a7979c1c38dc"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-c3710cbc89604b99e97b13e2fa2348f5"},"children":[]},{"value":{"nodeType":"element","tagName":"head","attributes":{},"_id":"element-5cb16929dc9465155c0b08a409c8996e"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-5712714af1316cee13418be5f0b7ae35"},"children":[]},{"value":{"nodeType":"element","tagName":"meta","attributes":{"charset":"utf-8"},"_id":"element-9e5311f3e9e04880707238a90dbcfd45"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-298383437e57c491397900bea8769c3e"},"children":[]},{"value":{"nodeType":"element","tagName":"meta","attributes":{"name":"viewport","content":"width=device-width, initial-scale=1.0"},"_id":"element-47b45a7f46f88562dd06631e07ae2622"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-dedcaaa9b458d483c9aa27b2855f53da"},"children":[]},{"value":{"nodeType":"element","tagName":"title","attributes":{"data-text":"documentTitle"},"_id":"element-f2ee43cd1671f5a5a81a9b6f3e2d7c32"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-60524e4f23f19c9dfff11d815dd0cea1"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-each":"headStyles"},"_id":"element-a931499b41fe25493c1f82f9e2969e4a"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-162bcb365d18f2c4aae24823e9710d56"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-include":"style"},"_id":"element-4d14b89df2a2950b525d71cd05c459a9"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-de6c16a583381b4511b0e15c421c1b65"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-b23fe0ad4f416b8eb28a4d4ae7381743"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-each":"headScripts"},"_id":"element-8a69cfb037b02eca617301c68fdaa929"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-21af9668188eca1f8d27c52a39783b92"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-include":"script"},"_id":"element-e65cb417b20b290fe3d09e732af0ee63"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-ebdd10809897be62b3cb6e68f3262b52"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-7a40a9c62f90c193bac1ae9980683195"},"children":[]}]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-388f585386f2fb9dba24dbe1c7d585bb"},"children":[]},{"value":{"nodeType":"element","tagName":"body","attributes":{},"_id":"element-b18c71a95f76fe45ed2fc407f8f92e64"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-09e1985066b3286c6cbbc65ace8aa821"},"children":[]},{"value":{"nodeType":"element","tagName":"div","attributes":{"data-container":"","data-html":"body"},"_id":"element-cfa674e1ce86bdc163d64314f5a4114b"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-ab18328162c26e2c26f142c4ed7dd0c4"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-each":"scripts"},"_id":"element-92648195a9014a9891bbc51af1a0e760"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n      ","_id":"text-e955e9b33aa94350a9776b051dbe223e"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-include":"script"},"_id":"element-1603102779ccc2e210a35a5c5a71eef4"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n    ","_id":"text-c8249e749ea5f72df8766f7924dad753"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-da8cb8379f9ae85bb56e2f8fcd37a9bd"},"children":[]}]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-7502b165ea81fab110333c9e328e8039"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-e03b8d9e6f7178c8e4e0102c19605a29"},"children":[]}]}},"script":{"schema":{"id":"script","$ref":"htmlResource"},"template":{"value":{"nodeType":"documentFragment","_id":"documentfragment-425abb6f54e84c72f5d187300d420374"},"children":[{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-if":"text"},"_id":"element-a0b47135351459d1c2de5d334eb41c3b"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-a2d26b7594276451d3cb09f1fd8df7dd"},"children":[]},{"value":{"nodeType":"element","tagName":"script","attributes":{"data-html":"text"},"_id":"element-22d293b89ee3e8b44cad6ab22ab34846"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-144d4bbb5a6a1c4b5dcda389b9a9fa95"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-1b14e2e54c8ea537d05181259c9ee15b"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-if":"src"},"_id":"element-0463eb61ab59f3a3a7347a8b57521454"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-bbf9402b724c926f049776a9b2898760"},"children":[]},{"value":{"nodeType":"element","tagName":"script","attributes":{"data-tag":"src"},"_id":"element-feb0eb0c316098071d8d77457a01fb25"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-97bd00c32793b7fc5d3a60304152b557"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-abd4daf06bb64916600882e607c1e35e"},"children":[]}]},"transform":{"src":{"$if":[{"$value":"src"},{"attr":["src",{"$value":"src"}]}]}}},"style":{"schema":{"id":"style","$ref":"htmlResource"},"template":{"value":{"nodeType":"documentFragment","_id":"documentfragment-0fa02f7bf387cf7de8ba5c2c014a9de3"},"children":[{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-if":"text"},"_id":"element-2f8de7bcaad251da800a20b6a0460178"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-3df94149738e7c3a23d6bb4003660c1c"},"children":[]},{"value":{"nodeType":"element","tagName":"style","attributes":{"data-html":"text"},"_id":"element-04ab92322c9a139c4ce6592b21fc3484"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-0f28a1fbddf52723aca875c0543e21d9"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-0df7540ba43c4dfe054d6549d3e82b4b"},"children":[]},{"value":{"nodeType":"element","tagName":"fragment","attributes":{"data-if":"src"},"_id":"element-0158f8c95448ce2d742fa2f25e76c69b"},"children":[{"value":{"nodeType":"text","nodeValue":"\r\n  ","_id":"text-388651138a5f9d2951220208f92bf828"},"children":[]},{"value":{"nodeType":"element","tagName":"link","attributes":{"rel":"stylesheet","data-tag":"src"},"_id":"element-00803944d00b366d09a9d1f8eafd38e2"},"children":[]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-0f102fbdac3ed8b7ea84b998c889fbbb"},"children":[]}]},{"value":{"nodeType":"text","nodeValue":"\r\n","_id":"text-c49febbe0bbb626436d3da1e4876f88c"},"children":[]}]},"transform":{"src":{"$if":[{"$value":"src"},{"attr":["href",{"$value":"src"}]}]}}}},"datas":{"data-small":{"value":{"nodeType":"fragment","_id":"fragment-e8d0915d6b361cdc45ade8243a925fe3"},"children":[{"value":{"nodeType":"tag","name":"strong","attr":{},"_id":"tag-9e19a4a49cb820b3c9de2657d111106e"},"children":[]},{"value":{"nodeType":"tag","name":"h2","attr":{"id":"myHeader","class":"primary-header"},"_id":"h2-fc3ad02e943cb8979ed95f008254e7c4"},"children":[{"value":{"data":"Hello ","nodeType":"text","_id":"text-e8430e778578dcb8a5cef17fcfdd9675"},"children":[]},{"value":{"nodeType":"text","data":"Chris","_id":"text-dfdea7742a24d7dccece3f0c6ca8ec80"},"children":[]}]}]}}}
},{}],2:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Tree = require('1tree');
var defaultAdapter = require('1tree/dist/adapter/default');

var basePlugins = Object.keys(Tree.plugins).map(function (key) {
  return Tree.plugins[key];
});

var Mtree = function Mtree() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var excludeBase = args.some(function (arg) {
    return typeof arg === 'boolean' && arg;
  });

  var adapter = defaultAdapter;
  var plugins = excludeBase ? [] : basePlugins;

  args.forEach(function (arg) {
    if (Array.isArray(arg)) {
      plugins = arg.concat(plugins);
    } else if (typeof arg === 'function') {
      plugins = [arg].concat(plugins);
    } else if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object') {
      adapter = arg;
    }
  });

  return Tree.adapter(adapter, plugins);
};

module.exports = Mtree;
},{"1tree":60,"1tree/dist/adapter/default":14}],3:[function(require,module,exports){
'use strict'

module.exports = require( './dist' )

},{"./dist":2}],4:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Tree = require('1tree');
var T = require('mtype');
var paths = require('./paths');

var pathFromNode = paths.pathFromNode,
    nodeFromPath = paths.nodeFromPath;


var t = T();

var valueTypes = ['string', 'number', 'boolean'];

var extendValue = function extendValue(node, value) {
  return node.value(Object.assign({}, node.value(), value));
};

var toNode = function toNode(jsonObj, parent) {
  var create = parent ? parent.createNode : Tree.createRoot;

  var nodeType = t.of(jsonObj);
  var value = { nodeType: nodeType };

  if (valueTypes.includes(nodeType)) value.nodeValue = jsonObj;

  var node = create(value);

  if (nodeType === 'array') {
    jsonObj.forEach(function (el, index) {
      var arrayItemNode = toNode(el, node);

      extendValue(arrayItemNode, { arrayIndex: index });

      node.append(arrayItemNode);
    });
  } else if (nodeType === 'object') {
    var propertyNames = Object.keys(jsonObj);

    propertyNames.forEach(function (name) {
      var propertyValue = jsonObj[name];
      var valueNode = toNode(propertyValue, node);

      extendValue(valueNode, { propertyName: name });

      node.append(valueNode);
    });
  }

  return node;
};

var toTree = function toTree(jsonObj) {
  return toNode(jsonObj, null);
};

var toJson = function toJson(tree) {
  var value = tree.value();
  var nodeType = value.nodeType;

  if (nodeType === 'null') return null;

  if (valueTypes.includes(nodeType)) return value.nodeValue;

  if (nodeType === 'array') return tree.getChildren().map(toJson);

  if (nodeType === 'object') {
    var _ret = function () {
      var obj = {};

      tree.getChildren().forEach(function (nameValueNode) {
        var value = nameValueNode.value();
        var propertyName = value.propertyName;

        var propertyValue = toJson(nameValueNode);

        obj[propertyName] = propertyValue;
      });

      return {
        v: obj
      };
    }();

    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
  }

  throw new Error('Unexpected node');
};

module.exports = { toTree: toTree, toJson: toJson, pathFromNode: pathFromNode, nodeFromPath: nodeFromPath };
},{"./paths":5,"1tree":60,"mtype":174}],5:[function(require,module,exports){
'use strict';

var slugFromNode = function slugFromNode(node) {
  var parent = node.getParent();

  if (!parent) return '$';

  var value = node.value();

  if (typeof value.propertyName === 'string') return value.propertyName;

  if (typeof value.arrayIndex === 'number') return value.arrayIndex + '';
};

var pathFromNode = function pathFromNode(node) {
  var parentWithSlug = node.closest(function (n) {
    return !!slugFromNode(n) && n.get() !== node.get();
  });

  if (!parentWithSlug) return '$';

  var parentPath = pathFromNode(parentWithSlug);
  var slug = slugFromNode(node);

  if (slug) return parentPath + '/' + slug;
};

var nodeFromPath = function nodeFromPath(tree, path) {
  return tree.find(function (node) {
    return path === pathFromNode(node);
  });
};

module.exports = { pathFromNode: pathFromNode, nodeFromPath: nodeFromPath };
},{}],6:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":4,"dup":3}],7:[function(require,module,exports){
'use strict';

var toTree = require('./toTree');
var toJson = require('./toJson');
var paths = require('./paths');

var pathFromNode = paths.pathFromNode,
    nodeFromPath = paths.nodeFromPath;


module.exports = { toTree: toTree, toJson: toJson, pathFromNode: pathFromNode, nodeFromPath: nodeFromPath };
},{"./paths":8,"./toJson":9,"./toTree":10}],8:[function(require,module,exports){
'use strict';

var slugFromNode = function slugFromNode(node) {
  var parent = node.getParent();

  if (!parent) return '$';

  var value = node.value();

  if (typeof value.propertyName === 'string') return value.propertyName;

  if (typeof value.arrayIndex === 'number') return value.arrayIndex + '';
};

var pathFromNode = function pathFromNode(node) {
  var parentWithSlug = node.closest(function (n) {
    return !!slugFromNode(n) && n.get() !== node.get();
  });

  if (!parentWithSlug) return '$';

  var nodePath = pathFromNode(parentWithSlug);
  var slug = slugFromNode(node);

  if (slug) nodePath += '/' + slug;

  return nodePath;
};

// this is easy but inefficent, it's very simple to use the path segments to
// traverse the tree, replace!
var nodeFromPath = function nodeFromPath(schemaTree, path) {
  return schemaTree.find(function (node) {
    return path === pathFromNode(node);
  });
};

module.exports = { pathFromNode: pathFromNode, nodeFromPath: nodeFromPath };
},{}],9:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var valueMapper = function valueMapper(node) {
  var value = node.value();

  var schema = Object.assign({}, value);

  if (value.type === 'union') {
    schema.type = value.typesUnion;

    delete schema.typesUnion;
  } else if (value.type === 'any') {
    delete schema.type;
  }

  return schema;
};

var deleteFromValue = function deleteFromValue(node, propertyName) {
  var value = node.value();

  delete value[propertyName];

  node.value(value);
};

var propertyPopulators = {
  propertyName: function propertyName(node, schema) {
    if (_typeof(schema.properties) !== 'object') schema.properties = {};

    var value = node.value();
    var propertyName = value.propertyName;


    deleteFromValue(node, 'propertyName');

    schema.properties[propertyName] = toJson(node);
  },
  propertyPattern: function propertyPattern(node, schema) {
    if (_typeof(schema.patternProperties) !== 'object') schema.patternProperties = {};

    var value = node.value();
    var pattern = value.propertyPattern;

    deleteFromValue(node, 'propertyPattern');

    schema.patternProperties[pattern] = toJson(node);
  },
  additionalPropertiesSchema: function additionalPropertiesSchema(node, schema) {
    deleteFromValue(node, 'additionalPropertiesSchema');

    schema.additionalProperties = toJson(node);
  },
  arrayItem: function arrayItem(node, schema) {
    deleteFromValue(node, 'arrayItem');

    schema.items = toJson(node);
  },
  arrayIndex: function arrayIndex(node, schema) {
    if (!Array.isArray(schema.items)) schema.items = [];

    var value = node.value();
    var arrayIndex = value.arrayIndex;


    deleteFromValue(node, 'arrayIndex');

    schema.items[arrayIndex] = toJson(node);
  },
  anyOf: function anyOf(node, schema) {
    if (!Array.isArray(schema.anyOf)) schema.anyOf = [];

    deleteFromValue(node, 'anyOf');

    var childSchema = toJson(node);

    schema.anyOf.push(childSchema);
  },
  allOf: function allOf(node, schema) {
    if (!Array.isArray(schema.allOf)) schema.allOf = [];

    deleteFromValue(node, 'allOf');

    var childSchema = toJson(node);

    schema.allOf.push(childSchema);
  },
  oneOf: function oneOf(node, schema) {
    if (!Array.isArray(schema.oneOf)) schema.oneOf = [];

    deleteFromValue(node, 'oneOf');

    var childSchema = toJson(node);

    schema.oneOf.push(childSchema);
  },
  not: function not(node, schema) {
    deleteFromValue(node, 'not');

    schema.not = toJson(node);
  }
};

var populatorProperties = Object.keys(propertyPopulators);

var nestingMapper = function nestingMapper(node) {
  var schema = valueMapper(node);

  var children = node.getChildren();

  children.forEach(function (childNode) {
    var value = childNode.value();

    var populateFor = populatorProperties.filter(function (propertyName) {
      return propertyName in value;
    });

    populateFor.forEach(function (propertyName) {
      var populator = propertyPopulators[propertyName];

      populator(childNode, schema);
    });
  });

  return schema;
};

var valueMappers = {
  object: nestingMapper,
  array: nestingMapper,
  any: nestingMapper,
  union: nestingMapper,
  string: valueMapper,
  number: valueMapper,
  boolean: valueMapper,
  integer: valueMapper,
  null: valueMapper
};

var toJson = function toJson(node) {
  node = node.clone();

  var value = node.value();
  var schemaType = value.type;
  var mapper = valueMappers[schemaType];

  return mapper(node);
};

module.exports = toJson;
},{}],10:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Tree = require('1tree');

var createsNesting = {
  object: ['properties', 'additionalProperties', 'definitions', 'patternProperties', 'dependencies', 'allOf', 'anyOf', 'oneOf', 'not'],
  array: ['items']
};

createsNesting.any = createsNesting.object.concat(createsNesting.array);
createsNesting.union = createsNesting.any;

var valueMapper = function valueMapper(schema) {
  var value = Object.assign({}, schema);

  if (Array.isArray(schema.type)) {
    value.type = 'union';
    value.typesUnion = schema.type.slice();
  } else if (typeof schema.type !== 'string') {
    value.type = 'any';
  }

  return value;
};

var nestingMapper = function nestingMapper(schema) {
  var value = valueMapper(schema);

  var createsNestingDef = createsNesting[value.type];

  createsNestingDef.forEach(function (propertyName) {
    delete value[propertyName];
  });

  return value;
};

var nodeValueMappers = {
  string: valueMapper,
  number: valueMapper,
  integer: valueMapper,
  boolean: valueMapper,
  null: valueMapper,
  object: nestingMapper,
  array: nestingMapper,
  any: nestingMapper
};

var extendValue = function extendValue(node, value) {
  return node.value(Object.assign({}, node.value(), value));
};

var createPropertyNode = function createPropertyNode(schema, node, propertyName) {
  var propertySchema = schema.properties[propertyName];
  var propertyNode = toNode(propertySchema, node);

  extendValue(propertyNode, { propertyName: propertyName });

  return propertyNode;
};

var createAdditionalPropertiesNode = function createAdditionalPropertiesNode(schema, node) {
  var additionalPropertiesSchema = schema.additionalProperties;
  var additionalPropertiesNode = toNode(additionalPropertiesSchema, node);

  extendValue(additionalPropertiesNode, { additionalPropertiesSchema: true });

  return additionalPropertiesNode;
};

var createPatternPropertyNode = function createPatternPropertyNode(schema, node, pattern) {
  var patternPropertySchema = schema.patternProperties[pattern];
  var patternPropertyNode = toNode(patternPropertySchema, node);

  extendValue(patternPropertyNode, { propertyPattern: pattern });

  return patternPropertyNode;
};

var createCombiningNode = function createCombiningNode(combineSchema, node, combineName) {
  var combineNode = toNode(combineSchema, node);

  extendValue(combineNode, _defineProperty({}, combineName, true));

  return combineNode;
};

var createItemsNode = function createItemsNode(schema, node) {
  var itemsSchema = schema.items;
  var itemsNode = toNode(itemsSchema, node);

  extendValue(itemsNode, { arrayItem: true });

  return itemsNode;
};

var createItemTupleNode = function createItemTupleNode(tupleSchema, node, index) {
  var itemTupleNode = toNode(tupleSchema, node);

  extendValue(itemTupleNode, { arrayIndex: index });

  return itemTupleNode;
};

var combineArrayTypes = ['anyOf', 'allOf', 'oneOf'];

var childrenPopulators = {
  object: function object(schema, node) {
    if (schema.properties) {
      var propertyNames = Object.keys(schema.properties);

      propertyNames.forEach(function (propertyName) {
        var propertyNode = createPropertyNode(schema, node, propertyName);
        node.append(propertyNode);
      });
    }

    if (typeof schema.additionalProperties === 'boolean') {
      var value = node.value();

      value.additionalProperties = schema.additionalProperties;

      node.value(value);
    } else if (_typeof(schema.additionalProperties) === 'object') {
      var additionalPropertiesNode = createAdditionalPropertiesNode(schema, node);

      node.append(additionalPropertiesNode);
    }

    if (schema.definitions) throw new Error('definitions not supported');

    if (schema.patternProperties) {
      var patterns = Object.keys(schema.patternProperties);

      patterns.forEach(function (pattern) {
        var patternPropertyNode = createPatternPropertyNode(schema, node, pattern);
        node.append(patternPropertyNode);
      });
    }

    if (schema.dependencies) throw new Error('dependencies not supported');

    combineArrayTypes.forEach(function (combineName) {
      if (schema[combineName]) {
        var combineDef = schema[combineName];

        combineDef.forEach(function (combineSchema) {
          var combineNode = createCombiningNode(combineSchema, node, combineName);

          node.append(combineNode);
        });
      }
    });

    if (schema.not) {
      var combineSchema = schema.not;
      var combineNode = createCombiningNode(combineSchema, node, 'not');

      node.append(combineNode);
    }
  },
  array: function array(schema, node) {
    if (Array.isArray(schema.items)) {
      schema.items.forEach(function (tupleSchema, index) {
        var itemTupleNode = createItemTupleNode(tupleSchema, node, index);

        node.append(itemTupleNode);
      });
    } else if (_typeof(schema.items) === 'object') {
      var itemsNode = createItemsNode(schema, node);

      node.append(itemsNode);
    }
  },
  any: function any(schema, node) {
    childrenPopulators.object(schema, node);
    childrenPopulators.array(schema, node);
  }
};

var containerNodeTypes = Object.keys(childrenPopulators);

var toNode = function toNode(schema, parent) {
  var create = parent ? parent.createNode : Tree.createRoot;

  var schemaType = typeof schema.type === 'string' ? schema.type : 'any';
  var valueMapper = nodeValueMappers[schemaType];
  var value = valueMapper(schema);
  var node = create(value);

  if (containerNodeTypes.includes(schemaType)) {
    var childrenPopulator = childrenPopulators[schemaType];

    childrenPopulator(schema, node);
  }

  return node;
};

var toTree = function toTree(schema) {
  return toNode(schema, null);
};

module.exports = toTree;
},{"1tree":60}],11:[function(require,module,exports){
'use strict'

module.exports = require( './dist' )

},{"./dist":7}],12:[function(require,module,exports){
'use strict';

module.exports = {
  createNode: function createNode(value) {
    return {
      value: value,
      children: []
    };
  },
  argTypes: ['nodeValue'],
  returnType: 'node',
  categories: ['manipulation', 'adapter']
};
},{}],13:[function(require,module,exports){
'use strict';

module.exports = {
  getChildren: function getChildren(node) {
    return node.children;
  },
  argTypes: ['node'],
  returnType: '[node]',
  categories: ['traversal', 'adapter']
};
},{}],14:[function(require,module,exports){
'use strict';

var createNode = require('./createNode');
var getChildren = require('./getChildren');
var insertBefore = require('./insertBefore');
var remove = require('./remove');
var value = require('./value');

module.exports = { createNode: createNode, getChildren: getChildren, insertBefore: insertBefore, remove: remove, value: value };
},{"./createNode":12,"./getChildren":13,"./insertBefore":15,"./remove":16,"./value":17}],15:[function(require,module,exports){
'use strict';

module.exports = {
  insertBefore: function insertBefore(fn, root, parentNode, childNode, referenceNode) {
    if (root) fn.remove(fn, root, childNode);

    if (referenceNode) {
      var referenceIndex = parentNode.children.indexOf(referenceNode);

      parentNode.children.splice(referenceIndex, 0, childNode);
    } else {
      parentNode.children.push(childNode);
    }

    return childNode;
  },
  argTypes: ['fn', 'rootNode', 'node', 'node', 'node'],
  returnType: 'node',
  requires: ['remove'],
  categories: ['manipulation', 'adapter']
};
},{}],16:[function(require,module,exports){
'use strict';

module.exports = {
  remove: function remove(fn, root, node) {
    var parentNode = fn.getParent(fn, root, node);

    if (!parentNode) return;

    var index = parentNode.children.indexOf(node);

    parentNode.children.splice(index, 1);

    return node;
  },
  argTypes: ['fn', 'rootNode', 'node'],
  returnType: 'node',
  requires: ['getParent'],
  categories: ['manipulation', 'adapter']
};
},{}],17:[function(require,module,exports){
'use strict';

module.exports = {
  value: function value(node, _value) {
    if (_value !== undefined) {
      node.value = _value;
    }

    return node.value;
  },
  argTypes: ['node', 'nodeValue?'],
  returnType: 'nodeValue',
  categories: ['manipulation', 'adapter']
};
},{}],18:[function(require,module,exports){
'use strict';

module.exports = {
  createNode: function createNode() {
    throw new Error('Adapter does not implement createNode');
  },
  argTypes: ['nodeValue'],
  returnType: 'node',
  categories: ['manipulation', 'adapter']
};
},{}],19:[function(require,module,exports){
'use strict';

module.exports = {
  getChildren: function getChildren() {
    throw new Error('Adapter does not implement getChildren');
  },
  argTypes: ['node'],
  returnType: '[node]',
  categories: ['traversal', 'adapter']
};
},{}],20:[function(require,module,exports){
'use strict';

module.exports = {
  insertBefore: function insertBefore() {
    throw new Error('Adapter does not implement insertBefore');
  },
  argTypes: ['fn', 'rootNode', 'node', 'node', 'node'],
  returnType: 'node',
  requires: ['remove'],
  categories: ['manipulation', 'adapter']
};
},{}],21:[function(require,module,exports){
'use strict';

module.exports = {
  remove: function remove() {
    throw new Error('Adapter does not implement remove');
  },
  argTypes: ['fn', 'rootNode', 'node'],
  returnType: 'node',
  requires: ['getParent'],
  categories: ['manipulation', 'adapter']
};
},{}],22:[function(require,module,exports){
'use strict';

module.exports = {
  value: function value() {
    throw new Error('Adapter does not implement value');
  },
  argTypes: ['node', 'nodeValue?'],
  returnType: 'nodeValue',
  categories: ['manipulation', 'adapter']
};
},{}],23:[function(require,module,exports){
'use strict';

var append = require('./manipulation/append');
var empty = require('./manipulation/empty');
var insertAfter = require('./manipulation/insertAfter');
var insertAt = require('./manipulation/insertAt');
var prepend = require('./manipulation/prepend');
var removeAt = require('./manipulation/removeAt');
var replaceChild = require('./manipulation/replaceChild');
var unwrap = require('./manipulation/unwrap');
var wrap = require('./manipulation/wrap');

var ancestors = require('./traversal/ancestors');
var childAt = require('./traversal/childAt');
var closest = require('./traversal/closest');
var contains = require('./traversal/contains');
var descendents = require('./traversal/descendents');
var find = require('./traversal/find');
var findAll = require('./traversal/findAll');
var firstChild = require('./traversal/firstChild');
var getParent = require('./traversal/getParent');
var hasChildren = require('./traversal/hasChildren');
var isEmpty = require('./traversal/isEmpty');
var lastChild = require('./traversal/lastChild');
var nextSibling = require('./traversal/nextSibling');
var previousSibling = require('./traversal/previousSibling');
var siblings = require('./traversal/siblings');
var walk = require('./traversal/walk');
var walkUp = require('./traversal/walkUp');

var createNode = require('./adapter/createNode');
var getChildren = require('./adapter/getChildren');
var insertBefore = require('./adapter/insertBefore');
var remove = require('./adapter/remove');
var value = require('./adapter/value');

module.exports = {
  append: append, empty: empty, insertAfter: insertAfter, insertAt: insertAt, prepend: prepend, removeAt: removeAt, replaceChild: replaceChild,
  unwrap: unwrap, wrap: wrap, ancestors: ancestors, childAt: childAt, closest: closest, contains: contains, descendents: descendents, find: find,
  findAll: findAll, firstChild: firstChild, getParent: getParent, hasChildren: hasChildren, isEmpty: isEmpty, lastChild: lastChild, nextSibling: nextSibling,
  previousSibling: previousSibling, siblings: siblings, walk: walk, walkUp: walkUp, createNode: createNode, getChildren: getChildren,
  insertBefore: insertBefore, remove: remove, value: value
};
},{"./adapter/createNode":18,"./adapter/getChildren":19,"./adapter/insertBefore":20,"./adapter/remove":21,"./adapter/value":22,"./manipulation/append":24,"./manipulation/empty":25,"./manipulation/insertAfter":26,"./manipulation/insertAt":27,"./manipulation/prepend":28,"./manipulation/removeAt":29,"./manipulation/replaceChild":30,"./manipulation/unwrap":31,"./manipulation/wrap":32,"./traversal/ancestors":33,"./traversal/childAt":34,"./traversal/closest":35,"./traversal/contains":36,"./traversal/descendents":37,"./traversal/find":38,"./traversal/findAll":39,"./traversal/firstChild":40,"./traversal/getParent":41,"./traversal/hasChildren":42,"./traversal/isEmpty":43,"./traversal/lastChild":44,"./traversal/nextSibling":45,"./traversal/previousSibling":46,"./traversal/siblings":47,"./traversal/walk":48,"./traversal/walkUp":49}],24:[function(require,module,exports){
'use strict';

module.exports = {
  append: function append(fn, root, parentNode, childNode) {
    return fn.insertBefore(fn, root, parentNode, childNode);
  },
  argTypes: ['fn', 'rootNode', 'node', 'node'],
  returnType: 'node',
  requires: ['insertBefore'],
  categories: ['manipulation']
};
},{}],25:[function(require,module,exports){
'use strict';

module.exports = {
  empty: function empty(fn, root, parentNode) {
    var children = fn.getChildren(parentNode).slice();

    return children.reduce(function (removed, node) {
      removed.push(fn.remove(fn, parentNode, node));

      return removed;
    }, []);
  },
  argTypes: ['fn', 'rootNode', 'node'],
  returnType: '[node]',
  requires: ['getChildren', 'remove'],
  categories: ['manipulation']
};
},{}],26:[function(require,module,exports){
'use strict';

module.exports = {
  insertAfter: function insertAfter(fn, root, parentNode, childNode, referenceNode) {
    var children = fn.getChildren(parentNode);
    var referenceIndex = children.indexOf(referenceNode);
    var beforeNode = children[referenceIndex + 1];

    return fn.insertBefore(fn, root, parentNode, childNode, beforeNode);
  },
  argTypes: ['fn', 'rootNode', 'node', 'node', 'node'],
  returnType: 'node',
  requires: ['getChildren', 'insertBefore'],
  categories: ['manipulation']
};
},{}],27:[function(require,module,exports){
'use strict';

module.exports = {
  insertAt: function insertAt(fn, root, parentNode, childNode, index) {
    var children = fn.getChildren(parentNode);
    var referenceNode = children[index];

    return fn.insertBefore(fn, root, parentNode, childNode, referenceNode);
  },
  argTypes: ['fn', 'rootNode', 'node', 'node', 'integer'],
  returnType: 'node',
  requires: ['getChildren', 'insertBefore'],
  categories: ['manipulation']
};
},{}],28:[function(require,module,exports){
'use strict';

module.exports = {
  prepend: function prepend(fn, root, parentNode, childNode) {
    var children = fn.getChildren(parentNode);

    // if child[ 0 ] is undefined this is the same as append
    return fn.insertBefore(fn, root, parentNode, childNode, children[0]);
  },
  argTypes: ['fn', 'rootNode', 'node', 'node'],
  returnType: 'node',
  requires: ['getChildren', 'insertBefore'],
  categories: ['manipulation']
};
},{}],29:[function(require,module,exports){
'use strict';

module.exports = {
  removeAt: function removeAt(fn, root, parentNode, index) {
    var children = fn.getChildren(parentNode);
    var childNode = children[index];

    return fn.remove(fn, root, childNode);
  },
  argTypes: ['fn', 'rootNode', 'node', 'integer'],
  returnType: 'node',
  requires: ['getChildren', 'remove'],
  categories: ['manipulation']
};
},{}],30:[function(require,module,exports){
'use strict';

module.exports = {
  replaceChild: function replaceChild(fn, root, parentNode, newNode, oldNode) {
    fn.insertBefore(fn, root, parentNode, newNode, oldNode);

    return fn.remove(fn, root, oldNode);
  },
  argTypes: ['fn', 'rootNode', 'node', 'node', 'node'],
  returnType: 'node',
  requires: ['insertBefore', 'remove'],
  categories: ['manipulation']
};
},{}],31:[function(require,module,exports){
'use strict';

module.exports = {
  unwrap: function unwrap(fn, root, node) {
    var parent = fn.getParent(fn, root, node);
    var grandparent = fn.getParent(fn, root, parent);
    var children = fn.getChildren(parent);

    children.forEach(function (child) {
      return fn.insertBefore(fn, root, grandparent, child, parent);
    });

    return fn.remove(fn, root, parent);
  },
  argTypes: ['fn', 'rootNode', 'node'],
  returnType: 'node',
  requires: ['getParent', 'getChildren', 'insertBefore', 'remove'],
  categories: ['manipulation']
};
},{}],32:[function(require,module,exports){
'use strict';

module.exports = {
  wrap: function wrap(fn, root, node, newNode) {
    var parent = fn.getParent(fn, root, node);

    fn.insertBefore(fn, root, parent, newNode, node);
    fn.append(fn, root, newNode, node);

    return newNode;
  },
  argTypes: ['fn', 'rootNode', 'node', 'node'],
  returnType: 'node',
  requires: ['getParent', 'insertBefore', 'append'],
  categories: ['manipulation']
};
},{}],33:[function(require,module,exports){
'use strict';

module.exports = {
  ancestors: function ancestors(fn, root, node) {
    var parentNodes = [];

    var parent = fn.getParent(fn, root, node);

    if (parent) fn.walkUp(fn, root, parent, function (n) {
      parentNodes.push(n);
    });

    return parentNodes;
  },
  argTypes: ['fn', 'rootNode', 'node'],
  returnType: '[node]',
  requires: ['getParent', 'walkUp']
};
},{}],34:[function(require,module,exports){
'use strict';

module.exports = {
  childAt: function childAt(fn, node, i) {
    return fn.getChildren(node)[i];
  },
  argTypes: ['fn', 'node', 'integer'],
  returnType: 'node',
  requires: ['getChildren'],
  categories: ['traversal']
};
},{}],35:[function(require,module,exports){
'use strict';

module.exports = {
  closest: function closest(fn, root, node, predicate) {
    var targetNode = void 0;

    fn.walkUp(fn, root, node, function (currentNode) {
      if (predicate(currentNode)) {
        targetNode = currentNode;

        return true;
      }
    });

    return targetNode;
  },
  argTypes: ['fn', 'rootNode', 'node', 'node => boolean'],
  returnType: 'node',
  requires: ['walkUp'],
  categories: ['traversal']
};
},{}],36:[function(require,module,exports){
'use strict';

module.exports = {
  contains: function contains(fn, node, predicate) {
    return !!fn.find(fn, node, predicate);
  },
  argTypes: ['fn', 'node', 'node => boolean'],
  returnType: 'boolean',
  requires: ['find'],
  categories: ['traversal']
};
},{}],37:[function(require,module,exports){
'use strict';

module.exports = {
  descendents: function descendents(fn, node) {
    return fn.findAll(fn, node, function (n) {
      return n !== node;
    });
  },
  argTypes: ['fn', 'node'],
  returnType: '[node]',
  requires: ['findAll'],
  categories: ['traversal']
};
},{}],38:[function(require,module,exports){
'use strict';

module.exports = {
  find: function find(fn, node, predicate) {
    var targetNode = void 0;

    fn.walk(fn, node, function (currentNode) {
      if (predicate(currentNode)) {
        targetNode = currentNode;

        return true;
      }
    });

    return targetNode;
  },
  argTypes: ['fn', 'node', 'node => boolean'],
  returnType: 'node',
  requires: ['walk'],
  categories: ['traversal']
};
},{}],39:[function(require,module,exports){
'use strict';

module.exports = {
  findAll: function findAll(fn, node, predicate) {
    var nodes = [];

    fn.walk(fn, node, function (currentNode) {
      if (predicate(currentNode)) {
        nodes.push(currentNode);
      }
    });

    return nodes;
  },
  argTypes: ['fn', 'node', 'node => boolean'],
  returnType: '[node]',
  requires: ['walk'],
  categories: ['traversal']
};
},{}],40:[function(require,module,exports){
'use strict';

module.exports = {
  firstChild: function firstChild(fn, node) {
    return fn.getChildren(node)[0];
  },
  argTypes: ['fn', 'node'],
  returnType: 'node',
  requires: ['getChildren'],
  categories: ['traversal']
};
},{}],41:[function(require,module,exports){
'use strict';

module.exports = {
  getParent: function getParent(fn, root, node) {
    return fn.find(fn, root, function (currentNode) {
      return fn.getChildren(currentNode).includes(node);
    });
  },
  argTypes: ['fn', 'rootNode', 'node'],
  returnType: 'node',
  requires: ['find', 'getChildren'],
  categories: ['traversal']
};
},{}],42:[function(require,module,exports){
'use strict';

module.exports = {
  hasChildren: function hasChildren(fn, node) {
    return fn.getChildren(node).length > 0;
  },
  argTypes: ['fn', 'node'],
  returnType: 'boolean',
  requires: ['getChildren'],
  categories: ['traversal']
};
},{}],43:[function(require,module,exports){
'use strict';

module.exports = {
  isEmpty: function isEmpty(fn, node) {
    return false;
  }, //eslint-disable-line no-unused-vars
  argTypes: ['fn', 'node'],
  returnType: 'boolean',
  requires: [],
  categories: ['traversal']
};
},{}],44:[function(require,module,exports){
'use strict';

module.exports = {
  lastChild: function lastChild(fn, node) {
    var children = fn.getChildren(node);

    return children[children.length - 1];
  },
  argTypes: ['fn', 'node'],
  returnType: 'node',
  requires: ['getChildren'],
  categories: ['traversal']
};
},{}],45:[function(require,module,exports){
'use strict';

module.exports = {
  nextSibling: function nextSibling(fn, root, node) {
    var parent = fn.getParent(fn, root, node);
    var children = fn.getChildren(parent);

    var index = children.indexOf(node);

    return children[index + 1];
  },
  argTypes: ['fn', 'rootNode', 'node'],
  returnType: 'node',
  requires: ['getParent', 'getChildren'],
  categories: ['traversal']
};
},{}],46:[function(require,module,exports){
'use strict';

module.exports = {
  previousSibling: function previousSibling(fn, root, node) {
    var parent = fn.getParent(fn, root, node);
    var children = fn.getChildren(parent);

    var index = children.indexOf(node);

    return children[index - 1];
  },
  argTypes: ['fn', 'rootNode', 'node'],
  returnType: 'node',
  requires: ['getParent', 'getChildren'],
  categories: ['traversal']
};
},{}],47:[function(require,module,exports){
'use strict';

module.exports = {
  siblings: function siblings(fn, root, node) {
    var parent = fn.getParent(fn, root, node);
    var children = fn.getChildren(parent);

    return children.filter(function (child) {
      return child !== node;
    });
  },
  argTypes: ['fn', 'rootNode', 'node'],
  returnType: '[node]',
  requires: ['getParent', 'getChildren'],
  categories: ['traversal']
};
},{}],48:[function(require,module,exports){
'use strict';

module.exports = {
  walk: function walk(fn, node, callback) {
    var current = void 0,
        parent = void 0,
        depth = void 0,
        i = void 0,
        children = void 0,
        stop = void 0;
    var nodes = [node];
    var parents = [null];
    var depths = [0];

    while (nodes.length) {
      current = nodes.pop();
      parent = parents.pop();
      depth = depths.pop();

      stop = callback(current, parent, depth);

      if (stop) break;

      children = fn.getChildren(current);

      for (i = children.length - 1; i >= 0; i--) {
        nodes.push(children[i]);
        parents.push(current);
        depths.push(depth + 1);
      }
    }
  },
  argTypes: ['fn', 'node', '( node, node, integer ) => boolean'],
  requires: ['getChildren'],
  categories: ['traversal']
};
},{}],49:[function(require,module,exports){
'use strict';

module.exports = {
  walkUp: function walkUp(fn, root, node, callback) {
    var stop = callback(node);

    if (!stop) {
      var parent = fn.getParent(fn, root, node);
      while (parent && !stop) {
        stop = callback(parent);
        if (!stop) parent = fn.getParent(fn, root, parent);
      }
    }
  },
  argTypes: ['fn', 'rootNode', 'node', 'node => boolean'],
  requires: ['getParent'],
  categories: ['traversal']
};
},{}],50:[function(require,module,exports){
'use strict';

var baseDefs = require('./defs');

var mapper = function mapper(defs) {
  var makeFn = function makeFn(name) {
    var fnDef = defs[name];
    var fn = fnDef[name];

    fn.def = fnDef;

    return fn;
  };

  var fnames = Object.keys(defs);

  return fnames.reduce(function (fns, name) {
    fns[name] = makeFn(name);

    return fns;
  }, {});
};

var fnFactory = function fnFactory(adapter) {
  var adapterDefs = Object.keys(adapter).reduce(function (defs, fname) {
    var adapterDef = adapter[fname];

    if (typeof adapterDef === 'function') {
      var fn = adapterDef;
      adapterDef = adapterDef.def || baseDefs[fname] || {};
      adapterDef[fname] = fn;
    }

    defs[fname] = adapterDef;

    return defs;
  }, {});

  return mapper(Object.assign({}, baseDefs, adapterDefs));
};

module.exports = fnFactory;
},{"./defs":23}],51:[function(require,module,exports){
'use strict';

require('./polyfills');

var defaultAdapter = require('./adapter/default');
var fnFactory = require('./fn-factory');

var meta = require('./plugins/meta');
var parentMap = require('./plugins/parent-map');
var serializer = require('./plugins/serializer');
var wrapNodes = require('./plugins/wrap-nodes');
var accepts = require('./plugins/accepts');
var nodeType = require('./plugins/nodeType');
var id = require('./plugins/id');

var plugins = { parentMap: parentMap, accepts: accepts, nodeType: nodeType, id: id, serializer: serializer, meta: meta, wrapNodes: wrapNodes };
var pluginArray = Object.keys(plugins).map(function (key) {
  return plugins[key];
});

var treeFactory = function treeFactory(adapter, plugins) {
  var fn = fnFactory(adapter);

  if (Array.isArray(plugins)) plugins.forEach(function (plugin) {
    return plugin(fn);
  });

  // create wrapped API
  var Tree = function Tree(root) {
    return fn.createTree(root);
  };

  var fnames = Object.keys(fn);

  fnames.forEach(function (fname) {
    var func = fn[fname];
    var def = func.def || {};
    var argTypes = Array.isArray(def.argTypes) ? def.argTypes : [];

    Tree[fname] = function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (argTypes.includes('fn')) {
        return func.apply(undefined, [fn].concat(args));
      }

      return func.apply(undefined, args);
    };
  });

  Tree.createRoot = function (value) {
    return Tree(Tree.createNode(value));
  };
  Tree.fn = fn;
  Tree.adapter = treeFactory;
  Tree.plugin = function (plugin) {
    return plugin(fn);
  };
  Tree.plugins = plugins;

  return Tree;
};

module.exports = treeFactory(defaultAdapter, pluginArray);
},{"./adapter/default":14,"./fn-factory":50,"./plugins/accepts":52,"./plugins/id":53,"./plugins/meta":54,"./plugins/nodeType":55,"./plugins/parent-map":56,"./plugins/serializer":57,"./plugins/wrap-nodes":58,"./polyfills":59}],52:[function(require,module,exports){
'use strict';

var acceptsNode = function acceptsNode(fn) {
  var accepts = function accepts(fn, node, childNode) {
    return !fn.isEmpty(fn, node);
  }; //eslint-disable-line no-unused-vars

  accepts.def = {
    argTypes: ['fn', 'node', 'node'],
    returnType: 'boolean',
    require: ['isEmpty'],
    categories: ['node', 'plugin']
  };

  var originalInsertBefore = fn.insertBefore;

  var insertBefore = function insertBefore(fn, root, parentNode, childNode, referenceNode) {
    if (!fn.accepts(fn, parentNode, childNode)) throw new Error('Node cannot accept this child');

    return originalInsertBefore(fn, root, parentNode, childNode, referenceNode);
  };

  insertBefore.def = originalInsertBefore.def;

  return Object.assign(fn, { accepts: accepts, insertBefore: insertBefore });
};

module.exports = acceptsNode;
},{}],53:[function(require,module,exports){
'use strict';

var utils = require('mojule-utils');

var lazyId = function lazyId(fn) {
  var id = function id(fn, node) {
    var value = fn.value(node);

    if (value._id) return value._id;

    var nodeType = fn.nodeType(fn, node);
    var id = utils.id(nodeType);

    value._id = id;

    fn.value(node, value);

    return id;
  };

  id.def = {
    argTypes: ['fn', 'node'],
    returnType: 'string',
    require: ['value', 'nodeType'],
    categories: ['node', 'plugin']
  };

  return Object.assign(fn, { id: id });
};

module.exports = lazyId;
},{"mojule-utils":161}],54:[function(require,module,exports){
'use strict';

/*
  Get/set runtime data for nodes that aren't written to the nodes themselves

  For example, when visualising trees you might want to allow the user to
  collapse or expand nodes for the duration of the session, but not actually
  modify the nodes themselves
*/

var metaPlugin = function metaPlugin(fn) {
  var metaMap = new Map();

  var meta = function meta(fn, node, key, value) {
    if (!metaMap.has(node)) {
      metaMap.set(node, {});
    }

    var obj = metaMap.get(node);

    if (value !== undefined) {
      obj[key] = value;
    }

    return obj[key];
  };

  meta.def = {
    argTypes: ['fn', 'node', 'string', 'any'],
    returnType: 'any',
    requires: [],
    categories: ['meta', 'plugin']
  };

  return Object.assign(fn, { meta: meta });
};

module.exports = metaPlugin;
},{}],55:[function(require,module,exports){
'use strict';

var getNodeType = function getNodeType(fn) {
  var nodeType = function nodeType(fn, node) {
    var value = fn.value(node);

    if (typeof value.nodeType === 'string' && value.nodeType.length > 0) return value.nodeType;

    return 'treeNode';
  };

  nodeType.def = {
    argTypes: ['fn', 'node'],
    returnType: 'string',
    require: ['value'],
    categories: ['node', 'plugin']
  };

  return Object.assign(fn, { nodeType: nodeType });
};

module.exports = getNodeType;
},{}],56:[function(require,module,exports){
'use strict';

var parentMap = function parentMap(fn) {
  var parents = new Map();

  var original = {
    insertBefore: fn.insertBefore,
    remove: fn.remove,
    getParent: fn.getParent
  };

  var insertBefore = function insertBefore(fn, root, parentNode, childNode, referenceNode) {
    var value = original.insertBefore(fn, root, parentNode, childNode, referenceNode);

    parents.set(childNode, parentNode);

    return value;
  };

  var remove = function remove(fn, root, node) {
    var value = original.remove(fn, root, node);

    parents.set(node, null);

    return value;
  };

  var getParent = function getParent(fn, root, node) {
    var parent = parents.get(node);

    if (!parent && original.getParent) {
      parent = original.getParent(fn, root, node);
      parents.set(node, parent);
    }

    return parent;
  };

  var wrapped = { insertBefore: insertBefore, remove: remove, getParent: getParent };

  Object.keys(wrapped).forEach(function (fname) {
    wrapped[fname].def = Object.assign({
      wraps: original[fname]
    }, original[fname].def);

    wrapped[fname].def.categories.push('parentMap', 'plugin');
  });

  return Object.assign(fn, wrapped);
};

module.exports = parentMap;
},{}],57:[function(require,module,exports){
'use strict';

var cloneObj = function cloneObj(obj) {
  return JSON.parse(JSON.stringify(obj));
};

var serializer = function serializer(fn) {
  var serialize = function serialize(node) {
    return {
      value: fn.value(node),
      children: fn.getChildren(node).map(serialize)
    };
  };

  serialize.def = {
    argTypes: ['node'],
    returnType: 'object',
    requires: ['value', 'getChildren'],
    categories: ['serializer', 'plugin']
  };

  var deserialize = function deserialize(obj) {
    var parentNode = fn.createNode(obj.value);

    if (Array.isArray(obj.children)) {
      obj.children.forEach(function (child) {
        fn.append(fn, null, parentNode, deserialize(child));
      });
    }

    return parentNode;
  };

  deserialize.def = {
    argTypes: ['object'],
    returnType: 'node',
    requires: ['createNode', 'append'],
    categories: ['serializer', 'plugin']
  };

  var clone = function clone(fn, node) {
    return fn.deserialize(cloneObj(fn.serialize(node)));
  };

  clone.def = {
    argTypes: ['fn', 'node'],
    returnType: 'node',
    requires: ['serialize', 'deserialize'],
    categories: ['clone', 'plugin']
  };

  return Object.assign(fn, { serialize: serialize, deserialize: deserialize, clone: clone });
};

module.exports = serializer;
},{}],58:[function(require,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var signatureToDef = function signatureToDef(sig) {
  var segs = sig.split('=>');
  var argTypes = segs[0].replace('(', '').replace(')', '').split(',').map(function (arg) {
    return arg.trim();
  });
  var returnType = segs[1].trim();

  return { argTypes: argTypes, returnType: returnType };
};

var argsMap = function argsMap(fn, argTypes, map) {
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var wrappedArgs = argTypes.map(function (typeName, i) {
      var value = args[i];

      if (map[typeName]) {
        return map[typeName](value);
      }

      return value;
    });

    return fn.apply(undefined, _toConsumableArray(wrappedArgs));
  };
};

var clone = function clone(obj) {
  return JSON.parse(JSON.stringify(obj));
};

var wrapNodes = function wrapNodes(_fn) {
  var fnames = Object.keys(_fn);

  var wrappedFn = function wrappedFn(root, _node, fname) {
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var func = _fn[fname];
      var def = func.def || {};
      var argTypes = def && Array.isArray(def.argTypes) ? def.argTypes : [];

      var firstNode = false;

      var curryMap = {
        fn: function fn() {
          return _fn;
        },
        rootNode: function rootNode() {
          return root;
        },
        node: function node() {
          if (!firstNode) {
            firstNode = true;
            return _node;
          }

          return args.shift().get();
        },
        any: function any() {
          return args.shift();
        }
      };

      var argMap = {
        rootNode: function rootNode(n) {
          return wrappedNode(root, n);
        },
        node: function node(n) {
          return wrappedNode(root, n);
        }
      };

      var curried = argTypes.map(function (t) {
        if (curryMap[t]) return curryMap[t]();

        if (t.indexOf('=>') !== -1) {
          var _def = signatureToDef(t);
          var fnArg = args.shift();

          return argsMap(fnArg, _def.argTypes, argMap);
        }

        return curryMap.any();
      });

      var result = func.apply(undefined, _toConsumableArray(curried));

      if (def.returnType === 'node') {
        result = wrappedNode(root, result);
      } else if (def.returnType === '[node]') {
        result = result.map(function (n) {
          return wrappedNode(root, n);
        });
      }

      return result;
    };
  };

  var wrappedNode = function wrappedNode(root, node) {
    if (node === null || node === undefined) return node;

    var wrapped = fnames.reduce(function (wrappedNode, fname) {
      wrappedNode[fname] = wrappedFn(root, node, fname);

      return wrappedNode;
    }, {});

    wrapped.get = function () {
      return node;
    };
    wrapped.getRoot = function () {
      return root;
    };

    // assist with debugging
    Object.defineProperty(wrapped, '_value', {
      get: function get() {
        return clone(_fn.value(node));
      }
    });
    Object.defineProperty(wrapped, '_children', {
      get: function get() {
        return clone(_fn.getChildren(node));
      }
    });

    return wrapped;
  };

  var createTree = function createTree(root) {
    return wrappedNode(root, root);
  };

  createTree.def = {
    argTypes: ['nodeValue'],
    returnType: 'wrappedNode',
    requires: ['createNode'],
    categories: ['wrapped-nodes', 'plugin']
  };

  return Object.assign(_fn, { createTree: createTree });
};

module.exports = wrapNodes;
},{}],59:[function(require,module,exports){
'use strict';

/*eslint-disable */
if (!Array.prototype.includes) {
  Array.prototype.includes = function (searchElement /*, fromIndex*/) {
    'use strict';

    var O = Object(this);
    var len = parseInt(O.length) || 0;
    if (len === 0) {
      return false;
    }
    var n = parseInt(arguments[1]) || 0;
    var k;
    if (n >= 0) {
      k = n;
    } else {
      k = len + n;
      if (k < 0) {
        k = 0;
      }
    }
    var currentElement;
    while (k < len) {
      currentElement = O[k];
      if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {
        return true;
      }
      k++;
    }
    return false;
  };
}
/*eslint-enable */
},{}],60:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":51,"dup":3}],61:[function(require,module,exports){
module.exports = function atoa (a, n) { return Array.prototype.slice.call(a, n); }

},{}],62:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],63:[function(require,module,exports){
module.exports = {
	trueFunc: function trueFunc(){
		return true;
	},
	falseFunc: function falseFunc(){
		return false;
	}
};
},{}],64:[function(require,module,exports){

},{}],65:[function(require,module,exports){
(function (global){
'use strict';

var buffer = require('buffer');
var Buffer = buffer.Buffer;
var SlowBuffer = buffer.SlowBuffer;
var MAX_LEN = buffer.kMaxLength || 2147483647;
exports.alloc = function alloc(size, fill, encoding) {
  if (typeof Buffer.alloc === 'function') {
    return Buffer.alloc(size, fill, encoding);
  }
  if (typeof encoding === 'number') {
    throw new TypeError('encoding must not be number');
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  var enc = encoding;
  var _fill = fill;
  if (_fill === undefined) {
    enc = undefined;
    _fill = 0;
  }
  var buf = new Buffer(size);
  if (typeof _fill === 'string') {
    var fillBuf = new Buffer(_fill, enc);
    var flen = fillBuf.length;
    var i = -1;
    while (++i < size) {
      buf[i] = fillBuf[i % flen];
    }
  } else {
    buf.fill(_fill);
  }
  return buf;
}
exports.allocUnsafe = function allocUnsafe(size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    return Buffer.allocUnsafe(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new Buffer(size);
}
exports.from = function from(value, encodingOrOffset, length) {
  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof value === 'string') {
    return new Buffer(value, encodingOrOffset);
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    var offset = encodingOrOffset;
    if (arguments.length === 1) {
      return new Buffer(value);
    }
    if (typeof offset === 'undefined') {
      offset = 0;
    }
    var len = length;
    if (typeof len === 'undefined') {
      len = value.byteLength - offset;
    }
    if (offset >= value.byteLength) {
      throw new RangeError('\'offset\' is out of bounds');
    }
    if (len > value.byteLength - offset) {
      throw new RangeError('\'length\' is out of bounds');
    }
    return new Buffer(value.slice(offset, offset + len));
  }
  if (Buffer.isBuffer(value)) {
    var out = new Buffer(value.length);
    value.copy(out, 0, 0, value.length);
    return out;
  }
  if (value) {
    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
      return new Buffer(value);
    }
    if (value.type === 'Buffer' && Array.isArray(value.data)) {
      return new Buffer(value.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
}
exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
  if (typeof Buffer.allocUnsafeSlow === 'function') {
    return Buffer.allocUnsafeSlow(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size >= MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new SlowBuffer(size);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"buffer":66}],66:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":62,"ieee754":120,"isarray":123}],67:[function(require,module,exports){
'use strict';

var ticky = require('ticky');

module.exports = function debounce (fn, args, ctx) {
  if (!fn) { return; }
  ticky(function run () {
    fn.apply(ctx || null, args || []);
  });
};

},{"ticky":193}],68:[function(require,module,exports){
'use strict';

var atoa = require('atoa');
var debounce = require('./debounce');

module.exports = function emitter (thing, options) {
  var opts = options || {};
  var evt = {};
  if (thing === undefined) { thing = {}; }
  thing.on = function (type, fn) {
    if (!evt[type]) {
      evt[type] = [fn];
    } else {
      evt[type].push(fn);
    }
    return thing;
  };
  thing.once = function (type, fn) {
    fn._once = true; // thing.off(fn) still works!
    thing.on(type, fn);
    return thing;
  };
  thing.off = function (type, fn) {
    var c = arguments.length;
    if (c === 1) {
      delete evt[type];
    } else if (c === 0) {
      evt = {};
    } else {
      var et = evt[type];
      if (!et) { return thing; }
      et.splice(et.indexOf(fn), 1);
    }
    return thing;
  };
  thing.emit = function () {
    var args = atoa(arguments);
    return thing.emitterSnapshot(args.shift()).apply(this, args);
  };
  thing.emitterSnapshot = function (type) {
    var et = (evt[type] || []).slice(0);
    return function () {
      var args = atoa(arguments);
      var ctx = this || thing;
      if (type === 'error' && opts.throws !== false && !et.length) { throw args.length === 1 ? args[0] : args; }
      et.forEach(function emitter (listen) {
        if (opts.async) { debounce(listen, args, ctx); } else { listen.apply(ctx, args); }
        if (listen._once) { thing.off(type, listen); }
      });
      return thing;
    };
  };
  return thing;
};

},{"./debounce":67,"atoa":61}],69:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":122}],70:[function(require,module,exports){
(function (global){
'use strict';

var customEvent = require('custom-event');
var eventmap = require('./eventmap');
var doc = global.document;
var addEvent = addEventEasy;
var removeEvent = removeEventEasy;
var hardCache = [];

if (!global.addEventListener) {
  addEvent = addEventHard;
  removeEvent = removeEventHard;
}

module.exports = {
  add: addEvent,
  remove: removeEvent,
  fabricate: fabricateEvent
};

function addEventEasy (el, type, fn, capturing) {
  return el.addEventListener(type, fn, capturing);
}

function addEventHard (el, type, fn) {
  return el.attachEvent('on' + type, wrap(el, type, fn));
}

function removeEventEasy (el, type, fn, capturing) {
  return el.removeEventListener(type, fn, capturing);
}

function removeEventHard (el, type, fn) {
  var listener = unwrap(el, type, fn);
  if (listener) {
    return el.detachEvent('on' + type, listener);
  }
}

function fabricateEvent (el, type, model) {
  var e = eventmap.indexOf(type) === -1 ? makeCustomEvent() : makeClassicEvent();
  if (el.dispatchEvent) {
    el.dispatchEvent(e);
  } else {
    el.fireEvent('on' + type, e);
  }
  function makeClassicEvent () {
    var e;
    if (doc.createEvent) {
      e = doc.createEvent('Event');
      e.initEvent(type, true, true);
    } else if (doc.createEventObject) {
      e = doc.createEventObject();
    }
    return e;
  }
  function makeCustomEvent () {
    return new customEvent(type, { detail: model });
  }
}

function wrapperFactory (el, type, fn) {
  return function wrapper (originalEvent) {
    var e = originalEvent || global.event;
    e.target = e.target || e.srcElement;
    e.preventDefault = e.preventDefault || function preventDefault () { e.returnValue = false; };
    e.stopPropagation = e.stopPropagation || function stopPropagation () { e.cancelBubble = true; };
    e.which = e.which || e.keyCode;
    fn.call(el, e);
  };
}

function wrap (el, type, fn) {
  var wrapper = unwrap(el, type, fn) || wrapperFactory(el, type, fn);
  hardCache.push({
    wrapper: wrapper,
    element: el,
    type: type,
    fn: fn
  });
  return wrapper;
}

function unwrap (el, type, fn) {
  var i = find(el, type, fn);
  if (i) {
    var wrapper = hardCache[i].wrapper;
    hardCache.splice(i, 1); // free up a tad of memory
    return wrapper;
  }
}

function find (el, type, fn) {
  var i, item;
  for (i = 0; i < hardCache.length; i++) {
    item = hardCache[i];
    if (item.element === el && item.type === type && item.fn === fn) {
      return i;
    }
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./eventmap":71,"custom-event":81}],71:[function(require,module,exports){
(function (global){
'use strict';

var eventmap = [];
var eventname = '';
var ron = /^on/;

for (eventname in global) {
  if (ron.test(eventname)) {
    eventmap.push(eventname.slice(2));
  }
}

module.exports = eventmap;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],72:[function(require,module,exports){
'use strict'

module.exports = adapterFactory;

function adapterFactory(implementation){
	ensureImplementation(implementation);

	var adapter = {}

	var baseAdapter = {
		removeSubsets: function (nodes){
			return removeSubsets(adapter, nodes);
		},
		existsOne: function(test, elems){
			return existsOne(adapter, test, elems);
		},
		getSiblings: function(elem){
			return getSiblings(adapter, elem);
		},
		hasAttrib: function(elem, name){
			return hasAttrib(adapter, elem, name);
		},
		findOne: function(test, arr){
			return findOne(adapter, test, arr);
		},
		findAll: function(test, elems){
			return findAll(adapter, test, elems)
		}
	};

	Object.assign(adapter, baseAdapter, implementation);

	return adapter;
}

var expectImplemented = [
	"isTag", "getAttributeValue", "getChildren", "getName", "getParent",
	"getText"
];

function ensureImplementation(implementation){
	if(!implementation)	throw new TypeError("Expected implementation")

	var notImplemented = expectImplemented.filter(function(fname){
		return typeof implementation[fname] !== "function";
	});

	if(notImplemented.length){
		var notList = "(" + notImplemented.join(", ") + ")";
		var message = "Expected functions " + notList + " to be implemented";
		throw new Error(message);
	}
}

function removeSubsets(adapter, nodes){
	var idx = nodes.length, node, ancestor, replace;

	// Check if each node (or one of its ancestors) is already contained in the
	// array.
	while(--idx > -1){
		node = ancestor = nodes[idx];

		// Temporarily remove the node under consideration
		nodes[idx] = null;
		replace = true;

		while(ancestor){
			if(nodes.indexOf(ancestor) > -1){
				replace = false;
				nodes.splice(idx, 1);
				break;
			}
			ancestor = adapter.getParent(ancestor)
		}

		// If the node has been found to be unique, re-insert it.
		if(replace){
			nodes[idx] = node;
		}
	}

	return nodes;
}

function existsOne(adapter, test, elems){
	return elems.some(function(elem){
		return adapter.isTag(elem) ?
			test(elem) || adapter.existsOne(test, adapter.getChildren(elem)) :
			false;
	});
}

function getSiblings(adapter, elem){
	var parent = adapter.getParent(elem);
	return parent && adapter.getChildren(parent);
}


function hasAttrib(adapter, elem, name){
	return adapter.getAttributeValue(elem,name) !== undefined
}

function findOne(adapter, test, arr){
	var elem = null;

	for(var i = 0, l = arr.length; i < l && !elem; i++){
		if(test(arr[i])){
			elem = arr[i];
		} else {
			var childs = adapter.getChildren(arr[i]);
			if(childs && childs.length > 0){
				elem = adapter.findOne(test, childs);
			}
		}
	}

	return elem;
}

function findAll(adapter, test, elems){
	var result = [];

	for(var i = 0, j = elems.length; i < j; i++){
		if(!adapter.isTag(elems[i])) continue;
		if(test(elems[i])) result.push(elems[i]);
		var childs = adapter.getChildren(elems[i]);
		if(childs) result = result.concat(adapter.findAll(test, childs));
	}

	return result;
}

},{}],73:[function(require,module,exports){
"use strict";

module.exports = CSSselect;

var DomUtils       = require("domutils"),
	falseFunc      = require("boolbase").falseFunc,
	compileFactory = require("./lib/compile.js"),
	defaultCompile = compileFactory(DomUtils);

function adapterCompile(adapter){
	return adapter === DomUtils ? defaultCompile : compileFactory(adapter);
}

function getSelectorFunc(searchFunc){
	return function select(query, elems, options){
		options = options || {}
		options.adapter = options.adapter || DomUtils;
		var compile = adapterCompile(options.adapter);

		if(typeof query !== "function") query = compile.compileUnsafe(query, options, elems);
		if(query.shouldTestNextSiblings) elems = appendNextSiblings((options && options.context) || elems, options.adapter);
		if(!Array.isArray(elems)) elems = options.adapter.getChildren(elems);
		else elems = options.adapter.removeSubsets(elems);
		return searchFunc(query, elems, options);
	};
}

function getNextSiblings(elem, adapter){
	var siblings = adapter.getSiblings(elem);
	if(!Array.isArray(siblings)) return [];
	siblings = siblings.slice(0);
	while(siblings.shift() !== elem);
	return siblings;
}

function appendNextSiblings(elems, adapter){
	// Order matters because jQuery seems to check the children before the siblings
	if(!Array.isArray(elems)) elems = [elems];
	var newElems = elems.slice(0);

	for(var i = 0, len = elems.length; i < len; i++){
		var nextSiblings = getNextSiblings(newElems[i], adapter);
		newElems.push.apply(newElems, nextSiblings);
	}
	return newElems;
}

var selectAll = getSelectorFunc(function selectAll(query, elems, options){
	return (query === falseFunc || !elems || elems.length === 0) ? [] : options.adapter.findAll(query, elems);
});

var selectOne = getSelectorFunc(function selectOne(query, elems, options){
	return (query === falseFunc || !elems || elems.length === 0) ? null : options.adapter.findOne(query, elems);
});

function is(elem, query, options){
	options = options || {}
	options.adapter = options.adapter || DomUtils;
	var compile = adapterCompile(options.adapter);
	return (typeof query === "function" ? query : compile(query, options))(elem);
}

/*
	the exported interface
*/
function CSSselect(query, elems, options){
	return selectAll(query, elems, options);
}

CSSselect.compile = defaultCompile;
CSSselect.filters = defaultCompile.Pseudos.filters;
CSSselect.pseudos = defaultCompile.Pseudos.pseudos;

CSSselect.selectAll = selectAll;
CSSselect.selectOne = selectOne;

CSSselect.is = is;

//legacy methods (might be removed)
CSSselect.parse = defaultCompile;
CSSselect.iterate = selectAll;

//hooks
CSSselect._compileUnsafe = defaultCompile.compileUnsafe;
CSSselect._compileToken = defaultCompile.compileToken;

},{"./lib/compile.js":75,"boolbase":63,"domutils":88}],74:[function(require,module,exports){
var falseFunc = require("boolbase").falseFunc;

//https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js#L469
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;

function factory(adapter){
	/*
		attribute selectors
	*/
	var attributeRules = {
		__proto__: null,
		equals: function(next, data){
			var name  = data.name,
				value = data.value;

			if(data.ignoreCase){
				value = value.toLowerCase();

				return function equalsIC(elem){
					var attr = adapter.getAttributeValue(elem, name);
					return attr != null && attr.toLowerCase() === value && next(elem);
				};
			}

			return function equals(elem){
				return adapter.getAttributeValue(elem, name) === value && next(elem);
			};
		},
		hyphen: function(next, data){
			var name  = data.name,
				value = data.value,
				len = value.length;

			if(data.ignoreCase){
				value = value.toLowerCase();

				return function hyphenIC(elem){
					var attr = adapter.getAttributeValue(elem, name);
					return attr != null &&
							(attr.length === len || attr.charAt(len) === "-") &&
							attr.substr(0, len).toLowerCase() === value &&
							next(elem);
				};
			}

			return function hyphen(elem){
				var attr = adapter.getAttributeValue(elem, name);
				return attr != null &&
						attr.substr(0, len) === value &&
						(attr.length === len || attr.charAt(len) === "-") &&
						next(elem);
			};
		},
		element: function(next, data){
			var name = data.name,
				value = data.value;

			if(/\s/.test(value)){
				return falseFunc;
			}

			value = value.replace(reChars, "\\$&");

			var pattern = "(?:^|\\s)" + value + "(?:$|\\s)",
				flags = data.ignoreCase ? "i" : "",
				regex = new RegExp(pattern, flags);

			return function element(elem){
				var attr = adapter.getAttributeValue(elem, name);
				return attr != null && regex.test(attr) && next(elem);
			};
		},
		exists: function(next, data){
			var name = data.name;
			return function exists(elem){
				return adapter.hasAttrib(elem, name) && next(elem);
			};
		},
		start: function(next, data){
			var name  = data.name,
				value = data.value,
				len = value.length;

			if(len === 0){
				return falseFunc;
			}

			if(data.ignoreCase){
				value = value.toLowerCase();

				return function startIC(elem){
					var attr = adapter.getAttributeValue(elem, name);
					return attr != null && attr.substr(0, len).toLowerCase() === value && next(elem);
				};
			}

			return function start(elem){
				var attr = adapter.getAttributeValue(elem, name);
				return attr != null && attr.substr(0, len) === value && next(elem);
			};
		},
		end: function(next, data){
			var name  = data.name,
				value = data.value,
				len   = -value.length;

			if(len === 0){
				return falseFunc;
			}

			if(data.ignoreCase){
				value = value.toLowerCase();

				return function endIC(elem){
					var attr = adapter.getAttributeValue(elem, name);
					return attr != null && attr.substr(len).toLowerCase() === value && next(elem);
				};
			}

			return function end(elem){
				var attr = adapter.getAttributeValue(elem, name);
				return attr != null && attr.substr(len) === value && next(elem);
			};
		},
		any: function(next, data){
			var name  = data.name,
				value = data.value;

			if(value === ""){
				return falseFunc;
			}

			if(data.ignoreCase){
				var regex = new RegExp(value.replace(reChars, "\\$&"), "i");

				return function anyIC(elem){
					var attr = adapter.getAttributeValue(elem, name);
					return attr != null && regex.test(attr) && next(elem);
				};
			}

			return function any(elem){
				var attr = adapter.getAttributeValue(elem, name);
				return attr != null && attr.indexOf(value) >= 0 && next(elem);
			};
		},
		not: function(next, data){
			var name  = data.name,
				value = data.value;

			if(value === ""){
				return function notEmpty(elem){
					return !!adapter.getAttributeValue(elem, name) && next(elem);
				};
			} else if(data.ignoreCase){
				value = value.toLowerCase();

				return function notIC(elem){
					var attr = adapter.getAttributeValue(elem, name);
					return attr != null && attr.toLowerCase() !== value && next(elem);
				};
			}

			return function not(elem){
				return adapter.getAttributeValue(elem, name) !== value && next(elem);
			};
		}
	};

	return {
		compile: function(next, data, options){
			if(options && options.strict && (
				data.ignoreCase || data.action === "not"
			)) throw new Error("Unsupported attribute selector");
			return attributeRules[data.action](next, data);
		},
		rules: attributeRules
	};
}

module.exports = factory;

},{"boolbase":63}],75:[function(require,module,exports){
/*
	compiles a selector to an executable function
*/

module.exports = compileFactory;

var parse          = require("css-what"),
	BaseFuncs      = require("boolbase"),
	sortRules      = require("./sort.js"),
	procedure      = require("./procedure.json"),
	rulesFactory   = require("./general.js"),
	pseudosFactory = require("./pseudos.js"),
	trueFunc       = BaseFuncs.trueFunc,
	falseFunc      = BaseFuncs.falseFunc;

function compileFactory(adapter){
	var Pseudos     = pseudosFactory(adapter),
		filters     = Pseudos.filters,
		Rules 			= rulesFactory(adapter, Pseudos);

	function compile(selector, options, context){
		var next = compileUnsafe(selector, options, context);
		return wrap(next);
	}

	function wrap(next){
		return function base(elem){
			return adapter.isTag(elem) && next(elem);
		};
	}

	function compileUnsafe(selector, options, context){
		var token = parse(selector, options);
		return compileToken(token, options, context);
	}

	function includesScopePseudo(t){
		return t.type === "pseudo" && (
			t.name === "scope" || (
				Array.isArray(t.data) &&
				t.data.some(function(data){
					return data.some(includesScopePseudo);
				})
			)
		);
	}

	var DESCENDANT_TOKEN = {type: "descendant"},
		FLEXIBLE_DESCENDANT_TOKEN = {type: "_flexibleDescendant"},
		SCOPE_TOKEN = {type: "pseudo", name: "scope"},
		PLACEHOLDER_ELEMENT = {};

	//CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector
	//http://www.w3.org/TR/selectors4/#absolutizing
	function absolutize(token, context){
		//TODO better check if context is document
		var hasContext = !!context && !!context.length && context.every(function(e){
			return e === PLACEHOLDER_ELEMENT || !!adapter.getParent(e);
		});


		token.forEach(function(t){
			if(t.length > 0 && isTraversal(t[0]) && t[0].type !== "descendant"){
				//don't return in else branch
			} else if(hasContext && !includesScopePseudo(t)){
				t.unshift(DESCENDANT_TOKEN);
			} else {
				return;
			}

			t.unshift(SCOPE_TOKEN);
		});
	}

	function compileToken(token, options, context){
		token = token.filter(function(t){ return t.length > 0; });

		token.forEach(sortRules);

		var isArrayContext = Array.isArray(context);

		context = (options && options.context) || context;

		if(context && !isArrayContext) context = [context];

		absolutize(token, context);

		var shouldTestNextSiblings = false;

		var query = token
			.map(function(rules){
				if(rules[0] && rules[1] && rules[0].name === "scope"){
					var ruleType = rules[1].type;
					if(isArrayContext && ruleType === "descendant") rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
					else if(ruleType === "adjacent" || ruleType === "sibling") shouldTestNextSiblings = true;
				}
				return compileRules(rules, options, context);
			})
			.reduce(reduceRules, falseFunc);

		query.shouldTestNextSiblings = shouldTestNextSiblings;

		return query;
	}

	function isTraversal(t){
		return procedure[t.type] < 0;
	}

	function compileRules(rules, options, context){
		return rules.reduce(function(func, rule){
			if(func === falseFunc) return func;
			return Rules[rule.type](func, rule, options, context);
		}, options && options.rootFunc || trueFunc);
	}

	function reduceRules(a, b){
		if(b === falseFunc || a === trueFunc){
			return a;
		}
		if(a === falseFunc || b === trueFunc){
			return b;
		}

		return function combine(elem){
			return a(elem) || b(elem);
		};
	}

	function containsTraversal(t){
		return t.some(isTraversal);
	}

	//:not, :has and :matches have to compile selectors
	//doing this in lib/pseudos.js would lead to circular dependencies,
	//so we add them here
	filters.not = function(next, token, options, context){
		var opts = {
			xmlMode: !!(options && options.xmlMode),
			strict: !!(options && options.strict)
		};

		if(opts.strict){
			if(token.length > 1 || token.some(containsTraversal)){
				throw new Error("complex selectors in :not aren't allowed in strict mode");
			}
		}

		var func = compileToken(token, opts, context);

		if(func === falseFunc) return next;
		if(func === trueFunc)  return falseFunc;

		return function(elem){
			return !func(elem) && next(elem);
		};
	};

	filters.has = function(next, token, options){
		var opts = {
			xmlMode: !!(options && options.xmlMode),
			strict: !!(options && options.strict)
		};

		//FIXME: Uses an array as a pointer to the current element (side effects)
		var context = token.some(containsTraversal) ? [PLACEHOLDER_ELEMENT] : null;

		var func = compileToken(token, opts, context);

		if(func === falseFunc) return falseFunc;
		if(func === trueFunc){
			return function(elem){
				return adapter.getChildren(elem).some(adapter.isTag) && next(elem);
			};
		}

		func = wrap(func);

		if(context){
			return function has(elem){
				return next(elem) && (
					(context[0] = elem), adapter.existsOne(func, adapter.getChildren(elem))
				);
			};
		}

		return function has(elem){
			return next(elem) && adapter.existsOne(func, adapter.getChildren(elem));
		};
	};

	filters.matches = function(next, token, options, context){
		var opts = {
			xmlMode: !!(options && options.xmlMode),
			strict: !!(options && options.strict),
			rootFunc: next
		};

		return compileToken(token, opts, context);
	};

	compile.compileToken = compileToken;
	compile.compileUnsafe = compileUnsafe;
	compile.Pseudos = Pseudos;

	return compile;
}

},{"./general.js":76,"./procedure.json":77,"./pseudos.js":78,"./sort.js":79,"boolbase":63,"css-what":80}],76:[function(require,module,exports){
var attributeFactory = require("./attributes.js");

function generalFactory(adapter, Pseudos){
	/*
		all available rules
	*/
	return {
		__proto__: null,

		attribute: attributeFactory(adapter).compile,
		pseudo: Pseudos.compile,

		//tags
		tag: function(next, data){
			var name = data.name;
			return function tag(elem){
				return adapter.getName(elem) === name && next(elem);
			};
		},

		//traversal
		descendant: function(next){
			return function descendant(elem){

				var found = false;

				while(!found && (elem = adapter.getParent(elem))){
					found = next(elem);
				}

				return found;
			};
		},
		_flexibleDescendant: function(next){
			// Include element itself, only used while querying an array
			return function descendant(elem){

				var found = next(elem);

				while(!found && (elem = adapter.getParent(elem))){
					found = next(elem);
				}

				return found;
			};
		},
		parent: function(next, data, options){
			if(options && options.strict) throw new Error("Parent selector isn't part of CSS3");

			return function parent(elem){
				return adapter.getChildren(elem).some(test);
			};

			function test(elem){
				return adapter.isTag(elem) && next(elem);
			}
		},
		child: function(next){
			return function child(elem){
				var parent = adapter.getParent(elem);
				return !!parent && next(parent);
			};
		},
		sibling: function(next){
			return function sibling(elem){
				var siblings = adapter.getSiblings(elem);

				for(var i = 0; i < siblings.length; i++){
					if(adapter.isTag(siblings[i])){
						if(siblings[i] === elem) break;
						if(next(siblings[i])) return true;
					}
				}

				return false;
			};
		},
		adjacent: function(next){
			return function adjacent(elem){
				var siblings = adapter.getSiblings(elem),
					lastElement;

				for(var i = 0; i < siblings.length; i++){
					if(adapter.isTag(siblings[i])){
						if(siblings[i] === elem) break;
						lastElement = siblings[i];
					}
				}

				return !!lastElement && next(lastElement);
			};
		},
		universal: function(next){
			return next;
		}
	};
}

module.exports = generalFactory;

},{"./attributes.js":74}],77:[function(require,module,exports){
module.exports={
  "universal": 50,
  "tag": 30,
  "attribute": 1,
  "pseudo": 0,
  "descendant": -1,
  "child": -1,
  "parent": -1,
  "sibling": -1,
  "adjacent": -1
}

},{}],78:[function(require,module,exports){
/*
	pseudo selectors

	---

	they are available in two forms:
	* filters called when the selector
	  is compiled and return a function
	  that needs to return next()
	* pseudos get called on execution
	  they need to return a boolean
*/

var getNCheck         = require("nth-check"),
	BaseFuncs         = require("boolbase"),
	attributesFactory = require("./attributes.js"),
	trueFunc          = BaseFuncs.trueFunc,
	falseFunc         = BaseFuncs.falseFunc;

function filtersFactory(adapter){
	var attributes  = attributesFactory(adapter),
		checkAttrib = attributes.rules.equals;

	//helper methods
	function equals(a, b){
		if(typeof adapter.equals === "function") return adapter.equals(a, b);

		return a === b;
	}

	function getAttribFunc(name, value){
		var data = {name: name, value: value};
		return function attribFunc(next){
			return checkAttrib(next, data);
		};
	}

	function getChildFunc(next){
		return function(elem){
			return !!adapter.getParent(elem) && next(elem);
		};
	}

	var filters = {
		contains: function(next, text){
			return function contains(elem){
				return next(elem) && adapter.getText(elem).indexOf(text) >= 0;
			};
		},
		icontains: function(next, text){
			var itext = text.toLowerCase();
			return function icontains(elem){
				return next(elem) &&
					adapter.getText(elem).toLowerCase().indexOf(itext) >= 0;
			};
		},

		//location specific methods
		"nth-child": function(next, rule){
			var func = getNCheck(rule);

			if(func === falseFunc) return func;
			if(func === trueFunc)  return getChildFunc(next);

			return function nthChild(elem){
				var siblings = adapter.getSiblings(elem);

				for(var i = 0, pos = 0; i < siblings.length; i++){
					if(adapter.isTag(siblings[i])){
						if(siblings[i] === elem) break;
						else pos++;
					}
				}

				return func(pos) && next(elem);
			};
		},
		"nth-last-child": function(next, rule){
			var func = getNCheck(rule);

			if(func === falseFunc) return func;
			if(func === trueFunc)  return getChildFunc(next);

			return function nthLastChild(elem){
				var siblings = adapter.getSiblings(elem);

				for(var pos = 0, i = siblings.length - 1; i >= 0; i--){
					if(adapter.isTag(siblings[i])){
						if(siblings[i] === elem) break;
						else pos++;
					}
				}

				return func(pos) && next(elem);
			};
		},
		"nth-of-type": function(next, rule){
			var func = getNCheck(rule);

			if(func === falseFunc) return func;
			if(func === trueFunc)  return getChildFunc(next);

			return function nthOfType(elem){
				var siblings = adapter.getSiblings(elem);

				for(var pos = 0, i = 0; i < siblings.length; i++){
					if(adapter.isTag(siblings[i])){
						if(siblings[i] === elem) break;
						if(adapter.getName(siblings[i]) === adapter.getName(elem)) pos++;
					}
				}

				return func(pos) && next(elem);
			};
		},
		"nth-last-of-type": function(next, rule){
			var func = getNCheck(rule);

			if(func === falseFunc) return func;
			if(func === trueFunc)  return getChildFunc(next);

			return function nthLastOfType(elem){
				var siblings = adapter.getSiblings(elem);

				for(var pos = 0, i = siblings.length - 1; i >= 0; i--){
					if(adapter.isTag(siblings[i])){
						if(siblings[i] === elem) break;
						if(adapter.getName(siblings[i]) === adapter.getName(elem)) pos++;
					}
				}

				return func(pos) && next(elem);
			};
		},

		//TODO determine the actual root element
		root: function(next){
			return function(elem){
				return !adapter.getParent(elem) && next(elem);
			};
		},

		scope: function(next, rule, options, context){
			if(!context || context.length === 0){
				//equivalent to :root
				return filters.root(next);
			}

			if(context.length === 1){
				//NOTE: can't be unpacked, as :has uses this for side-effects
				return function(elem){
					return equals(context[0], elem) && next(elem);
				};
			}

			return function(elem){
				return context.indexOf(elem) >= 0 && next(elem);
			};
		},

		//jQuery extensions (others follow as pseudos)
		checkbox: getAttribFunc("type", "checkbox"),
		file: getAttribFunc("type", "file"),
		password: getAttribFunc("type", "password"),
		radio: getAttribFunc("type", "radio"),
		reset: getAttribFunc("type", "reset"),
		image: getAttribFunc("type", "image"),
		submit: getAttribFunc("type", "submit")
	};
	return filters;
}

function pseudosFactory(adapter){
	//helper methods
	function getFirstElement(elems){
		for(var i = 0; elems && i < elems.length; i++){
			if(adapter.isTag(elems[i])) return elems[i];
		}
	}

	//while filters are precompiled, pseudos get called when they are needed
	var pseudos = {
		empty: function(elem){
			return !adapter.getChildren(elem).some(function(elem){
				return adapter.isTag(elem) || elem.type === "text";
			});
		},

		"first-child": function(elem){
			return getFirstElement(adapter.getSiblings(elem)) === elem;
		},
		"last-child": function(elem){
			var siblings = adapter.getSiblings(elem);

			for(var i = siblings.length - 1; i >= 0; i--){
				if(siblings[i] === elem) return true;
				if(adapter.isTag(siblings[i])) break;
			}

			return false;
		},
		"first-of-type": function(elem){
			var siblings = adapter.getSiblings(elem);

			for(var i = 0; i < siblings.length; i++){
				if(adapter.isTag(siblings[i])){
					if(siblings[i] === elem) return true;
					if(adapter.getName(siblings[i]) === adapter.getName(elem)) break;
				}
			}

			return false;
		},
		"last-of-type": function(elem){
			var siblings = adapter.getSiblings(elem);

			for(var i = siblings.length - 1; i >= 0; i--){
				if(adapter.isTag(siblings[i])){
					if(siblings[i] === elem) return true;
					if(adapter.getName(siblings[i]) === adapter.getName(elem)) break;
				}
			}

			return false;
		},
		"only-of-type": function(elem){
			var siblings = adapter.getSiblings(elem);

			for(var i = 0, j = siblings.length; i < j; i++){
				if(adapter.isTag(siblings[i])){
					if(siblings[i] === elem) continue;
					if(adapter.getName(siblings[i]) === adapter.getName(elem)) return false;
				}
			}

			return true;
		},
		"only-child": function(elem){
			var siblings = adapter.getSiblings(elem);

			for(var i = 0; i < siblings.length; i++){
				if(adapter.isTag(siblings[i]) && siblings[i] !== elem) return false;
			}

			return true;
		},

		//:matches(a, area, link)[href]
		link: function(elem){
			return adapter.hasAttrib(elem, "href");
		},
		visited: falseFunc, //seems to be a valid implementation
		//TODO: :any-link once the name is finalized (as an alias of :link)

		//forms
		//to consider: :target

		//:matches([selected], select:not([multiple]):not(> option[selected]) > option:first-of-type)
		selected: function(elem){
			if(adapter.hasAttrib(elem, "selected")) return true;
			else if(adapter.getName(elem) !== "option") return false;

			//the first <option> in a <select> is also selected
			var parent = adapter.getParent(elem);

			if(
				!parent ||
				adapter.getName(parent) !== "select" ||
				adapter.hasAttrib(parent, "multiple")
			) return false;

			var siblings = adapter.getChildren(parent),
				sawElem  = false;

			for(var i = 0; i < siblings.length; i++){
				if(adapter.isTag(siblings[i])){
					if(siblings[i] === elem){
						sawElem = true;
					} else if(!sawElem){
						return false;
					} else if(adapter.hasAttrib(siblings[i], "selected")){
						return false;
					}
				}
			}

			return sawElem;
		},
		//https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
		//:matches(
		//  :matches(button, input, select, textarea, menuitem, optgroup, option)[disabled],
		//  optgroup[disabled] > option),
		// fieldset[disabled] * //TODO not child of first <legend>
		//)
		disabled: function(elem){
			return adapter.hasAttrib(elem, "disabled");
		},
		enabled: function(elem){
			return !adapter.hasAttrib(elem, "disabled");
		},
		//:matches(:matches(:radio, :checkbox)[checked], :selected) (TODO menuitem)
		checked: function(elem){
			return adapter.hasAttrib(elem, "checked") || pseudos.selected(elem);
		},
		//:matches(input, select, textarea)[required]
		required: function(elem){
			return adapter.hasAttrib(elem, "required");
		},
		//:matches(input, select, textarea):not([required])
		optional: function(elem){
			return !adapter.hasAttrib(elem, "required");
		},

		//jQuery extensions

		//:not(:empty)
		parent: function(elem){
			return !pseudos.empty(elem);
		},
		//:matches(h1, h2, h3, h4, h5, h6)
		header: function(elem){
			var name = adapter.getName(elem);
			return name === "h1" ||
					name === "h2" ||
					name === "h3" ||
					name === "h4" ||
					name === "h5" ||
					name === "h6";
		},

		//:matches(button, input[type=button])
		button: function(elem){
			var name = adapter.getName(elem);
			return name === "button" ||
					name === "input" &&
					adapter.getAttributeValue(elem, "type") === "button";
		},
		//:matches(input, textarea, select, button)
		input: function(elem){
			var name = adapter.getName(elem);
			return name === "input" ||
					name === "textarea" ||
					name === "select" ||
					name === "button";
		},
		//input:matches(:not([type!='']), [type='text' i])
		text: function(elem){
			var attr;
			return adapter.getName(elem) === "input" && (
				!(attr = adapter.getAttributeValue(elem, "type")) ||
				attr.toLowerCase() === "text"
			);
		}
	};

	return pseudos;
}

function verifyArgs(func, name, subselect){
	if(subselect === null){
		if(func.length > 1 && name !== "scope"){
			throw new Error("pseudo-selector :" + name + " requires an argument");
		}
	} else {
		if(func.length === 1){
			throw new Error("pseudo-selector :" + name + " doesn't have any arguments");
		}
	}
}

//FIXME this feels hacky
var re_CSS3 = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;

function factory(adapter){
	var pseudos = pseudosFactory(adapter);
	var filters = filtersFactory(adapter);

	return {
		compile: function(next, data, options, context){
			var name = data.name,
				subselect = data.data;

			if(options && options.strict && !re_CSS3.test(name)){
				throw new Error(":" + name + " isn't part of CSS3");
			}

			if(typeof filters[name] === "function"){
				verifyArgs(filters[name], name,  subselect);
				return filters[name](next, subselect, options, context);
			} else if(typeof pseudos[name] === "function"){
				var func = pseudos[name];
				verifyArgs(func, name, subselect);

				if(next === trueFunc) return func;

				return function pseudoArgs(elem){
					return func(elem, subselect) && next(elem);
				};
			} else {
				throw new Error("unmatched pseudo-class :" + name);
			}
		},
		filters: filters,
		pseudos: pseudos
	};
}

module.exports = factory;

},{"./attributes.js":74,"boolbase":63,"nth-check":176}],79:[function(require,module,exports){
module.exports = sortByProcedure;

/*
	sort the parts of the passed selector,
	as there is potential for optimization
	(some types of selectors are faster than others)
*/

var procedure = require("./procedure.json");

var attributes = {
	__proto__: null,
	exists: 10,
	equals: 8,
	not: 7,
	start: 6,
	end: 6,
	any: 5,
	hyphen: 4,
	element: 4
};

function sortByProcedure(arr){
	var procs = arr.map(getProcedure);
	for(var i = 1; i < arr.length; i++){
		var procNew = procs[i];

		if(procNew < 0) continue;

		for(var j = i - 1; j >= 0 && procNew < procs[j]; j--){
			var token = arr[j + 1];
			arr[j + 1] = arr[j];
			arr[j] = token;
			procs[j + 1] = procs[j];
			procs[j] = procNew;
		}
	}
}

function getProcedure(token){
	var proc = procedure[token.type];

	if(proc === procedure.attribute){
		proc = attributes[token.action];

		if(proc === attributes.equals && token.name === "id"){
			//prefer ID selectors (eg. #ID)
			proc = 9;
		}

		if(token.ignoreCase){
			//ignoreCase adds some overhead, prefer "normal" token
			//this is a binary operation, to ensure it's still an int
			proc >>= 1;
		}
	} else if(proc === procedure.pseudo){
		if(!token.data){
			proc = 3;
		} else if(token.name === "has" || token.name === "contains"){
			proc = 0; //expensive in any case
		} else if(token.name === "matches" || token.name === "not"){
			proc = 0;
			for(var i = 0; i < token.data.length; i++){
				//TODO better handling of complex selectors
				if(token.data[i].length !== 1) continue;
				var cur = getProcedure(token.data[i][0]);
				//avoid executing :has or :contains
				if(cur === 0){
					proc = 0;
					break;
				}
				if(cur > proc) proc = cur;
			}
			if(token.data.length > 1 && proc > 0) proc -= 1;
		} else {
			proc = 1;
		}
	}
	return proc;
}

},{"./procedure.json":77}],80:[function(require,module,exports){
"use strict";

module.exports = parse;

var re_name = /^(?:\\.|[\w\-\u00c0-\uFFFF])+/,
    re_escape = /\\([\da-f]{1,6}\s?|(\s)|.)/ig,
    //modified version of https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L87
    re_attr = /^\s*((?:\\.|[\w\u00c0-\uFFFF\-])+)\s*(?:(\S?)=\s*(?:(['"])(.*?)\3|(#?(?:\\.|[\w\u00c0-\uFFFF\-])*)|)|)\s*(i)?\]/;

var actionTypes = {
	__proto__: null,
	"undefined": "exists",
	"":  "equals",
	"~": "element",
	"^": "start",
	"$": "end",
	"*": "any",
	"!": "not",
	"|": "hyphen"
};

var simpleSelectors = {
	__proto__: null,
	">": "child",
	"<": "parent",
	"~": "sibling",
	"+": "adjacent"
};

var attribSelectors = {
	__proto__: null,
	"#": ["id", "equals"],
	".": ["class", "element"]
};

//pseudos, whose data-property is parsed as well
var unpackPseudos = {
	__proto__: null,
	"has": true,
	"not": true,
	"matches": true
};

var stripQuotesFromPseudos = {
	__proto__: null,
	"contains": true,
	"icontains": true
};

var quotes = {
	__proto__: null,
	"\"": true,
	"'": true
};

//unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L139
function funescape( _, escaped, escapedWhitespace ) {
	var high = "0x" + escaped - 0x10000;
	// NaN means non-codepoint
	// Support: Firefox
	// Workaround erroneous numeric interpretation of +"0x"
	return high !== high || escapedWhitespace ?
		escaped :
		// BMP codepoint
		high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			// Supplemental Plane codepoint (surrogate pair)
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
}

function unescapeCSS(str){
	return str.replace(re_escape, funescape);
}

function isWhitespace(c){
	return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}

function parse(selector, options){
	var subselects = [];

	selector = parseSelector(subselects, selector + "", options);

	if(selector !== ""){
		throw new SyntaxError("Unmatched selector: " + selector);
	}

	return subselects;
}

function parseSelector(subselects, selector, options){
	var tokens = [],
		sawWS = false,
		data, firstChar, name, quot;

	function getName(){
		var sub = selector.match(re_name)[0];
		selector = selector.substr(sub.length);
		return unescapeCSS(sub);
	}

	function stripWhitespace(start){
		while(isWhitespace(selector.charAt(start))) start++;
		selector = selector.substr(start);
	}

	stripWhitespace(0);

	while(selector !== ""){
		firstChar = selector.charAt(0);

		if(isWhitespace(firstChar)){
			sawWS = true;
			stripWhitespace(1);
		} else if(firstChar in simpleSelectors){
			tokens.push({type: simpleSelectors[firstChar]});
			sawWS = false;

			stripWhitespace(1);
		} else if(firstChar === ","){
			if(tokens.length === 0){
				throw new SyntaxError("empty sub-selector");
			}
			subselects.push(tokens);
			tokens = [];
			sawWS = false;
			stripWhitespace(1);
		} else {
			if(sawWS){
				if(tokens.length > 0){
					tokens.push({type: "descendant"});
				}
				sawWS = false;
			}

			if(firstChar === "*"){
				selector = selector.substr(1);
				tokens.push({type: "universal"});
			} else if(firstChar in attribSelectors){
				selector = selector.substr(1);
				tokens.push({
					type: "attribute",
					name: attribSelectors[firstChar][0],
					action: attribSelectors[firstChar][1],
					value: getName(),
					ignoreCase: false
				});
			} else if(firstChar === "["){
				selector = selector.substr(1);
				data = selector.match(re_attr);
				if(!data){
					throw new SyntaxError("Malformed attribute selector: " + selector);
				}
				selector = selector.substr(data[0].length);
				name = unescapeCSS(data[1]);

				if(
					!options || (
						"lowerCaseAttributeNames" in options ?
							options.lowerCaseAttributeNames :
							!options.xmlMode
					)
				){
					name = name.toLowerCase();
				}

				tokens.push({
					type: "attribute",
					name: name,
					action: actionTypes[data[2]],
					value: unescapeCSS(data[4] || data[5] || ""),
					ignoreCase: !!data[6]
				});

			} else if(firstChar === ":"){
				if(selector.charAt(1) === ":"){
					selector = selector.substr(2);
					tokens.push({type: "pseudo-element", name: getName().toLowerCase()});
					continue;
				}

				selector = selector.substr(1);

				name = getName().toLowerCase();
				data = null;

				if(selector.charAt(0) === "("){
					if(name in unpackPseudos){
						quot = selector.charAt(1);
						var quoted = quot in quotes;

						selector = selector.substr(quoted + 1);

						data = [];
						selector = parseSelector(data, selector, options);

						if(quoted){
							if(selector.charAt(0) !== quot){
								throw new SyntaxError("unmatched quotes in :" + name);
							} else {
								selector = selector.substr(1);
							}
						}

						if(selector.charAt(0) !== ")"){
							throw new SyntaxError("missing closing parenthesis in :" + name + " " + selector);
						}

						selector = selector.substr(1);
					} else {
						var pos = 1, counter = 1;

						for(; counter > 0 && pos < selector.length; pos++){
							if(selector.charAt(pos) === "(") counter++;
							else if(selector.charAt(pos) === ")") counter--;
						}

						if(counter){
							throw new SyntaxError("parenthesis not matched");
						}

						data = selector.substr(1, pos - 2);
						selector = selector.substr(pos);

						if(name in stripQuotesFromPseudos){
							quot = data.charAt(0);

							if(quot === data.slice(-1) && quot in quotes){
								data = data.slice(1, -1);
							}

							data = unescapeCSS(data);
						}
					}
				}

				tokens.push({type: "pseudo", name: name, data: data});
			} else if(re_name.test(selector)){
				name = getName();

				if(!options || ("lowerCaseTags" in options ? options.lowerCaseTags : !options.xmlMode)){
					name = name.toLowerCase();
				}

				tokens.push({type: "tag", name: name});
			} else {
				if(tokens.length && tokens[tokens.length - 1].type === "descendant"){
					tokens.pop();
				}
				addToken(subselects, tokens);
				return selector;
			}
		}
	}

	addToken(subselects, tokens);

	return selector;
}

function addToken(subselects, tokens){
	if(subselects.length > 0 && tokens.length === 0){
		throw new SyntaxError("empty sub-selector");
	}

	subselects.push(tokens);
}

},{}],81:[function(require,module,exports){
(function (global){

var NativeCustomEvent = global.CustomEvent;

function useNative () {
  try {
    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });
    return  'cat' === p.type && 'bar' === p.detail.foo;
  } catch (e) {
  }
  return false;
}

/**
 * Cross-browser `CustomEvent` constructor.
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
 *
 * @public
 */

module.exports = useNative() ? NativeCustomEvent :

// IE >= 9
'function' === typeof document.createEvent ? function CustomEvent (type, params) {
  var e = document.createEvent('CustomEvent');
  if (params) {
    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
  } else {
    e.initCustomEvent(type, false, false, void 0);
  }
  return e;
} :

// IE <= 8
function CustomEvent (type, params) {
  var e = document.createEventObject();
  e.type = type;
  if (params) {
    e.bubbles = Boolean(params.bubbles);
    e.cancelable = Boolean(params.cancelable);
    e.detail = params.detail;
  } else {
    e.bubbles = false;
    e.cancelable = false;
    e.detail = void 0;
  }
  return e;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],82:[function(require,module,exports){
/*
  Module dependencies
*/
var ElementType = require('domelementtype');
var entities = require('entities');

/*
  Boolean Attributes
*/
var booleanAttributes = {
  __proto__: null,
  allowfullscreen: true,
  async: true,
  autofocus: true,
  autoplay: true,
  checked: true,
  controls: true,
  default: true,
  defer: true,
  disabled: true,
  hidden: true,
  ismap: true,
  loop: true,
  multiple: true,
  muted: true,
  open: true,
  readonly: true,
  required: true,
  reversed: true,
  scoped: true,
  seamless: true,
  selected: true,
  typemustmatch: true
};

var unencodedElements = {
  __proto__: null,
  style: true,
  script: true,
  xmp: true,
  iframe: true,
  noembed: true,
  noframes: true,
  plaintext: true,
  noscript: true
};

/*
  Format attributes
*/
function formatAttrs(attributes, opts) {
  if (!attributes) return;

  var output = '',
      value;

  // Loop through the attributes
  for (var key in attributes) {
    value = attributes[key];
    if (output) {
      output += ' ';
    }

    if (!value && booleanAttributes[key]) {
      output += key;
    } else {
      output += key + '="' + (opts.decodeEntities ? entities.encodeXML(value) : value) + '"';
    }
  }

  return output;
}

/*
  Self-enclosing tags (stolen from node-htmlparser)
*/
var singleTag = {
  __proto__: null,
  area: true,
  base: true,
  basefont: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  isindex: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true,
};


var render = module.exports = function(dom, opts) {
  if (!Array.isArray(dom) && !dom.cheerio) dom = [dom];
  opts = opts || {};

  var output = '';

  for(var i = 0; i < dom.length; i++){
    var elem = dom[i];

    if (elem.type === 'root')
      output += render(elem.children, opts);
    else if (ElementType.isTag(elem))
      output += renderTag(elem, opts);
    else if (elem.type === ElementType.Directive)
      output += renderDirective(elem);
    else if (elem.type === ElementType.Comment)
      output += renderComment(elem);
    else if (elem.type === ElementType.CDATA)
      output += renderCdata(elem);
    else
      output += renderText(elem, opts);
  }

  return output;
};

function renderTag(elem, opts) {
  // Handle SVG
  if (elem.name === "svg") opts = {decodeEntities: opts.decodeEntities, xmlMode: true};

  var tag = '<' + elem.name,
      attribs = formatAttrs(elem.attribs, opts);

  if (attribs) {
    tag += ' ' + attribs;
  }

  if (
    opts.xmlMode
    && (!elem.children || elem.children.length === 0)
  ) {
    tag += '/>';
  } else {
    tag += '>';
    if (elem.children) {
      tag += render(elem.children, opts);
    }

    if (!singleTag[elem.name] || opts.xmlMode) {
      tag += '</' + elem.name + '>';
    }
  }

  return tag;
}

function renderDirective(elem) {
  return '<' + elem.data + '>';
}

function renderText(elem, opts) {
  var data = elem.data || '';

  // if entities weren't decoded, no need to encode them back
  if (opts.decodeEntities && !(elem.parent && elem.parent.name in unencodedElements)) {
    data = entities.encodeXML(data);
  }

  return data;
}

function renderCdata(elem) {
  return '<![CDATA[' + elem.children[0].data + ']]>';
}

function renderComment(elem) {
  return '<!--' + elem.data + '-->';
}

},{"domelementtype":83,"entities":97}],83:[function(require,module,exports){
//Types of elements found in the DOM
module.exports = {
	Text: "text", //Text
	Directive: "directive", //<? ... ?>
	Comment: "comment", //<!-- ... -->
	Script: "script", //<script> tags
	Style: "style", //<style> tags
	Tag: "tag", //Any tag
	CDATA: "cdata", //<![CDATA[ ... ]]>

	isTag: function(elem){
		return elem.type === "tag" || elem.type === "script" || elem.type === "style";
	}
};
},{}],84:[function(require,module,exports){
//Types of elements found in the DOM
module.exports = {
	Text: "text", //Text
	Directive: "directive", //<? ... ?>
	Comment: "comment", //<!-- ... -->
	Script: "script", //<script> tags
	Style: "style", //<style> tags
	Tag: "tag", //Any tag
	CDATA: "cdata", //<![CDATA[ ... ]]>
	Doctype: "doctype",

	isTag: function(elem){
		return elem.type === "tag" || elem.type === "script" || elem.type === "style";
	}
};

},{}],85:[function(require,module,exports){
var ElementType = require("domelementtype");

var re_whitespace = /\s+/g;
var NodePrototype = require("./lib/node");
var ElementPrototype = require("./lib/element");

function DomHandler(callback, options, elementCB){
	if(typeof callback === "object"){
		elementCB = options;
		options = callback;
		callback = null;
	} else if(typeof options === "function"){
		elementCB = options;
		options = defaultOpts;
	}
	this._callback = callback;
	this._options = options || defaultOpts;
	this._elementCB = elementCB;
	this.dom = [];
	this._done = false;
	this._tagStack = [];
	this._parser = this._parser || null;
}

//default options
var defaultOpts = {
	normalizeWhitespace: false, //Replace all whitespace with single spaces
	withStartIndices: false, //Add startIndex properties to nodes
};

DomHandler.prototype.onparserinit = function(parser){
	this._parser = parser;
};

//Resets the handler back to starting state
DomHandler.prototype.onreset = function(){
	DomHandler.call(this, this._callback, this._options, this._elementCB);
};

//Signals the handler that parsing is done
DomHandler.prototype.onend = function(){
	if(this._done) return;
	this._done = true;
	this._parser = null;
	this._handleCallback(null);
};

DomHandler.prototype._handleCallback =
DomHandler.prototype.onerror = function(error){
	if(typeof this._callback === "function"){
		this._callback(error, this.dom);
	} else {
		if(error) throw error;
	}
};

DomHandler.prototype.onclosetag = function(){
	//if(this._tagStack.pop().name !== name) this._handleCallback(Error("Tagname didn't match!"));
	var elem = this._tagStack.pop();
	if(this._elementCB) this._elementCB(elem);
};

DomHandler.prototype._addDomElement = function(element){
	var parent = this._tagStack[this._tagStack.length - 1];
	var siblings = parent ? parent.children : this.dom;
	var previousSibling = siblings[siblings.length - 1];

	element.next = null;

	if(this._options.withStartIndices){
		element.startIndex = this._parser.startIndex;
	}

	if (this._options.withDomLvl1) {
		element.__proto__ = element.type === "tag" ? ElementPrototype : NodePrototype;
	}

	if(previousSibling){
		element.prev = previousSibling;
		previousSibling.next = element;
	} else {
		element.prev = null;
	}

	siblings.push(element);
	element.parent = parent || null;
};

DomHandler.prototype.onopentag = function(name, attribs){
	var element = {
		type: name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag,
		name: name,
		attribs: attribs,
		children: []
	};

	this._addDomElement(element);

	this._tagStack.push(element);
};

DomHandler.prototype.ontext = function(data){
	//the ignoreWhitespace is officially dropped, but for now,
	//it's an alias for normalizeWhitespace
	var normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace;

	var lastTag;

	if(!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length-1]).type === ElementType.Text){
		if(normalize){
			lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
		} else {
			lastTag.data += data;
		}
	} else {
		if(
			this._tagStack.length &&
			(lastTag = this._tagStack[this._tagStack.length - 1]) &&
			(lastTag = lastTag.children[lastTag.children.length - 1]) &&
			lastTag.type === ElementType.Text
		){
			if(normalize){
				lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
			} else {
				lastTag.data += data;
			}
		} else {
			if(normalize){
				data = data.replace(re_whitespace, " ");
			}

			this._addDomElement({
				data: data,
				type: ElementType.Text
			});
		}
	}
};

DomHandler.prototype.oncomment = function(data){
	var lastTag = this._tagStack[this._tagStack.length - 1];

	if(lastTag && lastTag.type === ElementType.Comment){
		lastTag.data += data;
		return;
	}

	var element = {
		data: data,
		type: ElementType.Comment
	};

	this._addDomElement(element);
	this._tagStack.push(element);
};

DomHandler.prototype.oncdatastart = function(){
	var element = {
		children: [{
			data: "",
			type: ElementType.Text
		}],
		type: ElementType.CDATA
	};

	this._addDomElement(element);
	this._tagStack.push(element);
};

DomHandler.prototype.oncommentend = DomHandler.prototype.oncdataend = function(){
	this._tagStack.pop();
};

DomHandler.prototype.onprocessinginstruction = function(name, data){
	this._addDomElement({
		name: name,
		data: data,
		type: ElementType.Directive
	});
};

module.exports = DomHandler;

},{"./lib/element":86,"./lib/node":87,"domelementtype":84}],86:[function(require,module,exports){
// DOM-Level-1-compliant structure
var NodePrototype = require('./node');
var ElementPrototype = module.exports = Object.create(NodePrototype);

var domLvl1 = {
	tagName: "name"
};

Object.keys(domLvl1).forEach(function(key) {
	var shorthand = domLvl1[key];
	Object.defineProperty(ElementPrototype, key, {
		get: function() {
			return this[shorthand] || null;
		},
		set: function(val) {
			this[shorthand] = val;
			return val;
		}
	});
});

},{"./node":87}],87:[function(require,module,exports){
// This object will be used as the prototype for Nodes when creating a
// DOM-Level-1-compliant structure.
var NodePrototype = module.exports = {
	get firstChild() {
		var children = this.children;
		return children && children[0] || null;
	},
	get lastChild() {
		var children = this.children;
		return children && children[children.length - 1] || null;
	},
	get nodeType() {
		return nodeTypes[this.type] || nodeTypes.element;
	}
};

var domLvl1 = {
	tagName: "name",
	childNodes: "children",
	parentNode: "parent",
	previousSibling: "prev",
	nextSibling: "next",
	nodeValue: "data"
};

var nodeTypes = {
	element: 1,
	text: 3,
	cdata: 4,
	comment: 8
};

Object.keys(domLvl1).forEach(function(key) {
	var shorthand = domLvl1[key];
	Object.defineProperty(NodePrototype, key, {
		get: function() {
			return this[shorthand] || null;
		},
		set: function(val) {
			this[shorthand] = val;
			return val;
		}
	});
});

},{}],88:[function(require,module,exports){
var DomUtils = module.exports;

[
	require("./lib/stringify"),
	require("./lib/traversal"),
	require("./lib/manipulation"),
	require("./lib/querying"),
	require("./lib/legacy"),
	require("./lib/helpers")
].forEach(function(ext){
	Object.keys(ext).forEach(function(key){
		DomUtils[key] = ext[key].bind(DomUtils);
	});
});

},{"./lib/helpers":89,"./lib/legacy":90,"./lib/manipulation":91,"./lib/querying":92,"./lib/stringify":93,"./lib/traversal":94}],89:[function(require,module,exports){
// removeSubsets
// Given an array of nodes, remove any member that is contained by another.
exports.removeSubsets = function(nodes) {
	var idx = nodes.length, node, ancestor, replace;

	// Check if each node (or one of its ancestors) is already contained in the
	// array.
	while (--idx > -1) {
		node = ancestor = nodes[idx];

		// Temporarily remove the node under consideration
		nodes[idx] = null;
		replace = true;

		while (ancestor) {
			if (nodes.indexOf(ancestor) > -1) {
				replace = false;
				nodes.splice(idx, 1);
				break;
			}
			ancestor = ancestor.parent;
		}

		// If the node has been found to be unique, re-insert it.
		if (replace) {
			nodes[idx] = node;
		}
	}

	return nodes;
};

// Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition
var POSITION = {
	DISCONNECTED: 1,
	PRECEDING: 2,
	FOLLOWING: 4,
	CONTAINS: 8,
	CONTAINED_BY: 16
};

// Compare the position of one node against another node in any other document.
// The return value is a bitmask with the following values:
//
// document order:
// > There is an ordering, document order, defined on all the nodes in the
// > document corresponding to the order in which the first character of the
// > XML representation of each node occurs in the XML representation of the
// > document after expansion of general entities. Thus, the document element
// > node will be the first node. Element nodes occur before their children.
// > Thus, document order orders element nodes in order of the occurrence of
// > their start-tag in the XML (after expansion of entities). The attribute
// > nodes of an element occur after the element and before its children. The
// > relative order of attribute nodes is implementation-dependent./
// Source:
// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
//
// @argument {Node} nodaA The first node to use in the comparison
// @argument {Node} nodeB The second node to use in the comparison
//
// @return {Number} A bitmask describing the input nodes' relative position.
//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
//         a description of these values.
var comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {
	var aParents = [];
	var bParents = [];
	var current, sharedParent, siblings, aSibling, bSibling, idx;

	if (nodeA === nodeB) {
		return 0;
	}

	current = nodeA;
	while (current) {
		aParents.unshift(current);
		current = current.parent;
	}
	current = nodeB;
	while (current) {
		bParents.unshift(current);
		current = current.parent;
	}

	idx = 0;
	while (aParents[idx] === bParents[idx]) {
		idx++;
	}

	if (idx === 0) {
		return POSITION.DISCONNECTED;
	}

	sharedParent = aParents[idx - 1];
	siblings = sharedParent.children;
	aSibling = aParents[idx];
	bSibling = bParents[idx];

	if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
		if (sharedParent === nodeB) {
			return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
		}
		return POSITION.FOLLOWING;
	} else {
		if (sharedParent === nodeA) {
			return POSITION.PRECEDING | POSITION.CONTAINS;
		}
		return POSITION.PRECEDING;
	}
};

// Sort an array of nodes based on their relative position in the document and
// remove any duplicate nodes. If the array contains nodes that do not belong
// to the same document, sort order is unspecified.
//
// @argument {Array} nodes Array of DOM nodes
//
// @returns {Array} collection of unique nodes, sorted in document order
exports.uniqueSort = function(nodes) {
	var idx = nodes.length, node, position;

	nodes = nodes.slice();

	while (--idx > -1) {
		node = nodes[idx];
		position = nodes.indexOf(node);
		if (position > -1 && position < idx) {
			nodes.splice(idx, 1);
		}
	}
	nodes.sort(function(a, b) {
		var relative = comparePos(a, b);
		if (relative & POSITION.PRECEDING) {
			return -1;
		} else if (relative & POSITION.FOLLOWING) {
			return 1;
		}
		return 0;
	});

	return nodes;
};

},{}],90:[function(require,module,exports){
var ElementType = require("domelementtype");
var isTag = exports.isTag = ElementType.isTag;

exports.testElement = function(options, element){
	for(var key in options){
		if(!options.hasOwnProperty(key));
		else if(key === "tag_name"){
			if(!isTag(element) || !options.tag_name(element.name)){
				return false;
			}
		} else if(key === "tag_type"){
			if(!options.tag_type(element.type)) return false;
		} else if(key === "tag_contains"){
			if(isTag(element) || !options.tag_contains(element.data)){
				return false;
			}
		} else if(!element.attribs || !options[key](element.attribs[key])){
			return false;
		}
	}
	return true;
};

var Checks = {
	tag_name: function(name){
		if(typeof name === "function"){
			return function(elem){ return isTag(elem) && name(elem.name); };
		} else if(name === "*"){
			return isTag;
		} else {
			return function(elem){ return isTag(elem) && elem.name === name; };
		}
	},
	tag_type: function(type){
		if(typeof type === "function"){
			return function(elem){ return type(elem.type); };
		} else {
			return function(elem){ return elem.type === type; };
		}
	},
	tag_contains: function(data){
		if(typeof data === "function"){
			return function(elem){ return !isTag(elem) && data(elem.data); };
		} else {
			return function(elem){ return !isTag(elem) && elem.data === data; };
		}
	}
};

function getAttribCheck(attrib, value){
	if(typeof value === "function"){
		return function(elem){ return elem.attribs && value(elem.attribs[attrib]); };
	} else {
		return function(elem){ return elem.attribs && elem.attribs[attrib] === value; };
	}
}

function combineFuncs(a, b){
	return function(elem){
		return a(elem) || b(elem);
	};
}

exports.getElements = function(options, element, recurse, limit){
	var funcs = Object.keys(options).map(function(key){
		var value = options[key];
		return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
	});

	return funcs.length === 0 ? [] : this.filter(
		funcs.reduce(combineFuncs),
		element, recurse, limit
	);
};

exports.getElementById = function(id, element, recurse){
	if(!Array.isArray(element)) element = [element];
	return this.findOne(getAttribCheck("id", id), element, recurse !== false);
};

exports.getElementsByTagName = function(name, element, recurse, limit){
	return this.filter(Checks.tag_name(name), element, recurse, limit);
};

exports.getElementsByTagType = function(type, element, recurse, limit){
	return this.filter(Checks.tag_type(type), element, recurse, limit);
};

},{"domelementtype":84}],91:[function(require,module,exports){
exports.removeElement = function(elem){
	if(elem.prev) elem.prev.next = elem.next;
	if(elem.next) elem.next.prev = elem.prev;

	if(elem.parent){
		var childs = elem.parent.children;
		childs.splice(childs.lastIndexOf(elem), 1);
	}
};

exports.replaceElement = function(elem, replacement){
	var prev = replacement.prev = elem.prev;
	if(prev){
		prev.next = replacement;
	}

	var next = replacement.next = elem.next;
	if(next){
		next.prev = replacement;
	}

	var parent = replacement.parent = elem.parent;
	if(parent){
		var childs = parent.children;
		childs[childs.lastIndexOf(elem)] = replacement;
	}
};

exports.appendChild = function(elem, child){
	child.parent = elem;

	if(elem.children.push(child) !== 1){
		var sibling = elem.children[elem.children.length - 2];
		sibling.next = child;
		child.prev = sibling;
		child.next = null;
	}
};

exports.append = function(elem, next){
	var parent = elem.parent,
		currNext = elem.next;

	next.next = currNext;
	next.prev = elem;
	elem.next = next;
	next.parent = parent;

	if(currNext){
		currNext.prev = next;
		if(parent){
			var childs = parent.children;
			childs.splice(childs.lastIndexOf(currNext), 0, next);
		}
	} else if(parent){
		parent.children.push(next);
	}
};

exports.prepend = function(elem, prev){
	var parent = elem.parent;
	if(parent){
		var childs = parent.children;
		childs.splice(childs.lastIndexOf(elem), 0, prev);
	}

	if(elem.prev){
		elem.prev.next = prev;
	}
	
	prev.parent = parent;
	prev.prev = elem.prev;
	prev.next = elem;
	elem.prev = prev;
};



},{}],92:[function(require,module,exports){
var isTag = require("domelementtype").isTag;

module.exports = {
	filter: filter,
	find: find,
	findOneChild: findOneChild,
	findOne: findOne,
	existsOne: existsOne,
	findAll: findAll
};

function filter(test, element, recurse, limit){
	if(!Array.isArray(element)) element = [element];

	if(typeof limit !== "number" || !isFinite(limit)){
		limit = Infinity;
	}
	return find(test, element, recurse !== false, limit);
}

function find(test, elems, recurse, limit){
	var result = [], childs;

	for(var i = 0, j = elems.length; i < j; i++){
		if(test(elems[i])){
			result.push(elems[i]);
			if(--limit <= 0) break;
		}

		childs = elems[i].children;
		if(recurse && childs && childs.length > 0){
			childs = find(test, childs, recurse, limit);
			result = result.concat(childs);
			limit -= childs.length;
			if(limit <= 0) break;
		}
	}

	return result;
}

function findOneChild(test, elems){
	for(var i = 0, l = elems.length; i < l; i++){
		if(test(elems[i])) return elems[i];
	}

	return null;
}

function findOne(test, elems){
	var elem = null;

	for(var i = 0, l = elems.length; i < l && !elem; i++){
		if(!isTag(elems[i])){
			continue;
		} else if(test(elems[i])){
			elem = elems[i];
		} else if(elems[i].children.length > 0){
			elem = findOne(test, elems[i].children);
		}
	}

	return elem;
}

function existsOne(test, elems){
	for(var i = 0, l = elems.length; i < l; i++){
		if(
			isTag(elems[i]) && (
				test(elems[i]) || (
					elems[i].children.length > 0 &&
					existsOne(test, elems[i].children)
				)
			)
		){
			return true;
		}
	}

	return false;
}

function findAll(test, elems){
	var result = [];
	for(var i = 0, j = elems.length; i < j; i++){
		if(!isTag(elems[i])) continue;
		if(test(elems[i])) result.push(elems[i]);

		if(elems[i].children.length > 0){
			result = result.concat(findAll(test, elems[i].children));
		}
	}
	return result;
}

},{"domelementtype":84}],93:[function(require,module,exports){
var ElementType = require("domelementtype"),
    getOuterHTML = require("dom-serializer"),
    isTag = ElementType.isTag;

module.exports = {
	getInnerHTML: getInnerHTML,
	getOuterHTML: getOuterHTML,
	getText: getText
};

function getInnerHTML(elem, opts){
	return elem.children ? elem.children.map(function(elem){
		return getOuterHTML(elem, opts);
	}).join("") : "";
}

function getText(elem){
	if(Array.isArray(elem)) return elem.map(getText).join("");
	if(isTag(elem) || elem.type === ElementType.CDATA) return getText(elem.children);
	if(elem.type === ElementType.Text) return elem.data;
	return "";
}

},{"dom-serializer":82,"domelementtype":84}],94:[function(require,module,exports){
var getChildren = exports.getChildren = function(elem){
	return elem.children;
};

var getParent = exports.getParent = function(elem){
	return elem.parent;
};

exports.getSiblings = function(elem){
	var parent = getParent(elem);
	return parent ? getChildren(parent) : [elem];
};

exports.getAttributeValue = function(elem, name){
	return elem.attribs && elem.attribs[name];
};

exports.hasAttrib = function(elem, name){
	return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
};

exports.getName = function(elem){
	return elem.name;
};

},{}],95:[function(require,module,exports){
'use strict';

var cache = {};
var start = '(?:^|\\s)';
var end = '(?:\\s|$)';

function lookupClass (className) {
  var cached = cache[className];
  if (cached) {
    cached.lastIndex = 0;
  } else {
    cache[className] = cached = new RegExp(start + className + end, 'g');
  }
  return cached;
}

function addClass (el, className) {
  var current = el.className;
  if (!current.length) {
    el.className = className;
  } else if (!lookupClass(className).test(current)) {
    el.className += ' ' + className;
  }
}

function rmClass (el, className) {
  el.className = el.className.replace(lookupClass(className), ' ').trim();
}

module.exports = {
  add: addClass,
  rm: rmClass
};

},{}],96:[function(require,module,exports){
(function (global){
'use strict';

var emitter = require('contra/emitter');
var crossvent = require('crossvent');
var classes = require('./classes');
var doc = document;
var documentElement = doc.documentElement;

function dragula (initialContainers, options) {
  var len = arguments.length;
  if (len === 1 && Array.isArray(initialContainers) === false) {
    options = initialContainers;
    initialContainers = [];
  }
  var _mirror; // mirror image
  var _source; // source container
  var _item; // item being dragged
  var _offsetX; // reference x
  var _offsetY; // reference y
  var _moveX; // reference move x
  var _moveY; // reference move y
  var _initialSibling; // reference sibling when grabbed
  var _currentSibling; // reference sibling now
  var _copy; // item used for copying
  var _renderTimer; // timer for setTimeout renderMirrorImage
  var _lastDropTarget = null; // last container item was over
  var _grabbed; // holds mousedown context until first mousemove

  var o = options || {};
  if (o.moves === void 0) { o.moves = always; }
  if (o.accepts === void 0) { o.accepts = always; }
  if (o.invalid === void 0) { o.invalid = invalidTarget; }
  if (o.containers === void 0) { o.containers = initialContainers || []; }
  if (o.isContainer === void 0) { o.isContainer = never; }
  if (o.copy === void 0) { o.copy = false; }
  if (o.copySortSource === void 0) { o.copySortSource = false; }
  if (o.revertOnSpill === void 0) { o.revertOnSpill = false; }
  if (o.removeOnSpill === void 0) { o.removeOnSpill = false; }
  if (o.direction === void 0) { o.direction = 'vertical'; }
  if (o.ignoreInputTextSelection === void 0) { o.ignoreInputTextSelection = true; }
  if (o.mirrorContainer === void 0) { o.mirrorContainer = doc.body; }

  var drake = emitter({
    containers: o.containers,
    start: manualStart,
    end: end,
    cancel: cancel,
    remove: remove,
    destroy: destroy,
    canMove: canMove,
    dragging: false
  });

  if (o.removeOnSpill === true) {
    drake.on('over', spillOver).on('out', spillOut);
  }

  events();

  return drake;

  function isContainer (el) {
    return drake.containers.indexOf(el) !== -1 || o.isContainer(el);
  }

  function events (remove) {
    var op = remove ? 'remove' : 'add';
    touchy(documentElement, op, 'mousedown', grab);
    touchy(documentElement, op, 'mouseup', release);
  }

  function eventualMovements (remove) {
    var op = remove ? 'remove' : 'add';
    touchy(documentElement, op, 'mousemove', startBecauseMouseMoved);
  }

  function movements (remove) {
    var op = remove ? 'remove' : 'add';
    crossvent[op](documentElement, 'selectstart', preventGrabbed); // IE8
    crossvent[op](documentElement, 'click', preventGrabbed);
  }

  function destroy () {
    events(true);
    release({});
  }

  function preventGrabbed (e) {
    if (_grabbed) {
      e.preventDefault();
    }
  }

  function grab (e) {
    _moveX = e.clientX;
    _moveY = e.clientY;

    var ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;
    if (ignore) {
      return; // we only care about honest-to-god left clicks and touch events
    }
    var item = e.target;
    var context = canStart(item);
    if (!context) {
      return;
    }
    _grabbed = context;
    eventualMovements();
    if (e.type === 'mousedown') {
      if (isInput(item)) { // see also: https://github.com/bevacqua/dragula/issues/208
        item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176
      } else {
        e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155
      }
    }
  }

  function startBecauseMouseMoved (e) {
    if (!_grabbed) {
      return;
    }
    if (whichMouseButton(e) === 0) {
      release({});
      return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope
    }
    // truthy check fixes #239, equality fixes #207
    if (e.clientX !== void 0 && e.clientX === _moveX && e.clientY !== void 0 && e.clientY === _moveY) {
      return;
    }
    if (o.ignoreInputTextSelection) {
      var clientX = getCoord('clientX', e);
      var clientY = getCoord('clientY', e);
      var elementBehindCursor = doc.elementFromPoint(clientX, clientY);
      if (isInput(elementBehindCursor)) {
        return;
      }
    }

    var grabbed = _grabbed; // call to end() unsets _grabbed
    eventualMovements(true);
    movements();
    end();
    start(grabbed);

    var offset = getOffset(_item);
    _offsetX = getCoord('pageX', e) - offset.left;
    _offsetY = getCoord('pageY', e) - offset.top;

    classes.add(_copy || _item, 'gu-transit');
    renderMirrorImage();
    drag(e);
  }

  function canStart (item) {
    if (drake.dragging && _mirror) {
      return;
    }
    if (isContainer(item)) {
      return; // don't drag container itself
    }
    var handle = item;
    while (getParent(item) && isContainer(getParent(item)) === false) {
      if (o.invalid(item, handle)) {
        return;
      }
      item = getParent(item); // drag target should be a top element
      if (!item) {
        return;
      }
    }
    var source = getParent(item);
    if (!source) {
      return;
    }
    if (o.invalid(item, handle)) {
      return;
    }

    var movable = o.moves(item, source, handle, nextEl(item));
    if (!movable) {
      return;
    }

    return {
      item: item,
      source: source
    };
  }

  function canMove (item) {
    return !!canStart(item);
  }

  function manualStart (item) {
    var context = canStart(item);
    if (context) {
      start(context);
    }
  }

  function start (context) {
    if (isCopy(context.item, context.source)) {
      _copy = context.item.cloneNode(true);
      drake.emit('cloned', _copy, context.item, 'copy');
    }

    _source = context.source;
    _item = context.item;
    _initialSibling = _currentSibling = nextEl(context.item);

    drake.dragging = true;
    drake.emit('drag', _item, _source);
  }

  function invalidTarget () {
    return false;
  }

  function end () {
    if (!drake.dragging) {
      return;
    }
    var item = _copy || _item;
    drop(item, getParent(item));
  }

  function ungrab () {
    _grabbed = false;
    eventualMovements(true);
    movements(true);
  }

  function release (e) {
    ungrab();

    if (!drake.dragging) {
      return;
    }
    var item = _copy || _item;
    var clientX = getCoord('clientX', e);
    var clientY = getCoord('clientY', e);
    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);
    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);
    if (dropTarget && ((_copy && o.copySortSource) || (!_copy || dropTarget !== _source))) {
      drop(item, dropTarget);
    } else if (o.removeOnSpill) {
      remove();
    } else {
      cancel();
    }
  }

  function drop (item, target) {
    var parent = getParent(item);
    if (_copy && o.copySortSource && target === _source) {
      parent.removeChild(_item);
    }
    if (isInitialPlacement(target)) {
      drake.emit('cancel', item, _source, _source);
    } else {
      drake.emit('drop', item, target, _source, _currentSibling);
    }
    cleanup();
  }

  function remove () {
    if (!drake.dragging) {
      return;
    }
    var item = _copy || _item;
    var parent = getParent(item);
    if (parent) {
      parent.removeChild(item);
    }
    drake.emit(_copy ? 'cancel' : 'remove', item, parent, _source);
    cleanup();
  }

  function cancel (revert) {
    if (!drake.dragging) {
      return;
    }
    var reverts = arguments.length > 0 ? revert : o.revertOnSpill;
    var item = _copy || _item;
    var parent = getParent(item);
    var initial = isInitialPlacement(parent);
    if (initial === false && reverts) {
      if (_copy) {
        if (parent) {
          parent.removeChild(_copy);
        }
      } else {
        _source.insertBefore(item, _initialSibling);
      }
    }
    if (initial || reverts) {
      drake.emit('cancel', item, _source, _source);
    } else {
      drake.emit('drop', item, parent, _source, _currentSibling);
    }
    cleanup();
  }

  function cleanup () {
    var item = _copy || _item;
    ungrab();
    removeMirrorImage();
    if (item) {
      classes.rm(item, 'gu-transit');
    }
    if (_renderTimer) {
      clearTimeout(_renderTimer);
    }
    drake.dragging = false;
    if (_lastDropTarget) {
      drake.emit('out', item, _lastDropTarget, _source);
    }
    drake.emit('dragend', item);
    _source = _item = _copy = _initialSibling = _currentSibling = _renderTimer = _lastDropTarget = null;
  }

  function isInitialPlacement (target, s) {
    var sibling;
    if (s !== void 0) {
      sibling = s;
    } else if (_mirror) {
      sibling = _currentSibling;
    } else {
      sibling = nextEl(_copy || _item);
    }
    return target === _source && sibling === _initialSibling;
  }

  function findDropTarget (elementBehindCursor, clientX, clientY) {
    var target = elementBehindCursor;
    while (target && !accepted()) {
      target = getParent(target);
    }
    return target;

    function accepted () {
      var droppable = isContainer(target);
      if (droppable === false) {
        return false;
      }

      var immediate = getImmediateChild(target, elementBehindCursor);
      var reference = getReference(target, immediate, clientX, clientY);
      var initial = isInitialPlacement(target, reference);
      if (initial) {
        return true; // should always be able to drop it right back where it was
      }
      return o.accepts(_item, target, _source, reference);
    }
  }

  function drag (e) {
    if (!_mirror) {
      return;
    }
    e.preventDefault();

    var clientX = getCoord('clientX', e);
    var clientY = getCoord('clientY', e);
    var x = clientX - _offsetX;
    var y = clientY - _offsetY;

    _mirror.style.left = x + 'px';
    _mirror.style.top = y + 'px';

    var item = _copy || _item;
    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);
    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);
    var changed = dropTarget !== null && dropTarget !== _lastDropTarget;
    if (changed || dropTarget === null) {
      out();
      _lastDropTarget = dropTarget;
      over();
    }
    var parent = getParent(item);
    if (dropTarget === _source && _copy && !o.copySortSource) {
      if (parent) {
        parent.removeChild(item);
      }
      return;
    }
    var reference;
    var immediate = getImmediateChild(dropTarget, elementBehindCursor);
    if (immediate !== null) {
      reference = getReference(dropTarget, immediate, clientX, clientY);
    } else if (o.revertOnSpill === true && !_copy) {
      reference = _initialSibling;
      dropTarget = _source;
    } else {
      if (_copy && parent) {
        parent.removeChild(item);
      }
      return;
    }
    if (
      (reference === null && changed) ||
      reference !== item &&
      reference !== nextEl(item)
    ) {
      _currentSibling = reference;
      dropTarget.insertBefore(item, reference);
      drake.emit('shadow', item, dropTarget, _source);
    }
    function moved (type) { drake.emit(type, item, _lastDropTarget, _source); }
    function over () { if (changed) { moved('over'); } }
    function out () { if (_lastDropTarget) { moved('out'); } }
  }

  function spillOver (el) {
    classes.rm(el, 'gu-hide');
  }

  function spillOut (el) {
    if (drake.dragging) { classes.add(el, 'gu-hide'); }
  }

  function renderMirrorImage () {
    if (_mirror) {
      return;
    }
    var rect = _item.getBoundingClientRect();
    _mirror = _item.cloneNode(true);
    _mirror.style.width = getRectWidth(rect) + 'px';
    _mirror.style.height = getRectHeight(rect) + 'px';
    classes.rm(_mirror, 'gu-transit');
    classes.add(_mirror, 'gu-mirror');
    o.mirrorContainer.appendChild(_mirror);
    touchy(documentElement, 'add', 'mousemove', drag);
    classes.add(o.mirrorContainer, 'gu-unselectable');
    drake.emit('cloned', _mirror, _item, 'mirror');
  }

  function removeMirrorImage () {
    if (_mirror) {
      classes.rm(o.mirrorContainer, 'gu-unselectable');
      touchy(documentElement, 'remove', 'mousemove', drag);
      getParent(_mirror).removeChild(_mirror);
      _mirror = null;
    }
  }

  function getImmediateChild (dropTarget, target) {
    var immediate = target;
    while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {
      immediate = getParent(immediate);
    }
    if (immediate === documentElement) {
      return null;
    }
    return immediate;
  }

  function getReference (dropTarget, target, x, y) {
    var horizontal = o.direction === 'horizontal';
    var reference = target !== dropTarget ? inside() : outside();
    return reference;

    function outside () { // slower, but able to figure out any position
      var len = dropTarget.children.length;
      var i;
      var el;
      var rect;
      for (i = 0; i < len; i++) {
        el = dropTarget.children[i];
        rect = el.getBoundingClientRect();
        if (horizontal && (rect.left + rect.width / 2) > x) { return el; }
        if (!horizontal && (rect.top + rect.height / 2) > y) { return el; }
      }
      return null;
    }

    function inside () { // faster, but only available if dropped inside a child element
      var rect = target.getBoundingClientRect();
      if (horizontal) {
        return resolve(x > rect.left + getRectWidth(rect) / 2);
      }
      return resolve(y > rect.top + getRectHeight(rect) / 2);
    }

    function resolve (after) {
      return after ? nextEl(target) : target;
    }
  }

  function isCopy (item, container) {
    return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);
  }
}

function touchy (el, op, type, fn) {
  var touch = {
    mouseup: 'touchend',
    mousedown: 'touchstart',
    mousemove: 'touchmove'
  };
  var pointers = {
    mouseup: 'pointerup',
    mousedown: 'pointerdown',
    mousemove: 'pointermove'
  };
  var microsoft = {
    mouseup: 'MSPointerUp',
    mousedown: 'MSPointerDown',
    mousemove: 'MSPointerMove'
  };
  if (global.navigator.pointerEnabled) {
    crossvent[op](el, pointers[type], fn);
  } else if (global.navigator.msPointerEnabled) {
    crossvent[op](el, microsoft[type], fn);
  } else {
    crossvent[op](el, touch[type], fn);
    crossvent[op](el, type, fn);
  }
}

function whichMouseButton (e) {
  if (e.touches !== void 0) { return e.touches.length; }
  if (e.which !== void 0 && e.which !== 0) { return e.which; } // see https://github.com/bevacqua/dragula/issues/261
  if (e.buttons !== void 0) { return e.buttons; }
  var button = e.button;
  if (button !== void 0) { // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575
    return button & 1 ? 1 : button & 2 ? 3 : (button & 4 ? 2 : 0);
  }
}

function getOffset (el) {
  var rect = el.getBoundingClientRect();
  return {
    left: rect.left + getScroll('scrollLeft', 'pageXOffset'),
    top: rect.top + getScroll('scrollTop', 'pageYOffset')
  };
}

function getScroll (scrollProp, offsetProp) {
  if (typeof global[offsetProp] !== 'undefined') {
    return global[offsetProp];
  }
  if (documentElement.clientHeight) {
    return documentElement[scrollProp];
  }
  return doc.body[scrollProp];
}

function getElementBehindPoint (point, x, y) {
  var p = point || {};
  var state = p.className;
  var el;
  p.className += ' gu-hide';
  el = doc.elementFromPoint(x, y);
  p.className = state;
  return el;
}

function never () { return false; }
function always () { return true; }
function getRectWidth (rect) { return rect.width || (rect.right - rect.left); }
function getRectHeight (rect) { return rect.height || (rect.bottom - rect.top); }
function getParent (el) { return el.parentNode === doc ? null : el.parentNode; }
function isInput (el) { return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el); }
function isEditable (el) {
  if (!el) { return false; } // no parents were editable
  if (el.contentEditable === 'false') { return false; } // stop the lookup
  if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain
  return isEditable(getParent(el)); // contentEditable is set to 'inherit'
}

function nextEl (el) {
  return el.nextElementSibling || manually();
  function manually () {
    var sibling = el;
    do {
      sibling = sibling.nextSibling;
    } while (sibling && sibling.nodeType !== 1);
    return sibling;
  }
}

function getEventHost (e) {
  // on touchend event, we have to use `e.changedTouches`
  // see http://stackoverflow.com/questions/7192563/touchend-event-properties
  // see https://github.com/bevacqua/dragula/issues/34
  if (e.targetTouches && e.targetTouches.length) {
    return e.targetTouches[0];
  }
  if (e.changedTouches && e.changedTouches.length) {
    return e.changedTouches[0];
  }
  return e;
}

function getCoord (coord, e) {
  var host = getEventHost(e);
  var missMap = {
    pageX: 'clientX', // IE8
    pageY: 'clientY' // IE8
  };
  if (coord in missMap && !(coord in host) && missMap[coord] in host) {
    coord = missMap[coord];
  }
  return host[coord];
}

module.exports = dragula;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./classes":95,"contra/emitter":68,"crossvent":70}],97:[function(require,module,exports){
var encode = require("./lib/encode.js"),
    decode = require("./lib/decode.js");

exports.decode = function(data, level){
	return (!level || level <= 0 ? decode.XML : decode.HTML)(data);
};

exports.decodeStrict = function(data, level){
	return (!level || level <= 0 ? decode.XML : decode.HTMLStrict)(data);
};

exports.encode = function(data, level){
	return (!level || level <= 0 ? encode.XML : encode.HTML)(data);
};

exports.encodeXML = encode.XML;

exports.encodeHTML4 =
exports.encodeHTML5 =
exports.encodeHTML  = encode.HTML;

exports.decodeXML =
exports.decodeXMLStrict = decode.XML;

exports.decodeHTML4 =
exports.decodeHTML5 =
exports.decodeHTML = decode.HTML;

exports.decodeHTML4Strict =
exports.decodeHTML5Strict =
exports.decodeHTMLStrict = decode.HTMLStrict;

exports.escape = encode.escape;

},{"./lib/decode.js":98,"./lib/encode.js":100}],98:[function(require,module,exports){
var entityMap = require("../maps/entities.json"),
    legacyMap = require("../maps/legacy.json"),
    xmlMap    = require("../maps/xml.json"),
    decodeCodePoint = require("./decode_codepoint.js");

var decodeXMLStrict  = getStrictDecoder(xmlMap),
    decodeHTMLStrict = getStrictDecoder(entityMap);

function getStrictDecoder(map){
	var keys = Object.keys(map).join("|"),
	    replace = getReplacer(map);

	keys += "|#[xX][\\da-fA-F]+|#\\d+";

	var re = new RegExp("&(?:" + keys + ");", "g");

	return function(str){
		return String(str).replace(re, replace);
	};
}

var decodeHTML = (function(){
	var legacy = Object.keys(legacyMap)
		.sort(sorter);

	var keys = Object.keys(entityMap)
		.sort(sorter);

	for(var i = 0, j = 0; i < keys.length; i++){
		if(legacy[j] === keys[i]){
			keys[i] += ";?";
			j++;
		} else {
			keys[i] += ";";
		}
	}

	var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"),
	    replace = getReplacer(entityMap);

	function replacer(str){
		if(str.substr(-1) !== ";") str += ";";
		return replace(str);
	}

	//TODO consider creating a merged map
	return function(str){
		return String(str).replace(re, replacer);
	};
}());

function sorter(a, b){
	return a < b ? 1 : -1;
}

function getReplacer(map){
	return function replace(str){
		if(str.charAt(1) === "#"){
			if(str.charAt(2) === "X" || str.charAt(2) === "x"){
				return decodeCodePoint(parseInt(str.substr(3), 16));
			}
			return decodeCodePoint(parseInt(str.substr(2), 10));
		}
		return map[str.slice(1, -1)];
	};
}

module.exports = {
	XML: decodeXMLStrict,
	HTML: decodeHTML,
	HTMLStrict: decodeHTMLStrict
};
},{"../maps/entities.json":102,"../maps/legacy.json":103,"../maps/xml.json":104,"./decode_codepoint.js":99}],99:[function(require,module,exports){
var decodeMap = require("../maps/decode.json");

module.exports = decodeCodePoint;

// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint(codePoint){

	if((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF){
		return "\uFFFD";
	}

	if(codePoint in decodeMap){
		codePoint = decodeMap[codePoint];
	}

	var output = "";

	if(codePoint > 0xFFFF){
		codePoint -= 0x10000;
		output += String.fromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
		codePoint = 0xDC00 | codePoint & 0x3FF;
	}

	output += String.fromCharCode(codePoint);
	return output;
}

},{"../maps/decode.json":101}],100:[function(require,module,exports){
var inverseXML = getInverseObj(require("../maps/xml.json")),
    xmlReplacer = getInverseReplacer(inverseXML);

exports.XML = getInverse(inverseXML, xmlReplacer);

var inverseHTML = getInverseObj(require("../maps/entities.json")),
    htmlReplacer = getInverseReplacer(inverseHTML);

exports.HTML = getInverse(inverseHTML, htmlReplacer);

function getInverseObj(obj){
	return Object.keys(obj).sort().reduce(function(inverse, name){
		inverse[obj[name]] = "&" + name + ";";
		return inverse;
	}, {});
}

function getInverseReplacer(inverse){
	var single = [],
	    multiple = [];

	Object.keys(inverse).forEach(function(k){
		if(k.length === 1){
			single.push("\\" + k);
		} else {
			multiple.push(k);
		}
	});

	//TODO add ranges
	multiple.unshift("[" + single.join("") + "]");

	return new RegExp(multiple.join("|"), "g");
}

var re_nonASCII = /[^\0-\x7F]/g,
    re_astralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;

function singleCharReplacer(c){
	return "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";";
}

function astralReplacer(c){
	// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	var high = c.charCodeAt(0);
	var low  = c.charCodeAt(1);
	var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
	return "&#x" + codePoint.toString(16).toUpperCase() + ";";
}

function getInverse(inverse, re){
	function func(name){
		return inverse[name];
	}

	return function(data){
		return data
				.replace(re, func)
				.replace(re_astralSymbols, astralReplacer)
				.replace(re_nonASCII, singleCharReplacer);
	};
}

var re_xmlChars = getInverseReplacer(inverseXML);

function escapeXML(data){
	return data
			.replace(re_xmlChars, singleCharReplacer)
			.replace(re_astralSymbols, astralReplacer)
			.replace(re_nonASCII, singleCharReplacer);
}

exports.escape = escapeXML;

},{"../maps/entities.json":102,"../maps/xml.json":104}],101:[function(require,module,exports){
module.exports={"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}
},{}],102:[function(require,module,exports){
module.exports={"Aacute":"\u00C1","aacute":"\u00E1","Abreve":"\u0102","abreve":"\u0103","ac":"\u223E","acd":"\u223F","acE":"\u223E\u0333","Acirc":"\u00C2","acirc":"\u00E2","acute":"\u00B4","Acy":"\u0410","acy":"\u0430","AElig":"\u00C6","aelig":"\u00E6","af":"\u2061","Afr":"\uD835\uDD04","afr":"\uD835\uDD1E","Agrave":"\u00C0","agrave":"\u00E0","alefsym":"\u2135","aleph":"\u2135","Alpha":"\u0391","alpha":"\u03B1","Amacr":"\u0100","amacr":"\u0101","amalg":"\u2A3F","amp":"&","AMP":"&","andand":"\u2A55","And":"\u2A53","and":"\u2227","andd":"\u2A5C","andslope":"\u2A58","andv":"\u2A5A","ang":"\u2220","ange":"\u29A4","angle":"\u2220","angmsdaa":"\u29A8","angmsdab":"\u29A9","angmsdac":"\u29AA","angmsdad":"\u29AB","angmsdae":"\u29AC","angmsdaf":"\u29AD","angmsdag":"\u29AE","angmsdah":"\u29AF","angmsd":"\u2221","angrt":"\u221F","angrtvb":"\u22BE","angrtvbd":"\u299D","angsph":"\u2222","angst":"\u00C5","angzarr":"\u237C","Aogon":"\u0104","aogon":"\u0105","Aopf":"\uD835\uDD38","aopf":"\uD835\uDD52","apacir":"\u2A6F","ap":"\u2248","apE":"\u2A70","ape":"\u224A","apid":"\u224B","apos":"'","ApplyFunction":"\u2061","approx":"\u2248","approxeq":"\u224A","Aring":"\u00C5","aring":"\u00E5","Ascr":"\uD835\uDC9C","ascr":"\uD835\uDCB6","Assign":"\u2254","ast":"*","asymp":"\u2248","asympeq":"\u224D","Atilde":"\u00C3","atilde":"\u00E3","Auml":"\u00C4","auml":"\u00E4","awconint":"\u2233","awint":"\u2A11","backcong":"\u224C","backepsilon":"\u03F6","backprime":"\u2035","backsim":"\u223D","backsimeq":"\u22CD","Backslash":"\u2216","Barv":"\u2AE7","barvee":"\u22BD","barwed":"\u2305","Barwed":"\u2306","barwedge":"\u2305","bbrk":"\u23B5","bbrktbrk":"\u23B6","bcong":"\u224C","Bcy":"\u0411","bcy":"\u0431","bdquo":"\u201E","becaus":"\u2235","because":"\u2235","Because":"\u2235","bemptyv":"\u29B0","bepsi":"\u03F6","bernou":"\u212C","Bernoullis":"\u212C","Beta":"\u0392","beta":"\u03B2","beth":"\u2136","between":"\u226C","Bfr":"\uD835\uDD05","bfr":"\uD835\uDD1F","bigcap":"\u22C2","bigcirc":"\u25EF","bigcup":"\u22C3","bigodot":"\u2A00","bigoplus":"\u2A01","bigotimes":"\u2A02","bigsqcup":"\u2A06","bigstar":"\u2605","bigtriangledown":"\u25BD","bigtriangleup":"\u25B3","biguplus":"\u2A04","bigvee":"\u22C1","bigwedge":"\u22C0","bkarow":"\u290D","blacklozenge":"\u29EB","blacksquare":"\u25AA","blacktriangle":"\u25B4","blacktriangledown":"\u25BE","blacktriangleleft":"\u25C2","blacktriangleright":"\u25B8","blank":"\u2423","blk12":"\u2592","blk14":"\u2591","blk34":"\u2593","block":"\u2588","bne":"=\u20E5","bnequiv":"\u2261\u20E5","bNot":"\u2AED","bnot":"\u2310","Bopf":"\uD835\uDD39","bopf":"\uD835\uDD53","bot":"\u22A5","bottom":"\u22A5","bowtie":"\u22C8","boxbox":"\u29C9","boxdl":"\u2510","boxdL":"\u2555","boxDl":"\u2556","boxDL":"\u2557","boxdr":"\u250C","boxdR":"\u2552","boxDr":"\u2553","boxDR":"\u2554","boxh":"\u2500","boxH":"\u2550","boxhd":"\u252C","boxHd":"\u2564","boxhD":"\u2565","boxHD":"\u2566","boxhu":"\u2534","boxHu":"\u2567","boxhU":"\u2568","boxHU":"\u2569","boxminus":"\u229F","boxplus":"\u229E","boxtimes":"\u22A0","boxul":"\u2518","boxuL":"\u255B","boxUl":"\u255C","boxUL":"\u255D","boxur":"\u2514","boxuR":"\u2558","boxUr":"\u2559","boxUR":"\u255A","boxv":"\u2502","boxV":"\u2551","boxvh":"\u253C","boxvH":"\u256A","boxVh":"\u256B","boxVH":"\u256C","boxvl":"\u2524","boxvL":"\u2561","boxVl":"\u2562","boxVL":"\u2563","boxvr":"\u251C","boxvR":"\u255E","boxVr":"\u255F","boxVR":"\u2560","bprime":"\u2035","breve":"\u02D8","Breve":"\u02D8","brvbar":"\u00A6","bscr":"\uD835\uDCB7","Bscr":"\u212C","bsemi":"\u204F","bsim":"\u223D","bsime":"\u22CD","bsolb":"\u29C5","bsol":"\\","bsolhsub":"\u27C8","bull":"\u2022","bullet":"\u2022","bump":"\u224E","bumpE":"\u2AAE","bumpe":"\u224F","Bumpeq":"\u224E","bumpeq":"\u224F","Cacute":"\u0106","cacute":"\u0107","capand":"\u2A44","capbrcup":"\u2A49","capcap":"\u2A4B","cap":"\u2229","Cap":"\u22D2","capcup":"\u2A47","capdot":"\u2A40","CapitalDifferentialD":"\u2145","caps":"\u2229\uFE00","caret":"\u2041","caron":"\u02C7","Cayleys":"\u212D","ccaps":"\u2A4D","Ccaron":"\u010C","ccaron":"\u010D","Ccedil":"\u00C7","ccedil":"\u00E7","Ccirc":"\u0108","ccirc":"\u0109","Cconint":"\u2230","ccups":"\u2A4C","ccupssm":"\u2A50","Cdot":"\u010A","cdot":"\u010B","cedil":"\u00B8","Cedilla":"\u00B8","cemptyv":"\u29B2","cent":"\u00A2","centerdot":"\u00B7","CenterDot":"\u00B7","cfr":"\uD835\uDD20","Cfr":"\u212D","CHcy":"\u0427","chcy":"\u0447","check":"\u2713","checkmark":"\u2713","Chi":"\u03A7","chi":"\u03C7","circ":"\u02C6","circeq":"\u2257","circlearrowleft":"\u21BA","circlearrowright":"\u21BB","circledast":"\u229B","circledcirc":"\u229A","circleddash":"\u229D","CircleDot":"\u2299","circledR":"\u00AE","circledS":"\u24C8","CircleMinus":"\u2296","CirclePlus":"\u2295","CircleTimes":"\u2297","cir":"\u25CB","cirE":"\u29C3","cire":"\u2257","cirfnint":"\u2A10","cirmid":"\u2AEF","cirscir":"\u29C2","ClockwiseContourIntegral":"\u2232","CloseCurlyDoubleQuote":"\u201D","CloseCurlyQuote":"\u2019","clubs":"\u2663","clubsuit":"\u2663","colon":":","Colon":"\u2237","Colone":"\u2A74","colone":"\u2254","coloneq":"\u2254","comma":",","commat":"@","comp":"\u2201","compfn":"\u2218","complement":"\u2201","complexes":"\u2102","cong":"\u2245","congdot":"\u2A6D","Congruent":"\u2261","conint":"\u222E","Conint":"\u222F","ContourIntegral":"\u222E","copf":"\uD835\uDD54","Copf":"\u2102","coprod":"\u2210","Coproduct":"\u2210","copy":"\u00A9","COPY":"\u00A9","copysr":"\u2117","CounterClockwiseContourIntegral":"\u2233","crarr":"\u21B5","cross":"\u2717","Cross":"\u2A2F","Cscr":"\uD835\uDC9E","cscr":"\uD835\uDCB8","csub":"\u2ACF","csube":"\u2AD1","csup":"\u2AD0","csupe":"\u2AD2","ctdot":"\u22EF","cudarrl":"\u2938","cudarrr":"\u2935","cuepr":"\u22DE","cuesc":"\u22DF","cularr":"\u21B6","cularrp":"\u293D","cupbrcap":"\u2A48","cupcap":"\u2A46","CupCap":"\u224D","cup":"\u222A","Cup":"\u22D3","cupcup":"\u2A4A","cupdot":"\u228D","cupor":"\u2A45","cups":"\u222A\uFE00","curarr":"\u21B7","curarrm":"\u293C","curlyeqprec":"\u22DE","curlyeqsucc":"\u22DF","curlyvee":"\u22CE","curlywedge":"\u22CF","curren":"\u00A4","curvearrowleft":"\u21B6","curvearrowright":"\u21B7","cuvee":"\u22CE","cuwed":"\u22CF","cwconint":"\u2232","cwint":"\u2231","cylcty":"\u232D","dagger":"\u2020","Dagger":"\u2021","daleth":"\u2138","darr":"\u2193","Darr":"\u21A1","dArr":"\u21D3","dash":"\u2010","Dashv":"\u2AE4","dashv":"\u22A3","dbkarow":"\u290F","dblac":"\u02DD","Dcaron":"\u010E","dcaron":"\u010F","Dcy":"\u0414","dcy":"\u0434","ddagger":"\u2021","ddarr":"\u21CA","DD":"\u2145","dd":"\u2146","DDotrahd":"\u2911","ddotseq":"\u2A77","deg":"\u00B0","Del":"\u2207","Delta":"\u0394","delta":"\u03B4","demptyv":"\u29B1","dfisht":"\u297F","Dfr":"\uD835\uDD07","dfr":"\uD835\uDD21","dHar":"\u2965","dharl":"\u21C3","dharr":"\u21C2","DiacriticalAcute":"\u00B4","DiacriticalDot":"\u02D9","DiacriticalDoubleAcute":"\u02DD","DiacriticalGrave":"`","DiacriticalTilde":"\u02DC","diam":"\u22C4","diamond":"\u22C4","Diamond":"\u22C4","diamondsuit":"\u2666","diams":"\u2666","die":"\u00A8","DifferentialD":"\u2146","digamma":"\u03DD","disin":"\u22F2","div":"\u00F7","divide":"\u00F7","divideontimes":"\u22C7","divonx":"\u22C7","DJcy":"\u0402","djcy":"\u0452","dlcorn":"\u231E","dlcrop":"\u230D","dollar":"$","Dopf":"\uD835\uDD3B","dopf":"\uD835\uDD55","Dot":"\u00A8","dot":"\u02D9","DotDot":"\u20DC","doteq":"\u2250","doteqdot":"\u2251","DotEqual":"\u2250","dotminus":"\u2238","dotplus":"\u2214","dotsquare":"\u22A1","doublebarwedge":"\u2306","DoubleContourIntegral":"\u222F","DoubleDot":"\u00A8","DoubleDownArrow":"\u21D3","DoubleLeftArrow":"\u21D0","DoubleLeftRightArrow":"\u21D4","DoubleLeftTee":"\u2AE4","DoubleLongLeftArrow":"\u27F8","DoubleLongLeftRightArrow":"\u27FA","DoubleLongRightArrow":"\u27F9","DoubleRightArrow":"\u21D2","DoubleRightTee":"\u22A8","DoubleUpArrow":"\u21D1","DoubleUpDownArrow":"\u21D5","DoubleVerticalBar":"\u2225","DownArrowBar":"\u2913","downarrow":"\u2193","DownArrow":"\u2193","Downarrow":"\u21D3","DownArrowUpArrow":"\u21F5","DownBreve":"\u0311","downdownarrows":"\u21CA","downharpoonleft":"\u21C3","downharpoonright":"\u21C2","DownLeftRightVector":"\u2950","DownLeftTeeVector":"\u295E","DownLeftVectorBar":"\u2956","DownLeftVector":"\u21BD","DownRightTeeVector":"\u295F","DownRightVectorBar":"\u2957","DownRightVector":"\u21C1","DownTeeArrow":"\u21A7","DownTee":"\u22A4","drbkarow":"\u2910","drcorn":"\u231F","drcrop":"\u230C","Dscr":"\uD835\uDC9F","dscr":"\uD835\uDCB9","DScy":"\u0405","dscy":"\u0455","dsol":"\u29F6","Dstrok":"\u0110","dstrok":"\u0111","dtdot":"\u22F1","dtri":"\u25BF","dtrif":"\u25BE","duarr":"\u21F5","duhar":"\u296F","dwangle":"\u29A6","DZcy":"\u040F","dzcy":"\u045F","dzigrarr":"\u27FF","Eacute":"\u00C9","eacute":"\u00E9","easter":"\u2A6E","Ecaron":"\u011A","ecaron":"\u011B","Ecirc":"\u00CA","ecirc":"\u00EA","ecir":"\u2256","ecolon":"\u2255","Ecy":"\u042D","ecy":"\u044D","eDDot":"\u2A77","Edot":"\u0116","edot":"\u0117","eDot":"\u2251","ee":"\u2147","efDot":"\u2252","Efr":"\uD835\uDD08","efr":"\uD835\uDD22","eg":"\u2A9A","Egrave":"\u00C8","egrave":"\u00E8","egs":"\u2A96","egsdot":"\u2A98","el":"\u2A99","Element":"\u2208","elinters":"\u23E7","ell":"\u2113","els":"\u2A95","elsdot":"\u2A97","Emacr":"\u0112","emacr":"\u0113","empty":"\u2205","emptyset":"\u2205","EmptySmallSquare":"\u25FB","emptyv":"\u2205","EmptyVerySmallSquare":"\u25AB","emsp13":"\u2004","emsp14":"\u2005","emsp":"\u2003","ENG":"\u014A","eng":"\u014B","ensp":"\u2002","Eogon":"\u0118","eogon":"\u0119","Eopf":"\uD835\uDD3C","eopf":"\uD835\uDD56","epar":"\u22D5","eparsl":"\u29E3","eplus":"\u2A71","epsi":"\u03B5","Epsilon":"\u0395","epsilon":"\u03B5","epsiv":"\u03F5","eqcirc":"\u2256","eqcolon":"\u2255","eqsim":"\u2242","eqslantgtr":"\u2A96","eqslantless":"\u2A95","Equal":"\u2A75","equals":"=","EqualTilde":"\u2242","equest":"\u225F","Equilibrium":"\u21CC","equiv":"\u2261","equivDD":"\u2A78","eqvparsl":"\u29E5","erarr":"\u2971","erDot":"\u2253","escr":"\u212F","Escr":"\u2130","esdot":"\u2250","Esim":"\u2A73","esim":"\u2242","Eta":"\u0397","eta":"\u03B7","ETH":"\u00D0","eth":"\u00F0","Euml":"\u00CB","euml":"\u00EB","euro":"\u20AC","excl":"!","exist":"\u2203","Exists":"\u2203","expectation":"\u2130","exponentiale":"\u2147","ExponentialE":"\u2147","fallingdotseq":"\u2252","Fcy":"\u0424","fcy":"\u0444","female":"\u2640","ffilig":"\uFB03","fflig":"\uFB00","ffllig":"\uFB04","Ffr":"\uD835\uDD09","ffr":"\uD835\uDD23","filig":"\uFB01","FilledSmallSquare":"\u25FC","FilledVerySmallSquare":"\u25AA","fjlig":"fj","flat":"\u266D","fllig":"\uFB02","fltns":"\u25B1","fnof":"\u0192","Fopf":"\uD835\uDD3D","fopf":"\uD835\uDD57","forall":"\u2200","ForAll":"\u2200","fork":"\u22D4","forkv":"\u2AD9","Fouriertrf":"\u2131","fpartint":"\u2A0D","frac12":"\u00BD","frac13":"\u2153","frac14":"\u00BC","frac15":"\u2155","frac16":"\u2159","frac18":"\u215B","frac23":"\u2154","frac25":"\u2156","frac34":"\u00BE","frac35":"\u2157","frac38":"\u215C","frac45":"\u2158","frac56":"\u215A","frac58":"\u215D","frac78":"\u215E","frasl":"\u2044","frown":"\u2322","fscr":"\uD835\uDCBB","Fscr":"\u2131","gacute":"\u01F5","Gamma":"\u0393","gamma":"\u03B3","Gammad":"\u03DC","gammad":"\u03DD","gap":"\u2A86","Gbreve":"\u011E","gbreve":"\u011F","Gcedil":"\u0122","Gcirc":"\u011C","gcirc":"\u011D","Gcy":"\u0413","gcy":"\u0433","Gdot":"\u0120","gdot":"\u0121","ge":"\u2265","gE":"\u2267","gEl":"\u2A8C","gel":"\u22DB","geq":"\u2265","geqq":"\u2267","geqslant":"\u2A7E","gescc":"\u2AA9","ges":"\u2A7E","gesdot":"\u2A80","gesdoto":"\u2A82","gesdotol":"\u2A84","gesl":"\u22DB\uFE00","gesles":"\u2A94","Gfr":"\uD835\uDD0A","gfr":"\uD835\uDD24","gg":"\u226B","Gg":"\u22D9","ggg":"\u22D9","gimel":"\u2137","GJcy":"\u0403","gjcy":"\u0453","gla":"\u2AA5","gl":"\u2277","glE":"\u2A92","glj":"\u2AA4","gnap":"\u2A8A","gnapprox":"\u2A8A","gne":"\u2A88","gnE":"\u2269","gneq":"\u2A88","gneqq":"\u2269","gnsim":"\u22E7","Gopf":"\uD835\uDD3E","gopf":"\uD835\uDD58","grave":"`","GreaterEqual":"\u2265","GreaterEqualLess":"\u22DB","GreaterFullEqual":"\u2267","GreaterGreater":"\u2AA2","GreaterLess":"\u2277","GreaterSlantEqual":"\u2A7E","GreaterTilde":"\u2273","Gscr":"\uD835\uDCA2","gscr":"\u210A","gsim":"\u2273","gsime":"\u2A8E","gsiml":"\u2A90","gtcc":"\u2AA7","gtcir":"\u2A7A","gt":">","GT":">","Gt":"\u226B","gtdot":"\u22D7","gtlPar":"\u2995","gtquest":"\u2A7C","gtrapprox":"\u2A86","gtrarr":"\u2978","gtrdot":"\u22D7","gtreqless":"\u22DB","gtreqqless":"\u2A8C","gtrless":"\u2277","gtrsim":"\u2273","gvertneqq":"\u2269\uFE00","gvnE":"\u2269\uFE00","Hacek":"\u02C7","hairsp":"\u200A","half":"\u00BD","hamilt":"\u210B","HARDcy":"\u042A","hardcy":"\u044A","harrcir":"\u2948","harr":"\u2194","hArr":"\u21D4","harrw":"\u21AD","Hat":"^","hbar":"\u210F","Hcirc":"\u0124","hcirc":"\u0125","hearts":"\u2665","heartsuit":"\u2665","hellip":"\u2026","hercon":"\u22B9","hfr":"\uD835\uDD25","Hfr":"\u210C","HilbertSpace":"\u210B","hksearow":"\u2925","hkswarow":"\u2926","hoarr":"\u21FF","homtht":"\u223B","hookleftarrow":"\u21A9","hookrightarrow":"\u21AA","hopf":"\uD835\uDD59","Hopf":"\u210D","horbar":"\u2015","HorizontalLine":"\u2500","hscr":"\uD835\uDCBD","Hscr":"\u210B","hslash":"\u210F","Hstrok":"\u0126","hstrok":"\u0127","HumpDownHump":"\u224E","HumpEqual":"\u224F","hybull":"\u2043","hyphen":"\u2010","Iacute":"\u00CD","iacute":"\u00ED","ic":"\u2063","Icirc":"\u00CE","icirc":"\u00EE","Icy":"\u0418","icy":"\u0438","Idot":"\u0130","IEcy":"\u0415","iecy":"\u0435","iexcl":"\u00A1","iff":"\u21D4","ifr":"\uD835\uDD26","Ifr":"\u2111","Igrave":"\u00CC","igrave":"\u00EC","ii":"\u2148","iiiint":"\u2A0C","iiint":"\u222D","iinfin":"\u29DC","iiota":"\u2129","IJlig":"\u0132","ijlig":"\u0133","Imacr":"\u012A","imacr":"\u012B","image":"\u2111","ImaginaryI":"\u2148","imagline":"\u2110","imagpart":"\u2111","imath":"\u0131","Im":"\u2111","imof":"\u22B7","imped":"\u01B5","Implies":"\u21D2","incare":"\u2105","in":"\u2208","infin":"\u221E","infintie":"\u29DD","inodot":"\u0131","intcal":"\u22BA","int":"\u222B","Int":"\u222C","integers":"\u2124","Integral":"\u222B","intercal":"\u22BA","Intersection":"\u22C2","intlarhk":"\u2A17","intprod":"\u2A3C","InvisibleComma":"\u2063","InvisibleTimes":"\u2062","IOcy":"\u0401","iocy":"\u0451","Iogon":"\u012E","iogon":"\u012F","Iopf":"\uD835\uDD40","iopf":"\uD835\uDD5A","Iota":"\u0399","iota":"\u03B9","iprod":"\u2A3C","iquest":"\u00BF","iscr":"\uD835\uDCBE","Iscr":"\u2110","isin":"\u2208","isindot":"\u22F5","isinE":"\u22F9","isins":"\u22F4","isinsv":"\u22F3","isinv":"\u2208","it":"\u2062","Itilde":"\u0128","itilde":"\u0129","Iukcy":"\u0406","iukcy":"\u0456","Iuml":"\u00CF","iuml":"\u00EF","Jcirc":"\u0134","jcirc":"\u0135","Jcy":"\u0419","jcy":"\u0439","Jfr":"\uD835\uDD0D","jfr":"\uD835\uDD27","jmath":"\u0237","Jopf":"\uD835\uDD41","jopf":"\uD835\uDD5B","Jscr":"\uD835\uDCA5","jscr":"\uD835\uDCBF","Jsercy":"\u0408","jsercy":"\u0458","Jukcy":"\u0404","jukcy":"\u0454","Kappa":"\u039A","kappa":"\u03BA","kappav":"\u03F0","Kcedil":"\u0136","kcedil":"\u0137","Kcy":"\u041A","kcy":"\u043A","Kfr":"\uD835\uDD0E","kfr":"\uD835\uDD28","kgreen":"\u0138","KHcy":"\u0425","khcy":"\u0445","KJcy":"\u040C","kjcy":"\u045C","Kopf":"\uD835\uDD42","kopf":"\uD835\uDD5C","Kscr":"\uD835\uDCA6","kscr":"\uD835\uDCC0","lAarr":"\u21DA","Lacute":"\u0139","lacute":"\u013A","laemptyv":"\u29B4","lagran":"\u2112","Lambda":"\u039B","lambda":"\u03BB","lang":"\u27E8","Lang":"\u27EA","langd":"\u2991","langle":"\u27E8","lap":"\u2A85","Laplacetrf":"\u2112","laquo":"\u00AB","larrb":"\u21E4","larrbfs":"\u291F","larr":"\u2190","Larr":"\u219E","lArr":"\u21D0","larrfs":"\u291D","larrhk":"\u21A9","larrlp":"\u21AB","larrpl":"\u2939","larrsim":"\u2973","larrtl":"\u21A2","latail":"\u2919","lAtail":"\u291B","lat":"\u2AAB","late":"\u2AAD","lates":"\u2AAD\uFE00","lbarr":"\u290C","lBarr":"\u290E","lbbrk":"\u2772","lbrace":"{","lbrack":"[","lbrke":"\u298B","lbrksld":"\u298F","lbrkslu":"\u298D","Lcaron":"\u013D","lcaron":"\u013E","Lcedil":"\u013B","lcedil":"\u013C","lceil":"\u2308","lcub":"{","Lcy":"\u041B","lcy":"\u043B","ldca":"\u2936","ldquo":"\u201C","ldquor":"\u201E","ldrdhar":"\u2967","ldrushar":"\u294B","ldsh":"\u21B2","le":"\u2264","lE":"\u2266","LeftAngleBracket":"\u27E8","LeftArrowBar":"\u21E4","leftarrow":"\u2190","LeftArrow":"\u2190","Leftarrow":"\u21D0","LeftArrowRightArrow":"\u21C6","leftarrowtail":"\u21A2","LeftCeiling":"\u2308","LeftDoubleBracket":"\u27E6","LeftDownTeeVector":"\u2961","LeftDownVectorBar":"\u2959","LeftDownVector":"\u21C3","LeftFloor":"\u230A","leftharpoondown":"\u21BD","leftharpoonup":"\u21BC","leftleftarrows":"\u21C7","leftrightarrow":"\u2194","LeftRightArrow":"\u2194","Leftrightarrow":"\u21D4","leftrightarrows":"\u21C6","leftrightharpoons":"\u21CB","leftrightsquigarrow":"\u21AD","LeftRightVector":"\u294E","LeftTeeArrow":"\u21A4","LeftTee":"\u22A3","LeftTeeVector":"\u295A","leftthreetimes":"\u22CB","LeftTriangleBar":"\u29CF","LeftTriangle":"\u22B2","LeftTriangleEqual":"\u22B4","LeftUpDownVector":"\u2951","LeftUpTeeVector":"\u2960","LeftUpVectorBar":"\u2958","LeftUpVector":"\u21BF","LeftVectorBar":"\u2952","LeftVector":"\u21BC","lEg":"\u2A8B","leg":"\u22DA","leq":"\u2264","leqq":"\u2266","leqslant":"\u2A7D","lescc":"\u2AA8","les":"\u2A7D","lesdot":"\u2A7F","lesdoto":"\u2A81","lesdotor":"\u2A83","lesg":"\u22DA\uFE00","lesges":"\u2A93","lessapprox":"\u2A85","lessdot":"\u22D6","lesseqgtr":"\u22DA","lesseqqgtr":"\u2A8B","LessEqualGreater":"\u22DA","LessFullEqual":"\u2266","LessGreater":"\u2276","lessgtr":"\u2276","LessLess":"\u2AA1","lesssim":"\u2272","LessSlantEqual":"\u2A7D","LessTilde":"\u2272","lfisht":"\u297C","lfloor":"\u230A","Lfr":"\uD835\uDD0F","lfr":"\uD835\uDD29","lg":"\u2276","lgE":"\u2A91","lHar":"\u2962","lhard":"\u21BD","lharu":"\u21BC","lharul":"\u296A","lhblk":"\u2584","LJcy":"\u0409","ljcy":"\u0459","llarr":"\u21C7","ll":"\u226A","Ll":"\u22D8","llcorner":"\u231E","Lleftarrow":"\u21DA","llhard":"\u296B","lltri":"\u25FA","Lmidot":"\u013F","lmidot":"\u0140","lmoustache":"\u23B0","lmoust":"\u23B0","lnap":"\u2A89","lnapprox":"\u2A89","lne":"\u2A87","lnE":"\u2268","lneq":"\u2A87","lneqq":"\u2268","lnsim":"\u22E6","loang":"\u27EC","loarr":"\u21FD","lobrk":"\u27E6","longleftarrow":"\u27F5","LongLeftArrow":"\u27F5","Longleftarrow":"\u27F8","longleftrightarrow":"\u27F7","LongLeftRightArrow":"\u27F7","Longleftrightarrow":"\u27FA","longmapsto":"\u27FC","longrightarrow":"\u27F6","LongRightArrow":"\u27F6","Longrightarrow":"\u27F9","looparrowleft":"\u21AB","looparrowright":"\u21AC","lopar":"\u2985","Lopf":"\uD835\uDD43","lopf":"\uD835\uDD5D","loplus":"\u2A2D","lotimes":"\u2A34","lowast":"\u2217","lowbar":"_","LowerLeftArrow":"\u2199","LowerRightArrow":"\u2198","loz":"\u25CA","lozenge":"\u25CA","lozf":"\u29EB","lpar":"(","lparlt":"\u2993","lrarr":"\u21C6","lrcorner":"\u231F","lrhar":"\u21CB","lrhard":"\u296D","lrm":"\u200E","lrtri":"\u22BF","lsaquo":"\u2039","lscr":"\uD835\uDCC1","Lscr":"\u2112","lsh":"\u21B0","Lsh":"\u21B0","lsim":"\u2272","lsime":"\u2A8D","lsimg":"\u2A8F","lsqb":"[","lsquo":"\u2018","lsquor":"\u201A","Lstrok":"\u0141","lstrok":"\u0142","ltcc":"\u2AA6","ltcir":"\u2A79","lt":"<","LT":"<","Lt":"\u226A","ltdot":"\u22D6","lthree":"\u22CB","ltimes":"\u22C9","ltlarr":"\u2976","ltquest":"\u2A7B","ltri":"\u25C3","ltrie":"\u22B4","ltrif":"\u25C2","ltrPar":"\u2996","lurdshar":"\u294A","luruhar":"\u2966","lvertneqq":"\u2268\uFE00","lvnE":"\u2268\uFE00","macr":"\u00AF","male":"\u2642","malt":"\u2720","maltese":"\u2720","Map":"\u2905","map":"\u21A6","mapsto":"\u21A6","mapstodown":"\u21A7","mapstoleft":"\u21A4","mapstoup":"\u21A5","marker":"\u25AE","mcomma":"\u2A29","Mcy":"\u041C","mcy":"\u043C","mdash":"\u2014","mDDot":"\u223A","measuredangle":"\u2221","MediumSpace":"\u205F","Mellintrf":"\u2133","Mfr":"\uD835\uDD10","mfr":"\uD835\uDD2A","mho":"\u2127","micro":"\u00B5","midast":"*","midcir":"\u2AF0","mid":"\u2223","middot":"\u00B7","minusb":"\u229F","minus":"\u2212","minusd":"\u2238","minusdu":"\u2A2A","MinusPlus":"\u2213","mlcp":"\u2ADB","mldr":"\u2026","mnplus":"\u2213","models":"\u22A7","Mopf":"\uD835\uDD44","mopf":"\uD835\uDD5E","mp":"\u2213","mscr":"\uD835\uDCC2","Mscr":"\u2133","mstpos":"\u223E","Mu":"\u039C","mu":"\u03BC","multimap":"\u22B8","mumap":"\u22B8","nabla":"\u2207","Nacute":"\u0143","nacute":"\u0144","nang":"\u2220\u20D2","nap":"\u2249","napE":"\u2A70\u0338","napid":"\u224B\u0338","napos":"\u0149","napprox":"\u2249","natural":"\u266E","naturals":"\u2115","natur":"\u266E","nbsp":"\u00A0","nbump":"\u224E\u0338","nbumpe":"\u224F\u0338","ncap":"\u2A43","Ncaron":"\u0147","ncaron":"\u0148","Ncedil":"\u0145","ncedil":"\u0146","ncong":"\u2247","ncongdot":"\u2A6D\u0338","ncup":"\u2A42","Ncy":"\u041D","ncy":"\u043D","ndash":"\u2013","nearhk":"\u2924","nearr":"\u2197","neArr":"\u21D7","nearrow":"\u2197","ne":"\u2260","nedot":"\u2250\u0338","NegativeMediumSpace":"\u200B","NegativeThickSpace":"\u200B","NegativeThinSpace":"\u200B","NegativeVeryThinSpace":"\u200B","nequiv":"\u2262","nesear":"\u2928","nesim":"\u2242\u0338","NestedGreaterGreater":"\u226B","NestedLessLess":"\u226A","NewLine":"\n","nexist":"\u2204","nexists":"\u2204","Nfr":"\uD835\uDD11","nfr":"\uD835\uDD2B","ngE":"\u2267\u0338","nge":"\u2271","ngeq":"\u2271","ngeqq":"\u2267\u0338","ngeqslant":"\u2A7E\u0338","nges":"\u2A7E\u0338","nGg":"\u22D9\u0338","ngsim":"\u2275","nGt":"\u226B\u20D2","ngt":"\u226F","ngtr":"\u226F","nGtv":"\u226B\u0338","nharr":"\u21AE","nhArr":"\u21CE","nhpar":"\u2AF2","ni":"\u220B","nis":"\u22FC","nisd":"\u22FA","niv":"\u220B","NJcy":"\u040A","njcy":"\u045A","nlarr":"\u219A","nlArr":"\u21CD","nldr":"\u2025","nlE":"\u2266\u0338","nle":"\u2270","nleftarrow":"\u219A","nLeftarrow":"\u21CD","nleftrightarrow":"\u21AE","nLeftrightarrow":"\u21CE","nleq":"\u2270","nleqq":"\u2266\u0338","nleqslant":"\u2A7D\u0338","nles":"\u2A7D\u0338","nless":"\u226E","nLl":"\u22D8\u0338","nlsim":"\u2274","nLt":"\u226A\u20D2","nlt":"\u226E","nltri":"\u22EA","nltrie":"\u22EC","nLtv":"\u226A\u0338","nmid":"\u2224","NoBreak":"\u2060","NonBreakingSpace":"\u00A0","nopf":"\uD835\uDD5F","Nopf":"\u2115","Not":"\u2AEC","not":"\u00AC","NotCongruent":"\u2262","NotCupCap":"\u226D","NotDoubleVerticalBar":"\u2226","NotElement":"\u2209","NotEqual":"\u2260","NotEqualTilde":"\u2242\u0338","NotExists":"\u2204","NotGreater":"\u226F","NotGreaterEqual":"\u2271","NotGreaterFullEqual":"\u2267\u0338","NotGreaterGreater":"\u226B\u0338","NotGreaterLess":"\u2279","NotGreaterSlantEqual":"\u2A7E\u0338","NotGreaterTilde":"\u2275","NotHumpDownHump":"\u224E\u0338","NotHumpEqual":"\u224F\u0338","notin":"\u2209","notindot":"\u22F5\u0338","notinE":"\u22F9\u0338","notinva":"\u2209","notinvb":"\u22F7","notinvc":"\u22F6","NotLeftTriangleBar":"\u29CF\u0338","NotLeftTriangle":"\u22EA","NotLeftTriangleEqual":"\u22EC","NotLess":"\u226E","NotLessEqual":"\u2270","NotLessGreater":"\u2278","NotLessLess":"\u226A\u0338","NotLessSlantEqual":"\u2A7D\u0338","NotLessTilde":"\u2274","NotNestedGreaterGreater":"\u2AA2\u0338","NotNestedLessLess":"\u2AA1\u0338","notni":"\u220C","notniva":"\u220C","notnivb":"\u22FE","notnivc":"\u22FD","NotPrecedes":"\u2280","NotPrecedesEqual":"\u2AAF\u0338","NotPrecedesSlantEqual":"\u22E0","NotReverseElement":"\u220C","NotRightTriangleBar":"\u29D0\u0338","NotRightTriangle":"\u22EB","NotRightTriangleEqual":"\u22ED","NotSquareSubset":"\u228F\u0338","NotSquareSubsetEqual":"\u22E2","NotSquareSuperset":"\u2290\u0338","NotSquareSupersetEqual":"\u22E3","NotSubset":"\u2282\u20D2","NotSubsetEqual":"\u2288","NotSucceeds":"\u2281","NotSucceedsEqual":"\u2AB0\u0338","NotSucceedsSlantEqual":"\u22E1","NotSucceedsTilde":"\u227F\u0338","NotSuperset":"\u2283\u20D2","NotSupersetEqual":"\u2289","NotTilde":"\u2241","NotTildeEqual":"\u2244","NotTildeFullEqual":"\u2247","NotTildeTilde":"\u2249","NotVerticalBar":"\u2224","nparallel":"\u2226","npar":"\u2226","nparsl":"\u2AFD\u20E5","npart":"\u2202\u0338","npolint":"\u2A14","npr":"\u2280","nprcue":"\u22E0","nprec":"\u2280","npreceq":"\u2AAF\u0338","npre":"\u2AAF\u0338","nrarrc":"\u2933\u0338","nrarr":"\u219B","nrArr":"\u21CF","nrarrw":"\u219D\u0338","nrightarrow":"\u219B","nRightarrow":"\u21CF","nrtri":"\u22EB","nrtrie":"\u22ED","nsc":"\u2281","nsccue":"\u22E1","nsce":"\u2AB0\u0338","Nscr":"\uD835\uDCA9","nscr":"\uD835\uDCC3","nshortmid":"\u2224","nshortparallel":"\u2226","nsim":"\u2241","nsime":"\u2244","nsimeq":"\u2244","nsmid":"\u2224","nspar":"\u2226","nsqsube":"\u22E2","nsqsupe":"\u22E3","nsub":"\u2284","nsubE":"\u2AC5\u0338","nsube":"\u2288","nsubset":"\u2282\u20D2","nsubseteq":"\u2288","nsubseteqq":"\u2AC5\u0338","nsucc":"\u2281","nsucceq":"\u2AB0\u0338","nsup":"\u2285","nsupE":"\u2AC6\u0338","nsupe":"\u2289","nsupset":"\u2283\u20D2","nsupseteq":"\u2289","nsupseteqq":"\u2AC6\u0338","ntgl":"\u2279","Ntilde":"\u00D1","ntilde":"\u00F1","ntlg":"\u2278","ntriangleleft":"\u22EA","ntrianglelefteq":"\u22EC","ntriangleright":"\u22EB","ntrianglerighteq":"\u22ED","Nu":"\u039D","nu":"\u03BD","num":"#","numero":"\u2116","numsp":"\u2007","nvap":"\u224D\u20D2","nvdash":"\u22AC","nvDash":"\u22AD","nVdash":"\u22AE","nVDash":"\u22AF","nvge":"\u2265\u20D2","nvgt":">\u20D2","nvHarr":"\u2904","nvinfin":"\u29DE","nvlArr":"\u2902","nvle":"\u2264\u20D2","nvlt":"<\u20D2","nvltrie":"\u22B4\u20D2","nvrArr":"\u2903","nvrtrie":"\u22B5\u20D2","nvsim":"\u223C\u20D2","nwarhk":"\u2923","nwarr":"\u2196","nwArr":"\u21D6","nwarrow":"\u2196","nwnear":"\u2927","Oacute":"\u00D3","oacute":"\u00F3","oast":"\u229B","Ocirc":"\u00D4","ocirc":"\u00F4","ocir":"\u229A","Ocy":"\u041E","ocy":"\u043E","odash":"\u229D","Odblac":"\u0150","odblac":"\u0151","odiv":"\u2A38","odot":"\u2299","odsold":"\u29BC","OElig":"\u0152","oelig":"\u0153","ofcir":"\u29BF","Ofr":"\uD835\uDD12","ofr":"\uD835\uDD2C","ogon":"\u02DB","Ograve":"\u00D2","ograve":"\u00F2","ogt":"\u29C1","ohbar":"\u29B5","ohm":"\u03A9","oint":"\u222E","olarr":"\u21BA","olcir":"\u29BE","olcross":"\u29BB","oline":"\u203E","olt":"\u29C0","Omacr":"\u014C","omacr":"\u014D","Omega":"\u03A9","omega":"\u03C9","Omicron":"\u039F","omicron":"\u03BF","omid":"\u29B6","ominus":"\u2296","Oopf":"\uD835\uDD46","oopf":"\uD835\uDD60","opar":"\u29B7","OpenCurlyDoubleQuote":"\u201C","OpenCurlyQuote":"\u2018","operp":"\u29B9","oplus":"\u2295","orarr":"\u21BB","Or":"\u2A54","or":"\u2228","ord":"\u2A5D","order":"\u2134","orderof":"\u2134","ordf":"\u00AA","ordm":"\u00BA","origof":"\u22B6","oror":"\u2A56","orslope":"\u2A57","orv":"\u2A5B","oS":"\u24C8","Oscr":"\uD835\uDCAA","oscr":"\u2134","Oslash":"\u00D8","oslash":"\u00F8","osol":"\u2298","Otilde":"\u00D5","otilde":"\u00F5","otimesas":"\u2A36","Otimes":"\u2A37","otimes":"\u2297","Ouml":"\u00D6","ouml":"\u00F6","ovbar":"\u233D","OverBar":"\u203E","OverBrace":"\u23DE","OverBracket":"\u23B4","OverParenthesis":"\u23DC","para":"\u00B6","parallel":"\u2225","par":"\u2225","parsim":"\u2AF3","parsl":"\u2AFD","part":"\u2202","PartialD":"\u2202","Pcy":"\u041F","pcy":"\u043F","percnt":"%","period":".","permil":"\u2030","perp":"\u22A5","pertenk":"\u2031","Pfr":"\uD835\uDD13","pfr":"\uD835\uDD2D","Phi":"\u03A6","phi":"\u03C6","phiv":"\u03D5","phmmat":"\u2133","phone":"\u260E","Pi":"\u03A0","pi":"\u03C0","pitchfork":"\u22D4","piv":"\u03D6","planck":"\u210F","planckh":"\u210E","plankv":"\u210F","plusacir":"\u2A23","plusb":"\u229E","pluscir":"\u2A22","plus":"+","plusdo":"\u2214","plusdu":"\u2A25","pluse":"\u2A72","PlusMinus":"\u00B1","plusmn":"\u00B1","plussim":"\u2A26","plustwo":"\u2A27","pm":"\u00B1","Poincareplane":"\u210C","pointint":"\u2A15","popf":"\uD835\uDD61","Popf":"\u2119","pound":"\u00A3","prap":"\u2AB7","Pr":"\u2ABB","pr":"\u227A","prcue":"\u227C","precapprox":"\u2AB7","prec":"\u227A","preccurlyeq":"\u227C","Precedes":"\u227A","PrecedesEqual":"\u2AAF","PrecedesSlantEqual":"\u227C","PrecedesTilde":"\u227E","preceq":"\u2AAF","precnapprox":"\u2AB9","precneqq":"\u2AB5","precnsim":"\u22E8","pre":"\u2AAF","prE":"\u2AB3","precsim":"\u227E","prime":"\u2032","Prime":"\u2033","primes":"\u2119","prnap":"\u2AB9","prnE":"\u2AB5","prnsim":"\u22E8","prod":"\u220F","Product":"\u220F","profalar":"\u232E","profline":"\u2312","profsurf":"\u2313","prop":"\u221D","Proportional":"\u221D","Proportion":"\u2237","propto":"\u221D","prsim":"\u227E","prurel":"\u22B0","Pscr":"\uD835\uDCAB","pscr":"\uD835\uDCC5","Psi":"\u03A8","psi":"\u03C8","puncsp":"\u2008","Qfr":"\uD835\uDD14","qfr":"\uD835\uDD2E","qint":"\u2A0C","qopf":"\uD835\uDD62","Qopf":"\u211A","qprime":"\u2057","Qscr":"\uD835\uDCAC","qscr":"\uD835\uDCC6","quaternions":"\u210D","quatint":"\u2A16","quest":"?","questeq":"\u225F","quot":"\"","QUOT":"\"","rAarr":"\u21DB","race":"\u223D\u0331","Racute":"\u0154","racute":"\u0155","radic":"\u221A","raemptyv":"\u29B3","rang":"\u27E9","Rang":"\u27EB","rangd":"\u2992","range":"\u29A5","rangle":"\u27E9","raquo":"\u00BB","rarrap":"\u2975","rarrb":"\u21E5","rarrbfs":"\u2920","rarrc":"\u2933","rarr":"\u2192","Rarr":"\u21A0","rArr":"\u21D2","rarrfs":"\u291E","rarrhk":"\u21AA","rarrlp":"\u21AC","rarrpl":"\u2945","rarrsim":"\u2974","Rarrtl":"\u2916","rarrtl":"\u21A3","rarrw":"\u219D","ratail":"\u291A","rAtail":"\u291C","ratio":"\u2236","rationals":"\u211A","rbarr":"\u290D","rBarr":"\u290F","RBarr":"\u2910","rbbrk":"\u2773","rbrace":"}","rbrack":"]","rbrke":"\u298C","rbrksld":"\u298E","rbrkslu":"\u2990","Rcaron":"\u0158","rcaron":"\u0159","Rcedil":"\u0156","rcedil":"\u0157","rceil":"\u2309","rcub":"}","Rcy":"\u0420","rcy":"\u0440","rdca":"\u2937","rdldhar":"\u2969","rdquo":"\u201D","rdquor":"\u201D","rdsh":"\u21B3","real":"\u211C","realine":"\u211B","realpart":"\u211C","reals":"\u211D","Re":"\u211C","rect":"\u25AD","reg":"\u00AE","REG":"\u00AE","ReverseElement":"\u220B","ReverseEquilibrium":"\u21CB","ReverseUpEquilibrium":"\u296F","rfisht":"\u297D","rfloor":"\u230B","rfr":"\uD835\uDD2F","Rfr":"\u211C","rHar":"\u2964","rhard":"\u21C1","rharu":"\u21C0","rharul":"\u296C","Rho":"\u03A1","rho":"\u03C1","rhov":"\u03F1","RightAngleBracket":"\u27E9","RightArrowBar":"\u21E5","rightarrow":"\u2192","RightArrow":"\u2192","Rightarrow":"\u21D2","RightArrowLeftArrow":"\u21C4","rightarrowtail":"\u21A3","RightCeiling":"\u2309","RightDoubleBracket":"\u27E7","RightDownTeeVector":"\u295D","RightDownVectorBar":"\u2955","RightDownVector":"\u21C2","RightFloor":"\u230B","rightharpoondown":"\u21C1","rightharpoonup":"\u21C0","rightleftarrows":"\u21C4","rightleftharpoons":"\u21CC","rightrightarrows":"\u21C9","rightsquigarrow":"\u219D","RightTeeArrow":"\u21A6","RightTee":"\u22A2","RightTeeVector":"\u295B","rightthreetimes":"\u22CC","RightTriangleBar":"\u29D0","RightTriangle":"\u22B3","RightTriangleEqual":"\u22B5","RightUpDownVector":"\u294F","RightUpTeeVector":"\u295C","RightUpVectorBar":"\u2954","RightUpVector":"\u21BE","RightVectorBar":"\u2953","RightVector":"\u21C0","ring":"\u02DA","risingdotseq":"\u2253","rlarr":"\u21C4","rlhar":"\u21CC","rlm":"\u200F","rmoustache":"\u23B1","rmoust":"\u23B1","rnmid":"\u2AEE","roang":"\u27ED","roarr":"\u21FE","robrk":"\u27E7","ropar":"\u2986","ropf":"\uD835\uDD63","Ropf":"\u211D","roplus":"\u2A2E","rotimes":"\u2A35","RoundImplies":"\u2970","rpar":")","rpargt":"\u2994","rppolint":"\u2A12","rrarr":"\u21C9","Rrightarrow":"\u21DB","rsaquo":"\u203A","rscr":"\uD835\uDCC7","Rscr":"\u211B","rsh":"\u21B1","Rsh":"\u21B1","rsqb":"]","rsquo":"\u2019","rsquor":"\u2019","rthree":"\u22CC","rtimes":"\u22CA","rtri":"\u25B9","rtrie":"\u22B5","rtrif":"\u25B8","rtriltri":"\u29CE","RuleDelayed":"\u29F4","ruluhar":"\u2968","rx":"\u211E","Sacute":"\u015A","sacute":"\u015B","sbquo":"\u201A","scap":"\u2AB8","Scaron":"\u0160","scaron":"\u0161","Sc":"\u2ABC","sc":"\u227B","sccue":"\u227D","sce":"\u2AB0","scE":"\u2AB4","Scedil":"\u015E","scedil":"\u015F","Scirc":"\u015C","scirc":"\u015D","scnap":"\u2ABA","scnE":"\u2AB6","scnsim":"\u22E9","scpolint":"\u2A13","scsim":"\u227F","Scy":"\u0421","scy":"\u0441","sdotb":"\u22A1","sdot":"\u22C5","sdote":"\u2A66","searhk":"\u2925","searr":"\u2198","seArr":"\u21D8","searrow":"\u2198","sect":"\u00A7","semi":";","seswar":"\u2929","setminus":"\u2216","setmn":"\u2216","sext":"\u2736","Sfr":"\uD835\uDD16","sfr":"\uD835\uDD30","sfrown":"\u2322","sharp":"\u266F","SHCHcy":"\u0429","shchcy":"\u0449","SHcy":"\u0428","shcy":"\u0448","ShortDownArrow":"\u2193","ShortLeftArrow":"\u2190","shortmid":"\u2223","shortparallel":"\u2225","ShortRightArrow":"\u2192","ShortUpArrow":"\u2191","shy":"\u00AD","Sigma":"\u03A3","sigma":"\u03C3","sigmaf":"\u03C2","sigmav":"\u03C2","sim":"\u223C","simdot":"\u2A6A","sime":"\u2243","simeq":"\u2243","simg":"\u2A9E","simgE":"\u2AA0","siml":"\u2A9D","simlE":"\u2A9F","simne":"\u2246","simplus":"\u2A24","simrarr":"\u2972","slarr":"\u2190","SmallCircle":"\u2218","smallsetminus":"\u2216","smashp":"\u2A33","smeparsl":"\u29E4","smid":"\u2223","smile":"\u2323","smt":"\u2AAA","smte":"\u2AAC","smtes":"\u2AAC\uFE00","SOFTcy":"\u042C","softcy":"\u044C","solbar":"\u233F","solb":"\u29C4","sol":"/","Sopf":"\uD835\uDD4A","sopf":"\uD835\uDD64","spades":"\u2660","spadesuit":"\u2660","spar":"\u2225","sqcap":"\u2293","sqcaps":"\u2293\uFE00","sqcup":"\u2294","sqcups":"\u2294\uFE00","Sqrt":"\u221A","sqsub":"\u228F","sqsube":"\u2291","sqsubset":"\u228F","sqsubseteq":"\u2291","sqsup":"\u2290","sqsupe":"\u2292","sqsupset":"\u2290","sqsupseteq":"\u2292","square":"\u25A1","Square":"\u25A1","SquareIntersection":"\u2293","SquareSubset":"\u228F","SquareSubsetEqual":"\u2291","SquareSuperset":"\u2290","SquareSupersetEqual":"\u2292","SquareUnion":"\u2294","squarf":"\u25AA","squ":"\u25A1","squf":"\u25AA","srarr":"\u2192","Sscr":"\uD835\uDCAE","sscr":"\uD835\uDCC8","ssetmn":"\u2216","ssmile":"\u2323","sstarf":"\u22C6","Star":"\u22C6","star":"\u2606","starf":"\u2605","straightepsilon":"\u03F5","straightphi":"\u03D5","strns":"\u00AF","sub":"\u2282","Sub":"\u22D0","subdot":"\u2ABD","subE":"\u2AC5","sube":"\u2286","subedot":"\u2AC3","submult":"\u2AC1","subnE":"\u2ACB","subne":"\u228A","subplus":"\u2ABF","subrarr":"\u2979","subset":"\u2282","Subset":"\u22D0","subseteq":"\u2286","subseteqq":"\u2AC5","SubsetEqual":"\u2286","subsetneq":"\u228A","subsetneqq":"\u2ACB","subsim":"\u2AC7","subsub":"\u2AD5","subsup":"\u2AD3","succapprox":"\u2AB8","succ":"\u227B","succcurlyeq":"\u227D","Succeeds":"\u227B","SucceedsEqual":"\u2AB0","SucceedsSlantEqual":"\u227D","SucceedsTilde":"\u227F","succeq":"\u2AB0","succnapprox":"\u2ABA","succneqq":"\u2AB6","succnsim":"\u22E9","succsim":"\u227F","SuchThat":"\u220B","sum":"\u2211","Sum":"\u2211","sung":"\u266A","sup1":"\u00B9","sup2":"\u00B2","sup3":"\u00B3","sup":"\u2283","Sup":"\u22D1","supdot":"\u2ABE","supdsub":"\u2AD8","supE":"\u2AC6","supe":"\u2287","supedot":"\u2AC4","Superset":"\u2283","SupersetEqual":"\u2287","suphsol":"\u27C9","suphsub":"\u2AD7","suplarr":"\u297B","supmult":"\u2AC2","supnE":"\u2ACC","supne":"\u228B","supplus":"\u2AC0","supset":"\u2283","Supset":"\u22D1","supseteq":"\u2287","supseteqq":"\u2AC6","supsetneq":"\u228B","supsetneqq":"\u2ACC","supsim":"\u2AC8","supsub":"\u2AD4","supsup":"\u2AD6","swarhk":"\u2926","swarr":"\u2199","swArr":"\u21D9","swarrow":"\u2199","swnwar":"\u292A","szlig":"\u00DF","Tab":"\t","target":"\u2316","Tau":"\u03A4","tau":"\u03C4","tbrk":"\u23B4","Tcaron":"\u0164","tcaron":"\u0165","Tcedil":"\u0162","tcedil":"\u0163","Tcy":"\u0422","tcy":"\u0442","tdot":"\u20DB","telrec":"\u2315","Tfr":"\uD835\uDD17","tfr":"\uD835\uDD31","there4":"\u2234","therefore":"\u2234","Therefore":"\u2234","Theta":"\u0398","theta":"\u03B8","thetasym":"\u03D1","thetav":"\u03D1","thickapprox":"\u2248","thicksim":"\u223C","ThickSpace":"\u205F\u200A","ThinSpace":"\u2009","thinsp":"\u2009","thkap":"\u2248","thksim":"\u223C","THORN":"\u00DE","thorn":"\u00FE","tilde":"\u02DC","Tilde":"\u223C","TildeEqual":"\u2243","TildeFullEqual":"\u2245","TildeTilde":"\u2248","timesbar":"\u2A31","timesb":"\u22A0","times":"\u00D7","timesd":"\u2A30","tint":"\u222D","toea":"\u2928","topbot":"\u2336","topcir":"\u2AF1","top":"\u22A4","Topf":"\uD835\uDD4B","topf":"\uD835\uDD65","topfork":"\u2ADA","tosa":"\u2929","tprime":"\u2034","trade":"\u2122","TRADE":"\u2122","triangle":"\u25B5","triangledown":"\u25BF","triangleleft":"\u25C3","trianglelefteq":"\u22B4","triangleq":"\u225C","triangleright":"\u25B9","trianglerighteq":"\u22B5","tridot":"\u25EC","trie":"\u225C","triminus":"\u2A3A","TripleDot":"\u20DB","triplus":"\u2A39","trisb":"\u29CD","tritime":"\u2A3B","trpezium":"\u23E2","Tscr":"\uD835\uDCAF","tscr":"\uD835\uDCC9","TScy":"\u0426","tscy":"\u0446","TSHcy":"\u040B","tshcy":"\u045B","Tstrok":"\u0166","tstrok":"\u0167","twixt":"\u226C","twoheadleftarrow":"\u219E","twoheadrightarrow":"\u21A0","Uacute":"\u00DA","uacute":"\u00FA","uarr":"\u2191","Uarr":"\u219F","uArr":"\u21D1","Uarrocir":"\u2949","Ubrcy":"\u040E","ubrcy":"\u045E","Ubreve":"\u016C","ubreve":"\u016D","Ucirc":"\u00DB","ucirc":"\u00FB","Ucy":"\u0423","ucy":"\u0443","udarr":"\u21C5","Udblac":"\u0170","udblac":"\u0171","udhar":"\u296E","ufisht":"\u297E","Ufr":"\uD835\uDD18","ufr":"\uD835\uDD32","Ugrave":"\u00D9","ugrave":"\u00F9","uHar":"\u2963","uharl":"\u21BF","uharr":"\u21BE","uhblk":"\u2580","ulcorn":"\u231C","ulcorner":"\u231C","ulcrop":"\u230F","ultri":"\u25F8","Umacr":"\u016A","umacr":"\u016B","uml":"\u00A8","UnderBar":"_","UnderBrace":"\u23DF","UnderBracket":"\u23B5","UnderParenthesis":"\u23DD","Union":"\u22C3","UnionPlus":"\u228E","Uogon":"\u0172","uogon":"\u0173","Uopf":"\uD835\uDD4C","uopf":"\uD835\uDD66","UpArrowBar":"\u2912","uparrow":"\u2191","UpArrow":"\u2191","Uparrow":"\u21D1","UpArrowDownArrow":"\u21C5","updownarrow":"\u2195","UpDownArrow":"\u2195","Updownarrow":"\u21D5","UpEquilibrium":"\u296E","upharpoonleft":"\u21BF","upharpoonright":"\u21BE","uplus":"\u228E","UpperLeftArrow":"\u2196","UpperRightArrow":"\u2197","upsi":"\u03C5","Upsi":"\u03D2","upsih":"\u03D2","Upsilon":"\u03A5","upsilon":"\u03C5","UpTeeArrow":"\u21A5","UpTee":"\u22A5","upuparrows":"\u21C8","urcorn":"\u231D","urcorner":"\u231D","urcrop":"\u230E","Uring":"\u016E","uring":"\u016F","urtri":"\u25F9","Uscr":"\uD835\uDCB0","uscr":"\uD835\uDCCA","utdot":"\u22F0","Utilde":"\u0168","utilde":"\u0169","utri":"\u25B5","utrif":"\u25B4","uuarr":"\u21C8","Uuml":"\u00DC","uuml":"\u00FC","uwangle":"\u29A7","vangrt":"\u299C","varepsilon":"\u03F5","varkappa":"\u03F0","varnothing":"\u2205","varphi":"\u03D5","varpi":"\u03D6","varpropto":"\u221D","varr":"\u2195","vArr":"\u21D5","varrho":"\u03F1","varsigma":"\u03C2","varsubsetneq":"\u228A\uFE00","varsubsetneqq":"\u2ACB\uFE00","varsupsetneq":"\u228B\uFE00","varsupsetneqq":"\u2ACC\uFE00","vartheta":"\u03D1","vartriangleleft":"\u22B2","vartriangleright":"\u22B3","vBar":"\u2AE8","Vbar":"\u2AEB","vBarv":"\u2AE9","Vcy":"\u0412","vcy":"\u0432","vdash":"\u22A2","vDash":"\u22A8","Vdash":"\u22A9","VDash":"\u22AB","Vdashl":"\u2AE6","veebar":"\u22BB","vee":"\u2228","Vee":"\u22C1","veeeq":"\u225A","vellip":"\u22EE","verbar":"|","Verbar":"\u2016","vert":"|","Vert":"\u2016","VerticalBar":"\u2223","VerticalLine":"|","VerticalSeparator":"\u2758","VerticalTilde":"\u2240","VeryThinSpace":"\u200A","Vfr":"\uD835\uDD19","vfr":"\uD835\uDD33","vltri":"\u22B2","vnsub":"\u2282\u20D2","vnsup":"\u2283\u20D2","Vopf":"\uD835\uDD4D","vopf":"\uD835\uDD67","vprop":"\u221D","vrtri":"\u22B3","Vscr":"\uD835\uDCB1","vscr":"\uD835\uDCCB","vsubnE":"\u2ACB\uFE00","vsubne":"\u228A\uFE00","vsupnE":"\u2ACC\uFE00","vsupne":"\u228B\uFE00","Vvdash":"\u22AA","vzigzag":"\u299A","Wcirc":"\u0174","wcirc":"\u0175","wedbar":"\u2A5F","wedge":"\u2227","Wedge":"\u22C0","wedgeq":"\u2259","weierp":"\u2118","Wfr":"\uD835\uDD1A","wfr":"\uD835\uDD34","Wopf":"\uD835\uDD4E","wopf":"\uD835\uDD68","wp":"\u2118","wr":"\u2240","wreath":"\u2240","Wscr":"\uD835\uDCB2","wscr":"\uD835\uDCCC","xcap":"\u22C2","xcirc":"\u25EF","xcup":"\u22C3","xdtri":"\u25BD","Xfr":"\uD835\uDD1B","xfr":"\uD835\uDD35","xharr":"\u27F7","xhArr":"\u27FA","Xi":"\u039E","xi":"\u03BE","xlarr":"\u27F5","xlArr":"\u27F8","xmap":"\u27FC","xnis":"\u22FB","xodot":"\u2A00","Xopf":"\uD835\uDD4F","xopf":"\uD835\uDD69","xoplus":"\u2A01","xotime":"\u2A02","xrarr":"\u27F6","xrArr":"\u27F9","Xscr":"\uD835\uDCB3","xscr":"\uD835\uDCCD","xsqcup":"\u2A06","xuplus":"\u2A04","xutri":"\u25B3","xvee":"\u22C1","xwedge":"\u22C0","Yacute":"\u00DD","yacute":"\u00FD","YAcy":"\u042F","yacy":"\u044F","Ycirc":"\u0176","ycirc":"\u0177","Ycy":"\u042B","ycy":"\u044B","yen":"\u00A5","Yfr":"\uD835\uDD1C","yfr":"\uD835\uDD36","YIcy":"\u0407","yicy":"\u0457","Yopf":"\uD835\uDD50","yopf":"\uD835\uDD6A","Yscr":"\uD835\uDCB4","yscr":"\uD835\uDCCE","YUcy":"\u042E","yucy":"\u044E","yuml":"\u00FF","Yuml":"\u0178","Zacute":"\u0179","zacute":"\u017A","Zcaron":"\u017D","zcaron":"\u017E","Zcy":"\u0417","zcy":"\u0437","Zdot":"\u017B","zdot":"\u017C","zeetrf":"\u2128","ZeroWidthSpace":"\u200B","Zeta":"\u0396","zeta":"\u03B6","zfr":"\uD835\uDD37","Zfr":"\u2128","ZHcy":"\u0416","zhcy":"\u0436","zigrarr":"\u21DD","zopf":"\uD835\uDD6B","Zopf":"\u2124","Zscr":"\uD835\uDCB5","zscr":"\uD835\uDCCF","zwj":"\u200D","zwnj":"\u200C"}
},{}],103:[function(require,module,exports){
module.exports={"Aacute":"\u00C1","aacute":"\u00E1","Acirc":"\u00C2","acirc":"\u00E2","acute":"\u00B4","AElig":"\u00C6","aelig":"\u00E6","Agrave":"\u00C0","agrave":"\u00E0","amp":"&","AMP":"&","Aring":"\u00C5","aring":"\u00E5","Atilde":"\u00C3","atilde":"\u00E3","Auml":"\u00C4","auml":"\u00E4","brvbar":"\u00A6","Ccedil":"\u00C7","ccedil":"\u00E7","cedil":"\u00B8","cent":"\u00A2","copy":"\u00A9","COPY":"\u00A9","curren":"\u00A4","deg":"\u00B0","divide":"\u00F7","Eacute":"\u00C9","eacute":"\u00E9","Ecirc":"\u00CA","ecirc":"\u00EA","Egrave":"\u00C8","egrave":"\u00E8","ETH":"\u00D0","eth":"\u00F0","Euml":"\u00CB","euml":"\u00EB","frac12":"\u00BD","frac14":"\u00BC","frac34":"\u00BE","gt":">","GT":">","Iacute":"\u00CD","iacute":"\u00ED","Icirc":"\u00CE","icirc":"\u00EE","iexcl":"\u00A1","Igrave":"\u00CC","igrave":"\u00EC","iquest":"\u00BF","Iuml":"\u00CF","iuml":"\u00EF","laquo":"\u00AB","lt":"<","LT":"<","macr":"\u00AF","micro":"\u00B5","middot":"\u00B7","nbsp":"\u00A0","not":"\u00AC","Ntilde":"\u00D1","ntilde":"\u00F1","Oacute":"\u00D3","oacute":"\u00F3","Ocirc":"\u00D4","ocirc":"\u00F4","Ograve":"\u00D2","ograve":"\u00F2","ordf":"\u00AA","ordm":"\u00BA","Oslash":"\u00D8","oslash":"\u00F8","Otilde":"\u00D5","otilde":"\u00F5","Ouml":"\u00D6","ouml":"\u00F6","para":"\u00B6","plusmn":"\u00B1","pound":"\u00A3","quot":"\"","QUOT":"\"","raquo":"\u00BB","reg":"\u00AE","REG":"\u00AE","sect":"\u00A7","shy":"\u00AD","sup1":"\u00B9","sup2":"\u00B2","sup3":"\u00B3","szlig":"\u00DF","THORN":"\u00DE","thorn":"\u00FE","times":"\u00D7","Uacute":"\u00DA","uacute":"\u00FA","Ucirc":"\u00DB","ucirc":"\u00FB","Ugrave":"\u00D9","ugrave":"\u00F9","uml":"\u00A8","Uuml":"\u00DC","uuml":"\u00FC","Yacute":"\u00DD","yacute":"\u00FD","yen":"\u00A5","yuml":"\u00FF"}
},{}],104:[function(require,module,exports){
module.exports={"amp":"&","apos":"'","gt":">","lt":"<","quot":"\""}

},{}],105:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],106:[function(require,module,exports){
module.exports={
  "html": {
    "content": [ "<head>", "<body>" ],
    "singular": true
  },
  "head": {
    "content": [ "metadata content" ],
    "parent": [ "<html>" ],
    "singular": true
  },
  "body": {
    "categories": [ "sectioning root" ],
    "content": [ "flow content" ],
    "parent": [ "<html>" ],
    "singular": true
  },

  "title": {
    "categories": [ "metadata content" ],
    "content": [ "text" ],
    "parent": [ "<head>" ],
    "singular": true
  },
  "base": {
    "categories": [ "metadata content" ],
    "parent": [ "<head>" ],
    "singular": true
  },
  "link": {
    "categories": [ "metadata content" ],
    "parent": [ "<head>" ]
  },
  "meta": {
    "categories": [ "metadata content" ],
    "parent": [ "<head>" ]
  },
  "style": {
    "categories": [ "metadata content" ],
    "content": [ "text" ],
    "parent": [ "<head>" ]
  },

  "address": {
    "categories": [ "flow content", "palpable content" ],
    "content": [ "flow content" ],
    "disallow": [ "<address>", "heading content", "sectioning content", "<header>", "<footer>" ]
  },
  "article": {
    "categories": [ "flow content", "sectioning content", "palpable content" ],
    "content": [ "flow content" ],
    "disallow": [ "<main>" ],
    "nospec": [ "4.01" ]
  },
  "aside": {
    "categories": [ "flow content", "sectioning content", "palpable content" ],
    "content": [ "flow content" ],
    "disallow": [ "<main>" ],
    "nospec": [ "4.01" ]
  },
  "footer": {
    "categories": [ "flow content", "palpable content" ],
    "content": [ "flow content" ],
    "disallow": [ "<footer>", "<header>", "<main>" ],
    "nospec": [ "4.01" ]
  },
  "header": {
    "categories": [ "flow content", "palpable content" ],
    "content": [ "flow content" ],
    "disallow": [ "<footer>", "<header>", "<main>" ],
    "nospec": [ "4.01" ]
  },
  "h1": {
    "categories": [ "flow content", "heading content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "h2": {
    "categories": [ "flow content", "heading content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "h3": {
    "categories": [ "flow content", "heading content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "h4": {
    "categories": [ "flow content", "heading content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "h5": {
    "categories": [ "flow content", "heading content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "h6": {
    "categories": [ "flow content", "heading content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "nav": {
    "categories": [ "flow content", "sectioning content", "palpable content" ],
    "content": [ "flow content" ],
    "disallow": [ "<main>" ],
    "nospec": [ "4.01" ]
  },

  "blockquote": {
    "categories": [ "flow content", "sectioning root", "palpable content" ],
    "content": [ "flow content" ]
  },
  "dd": {
    "content": [ "flow content" ],
    "parent": [ "<dl>" ],
    "previous": [ "<dt>", "<dd>" ]
  },
  "div": {
    "categories": [ "flow content", "palpable content" ],
    "content": [ "flow content" ]
  },
  "dl": {
    "categories": [ "flow content" ],
    "content": [ "<dt>", "<dd>" ]
  },
  "dt": {
    "content": [ "flow content" ],
    "parent": [ "<dl>" ],
    "disallow": [ "<footer>", "<header>", "sectioning content", "heading content" ],
    "next": [ "<dt>", "<dd>" ]
  },
  "figcaption": {
    "content": [ "flow content" ],
    "parent": [ "<figure>" ],
    "position": [ "first", "last" ],
    "nospec": [ "4.01" ]
  },
  "figure": {
    "categories": [ "flow content", "sectioning root", "palpable content" ],
    "content": [ "flow content", "<figcaption>" ],
    "nospec": [ "4.01" ]
  },
  "hr": {
    "categories": [ "flow content" ]
  },
  "li": {
    "content": [ "flow content" ],
    "parent": [ "<ul>", "<ol>", "<menu>" ]
  },
  "main": {
    "categories": [ "flow content", "palpable content" ],
    "content": [ "flow content" ],
    "nospec": [ "4.01" ]
  },
  "ol": {
    "categories": [ "flow content" ],
    "content": [ "<li>" ],
    "states": {
      ":not(:empty)": {
        "categories": [ "palpable content" ]
      }
    }
  },
  "p": {
    "categories": [ "flow content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "pre": {
    "categories": [ "flow content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "section": {
    "categories": [ "flow content", "sectioning content", "palpable content" ],
    "content": [ "flow content" ],
    "nospec": [ "4.01" ]
  },
  "ul": {
    "categories": [ "flow content" ],
    "content": [ "<li>" ],
    "states": {
      ":not(:empty)": {
        "categories": [ "palpable content" ]
      }
    }
  },

  "a": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "flow content", "phrasing content" ],
    "disallow": [ "interactive content" ],
    "states": {
      "[href]" : {
        "categories": [ "interactive content" ]
      }
    }
  },
  "abbr": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "b": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "bdi": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ],
    "nospec": [ "4.01" ]
  },
  "bdo": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ],
    "nospec": [ "4.01" ]
  },
  "br": {
    "categories": [ "flow content", "phrasing content" ]
  },
  "cite": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "code": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "data": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ],
    "nospec": [ "4.01" ]
  },
  "dfn": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ],
    "disallow": [ "<dfn>" ]
  },
  "em": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "i": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "kbd": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "mark": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ],
    "nospec": [ "4.01" ]
  },
  "q": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "rp": {
    "content": [ "phrasing content" ],
    "parent": [ "<ruby>" ],
    "nospec": [ "4.01" ]
  },
  "rt": {
    "content": [ "phrasing content" ],
    "parent": [ "<ruby>", "<rtc>" ],
    "nospec": [ "4.01" ]
  },
  "rtc": {
    "content": [ "phrasing content", "<rt>" ],
    "parent": [ "<ruby>" ],
    "nospec": [ "4.01" ]
  },
  "ruby": {
    "categories": [ "flow content", "phrasing content" ],
    "content": [ "phrasing content", "<rp>", "<rt>", "<rtc>" ],
    "nospec": [ "4.01" ]
  },
  "s": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "samp": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "small": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "span": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "strong": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "sub": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "sup": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "time": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ],
    "nospec": [ "4.01" ]
  },
  "u": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "var": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "wbr": {
    "categories": [ "flow content", "phrasing content" ],
    "nospec": [ "4.01" ]
  },

  "area": {
    "categories": [ "flow content", "phrasing content" ],
    "ancestor": [ "<map>" ]
  },
  "audio": {
    "categories": [ "flow content", "phrasing content", "embedded content" ],
    "content": [ "transparent", "<track>" ],
    "disallow": [ "<audio>", "<video>" ],
    "states": {
      "[controls]": {
        "categories": [ "interactive content", "palpable content" ]
      },
      ":not([src])": {
        "content": [ "<source>" ]
      }
    },
    "nospec": [ "4.01" ]
  },
  "map": {
    "categories": [ "flow content", "phrasing content", "palpable content" ],
    "content": [ "transparent", "<area>" ]
  },
  "track": {
    "parent": [ "<audio>", "<video>" ],
    "nospec": [ "4.01" ]
  },
  "video": {
    "categories": [ "flow content", "phrasing content", "embedded content" ],
    "content": [ "transparent", "<track>" ],
    "disallow": [ "<audio>", "<video>" ],
    "states": {
      "[controls]": {
        "categories": [ "interactive content", "palpable content" ]
      },
      ":not([src])": {
        "content": [ "<source>" ]
      }
    },
    "nospec": [ "4.01" ]
  },

  "embed": {
    "categories": [ "flow content", "phrasing content", "embedded content", "interactive content", "palpable content" ],
    "nospec": [ "4.01" ]
  },
  "iframe": {
    "categories": [ "flow content", "phrasing content", "embedded content", "interactive content", "palpable content" ],
    "content": [ "phrasing content" ],
    "disallow": [ "<script>" ]
  },
  "img": {
    "categories": [ "flow content", "phrasing content", "embedded content", "palpable content" ],
    "states": {
      "[usemap]": {
        "categories": [ "interactive content" ]
      }
    }
  },
  "object": {
    "categories": [ "flow content", "phrasing content", "embedded content", "palpable content", "form-associated content", "listed", "submittable" ],
    "content": [ "transparent", "<param>" ],
    "states": {
      "[usemap]": {
        "categories": [ "interactive content" ]
      }
    }
  },
  "param": {
    "parent": [ "<object>" ]
  },
  "source": {
    "parent": [ "<picture>", "<audio>", "<video>" ],
    "position": [ "first" ],
    "nospec": [ "4.01" ]
  },

  "canvas": {
    "categories": [ "flow content", "phrasing content", "embedded content", "palpable content" ],
    "content": [ "transparent" ],
    "nospec": [ "4.01" ]
  },
  "noscript": {
    "categories": [ "flow content", "phrasing content", "metadata content" ],
    "disallow": [ "<noscript>" ],
    "states": {
      "head > noscript": {
        "content": [ "<link>", "<style>", "<meta>" ]
      },
      ":not( head > noscript )": {
        "content": [ "transparent" ]
      }
    }
  },
  "script": {
    "categories": [ "flow content", "phrasing content", "metadata content" ],
    "content": [ "text" ]
  },
  "template": {
    "categories": [ "metadata content", "flow content", "phrasing content" ],
    "content": [ "metadata content", "flow content" ],
    "parent": [ "body", "head", "colgroup" ],
    "nospec": [ "4.01" ]
  },

  "del": {
    "categories": [ "flow content", "phrasing content" ],
    "content": [ "transparent" ]
  },
  "ins": {
    "categories": [ "flow content", "phrasing content" ],
    "content": [ "transparent" ]
  },

  "caption": {
    "content": [ "flow content" ],
    "parent": [ "<table>" ],
    "position": [ "first" ]
  },
  "col": {
    "parent": [ "<colgroup>" ]
  },
  "colgroup": {
    "parent": [ "<table>" ],
    "states": {
      ":not([span])": {
        "content": [ "<col>" ]
      }
    }
  },
  "table": {
    "categories": [ "flow content" ],
    "content": [ "<caption>", "<colgroup>", "<thead>", "<tbody>", "<tfoot>", "<tr>" ]
  },
  "tbody": {
    "content": [ "<tr>" ],
    "parent": [ "<table>" ]
  },
  "td": {
    "content": [ "flow content", "phrasing content" ],
    "parent": [ "<tr>" ]
  },
  "tfoot": {
    "content": [ "<tr>" ],
    "parent": [ "<table>" ]
  },
  "th": {
    "content": [ "phrasing content" ],
    "parent": [ "<tr>" ]
  },
  "thead": {
    "content": [ "<tr>" ],
    "parent": [ "<table>" ]
  },
  "tr": {
    "content": [ "<th>", "<td>" ],
    "parent": [ "<table>", "<thead>", "<tbody>", "<tfoot>" ]
  },

  "button": {
    "categories": [ "flow content", "phrasing content", "interactive content", "form-associated content", "listed", "labelable", "submittable", "palpable content" ],
    "content": [ "phrasing content" ]
  },
  "datalist": {
    "categories": [ "flow content", "phrasing content" ],
    "content": [ "phrasing content", "<option>" ],
    "nospec": [ "4.01" ]
  },
  "fieldset": {
    "categories": [ "flow content", "sectioning root", "form-associated content", "listed", "palpable content" ],
    "content": [ "<legend>", "flow content" ]
  },
  "form": {
    "categories": [ "flow content", "palpable content" ],
    "content": [ "flow content" ],
    "disallow": [ "<form>" ]
  },
  "input": {
    "categories": [ "flow content", "phrasing content", "form-associated content", "listed", "submittable", "resettable" ],
    "states": {
      ":not([type=hidden])": {
        "categories": [ "labelable", "palpable content" ]
      }
    }
  },
  "label": {
    "categories": [ "flow content", "phrasing content", "interactive content", "form-associated content", "palpable content" ],
    "content": [ "phrasing content" ],
    "disallow": [ "<label>" ]
  },
  "legend": {
    "content": [ "phrasing content" ],
    "parent": [ "<fieldset>" ],
    "position": [ "first" ]
  },
  "meter": {
    "categories": [ "flow content", "phrasing content", "form-associated content", "labelable", "palpable content" ],
    "content": [ "phrasing content" ],
    "disallow": [ "<meter>" ],
    "nospec": [ "4.01" ]
  },
  "optgroup": {
    "content": [ "<option>" ],
    "parent": [ "<select>" ]
  },
  "option": {
    "content": [ "text" ],
    "parent": [ "<select>", "<optgroup>", "<datalist>" ]
  },
  "output": {
    "categories": [ "flow content", "phrasing content", "form-associated content", "listed", "labelable", "resettable", "palpable content" ],
    "content": [ "phrasing content" ],
    "nospec": [ "4.01" ]
  },
  "progress": {
    "categories": [ "flow content", "phrasing content", "form-associated content", "labelable", "palpable content" ],
    "content": [ "phrasing content" ],
    "disallow": [ "<progress>" ],
    "nospec": [ "4.01" ]
  },
  "select": {
    "categories": [ "flow content", "phrasing content", "interactive content", "form-associated content", "listed", "labelable", "submittable", "resettable" ],
    "content": [ "<optgroup>", "<option>" ]
  },
  "textarea": {
    "categories": [ "flow content", "phrasing content", "interactive content", "form-associated content", "listed", "labelable", "submittable", "resettable" ],
    "content": [ "text" ]
  },

  "details": {
    "categories": [ "flow content", "sectioning root", "interactive content", "palpable content" ],
    "content": [ "<summary>", "flow content" ],
    "nospec": [ "4.01", "5" ],
    "experimental": true
  },
  "dialog": {
    "categories": [ "flow content", "sectioning root" ],
    "content": [ "flow content" ],
    "nospec": [ "4.01", "5" ],
    "experimental": true
  },
   "hgroup": {
    "categories": [ "flow content", "heading content", "palpable content" ],
    "content": [ "<h1>", "<h2>", "<h3>", "<h4>", "<h5>", "<h6>" ],
    "nospec": [ "4.01", "5" ],
    "experimental": true
  },
  "menu": {
    "categories": [ "flow content" ],
    "states": {
      "[type=list], :not([type])": {
        "categories": [ "palpable content" ],
        "content": [ "flow content", "<li>", "<script>", "<template>" ]
      },
      "[type=menu]": {
        "content": [ "<script>", "<template>", "<menu>", "<menuitem>", "<hr>" ]
      }
    },
    "nospec": [ "4.01", "5" ],
    "experimental": true
  },
  "menuitem": {
    "parent": [ "<menu>" ],
    "nospec": [ "4.01", "5" ],
    "experimental": true
  },
  "picture": {
    "categories": [ "flow content", "phrasing content", "embedded content" ],
    "content": [ "<source>", "<img>" ],
    "nospec": [ "4.01", "5", "5.1" ],
    "experimental": true
  },
  "shadow": {
    "content": [ "flow content" ],
    "nospec": [ "4.01", "5", "5.1", "LS" ],
    "experimental": true
  },
  "summary": {
    "content": [ "phrasing content", "heading content" ],
    "parent": [ "<details>" ],
    "nospec": [ "4.01", "5" ],
    "experimental": true
  }
}

},{}],107:[function(require,module,exports){
'use strict';

var elementData = require('../data/elements.json');
var schema = require('../schema/hinfo.schema.json');

// ensure a fresh copy, in case the consumer modifies it
var hinfo = function hinfo() {
  return JSON.parse(JSON.stringify(elementData));
};

hinfo.schema = function () {
  return JSON.parse(JSON.stringify(schema));
};

module.exports = hinfo;
},{"../data/elements.json":106,"../schema/hinfo.schema.json":109}],108:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":107,"dup":3}],109:[function(require,module,exports){
module.exports={
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "html element meta data",
    "description": "schema for html element meta data",
    "type": "object",
    "patternProperties": {
        "^[a-z][a-z\\d]*$": {
            "$ref": "#/definitions/elementDef"
        }
    },
    "additionalProperties": false,
    "definitions": {
        "elementDef": {
            "type": "object",
            "properties": {
                "categories": {
                    "$ref": "#/definitions/categoryArrayDef"
                },
                "content": {
                    "$ref": "#/definitions/stringArrayDef"
                },
                "parent": {
                    "$ref": "#/definitions/stringArrayDef"
                },
                "disallow": {
                    "$ref": "#/definitions/stringArrayDef"
                },
                "ancestor": {
                    "$ref": "#/definitions/stringArrayDef"
                },
                "position": {
                    "$ref": "#/definitions/positionArrayDef"
                },
                "previous": {
                    "$ref": "#/definitions/tagArrayDef"
                },
                "next": {
                    "$ref": "#/definitions/tagArrayDef"
                },
                "states": {
                    "$ref": "#/definitions/stateDef"
                },
                "nospec": {
                    "$ref": "#/definitions/nospecDef"
                },
                "singular": {
                    "type": "boolean"
                },
                "experimental": {
                    "type": "boolean"
                }
            },
            "additionalProperties": false
        },
        "stringArrayDef": {
            "type": "array",
            "items": {
                "type": "string"
            },
            "uniqueItems": true
        },
        "tagArrayDef": {
            "type": "array",
            "items": {
                "type": "string",
                "pattern": "^<[a-z][a-z0-9]*>$"
            },
            "uniqueItems": true
        },
        "categoryArrayDef": {
            "type": "array",
            "items": {
                "enum": [
                    "embedded content",
                    "flow content",
                    "form-associated content",
                    "heading content",
                    "interactive content",
                    "labelable",
                    "listed",
                    "metadata content",
                    "palpable content",
                    "phrasing content",
                    "resettable",
                    "sectioning content",
                    "sectioning root",
                    "submittable"
                ]
            },
            "uniqueItems": true
        },
        "positionArrayDef": {
            "type": "array",
            "items": {
                "enum": [
                    "first",
                    "last"
                ]
            },
            "uniqueItems": true
        },
        "stateDef": {
            "type": "object",
            "patternProperties": {
                "^[\\w\\d :=,<>\\(\\)\\[\\]]+$": {
                    "type": "object",
                    "properties": {
                        "categories": {
                            "$ref": "#/definitions/stringArrayDef"
                        },
                        "content": {
                            "$ref": "#/definitions/stringArrayDef"
                        }
                    },
                    "additionalProperties": false
                }
            },
            "additionalProperties": false
        },
        "nospecDef": {
            "type": "array",
            "minItems": 1,
            "items": {
                "enum": [
                    "4.01",
                    "5",
                    "5.1",
                    "LS"
                ]
            },
            "uniqueItems": true
        }
    }
}
},{}],110:[function(require,module,exports){
'use strict';

var hinfo = require('hinfo');

var nodeDefs = {
  '#document': {
    'content': ['#documentType', '<html>']
  },
  '#documentType': {
    'parent': ['#document']
  },
  '#text': {
    'categories': ['flow content', 'phrasing content', 'palpable content']
  },
  '#comment': {
    'categories': ['flow content']
  },
  '#documentFragment': {
    'content': ['flow content']
  }
};

var ensureArray = function ensureArray(obj, name) {
  if (!Array.isArray(obj[name])) obj[name] = [];
};

var ensureProperties = function ensureProperties(def) {
  ensureArray(def, 'categories');
  ensureArray(def, 'content');
  ensureArray(def, 'parent');
};

var defaultDefs = Object.assign(hinfo(), nodeDefs);

var Html = function Html() {
  var defs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultDefs;

  defs = JSON.parse(JSON.stringify(defs));

  var _tagNames = Object.keys(defs);

  var hasCategory = function hasCategory(tagName, categoryName) {
    return defs[tagName].categories.includes(categoryName);
  };

  var predicates = {
    empty: function empty(tagName) {
      return defs[tagName].content.length === 0;
    },
    metadata: function metadata(tagName) {
      return hasCategory(tagName, 'metadata content');
    },
    inline: function inline(tagName) {
      return hasCategory(tagName, 'phrasing content');
    },
    embedded: function embedded(tagName) {
      return hasCategory(tagName, 'embedded content');
    },
    block: function block(tagName) {
      return hasCategory(tagName, 'flow content') && !predicates.inline(tagName);
    },
    container: function container(tagName) {
      return !predicates.empty(tagName);
    }
  };

  var doesAccept = function doesAccept(tagName, childTagName) {
    if (predicates.empty(tagName)) return false;

    var def = defs[tagName];
    var childDef = defs[childTagName];

    if (childDef.parent.includes('<' + tagName + '>')) return true;

    if (def.content.includes('<' + childTagName + '>') || def.content.includes('#' + childTagName)) return true;

    return childDef.categories.some(function (category) {
      return def.content.includes(category);
    });
  };

  var predicateNames = Object.keys(predicates);

  var maps = {
    accepts: {}
  };

  predicateNames.forEach(function (name) {
    return maps[name] = {};
  });

  var allCategories = [];

  _tagNames.forEach(function (tagName) {
    var def = defs[tagName];

    ensureProperties(def);

    allCategories = allCategories.concat(def.categories);

    predicateNames.forEach(function (predicateName) {
      return maps[predicateName][tagName] = predicates[predicateName](tagName);
    });

    maps.accepts[tagName] = {};

    _tagNames.forEach(function (childTagName) {
      ensureProperties(defs[childTagName]);

      maps.accepts[tagName][childTagName] = doesAccept(tagName, childTagName);
    });
  });

  var _categoryNames = Array.from(new Set(allCategories)).sort();

  var api = {
    tagNames: function tagNames() {
      return _tagNames;
    },
    categoryNames: function categoryNames() {
      return _categoryNames;
    },
    isEmpty: function isEmpty(tagName) {
      return maps.empty[tagName];
    },
    isMetadata: function isMetadata(tagName) {
      return maps.metadata[tagName];
    },
    isInline: function isInline(tagName) {
      return maps.inline[tagName];
    },
    isEmbedded: function isEmbedded(tagName) {
      return maps.embedded[tagName];
    },
    isBlock: function isBlock(tagName) {
      return maps.block[tagName];
    },
    isContainer: function isContainer(tagName) {
      return maps.container[tagName];
    },
    accepts: function accepts(tagName, childTagName) {
      return maps.accepts[tagName][childTagName];
    },
    def: function def(tagName) {
      if (defs[tagName]) return JSON.parse(JSON.stringify(defs[tagName]));
    }
  };

  return api;
};

module.exports = Html;
},{"hinfo":108}],111:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":110,"dup":3}],112:[function(require,module,exports){
module.exports = CollectingHandler;

function CollectingHandler(cbs){
	this._cbs = cbs || {};
	this.events = [];
}

var EVENTS = require("./").EVENTS;
Object.keys(EVENTS).forEach(function(name){
	if(EVENTS[name] === 0){
		name = "on" + name;
		CollectingHandler.prototype[name] = function(){
			this.events.push([name]);
			if(this._cbs[name]) this._cbs[name]();
		};
	} else if(EVENTS[name] === 1){
		name = "on" + name;
		CollectingHandler.prototype[name] = function(a){
			this.events.push([name, a]);
			if(this._cbs[name]) this._cbs[name](a);
		};
	} else if(EVENTS[name] === 2){
		name = "on" + name;
		CollectingHandler.prototype[name] = function(a, b){
			this.events.push([name, a, b]);
			if(this._cbs[name]) this._cbs[name](a, b);
		};
	} else {
		throw Error("wrong number of arguments");
	}
});

CollectingHandler.prototype.onreset = function(){
	this.events = [];
	if(this._cbs.onreset) this._cbs.onreset();
};

CollectingHandler.prototype.restart = function(){
	if(this._cbs.onreset) this._cbs.onreset();

	for(var i = 0, len = this.events.length; i < len; i++){
		if(this._cbs[this.events[i][0]]){

			var num = this.events[i].length;

			if(num === 1){
				this._cbs[this.events[i][0]]();
			} else if(num === 2){
				this._cbs[this.events[i][0]](this.events[i][1]);
			} else {
				this._cbs[this.events[i][0]](this.events[i][1], this.events[i][2]);
			}
		}
	}
};

},{"./":119}],113:[function(require,module,exports){
var index = require("./index.js"),
    DomHandler = index.DomHandler,
    DomUtils = index.DomUtils;

//TODO: make this a streamable handler
function FeedHandler(callback, options){
	this.init(callback, options);
}

require("inherits")(FeedHandler, DomHandler);

FeedHandler.prototype.init = DomHandler;

function getElements(what, where){
	return DomUtils.getElementsByTagName(what, where, true);
}
function getOneElement(what, where){
	return DomUtils.getElementsByTagName(what, where, true, 1)[0];
}
function fetch(what, where, recurse){
	return DomUtils.getText(
		DomUtils.getElementsByTagName(what, where, recurse, 1)
	).trim();
}

function addConditionally(obj, prop, what, where, recurse){
	var tmp = fetch(what, where, recurse);
	if(tmp) obj[prop] = tmp;
}

var isValidFeed = function(value){
	return value === "rss" || value === "feed" || value === "rdf:RDF";
};

FeedHandler.prototype.onend = function(){
	var feed = {},
	    feedRoot = getOneElement(isValidFeed, this.dom),
	    tmp, childs;

	if(feedRoot){
		if(feedRoot.name === "feed"){
			childs = feedRoot.children;

			feed.type = "atom";
			addConditionally(feed, "id", "id", childs);
			addConditionally(feed, "title", "title", childs);
			if((tmp = getOneElement("link", childs)) && (tmp = tmp.attribs) && (tmp = tmp.href)) feed.link = tmp;
			addConditionally(feed, "description", "subtitle", childs);
			if((tmp = fetch("updated", childs))) feed.updated = new Date(tmp);
			addConditionally(feed, "author", "email", childs, true);

			feed.items = getElements("entry", childs).map(function(item){
				var entry = {}, tmp;

				item = item.children;

				addConditionally(entry, "id", "id", item);
				addConditionally(entry, "title", "title", item);
				if((tmp = getOneElement("link", item)) && (tmp = tmp.attribs) && (tmp = tmp.href)) entry.link = tmp;
				if((tmp = fetch("summary", item) || fetch("content", item))) entry.description = tmp;
				if((tmp = fetch("updated", item))) entry.pubDate = new Date(tmp);
				return entry;
			});
		} else {
			childs = getOneElement("channel", feedRoot.children).children;

			feed.type = feedRoot.name.substr(0, 3);
			feed.id = "";
			addConditionally(feed, "title", "title", childs);
			addConditionally(feed, "link", "link", childs);
			addConditionally(feed, "description", "description", childs);
			if((tmp = fetch("lastBuildDate", childs))) feed.updated = new Date(tmp);
			addConditionally(feed, "author", "managingEditor", childs, true);

			feed.items = getElements("item", feedRoot.children).map(function(item){
				var entry = {}, tmp;

				item = item.children;

				addConditionally(entry, "id", "guid", item);
				addConditionally(entry, "title", "title", item);
				addConditionally(entry, "link", "link", item);
				addConditionally(entry, "description", "description", item);
				if((tmp = fetch("pubDate", item))) entry.pubDate = new Date(tmp);
				return entry;
			});
		}
	}
	this.dom = feed;
	DomHandler.prototype._handleCallback.call(
		this, feedRoot ? null : Error("couldn't find root of feed")
	);
};

module.exports = FeedHandler;

},{"./index.js":119,"inherits":121}],114:[function(require,module,exports){
var Tokenizer = require("./Tokenizer.js");

/*
	Options:

	xmlMode: Disables the special behavior for script/style tags (false by default)
	lowerCaseAttributeNames: call .toLowerCase for each attribute name (true if xmlMode is `false`)
	lowerCaseTags: call .toLowerCase for each tag name (true if xmlMode is `false`)
*/

/*
	Callbacks:

	oncdataend,
	oncdatastart,
	onclosetag,
	oncomment,
	oncommentend,
	onerror,
	onopentag,
	onprocessinginstruction,
	onreset,
	ontext
*/

var formTags = {
	input: true,
	option: true,
	optgroup: true,
	select: true,
	button: true,
	datalist: true,
	textarea: true
};

var openImpliesClose = {
	tr      : { tr:true, th:true, td:true },
	th      : { th:true },
	td      : { thead:true, th:true, td:true },
	body    : { head:true, link:true, script:true },
	li      : { li:true },
	p       : { p:true },
	h1      : { p:true },
	h2      : { p:true },
	h3      : { p:true },
	h4      : { p:true },
	h5      : { p:true },
	h6      : { p:true },
	select  : formTags,
	input   : formTags,
	output  : formTags,
	button  : formTags,
	datalist: formTags,
	textarea: formTags,
	option  : { option:true },
	optgroup: { optgroup:true }
};

var voidElements = {
	__proto__: null,
	area: true,
	base: true,
	basefont: true,
	br: true,
	col: true,
	command: true,
	embed: true,
	frame: true,
	hr: true,
	img: true,
	input: true,
	isindex: true,
	keygen: true,
	link: true,
	meta: true,
	param: true,
	source: true,
	track: true,
	wbr: true,

	//common self closing svg elements
	path: true,
	circle: true,
	ellipse: true,
	line: true,
	rect: true,
	use: true,
	stop: true,
	polyline: true,
	polygon: true
};

var re_nameEnd = /\s|\//;

function Parser(cbs, options){
	this._options = options || {};
	this._cbs = cbs || {};

	this._tagname = "";
	this._attribname = "";
	this._attribvalue = "";
	this._attribs = null;
	this._stack = [];

	this.startIndex = 0;
	this.endIndex = null;

	this._lowerCaseTagNames = "lowerCaseTags" in this._options ?
									!!this._options.lowerCaseTags :
									!this._options.xmlMode;
	this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ?
									!!this._options.lowerCaseAttributeNames :
									!this._options.xmlMode;

	if(this._options.Tokenizer) {
		Tokenizer = this._options.Tokenizer;
	}
	this._tokenizer = new Tokenizer(this._options, this);

	if(this._cbs.onparserinit) this._cbs.onparserinit(this);
}

require("inherits")(Parser, require("events").EventEmitter);

Parser.prototype._updatePosition = function(initialOffset){
	if(this.endIndex === null){
		if(this._tokenizer._sectionStart <= initialOffset){
			this.startIndex = 0;
		} else {
			this.startIndex = this._tokenizer._sectionStart - initialOffset;
		}
	}
	else this.startIndex = this.endIndex + 1;
	this.endIndex = this._tokenizer.getAbsoluteIndex();
};

//Tokenizer event handlers
Parser.prototype.ontext = function(data){
	this._updatePosition(1);
	this.endIndex--;

	if(this._cbs.ontext) this._cbs.ontext(data);
};

Parser.prototype.onopentagname = function(name){
	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	this._tagname = name;

	if(!this._options.xmlMode && name in openImpliesClose) {
		for(
			var el;
			(el = this._stack[this._stack.length - 1]) in openImpliesClose[name];
			this.onclosetag(el)
		);
	}

	if(this._options.xmlMode || !(name in voidElements)){
		this._stack.push(name);
	}

	if(this._cbs.onopentagname) this._cbs.onopentagname(name);
	if(this._cbs.onopentag) this._attribs = {};
};

Parser.prototype.onopentagend = function(){
	this._updatePosition(1);

	if(this._attribs){
		if(this._cbs.onopentag) this._cbs.onopentag(this._tagname, this._attribs);
		this._attribs = null;
	}

	if(!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements){
		this._cbs.onclosetag(this._tagname);
	}

	this._tagname = "";
};

Parser.prototype.onclosetag = function(name){
	this._updatePosition(1);

	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	if(this._stack.length && (!(name in voidElements) || this._options.xmlMode)){
		var pos = this._stack.lastIndexOf(name);
		if(pos !== -1){
			if(this._cbs.onclosetag){
				pos = this._stack.length - pos;
				while(pos--) this._cbs.onclosetag(this._stack.pop());
			}
			else this._stack.length = pos;
		} else if(name === "p" && !this._options.xmlMode){
			this.onopentagname(name);
			this._closeCurrentTag();
		}
	} else if(!this._options.xmlMode && (name === "br" || name === "p")){
		this.onopentagname(name);
		this._closeCurrentTag();
	}
};

Parser.prototype.onselfclosingtag = function(){
	if(this._options.xmlMode || this._options.recognizeSelfClosing){
		this._closeCurrentTag();
	} else {
		this.onopentagend();
	}
};

Parser.prototype._closeCurrentTag = function(){
	var name = this._tagname;

	this.onopentagend();

	//self-closing tags will be on the top of the stack
	//(cheaper check than in onclosetag)
	if(this._stack[this._stack.length - 1] === name){
		if(this._cbs.onclosetag){
			this._cbs.onclosetag(name);
		}
		this._stack.pop();
	}
};

Parser.prototype.onattribname = function(name){
	if(this._lowerCaseAttributeNames){
		name = name.toLowerCase();
	}
	this._attribname = name;
};

Parser.prototype.onattribdata = function(value){
	this._attribvalue += value;
};

Parser.prototype.onattribend = function(){
	if(this._cbs.onattribute) this._cbs.onattribute(this._attribname, this._attribvalue);
	if(
		this._attribs &&
		!Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)
	){
		this._attribs[this._attribname] = this._attribvalue;
	}
	this._attribname = "";
	this._attribvalue = "";
};

Parser.prototype._getInstructionName = function(value){
	var idx = value.search(re_nameEnd),
	    name = idx < 0 ? value : value.substr(0, idx);

	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	return name;
};

Parser.prototype.ondeclaration = function(value){
	if(this._cbs.onprocessinginstruction){
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("!" + name, "!" + value);
	}
};

Parser.prototype.onprocessinginstruction = function(value){
	if(this._cbs.onprocessinginstruction){
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("?" + name, "?" + value);
	}
};

Parser.prototype.oncomment = function(value){
	this._updatePosition(4);

	if(this._cbs.oncomment) this._cbs.oncomment(value);
	if(this._cbs.oncommentend) this._cbs.oncommentend();
};

Parser.prototype.oncdata = function(value){
	this._updatePosition(1);

	if(this._options.xmlMode || this._options.recognizeCDATA){
		if(this._cbs.oncdatastart) this._cbs.oncdatastart();
		if(this._cbs.ontext) this._cbs.ontext(value);
		if(this._cbs.oncdataend) this._cbs.oncdataend();
	} else {
		this.oncomment("[CDATA[" + value + "]]");
	}
};

Parser.prototype.onerror = function(err){
	if(this._cbs.onerror) this._cbs.onerror(err);
};

Parser.prototype.onend = function(){
	if(this._cbs.onclosetag){
		for(
			var i = this._stack.length;
			i > 0;
			this._cbs.onclosetag(this._stack[--i])
		);
	}
	if(this._cbs.onend) this._cbs.onend();
};


//Resets the parser to a blank state, ready to parse a new HTML document
Parser.prototype.reset = function(){
	if(this._cbs.onreset) this._cbs.onreset();
	this._tokenizer.reset();

	this._tagname = "";
	this._attribname = "";
	this._attribs = null;
	this._stack = [];

	if(this._cbs.onparserinit) this._cbs.onparserinit(this);
};

//Parses a complete HTML document and pushes it to the handler
Parser.prototype.parseComplete = function(data){
	this.reset();
	this.end(data);
};

Parser.prototype.write = function(chunk){
	this._tokenizer.write(chunk);
};

Parser.prototype.end = function(chunk){
	this._tokenizer.end(chunk);
};

Parser.prototype.pause = function(){
	this._tokenizer.pause();
};

Parser.prototype.resume = function(){
	this._tokenizer.resume();
};

//alias for backwards compat
Parser.prototype.parseChunk = Parser.prototype.write;
Parser.prototype.done = Parser.prototype.end;

module.exports = Parser;

},{"./Tokenizer.js":117,"events":105,"inherits":121}],115:[function(require,module,exports){
module.exports = ProxyHandler;

function ProxyHandler(cbs){
	this._cbs = cbs || {};
}

var EVENTS = require("./").EVENTS;
Object.keys(EVENTS).forEach(function(name){
	if(EVENTS[name] === 0){
		name = "on" + name;
		ProxyHandler.prototype[name] = function(){
			if(this._cbs[name]) this._cbs[name]();
		};
	} else if(EVENTS[name] === 1){
		name = "on" + name;
		ProxyHandler.prototype[name] = function(a){
			if(this._cbs[name]) this._cbs[name](a);
		};
	} else if(EVENTS[name] === 2){
		name = "on" + name;
		ProxyHandler.prototype[name] = function(a, b){
			if(this._cbs[name]) this._cbs[name](a, b);
		};
	} else {
		throw Error("wrong number of arguments");
	}
});
},{"./":119}],116:[function(require,module,exports){
module.exports = Stream;

var Parser = require("./WritableStream.js");

function Stream(options){
	Parser.call(this, new Cbs(this), options);
}

require("inherits")(Stream, Parser);

Stream.prototype.readable = true;

function Cbs(scope){
	this.scope = scope;
}

var EVENTS = require("../").EVENTS;

Object.keys(EVENTS).forEach(function(name){
	if(EVENTS[name] === 0){
		Cbs.prototype["on" + name] = function(){
			this.scope.emit(name);
		};
	} else if(EVENTS[name] === 1){
		Cbs.prototype["on" + name] = function(a){
			this.scope.emit(name, a);
		};
	} else if(EVENTS[name] === 2){
		Cbs.prototype["on" + name] = function(a, b){
			this.scope.emit(name, a, b);
		};
	} else {
		throw Error("wrong number of arguments!");
	}
});
},{"../":119,"./WritableStream.js":118,"inherits":121}],117:[function(require,module,exports){
module.exports = Tokenizer;

var decodeCodePoint = require("entities/lib/decode_codepoint.js"),
    entityMap = require("entities/maps/entities.json"),
    legacyMap = require("entities/maps/legacy.json"),
    xmlMap    = require("entities/maps/xml.json"),

    i = 0,

    TEXT                      = i++,
    BEFORE_TAG_NAME           = i++, //after <
    IN_TAG_NAME               = i++,
    IN_SELF_CLOSING_TAG       = i++,
    BEFORE_CLOSING_TAG_NAME   = i++,
    IN_CLOSING_TAG_NAME       = i++,
    AFTER_CLOSING_TAG_NAME    = i++,

    //attributes
    BEFORE_ATTRIBUTE_NAME     = i++,
    IN_ATTRIBUTE_NAME         = i++,
    AFTER_ATTRIBUTE_NAME      = i++,
    BEFORE_ATTRIBUTE_VALUE    = i++,
    IN_ATTRIBUTE_VALUE_DQ     = i++, // "
    IN_ATTRIBUTE_VALUE_SQ     = i++, // '
    IN_ATTRIBUTE_VALUE_NQ     = i++,

    //declarations
    BEFORE_DECLARATION        = i++, // !
    IN_DECLARATION            = i++,

    //processing instructions
    IN_PROCESSING_INSTRUCTION = i++, // ?

    //comments
    BEFORE_COMMENT            = i++,
    IN_COMMENT                = i++,
    AFTER_COMMENT_1           = i++,
    AFTER_COMMENT_2           = i++,

    //cdata
    BEFORE_CDATA_1            = i++, // [
    BEFORE_CDATA_2            = i++, // C
    BEFORE_CDATA_3            = i++, // D
    BEFORE_CDATA_4            = i++, // A
    BEFORE_CDATA_5            = i++, // T
    BEFORE_CDATA_6            = i++, // A
    IN_CDATA                  = i++, // [
    AFTER_CDATA_1             = i++, // ]
    AFTER_CDATA_2             = i++, // ]

    //special tags
    BEFORE_SPECIAL            = i++, //S
    BEFORE_SPECIAL_END        = i++,   //S

    BEFORE_SCRIPT_1           = i++, //C
    BEFORE_SCRIPT_2           = i++, //R
    BEFORE_SCRIPT_3           = i++, //I
    BEFORE_SCRIPT_4           = i++, //P
    BEFORE_SCRIPT_5           = i++, //T
    AFTER_SCRIPT_1            = i++, //C
    AFTER_SCRIPT_2            = i++, //R
    AFTER_SCRIPT_3            = i++, //I
    AFTER_SCRIPT_4            = i++, //P
    AFTER_SCRIPT_5            = i++, //T

    BEFORE_STYLE_1            = i++, //T
    BEFORE_STYLE_2            = i++, //Y
    BEFORE_STYLE_3            = i++, //L
    BEFORE_STYLE_4            = i++, //E
    AFTER_STYLE_1             = i++, //T
    AFTER_STYLE_2             = i++, //Y
    AFTER_STYLE_3             = i++, //L
    AFTER_STYLE_4             = i++, //E

    BEFORE_ENTITY             = i++, //&
    BEFORE_NUMERIC_ENTITY     = i++, //#
    IN_NAMED_ENTITY           = i++,
    IN_NUMERIC_ENTITY         = i++,
    IN_HEX_ENTITY             = i++, //X

    j = 0,

    SPECIAL_NONE              = j++,
    SPECIAL_SCRIPT            = j++,
    SPECIAL_STYLE             = j++;

function whitespace(c){
	return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}

function characterState(char, SUCCESS){
	return function(c){
		if(c === char) this._state = SUCCESS;
	};
}

function ifElseState(upper, SUCCESS, FAILURE){
	var lower = upper.toLowerCase();

	if(upper === lower){
		return function(c){
			if(c === lower){
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	} else {
		return function(c){
			if(c === lower || c === upper){
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	}
}

function consumeSpecialNameChar(upper, NEXT_STATE){
	var lower = upper.toLowerCase();

	return function(c){
		if(c === lower || c === upper){
			this._state = NEXT_STATE;
		} else {
			this._state = IN_TAG_NAME;
			this._index--; //consume the token again
		}
	};
}

function Tokenizer(options, cbs){
	this._state = TEXT;
	this._buffer = "";
	this._sectionStart = 0;
	this._index = 0;
	this._bufferOffset = 0; //chars removed from _buffer
	this._baseState = TEXT;
	this._special = SPECIAL_NONE;
	this._cbs = cbs;
	this._running = true;
	this._ended = false;
	this._xmlMode = !!(options && options.xmlMode);
	this._decodeEntities = !!(options && options.decodeEntities);
}

Tokenizer.prototype._stateText = function(c){
	if(c === "<"){
		if(this._index > this._sectionStart){
			this._cbs.ontext(this._getSection());
		}
		this._state = BEFORE_TAG_NAME;
		this._sectionStart = this._index;
	} else if(this._decodeEntities && this._special === SPECIAL_NONE && c === "&"){
		if(this._index > this._sectionStart){
			this._cbs.ontext(this._getSection());
		}
		this._baseState = TEXT;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateBeforeTagName = function(c){
	if(c === "/"){
		this._state = BEFORE_CLOSING_TAG_NAME;
	} else if(c === "<"){
		this._cbs.ontext(this._getSection());
		this._sectionStart = this._index;
	} else if(c === ">" || this._special !== SPECIAL_NONE || whitespace(c)) {
		this._state = TEXT;
	} else if(c === "!"){
		this._state = BEFORE_DECLARATION;
		this._sectionStart = this._index + 1;
	} else if(c === "?"){
		this._state = IN_PROCESSING_INSTRUCTION;
		this._sectionStart = this._index + 1;
	} else {
		this._state = (!this._xmlMode && (c === "s" || c === "S")) ?
						BEFORE_SPECIAL : IN_TAG_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInTagName = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._emitToken("onopentagname");
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateBeforeCloseingTagName = function(c){
	if(whitespace(c));
	else if(c === ">"){
		this._state = TEXT;
	} else if(this._special !== SPECIAL_NONE){
		if(c === "s" || c === "S"){
			this._state = BEFORE_SPECIAL_END;
		} else {
			this._state = TEXT;
			this._index--;
		}
	} else {
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInCloseingTagName = function(c){
	if(c === ">" || whitespace(c)){
		this._emitToken("onclosetag");
		this._state = AFTER_CLOSING_TAG_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateAfterCloseingTagName = function(c){
	//skip everything until ">"
	if(c === ">"){
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer.prototype._stateBeforeAttributeName = function(c){
	if(c === ">"){
		this._cbs.onopentagend();
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c === "/"){
		this._state = IN_SELF_CLOSING_TAG;
	} else if(!whitespace(c)){
		this._state = IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInSelfClosingTag = function(c){
	if(c === ">"){
		this._cbs.onselfclosingtag();
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(!whitespace(c)){
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateInAttributeName = function(c){
	if(c === "=" || c === "/" || c === ">" || whitespace(c)){
		this._cbs.onattribname(this._getSection());
		this._sectionStart = -1;
		this._state = AFTER_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateAfterAttributeName = function(c){
	if(c === "="){
		this._state = BEFORE_ATTRIBUTE_VALUE;
	} else if(c === "/" || c === ">"){
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if(!whitespace(c)){
		this._cbs.onattribend();
		this._state = IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateBeforeAttributeValue = function(c){
	if(c === "\""){
		this._state = IN_ATTRIBUTE_VALUE_DQ;
		this._sectionStart = this._index + 1;
	} else if(c === "'"){
		this._state = IN_ATTRIBUTE_VALUE_SQ;
		this._sectionStart = this._index + 1;
	} else if(!whitespace(c)){
		this._state = IN_ATTRIBUTE_VALUE_NQ;
		this._sectionStart = this._index;
		this._index--; //reconsume token
	}
};

Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function(c){
	if(c === "\""){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInAttributeValueSingleQuotes = function(c){
	if(c === "'"){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInAttributeValueNoQuotes = function(c){
	if(whitespace(c) || c === ">"){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateBeforeDeclaration = function(c){
	this._state = c === "[" ? BEFORE_CDATA_1 :
					c === "-" ? BEFORE_COMMENT :
						IN_DECLARATION;
};

Tokenizer.prototype._stateInDeclaration = function(c){
	if(c === ">"){
		this._cbs.ondeclaration(this._getSection());
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer.prototype._stateInProcessingInstruction = function(c){
	if(c === ">"){
		this._cbs.onprocessinginstruction(this._getSection());
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer.prototype._stateBeforeComment = function(c){
	if(c === "-"){
		this._state = IN_COMMENT;
		this._sectionStart = this._index + 1;
	} else {
		this._state = IN_DECLARATION;
	}
};

Tokenizer.prototype._stateInComment = function(c){
	if(c === "-") this._state = AFTER_COMMENT_1;
};

Tokenizer.prototype._stateAfterComment1 = function(c){
	if(c === "-"){
		this._state = AFTER_COMMENT_2;
	} else {
		this._state = IN_COMMENT;
	}
};

Tokenizer.prototype._stateAfterComment2 = function(c){
	if(c === ">"){
		//remove 2 trailing chars
		this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c !== "-"){
		this._state = IN_COMMENT;
	}
	// else: stay in AFTER_COMMENT_2 (`--->`)
};

Tokenizer.prototype._stateBeforeCdata1 = ifElseState("C", BEFORE_CDATA_2, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata2 = ifElseState("D", BEFORE_CDATA_3, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata3 = ifElseState("A", BEFORE_CDATA_4, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata4 = ifElseState("T", BEFORE_CDATA_5, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata5 = ifElseState("A", BEFORE_CDATA_6, IN_DECLARATION);

Tokenizer.prototype._stateBeforeCdata6 = function(c){
	if(c === "["){
		this._state = IN_CDATA;
		this._sectionStart = this._index + 1;
	} else {
		this._state = IN_DECLARATION;
		this._index--;
	}
};

Tokenizer.prototype._stateInCdata = function(c){
	if(c === "]") this._state = AFTER_CDATA_1;
};

Tokenizer.prototype._stateAfterCdata1 = characterState("]", AFTER_CDATA_2);

Tokenizer.prototype._stateAfterCdata2 = function(c){
	if(c === ">"){
		//remove 2 trailing chars
		this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c !== "]") {
		this._state = IN_CDATA;
	}
	//else: stay in AFTER_CDATA_2 (`]]]>`)
};

Tokenizer.prototype._stateBeforeSpecial = function(c){
	if(c === "c" || c === "C"){
		this._state = BEFORE_SCRIPT_1;
	} else if(c === "t" || c === "T"){
		this._state = BEFORE_STYLE_1;
	} else {
		this._state = IN_TAG_NAME;
		this._index--; //consume the token again
	}
};

Tokenizer.prototype._stateBeforeSpecialEnd = function(c){
	if(this._special === SPECIAL_SCRIPT && (c === "c" || c === "C")){
		this._state = AFTER_SCRIPT_1;
	} else if(this._special === SPECIAL_STYLE && (c === "t" || c === "T")){
		this._state = AFTER_STYLE_1;
	}
	else this._state = TEXT;
};

Tokenizer.prototype._stateBeforeScript1 = consumeSpecialNameChar("R", BEFORE_SCRIPT_2);
Tokenizer.prototype._stateBeforeScript2 = consumeSpecialNameChar("I", BEFORE_SCRIPT_3);
Tokenizer.prototype._stateBeforeScript3 = consumeSpecialNameChar("P", BEFORE_SCRIPT_4);
Tokenizer.prototype._stateBeforeScript4 = consumeSpecialNameChar("T", BEFORE_SCRIPT_5);

Tokenizer.prototype._stateBeforeScript5 = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._special = SPECIAL_SCRIPT;
	}
	this._state = IN_TAG_NAME;
	this._index--; //consume the token again
};

Tokenizer.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT);
Tokenizer.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT);
Tokenizer.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT);
Tokenizer.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT);

Tokenizer.prototype._stateAfterScript5 = function(c){
	if(c === ">" || whitespace(c)){
		this._special = SPECIAL_NONE;
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 6;
		this._index--; //reconsume the token
	}
	else this._state = TEXT;
};

Tokenizer.prototype._stateBeforeStyle1 = consumeSpecialNameChar("Y", BEFORE_STYLE_2);
Tokenizer.prototype._stateBeforeStyle2 = consumeSpecialNameChar("L", BEFORE_STYLE_3);
Tokenizer.prototype._stateBeforeStyle3 = consumeSpecialNameChar("E", BEFORE_STYLE_4);

Tokenizer.prototype._stateBeforeStyle4 = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._special = SPECIAL_STYLE;
	}
	this._state = IN_TAG_NAME;
	this._index--; //consume the token again
};

Tokenizer.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT);
Tokenizer.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT);
Tokenizer.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT);

Tokenizer.prototype._stateAfterStyle4 = function(c){
	if(c === ">" || whitespace(c)){
		this._special = SPECIAL_NONE;
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 5;
		this._index--; //reconsume the token
	}
	else this._state = TEXT;
};

Tokenizer.prototype._stateBeforeEntity = ifElseState("#", BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY);
Tokenizer.prototype._stateBeforeNumericEntity = ifElseState("X", IN_HEX_ENTITY, IN_NUMERIC_ENTITY);

//for entities terminated with a semicolon
Tokenizer.prototype._parseNamedEntityStrict = function(){
	//offset = 1
	if(this._sectionStart + 1 < this._index){
		var entity = this._buffer.substring(this._sectionStart + 1, this._index),
		    map = this._xmlMode ? xmlMap : entityMap;

		if(map.hasOwnProperty(entity)){
			this._emitPartial(map[entity]);
			this._sectionStart = this._index + 1;
		}
	}
};


//parses legacy entities (without trailing semicolon)
Tokenizer.prototype._parseLegacyEntity = function(){
	var start = this._sectionStart + 1,
	    limit = this._index - start;

	if(limit > 6) limit = 6; //the max length of legacy entities is 6

	while(limit >= 2){ //the min length of legacy entities is 2
		var entity = this._buffer.substr(start, limit);

		if(legacyMap.hasOwnProperty(entity)){
			this._emitPartial(legacyMap[entity]);
			this._sectionStart += limit + 1;
			return;
		} else {
			limit--;
		}
	}
};

Tokenizer.prototype._stateInNamedEntity = function(c){
	if(c === ";"){
		this._parseNamedEntityStrict();
		if(this._sectionStart + 1 < this._index && !this._xmlMode){
			this._parseLegacyEntity();
		}
		this._state = this._baseState;
	} else if((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")){
		if(this._xmlMode);
		else if(this._sectionStart + 1 === this._index);
		else if(this._baseState !== TEXT){
			if(c !== "="){
				this._parseNamedEntityStrict();
			}
		} else {
			this._parseLegacyEntity();
		}

		this._state = this._baseState;
		this._index--;
	}
};

Tokenizer.prototype._decodeNumericEntity = function(offset, base){
	var sectionStart = this._sectionStart + offset;

	if(sectionStart !== this._index){
		//parse entity
		var entity = this._buffer.substring(sectionStart, this._index);
		var parsed = parseInt(entity, base);

		this._emitPartial(decodeCodePoint(parsed));
		this._sectionStart = this._index;
	} else {
		this._sectionStart--;
	}

	this._state = this._baseState;
};

Tokenizer.prototype._stateInNumericEntity = function(c){
	if(c === ";"){
		this._decodeNumericEntity(2, 10);
		this._sectionStart++;
	} else if(c < "0" || c > "9"){
		if(!this._xmlMode){
			this._decodeNumericEntity(2, 10);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

Tokenizer.prototype._stateInHexEntity = function(c){
	if(c === ";"){
		this._decodeNumericEntity(3, 16);
		this._sectionStart++;
	} else if((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")){
		if(!this._xmlMode){
			this._decodeNumericEntity(3, 16);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

Tokenizer.prototype._cleanup = function (){
	if(this._sectionStart < 0){
		this._buffer = "";
		this._bufferOffset += this._index;
		this._index = 0;
	} else if(this._running){
		if(this._state === TEXT){
			if(this._sectionStart !== this._index){
				this._cbs.ontext(this._buffer.substr(this._sectionStart));
			}
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else if(this._sectionStart === this._index){
			//the section just started
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else {
			//remove everything unnecessary
			this._buffer = this._buffer.substr(this._sectionStart);
			this._index -= this._sectionStart;
			this._bufferOffset += this._sectionStart;
		}

		this._sectionStart = 0;
	}
};

//TODO make events conditional
Tokenizer.prototype.write = function(chunk){
	if(this._ended) this._cbs.onerror(Error(".write() after done!"));

	this._buffer += chunk;
	this._parse();
};

Tokenizer.prototype._parse = function(){
	while(this._index < this._buffer.length && this._running){
		var c = this._buffer.charAt(this._index);
		if(this._state === TEXT) {
			this._stateText(c);
		} else if(this._state === BEFORE_TAG_NAME){
			this._stateBeforeTagName(c);
		} else if(this._state === IN_TAG_NAME) {
			this._stateInTagName(c);
		} else if(this._state === BEFORE_CLOSING_TAG_NAME){
			this._stateBeforeCloseingTagName(c);
		} else if(this._state === IN_CLOSING_TAG_NAME){
			this._stateInCloseingTagName(c);
		} else if(this._state === AFTER_CLOSING_TAG_NAME){
			this._stateAfterCloseingTagName(c);
		} else if(this._state === IN_SELF_CLOSING_TAG){
			this._stateInSelfClosingTag(c);
		}

		/*
		*	attributes
		*/
		else if(this._state === BEFORE_ATTRIBUTE_NAME){
			this._stateBeforeAttributeName(c);
		} else if(this._state === IN_ATTRIBUTE_NAME){
			this._stateInAttributeName(c);
		} else if(this._state === AFTER_ATTRIBUTE_NAME){
			this._stateAfterAttributeName(c);
		} else if(this._state === BEFORE_ATTRIBUTE_VALUE){
			this._stateBeforeAttributeValue(c);
		} else if(this._state === IN_ATTRIBUTE_VALUE_DQ){
			this._stateInAttributeValueDoubleQuotes(c);
		} else if(this._state === IN_ATTRIBUTE_VALUE_SQ){
			this._stateInAttributeValueSingleQuotes(c);
		} else if(this._state === IN_ATTRIBUTE_VALUE_NQ){
			this._stateInAttributeValueNoQuotes(c);
		}

		/*
		*	declarations
		*/
		else if(this._state === BEFORE_DECLARATION){
			this._stateBeforeDeclaration(c);
		} else if(this._state === IN_DECLARATION){
			this._stateInDeclaration(c);
		}

		/*
		*	processing instructions
		*/
		else if(this._state === IN_PROCESSING_INSTRUCTION){
			this._stateInProcessingInstruction(c);
		}

		/*
		*	comments
		*/
		else if(this._state === BEFORE_COMMENT){
			this._stateBeforeComment(c);
		} else if(this._state === IN_COMMENT){
			this._stateInComment(c);
		} else if(this._state === AFTER_COMMENT_1){
			this._stateAfterComment1(c);
		} else if(this._state === AFTER_COMMENT_2){
			this._stateAfterComment2(c);
		}

		/*
		*	cdata
		*/
		else if(this._state === BEFORE_CDATA_1){
			this._stateBeforeCdata1(c);
		} else if(this._state === BEFORE_CDATA_2){
			this._stateBeforeCdata2(c);
		} else if(this._state === BEFORE_CDATA_3){
			this._stateBeforeCdata3(c);
		} else if(this._state === BEFORE_CDATA_4){
			this._stateBeforeCdata4(c);
		} else if(this._state === BEFORE_CDATA_5){
			this._stateBeforeCdata5(c);
		} else if(this._state === BEFORE_CDATA_6){
			this._stateBeforeCdata6(c);
		} else if(this._state === IN_CDATA){
			this._stateInCdata(c);
		} else if(this._state === AFTER_CDATA_1){
			this._stateAfterCdata1(c);
		} else if(this._state === AFTER_CDATA_2){
			this._stateAfterCdata2(c);
		}

		/*
		* special tags
		*/
		else if(this._state === BEFORE_SPECIAL){
			this._stateBeforeSpecial(c);
		} else if(this._state === BEFORE_SPECIAL_END){
			this._stateBeforeSpecialEnd(c);
		}

		/*
		* script
		*/
		else if(this._state === BEFORE_SCRIPT_1){
			this._stateBeforeScript1(c);
		} else if(this._state === BEFORE_SCRIPT_2){
			this._stateBeforeScript2(c);
		} else if(this._state === BEFORE_SCRIPT_3){
			this._stateBeforeScript3(c);
		} else if(this._state === BEFORE_SCRIPT_4){
			this._stateBeforeScript4(c);
		} else if(this._state === BEFORE_SCRIPT_5){
			this._stateBeforeScript5(c);
		}

		else if(this._state === AFTER_SCRIPT_1){
			this._stateAfterScript1(c);
		} else if(this._state === AFTER_SCRIPT_2){
			this._stateAfterScript2(c);
		} else if(this._state === AFTER_SCRIPT_3){
			this._stateAfterScript3(c);
		} else if(this._state === AFTER_SCRIPT_4){
			this._stateAfterScript4(c);
		} else if(this._state === AFTER_SCRIPT_5){
			this._stateAfterScript5(c);
		}

		/*
		* style
		*/
		else if(this._state === BEFORE_STYLE_1){
			this._stateBeforeStyle1(c);
		} else if(this._state === BEFORE_STYLE_2){
			this._stateBeforeStyle2(c);
		} else if(this._state === BEFORE_STYLE_3){
			this._stateBeforeStyle3(c);
		} else if(this._state === BEFORE_STYLE_4){
			this._stateBeforeStyle4(c);
		}

		else if(this._state === AFTER_STYLE_1){
			this._stateAfterStyle1(c);
		} else if(this._state === AFTER_STYLE_2){
			this._stateAfterStyle2(c);
		} else if(this._state === AFTER_STYLE_3){
			this._stateAfterStyle3(c);
		} else if(this._state === AFTER_STYLE_4){
			this._stateAfterStyle4(c);
		}

		/*
		* entities
		*/
		else if(this._state === BEFORE_ENTITY){
			this._stateBeforeEntity(c);
		} else if(this._state === BEFORE_NUMERIC_ENTITY){
			this._stateBeforeNumericEntity(c);
		} else if(this._state === IN_NAMED_ENTITY){
			this._stateInNamedEntity(c);
		} else if(this._state === IN_NUMERIC_ENTITY){
			this._stateInNumericEntity(c);
		} else if(this._state === IN_HEX_ENTITY){
			this._stateInHexEntity(c);
		}

		else {
			this._cbs.onerror(Error("unknown _state"), this._state);
		}

		this._index++;
	}

	this._cleanup();
};

Tokenizer.prototype.pause = function(){
	this._running = false;
};
Tokenizer.prototype.resume = function(){
	this._running = true;

	if(this._index < this._buffer.length){
		this._parse();
	}
	if(this._ended){
		this._finish();
	}
};

Tokenizer.prototype.end = function(chunk){
	if(this._ended) this._cbs.onerror(Error(".end() after done!"));
	if(chunk) this.write(chunk);

	this._ended = true;

	if(this._running) this._finish();
};

Tokenizer.prototype._finish = function(){
	//if there is remaining data, emit it in a reasonable way
	if(this._sectionStart < this._index){
		this._handleTrailingData();
	}

	this._cbs.onend();
};

Tokenizer.prototype._handleTrailingData = function(){
	var data = this._buffer.substr(this._sectionStart);

	if(this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2){
		this._cbs.oncdata(data);
	} else if(this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2){
		this._cbs.oncomment(data);
	} else if(this._state === IN_NAMED_ENTITY && !this._xmlMode){
		this._parseLegacyEntity();
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(this._state === IN_NUMERIC_ENTITY && !this._xmlMode){
		this._decodeNumericEntity(2, 10);
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(this._state === IN_HEX_ENTITY && !this._xmlMode){
		this._decodeNumericEntity(3, 16);
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(
		this._state !== IN_TAG_NAME &&
		this._state !== BEFORE_ATTRIBUTE_NAME &&
		this._state !== BEFORE_ATTRIBUTE_VALUE &&
		this._state !== AFTER_ATTRIBUTE_NAME &&
		this._state !== IN_ATTRIBUTE_NAME &&
		this._state !== IN_ATTRIBUTE_VALUE_SQ &&
		this._state !== IN_ATTRIBUTE_VALUE_DQ &&
		this._state !== IN_ATTRIBUTE_VALUE_NQ &&
		this._state !== IN_CLOSING_TAG_NAME
	){
		this._cbs.ontext(data);
	}
	//else, ignore remaining data
	//TODO add a way to remove current tag
};

Tokenizer.prototype.reset = function(){
	Tokenizer.call(this, {xmlMode: this._xmlMode, decodeEntities: this._decodeEntities}, this._cbs);
};

Tokenizer.prototype.getAbsoluteIndex = function(){
	return this._bufferOffset + this._index;
};

Tokenizer.prototype._getSection = function(){
	return this._buffer.substring(this._sectionStart, this._index);
};

Tokenizer.prototype._emitToken = function(name){
	this._cbs[name](this._getSection());
	this._sectionStart = -1;
};

Tokenizer.prototype._emitPartial = function(value){
	if(this._baseState !== TEXT){
		this._cbs.onattribdata(value); //TODO implement the new event
	} else {
		this._cbs.ontext(value);
	}
};

},{"entities/lib/decode_codepoint.js":99,"entities/maps/entities.json":102,"entities/maps/legacy.json":103,"entities/maps/xml.json":104}],118:[function(require,module,exports){
module.exports = Stream;

var Parser = require("./Parser.js"),
    WritableStream = require("stream").Writable || require("readable-stream").Writable,
    StringDecoder = require("string_decoder").StringDecoder,
    Buffer = require("buffer").Buffer;

function Stream(cbs, options){
	var parser = this._parser = new Parser(cbs, options);
	var decoder = this._decoder = new StringDecoder();

	WritableStream.call(this, {decodeStrings: false});

	this.once("finish", function(){
		parser.end(decoder.end());
	});
}

require("inherits")(Stream, WritableStream);

WritableStream.prototype._write = function(chunk, encoding, cb){
	if(chunk instanceof Buffer) chunk = this._decoder.write(chunk);
	this._parser.write(chunk);
	cb();
};
},{"./Parser.js":114,"buffer":66,"inherits":121,"readable-stream":64,"stream":191,"string_decoder":192}],119:[function(require,module,exports){
var Parser = require("./Parser.js"),
    DomHandler = require("domhandler");

function defineProp(name, value){
	delete module.exports[name];
	module.exports[name] = value;
	return value;
}

module.exports = {
	Parser: Parser,
	Tokenizer: require("./Tokenizer.js"),
	ElementType: require("domelementtype"),
	DomHandler: DomHandler,
	get FeedHandler(){
		return defineProp("FeedHandler", require("./FeedHandler.js"));
	},
	get Stream(){
		return defineProp("Stream", require("./Stream.js"));
	},
	get WritableStream(){
		return defineProp("WritableStream", require("./WritableStream.js"));
	},
	get ProxyHandler(){
		return defineProp("ProxyHandler", require("./ProxyHandler.js"));
	},
	get DomUtils(){
		return defineProp("DomUtils", require("domutils"));
	},
	get CollectingHandler(){
		return defineProp("CollectingHandler", require("./CollectingHandler.js"));
	},
	// For legacy support
	DefaultHandler: DomHandler,
	get RssHandler(){
		return defineProp("RssHandler", this.FeedHandler);
	},
	//helper methods
	parseDOM: function(data, options){
		var handler = new DomHandler(options);
		new Parser(handler, options).end(data);
		return handler.dom;
	},
	parseFeed: function(feed, options){
		var handler = new module.exports.FeedHandler(options);
		new Parser(handler, options).end(feed);
		return handler.dom;
	},
	createDomStream: function(cb, options, elementCb){
		var handler = new DomHandler(cb, options, elementCb);
		return new Parser(handler, options);
	},
	// List of all events that the parser emits
	EVENTS: { /* Format: eventname: number of arguments */
		attribute: 2,
		cdatastart: 0,
		cdataend: 0,
		text: 1,
		processinginstruction: 2,
		comment: 1,
		commentend: 0,
		closetag: 1,
		opentag: 2,
		opentagname: 1,
		error: 1,
		end: 0
	}
};

},{"./CollectingHandler.js":112,"./FeedHandler.js":113,"./Parser.js":114,"./ProxyHandler.js":115,"./Stream.js":116,"./Tokenizer.js":117,"./WritableStream.js":118,"domelementtype":84,"domhandler":85,"domutils":88}],120:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],121:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],122:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],123:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],124:[function(require,module,exports){
'use strict';

var Mtree = require('1tree-factory');

var createTree = require('./plugins/createTree');
var insertBefore = require('./plugins/insertBefore');
var dom = require('./plugins/dom');
var parse = require('./plugins/parse');
var select = require('./plugins/select');
var stringify = require('./plugins/stringify');
var types = require('./plugins/types');
var vdom = require('./plugins/vdom');

var Htree = Mtree(dom, parse, select, stringify, types, vdom);

// add afterwards because the original createTree doesn't exist until now
Htree.plugin(createTree);
// add afterwards so that it wraps parentMap and not the other way round
Htree.plugin(insertBefore);

module.exports = Htree;
},{"./plugins/createTree":127,"./plugins/dom":130,"./plugins/insertBefore":132,"./plugins/parse":133,"./plugins/select":135,"./plugins/stringify":136,"./plugins/types":137,"./plugins/vdom":138,"1tree-factory":3}],125:[function(require,module,exports){
'use strict';

var EntityNode = require('mtype-node');

var DomHandler = function DomHandler(options) {
  var state = State(options);

  var handler = { state: state };

  var api = Api(handler);

  return api;
};

//default options
var defaultOpts = {
  normalizeWhitespace: false
};

var whitespace = /\s+/g;

var State = function State(options) {
  options = options || defaultOpts;

  var dom = EntityNode('documentFragment');
  var done = false;
  var tagStack = [];
  var parser = null;

  var state = {
    options: options, dom: dom, done: done, tagStack: tagStack, parser: parser
  };

  return state;
};

var Api = function Api(handler) {
  var oninit = function oninit(parser) {
    return handler.state.parser = parser;
  };

  var onreset = function onreset() {
    var options = handler.state.options;


    handler.state = State(options);
  };

  var onend = function onend() {
    if (handler.state.done) return;

    handler.state.done = true;
    handler.state.parser = null;
    onerror(null);
  };

  var onerror = function onerror(err) {
    if (err) throw err;
  };

  var onclosetag = function onclosetag() {
    var tagStack = handler.state.tagStack;


    tagStack.pop();
  };

  var onopentag = function onopentag(name, attribs) {
    var tagStack = handler.state.tagStack;


    var element = EntityNode('element', {
      tagName: name,
      attributes: attribs
    });

    addDomElement(handler, element);
    tagStack.push(element);
  };

  var ontext = function ontext(data) {
    var options = handler.state.options;


    var normalize = options.normalizeWhitespace || options.ignoreWhitespace ? function (str) {
      return str.replace(whitespace, ' ');
    } : function (str) {
      return str;
    };

    var previousText = findPreviousText(handler);

    if (previousText) {
      previousText.value.nodeValue = normalize(previousText.nodeValue + data);
    } else {
      data = normalize(data);

      var text = EntityNode('text', { nodeValue: data });

      addDomElement(handler, text);
    }
  };

  var oncomment = function oncomment(data) {
    var tagStack = handler.state.tagStack;


    var lastTag = tagStack[tagStack.length - 1];

    if (lastTag && lastTag.value.nodeType === 'comment') {
      lastTag.value.nodeValue += data;

      return;
    }

    var comment = EntityNode('comment', { nodeValue: data });

    addDomElement(handler, comment);
    tagStack.push(comment);
  };

  var onprocessinginstruction = function onprocessinginstruction(name, data) {
    oncomment(data);
    oncommentend();
  };

  var oncommentend = function oncommentend() {
    return handler.state.tagStack.pop();
  };

  var getDom = function getDom() {
    return handler.state.dom;
  };

  var api = {
    oninit: oninit, onreset: onreset, onend: onend, onerror: onerror, onclosetag: onclosetag, onopentag: onopentag, ontext: ontext, oncomment: oncomment,
    oncommentend: oncommentend, onprocessinginstruction: onprocessinginstruction, getDom: getDom
  };

  return api;
};

var findPreviousText = function findPreviousText(handler) {
  var _handler$state = handler.state,
      tagStack = _handler$state.tagStack,
      dom = _handler$state.dom;


  if (tagStack.length) {
    var lastTag = tagStack[tagStack.length - 1];
    var _children = lastTag.children;

    if (_children.length) {
      var _lastChild = _children[_children.length - 1];

      if (_lastChild.value.nodeType === 'text') return _lastChild;
    }
  }

  var children = dom.children;

  if (!children || !children.length) return;

  var lastChild = children[children.length - 1];

  if (lastChild.value.nodeType === 'text') return lastChild;
};

var addDomElement = function addDomElement(handler, element) {
  var _handler$state2 = handler.state,
      tagStack = _handler$state2.tagStack,
      dom = _handler$state2.dom;


  var parent = tagStack[tagStack.length - 1];
  var target = parent ? parent.children : dom.children;

  target.push(element);
};

module.exports = DomHandler;
},{"mtype-node":165}],126:[function(require,module,exports){
'use strict';

var htmlparser2 = require('htmlparser2');
var DomHandler = require('./domhandler-adapter');

var parse = function parse(str) {
  var handler = DomHandler();
  new htmlparser2.Parser(handler).end(str);

  return handler.getDom();
};

module.exports = parse;
},{"./domhandler-adapter":125,"htmlparser2":119}],127:[function(require,module,exports){
'use strict';

/*
  Extend createTree to allow creating a tree from an HTML string
*/

var parseStr = require('../../parse');

// should be added after the default plugins so that createTree exists!
var createTreeFromStr = function createTreeFromStr(fn) {
  // override createTree to allow passing a string
  var originalCreateTree = fn.createTree;

  var createTree = function createTree(rootValue) {
    if (typeof rootValue === 'string') rootValue = parseStr(rootValue);

    return originalCreateTree(rootValue);
  };

  createTree.def = originalCreateTree.def;

  return Object.assign(fn, { createTree: createTree });
};

module.exports = createTreeFromStr;
},{"../../parse":126}],128:[function(require,module,exports){
'use strict';

var EntityNode = require('mtype-node');
var utils = require('mojule-utils');

var capitalizeFirstLetter = utils.capitalizeFirstLetter;


var nodeMap = {
  element: function element() {
    return {
      tagName: 'div',
      attributes: {}
    };
  },
  comment: function comment() {
    return {
      nodeValue: '',
      isEmpty: true
    };
  },
  text: function text() {
    return {
      nodeValue: '',
      isEmpty: true
    };
  },
  documentType: function documentType() {
    return {
      name: 'html',
      publicId: '',
      systemId: '',
      isEmpty: true
    };
  }
};

var createDomNode = function createDomNode(fn, nodeType, value) {
  var defaultValue = nodeType in nodeMap ? nodeMap[nodeType]() : {};

  value = Object.assign({ nodeType: nodeType }, defaultValue, value || {});

  var entityNode = EntityNode(nodeType, value);

  var node = fn.createNode(entityNode.value);

  var capNodeType = capitalizeFirstLetter(nodeType);
  var assertName = 'assert' + capNodeType;

  fn[assertName](node);

  return node;
};

var createDomNodeDef = function createDomNodeDef(nodeType, argTypes) {
  return {
    argTypes: argTypes,
    returnType: 'node',
    requires: ['createNode', 'assert' + capitalizeFirstLetter(nodeType)],
    categories: ['create', 'plugin']
  };
};

var create = function create(fn) {
  var createElement = function createElement(tagName, attributes) {
    attributes = attributes || {};

    return createDomNode(fn, 'element', { tagName: tagName, attributes: attributes });
  };

  createElement.def = createDomNodeDef('element', ['string', 'object']);

  var createComment = function createComment(nodeValue) {
    return createDomNode(fn, 'element', { nodeValue: nodeValue });
  };

  createComment.def = createDomNodeDef('comment', ['string']);

  var createDocument = function createDocument() {
    return createDomNode(fn, 'document');
  };

  createDocument.def = createDomNodeDef('document', []);

  var createDocumentFragment = function createDocumentFragment() {
    return createDomNode(fn, 'documentFragment');
  };

  createDocumentFragment.def = createDomNodeDef('documentFragment', []);

  var createText = function createText(nodeValue) {
    return createDomNode(fn, 'text', {
      nodeValue: String(nodeValue)
    });
  };

  createText.def = createDomNodeDef('text', ['string']);

  var createDocumentType = function createDocumentType(name, publicId, systemId) {
    return createDomNode(fn, 'documentType', { name: name, publicId: publicId, systemId: systemId });
  };

  createDocumentType.def = createDomNodeDef('documentType', ['string', 'string', 'string']);

  var plugins = {
    createText: createText, createElement: createElement, createComment: createComment, createDocument: createDocument,
    createDocumentFragment: createDocumentFragment, createDocumentType: createDocumentType
  };

  return Object.assign(fn, plugins);
};

module.exports = create;
},{"mojule-utils":161,"mtype-node":165}],129:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var utils = require('mojule-utils');

var clone = utils.clone;


var element = function element(fn) {
  var attributes = function attributes(node, attributeMap) {
    fn.assertElement(node);

    var nodeValue = fn.value(node);

    if ((typeof attributeMap === 'undefined' ? 'undefined' : _typeof(attributeMap)) === 'object') {
      Object.keys(attributeMap).forEach(function (attributeName) {
        var attributeValue = attributeMap[attributeName];

        fn.attr(node, attributeName, attributeValue);
      });
    }

    if (nodeValue.attributes === undefined) return {};

    return clone(nodeValue.attributes);
  };

  attributes.def = {
    argTypes: ['node', 'object?'],
    returnType: 'object',
    requires: ['value', 'assertElement', 'attr'],
    categories: ['dom', 'attributes', 'plugins']
  };

  var tagName = function tagName(node, value) {
    fn.assertElement(node);

    var nodeValue = fn.value(node);

    if (value !== undefined) {
      nodeValue.tagName = value;

      fn.value(node, nodeValue);
    }

    return nodeValue.tagName;
  };

  tagName.def = {
    argTypes: ['node', 'string'],
    returnType: 'string',
    requires: ['value', 'assertElement'],
    categories: ['dom', 'tagName', 'plugins']
  };

  var attr = function attr(node, name, value) {
    fn.assertElement(node);

    var nodeValue = fn.value(node);

    if (value !== undefined) {
      if (nodeValue.attributes === undefined) nodeValue.attributes = {};

      nodeValue.attributes[name] = value.toString();

      fn.value(node, nodeValue);
    }

    if (_typeof(nodeValue.attributes) === 'object') return nodeValue.attributes[name];
  };

  attr.def = {
    argTypes: ['node', 'string', 'string'],
    returnType: 'string',
    requires: ['value', 'assertElement'],
    categories: ['dom', 'attr', 'plugins']
  };

  var hasAttr = function hasAttr(node, name) {
    fn.assertElement(node);

    return fn.attr(node, name) !== undefined;
  };

  hasAttr.def = {
    argTypes: ['node', 'string'],
    returnType: 'boolean',
    requires: ['value', 'assertElement'],
    categories: ['dom', 'hasAttr', 'plugins']
  };

  var removeAttr = function removeAttr(node, name) {
    fn.assertElement(node);

    var nodeValue = fn.value(node);

    if (_typeof(nodeValue.attributes) === 'object') delete nodeValue.attributes[name];

    fn.value(node, nodeValue);
  };

  removeAttr.def = {
    argTypes: ['node', 'string'],
    requires: ['value', 'assertElement'],
    categories: ['dom', 'removeAttr', 'plugins']
  };

  var clearAttrs = function clearAttrs(node) {
    fn.assertElement(node);

    var nodeValue = fn.value(node);

    nodeValue.attributes = {};

    fn.value(node, nodeValue);
  };

  clearAttrs.def = {
    argTypes: ['node'],
    requires: ['value', 'assertElement'],
    categories: ['dom', 'clearAttrs', 'plugins']
  };

  var clearClasses = function clearClasses(node) {
    fn.assertElement(node);

    fn.attr(node, 'class', '');
  };

  clearClasses.def = {
    argTypes: ['node'],
    requires: ['value', 'assertElement'],
    categories: ['dom', 'clearClasses', 'plugins']
  };

  var classNames = function classNames(node) {
    fn.assertElement(node);

    var classNames = fn.attr(node, 'class');

    if (typeof classNames === 'string') return classNames.split(' ');

    return [];
  };

  classNames.def = {
    argTypes: ['node'],
    returnType: '[string]',
    requires: ['attr', 'assertElement'],
    categories: ['dom', 'classNames', 'plugins']
  };

  var hasClass = function hasClass(node, className) {
    fn.assertElement(node);

    return fn.classNames(node).some(function (name) {
      return name === className;
    });
  };

  hasClass.def = {
    argTypes: ['node', 'string'],
    returnType: 'boolean',
    requires: ['classNames', 'assertElement'],
    categories: ['dom', 'hasClass', 'plugins']
  };

  var addClass = function addClass(node, className) {
    fn.assertElement(node);

    className = className.trim();

    var existing = fn.classNames(node);

    existing.push(className);

    fn.attr(node, 'class', existing.join(' '));

    return node;
  };

  addClass.def = {
    argTypes: ['node', 'string'],
    returnType: 'node',
    requires: ['classNames', 'attr', 'assertElement'],
    categories: ['dom', 'addClass', 'plugins']
  };

  var removeClass = function removeClass(node, className) {
    fn.assertElement(node);

    className = className.trim();

    var existing = fn.classNames(node).filter(function (name) {
      return name !== className;
    });

    fn.attr(node, 'class', existing.join(' '));

    return node;
  };

  removeClass.def = {
    argTypes: ['node', 'string'],
    returnType: 'node',
    requires: ['classNames', 'attr', 'assertElement'],
    categories: ['dom', 'removeClass', 'plugins']
  };

  var toggleClass = function toggleClass(node, className, shouldHave) {
    fn.assertElement(node);

    var alreadyHas = fn.hasClass(node, className);

    if (typeof shouldHave !== 'boolean') return fn.toggleClass(node, className, !alreadyHas);

    if (alreadyHas) {
      if (shouldHave) return node;

      return fn.removeClass(node, className);
    }

    if (shouldHave) return fn.addClass(node, className);

    return node;
  };

  toggleClass.def = {
    argTypes: ['node', 'string', 'boolean'],
    returnType: 'node',
    requires: ['hasClass', 'removeClass', 'addClass', 'assertElement'],
    categories: ['dom', 'toggleClass', 'plugins']
  };

  var plugins = {
    attributes: attributes, attr: attr, hasAttr: hasAttr, removeAttr: removeAttr, classNames: classNames, hasClass: hasClass, addClass: addClass,
    removeClass: removeClass, toggleClass: toggleClass, tagName: tagName, clearAttrs: clearAttrs, clearClasses: clearClasses
  };

  return Object.assign(fn, plugins);
};

module.exports = element;
},{"mojule-utils":161}],130:[function(require,module,exports){
'use strict';

var element = require('./element');
var create = require('./create');
var node = require('./node');

var dom = function dom(fn) {
  element(fn);
  create(fn);
  node(fn);
};

module.exports = dom;
},{"./create":128,"./element":129,"./node":131}],131:[function(require,module,exports){
'use strict';

var Html = require('html-node');

var html = Html();

var emptyNodeTypes = ['text', 'comment', 'documentType'];

var nodeNameMap = {
  element: function element(fn, node) {
    return fn.tagName(node);
  },
  documentType: function documentType(fn, node) {
    var value = fn.value(node);

    return value.name;
  }
};

var nodePlugins = function nodePlugins(fn) {
  var nodeType = function nodeType(fn, node) {
    var value = fn.value(node);

    return value.nodeType;
  };

  nodeType.def = {
    argTypes: ['fn', 'node'],
    returnType: 'string',
    requires: ['value'],
    categories: ['node', 'plugin']
  };

  var nodeName = function nodeName(fn, node) {
    var nodeType = fn.nodeType(fn, node);

    if (nodeType in nodeNameMap) return nodeNameMap[nodeType](fn, node);

    return '#' + nodeType;
  };

  nodeName.def = {
    argTypes: ['fn', 'node'],
    returnType: 'string',
    requires: ['nodeType'],
    categories: ['node', 'plugin']
  };

  var isEmpty = function isEmpty(fn, node) {
    var nodeType = fn.nodeType(fn, node);

    if (emptyNodeTypes.includes(nodeType)) return true;

    if (nodeType === 'element') {
      var tagName = fn.tagName(node);

      return html.isEmpty(tagName);
    }

    // assumes remaining node types should be able to have children, is this true?
    return false;
  };

  isEmpty.def = {
    argType: ['fn', 'node'],
    returnType: 'boolean',
    require: ['nodeType', 'tagName'],
    categories: ['node', 'plugin']
  };

  var accepts = function accepts(fn, node, childNode) {
    var isEmpty = fn.isEmpty(fn, node);

    if (isEmpty) return false;

    var nodeType = fn.nodeType(fn, node);
    var childNodeType = fn.nodeType(fn, childNode);

    if (childNodeType === 'documentType') return nodeType === 'document';

    if (nodeType === 'element') {
      if (childNodeType === 'text' || childNodeType === 'comment') return true;

      var _nodeName = fn.nodeName(fn, node);
      var childName = fn.nodeName(fn, childNode);

      return html.accepts(_nodeName, childName);
    }

    // assumes non-elements that can have child nodes can have any child node,
    // is this true?
    return true;
  };

  accepts.def = {
    argType: ['fn', 'node', 'node'],
    returnType: 'boolean',
    require: ['isEmpty', 'nodeType', 'nodeName'],
    categories: ['node', 'plugin']
  };

  return Object.assign(fn, { nodeType: nodeType, nodeName: nodeName, isEmpty: isEmpty, accepts: accepts });
};

module.exports = nodePlugins;
},{"html-node":111}],132:[function(require,module,exports){
'use strict';

var insertBeforeWrapper = function insertBeforeWrapper(fn) {
  var originalInsertBefore = fn.insertBefore;

  var insertBefore = function insertBefore(fn, root, parentNode, childNode, referenceNode) {
    // TODO
    // handle document fragments
    // handle combining text elements
    return originalInsertBefore(fn, root, parentNode, childNode, referenceNode);
  };

  insertBefore.def = originalInsertBefore.def;

  return Object.assign(fn, { insertBefore: insertBefore });
};

module.exports = insertBeforeWrapper;
},{}],133:[function(require,module,exports){
'use strict';

var parseStr = require('../../parse');

var parser = function parser(fn) {
  var parse = function parse(str) {
    return fn.deserialize(parseStr(str));
  };

  parse.def = {
    argTypes: ['string'],
    returnType: 'node',
    requires: ['deserialize'],
    categories: ['parser', 'plugin']
  };

  return Object.assign(fn, { parse: parse });
};

module.exports = parser;
},{"../../parse":126}],134:[function(require,module,exports){
'use strict';

var baseAdapter = require('css-select-base-adapter');

var Adapter = function Adapter(fn, root) {
  var isTag = function isTag(node) {
    var value = fn.value(node);

    return value && value.nodeType === 'element';
  };

  var getAttributeValue = function getAttributeValue(node, name) {
    var value = fn.value(node);

    if (value && value.attributes) return value.attributes[name];
  };

  var getChildren = function getChildren(node) {
    return fn.getChildren(node);
  };

  var getName = function getName(node) {
    var value = fn.value(node);

    if (value) return value.tagName;
  };

  var getParent = function getParent(node) {
    return fn.getParent(fn, root, node);
  };

  var getText = function getText(node) {
    if (Array.isArray(node)) return node.map(getText).join('');

    if (isTag(node)) return getText(getChildren(node));

    var value = fn.value(node);

    if (value && value.nodeType === 'text') return value.nodeValue;

    return '';
  };

  var adapter = {
    isTag: isTag, getAttributeValue: getAttributeValue, getChildren: getChildren, getName: getName, getParent: getParent, getText: getText
  };

  return baseAdapter(adapter);
};

module.exports = Adapter;
},{"css-select-base-adapter":72}],135:[function(require,module,exports){
'use strict';

var Adapter = require('./htmlparser2-adapter');
var Select = require('../../select');

var Selecter = function Selecter(fn, root) {
  return Select(Adapter(fn, root));
};

var querySelector = function querySelector(fn) {
  var select = function select(fn, root, node, query) {
    return Selecter(fn, root).select(node, query);
  };

  select.def = {
    argTypes: ['fn', 'rootNode', 'node', 'string'],
    returnType: 'node',
    requires: ['value', 'getChildren', 'getParent'],
    categories: ['query', 'select', 'plugins']
  };

  var selectAll = function selectAll(fn, root, node, query) {
    return Selecter(fn, root).selectAll(node, query);
  };

  selectAll.def = {
    argTypes: ['fn', 'rootNode', 'node', 'string'],
    returnType: '[node]',
    requires: ['value', 'getChildren', 'getParent'],
    categories: ['query', 'select', 'plugins']
  };

  var matches = function matches(fn, root, node, query) {
    return Selecter(fn, root).matches(node, query);
  };

  matches.def = {
    argTypes: ['fn', 'rootNode', 'node', 'string'],
    returnType: 'boolean',
    requires: ['value', 'getChildren', 'getParent'],
    categories: ['query', 'select', 'plugins']
  };

  var plugin = { select: select, selectAll: selectAll, matches: matches };

  return Object.assign(fn, plugin);
};

module.exports = querySelector;
},{"../../select":140,"./htmlparser2-adapter":134}],136:[function(require,module,exports){
'use strict';

var stringifyNode = require('../../stringify');

var stringifier = function stringifier(fn) {
  var stringify = function stringify(node) {
    return stringifyNode(node);
  };

  stringify.def = {
    argTypes: ['node'],
    returnType: 'string',
    requires: [],
    categories: ['stringify', 'plugin']
  };

  return Object.assign(fn, { stringify: stringify });
};

module.exports = stringifier;
},{"../../stringify":141}],137:[function(require,module,exports){
'use strict';

var Validator = require('mtype-tv4');
var schema = require('../../schema');
var utils = require('mojule-utils');

var capitalizeFirstLetter = utils.capitalizeFirstLetter;

// could get this from the names, but better to be explicit

var nodeTypes = ['text', 'element', 'comment', 'document', 'documentType', 'documentFragment'];

var validator = Validator(schema);
var t = Validator.mtype(validator);

var isType = function isType(node, typename) {
  return t.is(node, typename);
};

isType.def = {
  argTypes: ['node', 'string'],
  returnType: 'boolean',
  requires: [],
  categories: ['type', 'plugin']
};

var types = function types(fn) {
  var assertType = function assertType(node, typename) {
    if (!fn.isType(node, typename)) {
      var result = validator.validateMultiple(node, schema[typename]);
      var errors = JSON.stringify(result.errors);

      throw new TypeError('Expected node to be ' + typename + '; ' + errors);
    }
  };

  assertType.def = {
    argTypes: ['node', 'string'],
    requires: ['isType'],
    categories: ['type', 'plugin']
  };

  var plugins = { isType: isType, assertType: assertType };

  // add isDocument, isText etc
  nodeTypes.forEach(function (typename) {
    var capTypename = capitalizeFirstLetter(typename);
    var isName = 'is' + capTypename;
    var assertName = 'assert' + capTypename;

    plugins[isName] = function (node) {
      return fn.isType(node, typename);
    };
    plugins[isName].def = isType.def;

    plugins[assertName] = function (node) {
      return fn.assertType(node, typename);
    };
    plugins[assertName].def = assertType.def;
  });

  return Object.assign(fn, plugins);
};

module.exports = types;
},{"../../schema":139,"mojule-utils":161,"mtype-tv4":171}],138:[function(require,module,exports){
'use strict';

var morphdom = require('morphdom');
var Vnode = require('../../vdom');

var morphdomPlugin = function morphdomPlugin(fn) {
  var patchDom = function patchDom(node, targetEl, options) {
    //Vnode expects wrapped node!
    var wrapped = fn.createTree(node);
    var vdom = Vnode(wrapped);

    morphdom(targetEl, vdom, options);
  };

  patchDom.def = {
    argTypes: ['node', 'object', 'object'],
    requires: ['createTree'],
    categories: ['patch', 'plugin']
  };

  return Object.assign(fn, { morphdom: patchDom });
};

module.exports = morphdomPlugin;
},{"../../vdom":142,"morphdom":162}],139:[function(require,module,exports){
'use strict';

var entityNode = require('mtype-node/schema/entityNode.schema.json');
var entityNodeValue = require('mtype-node/schema/entityNodeValue.schema.json');
var emptyNode = require('mtype-node/schema/emptyNode.schema.json');
var parentNode = require('mtype-node/schema/parentNode.schema.json');

var comment = require('../../schema/comment.schema.json');
var commentValue = require('../../schema/commentValue.schema.json');
var documentFragment = require('../../schema/documentFragment.schema.json');
var documentFragmentValue = require('../../schema/documentFragmentValue.schema.json');
var document = require('../../schema/document.schema.json');
var documentValue = require('../../schema/documentValue.schema.json');
var documentType = require('../../schema/documentType.json');
var documentTypeValue = require('../../schema/documentTypeValue.schema.json');
var element = require('../../schema/element.schema.json');
var elementValue = require('../../schema/elementValue.schema.json');
var text = require('../../schema/text.schema.json');
var textValue = require('../../schema/textValue.schema.json');

var schema = {
  comment: comment, commentValue: commentValue, documentFragment: documentFragment,
  documentFragmentValue: documentFragmentValue, document: document, documentValue: documentValue, documentType: documentType,
  documentTypeValue: documentTypeValue, element: element, elementValue: elementValue, text: text, textValue: textValue,

  entityNode: entityNode, entityNodeValue: entityNodeValue, emptyNode: emptyNode, parentNode: parentNode
};

module.exports = schema;
},{"../../schema/comment.schema.json":144,"../../schema/commentValue.schema.json":145,"../../schema/document.schema.json":146,"../../schema/documentFragment.schema.json":147,"../../schema/documentFragmentValue.schema.json":148,"../../schema/documentType.json":149,"../../schema/documentTypeValue.schema.json":150,"../../schema/documentValue.schema.json":151,"../../schema/element.schema.json":152,"../../schema/elementValue.schema.json":153,"../../schema/text.schema.json":154,"../../schema/textValue.schema.json":155,"mtype-node/schema/emptyNode.schema.json":166,"mtype-node/schema/entityNode.schema.json":167,"mtype-node/schema/entityNodeValue.schema.json":168,"mtype-node/schema/parentNode.schema.json":169}],140:[function(require,module,exports){
'use strict';

var CSSselect = require('css-select');

var Select = function Select(adapter) {
  var options = { adapter: adapter };

  var select = function select(node, selector) {
    return CSSselect.selectOne(selector, node, options);
  };

  var selectAll = function selectAll(node, selector) {
    return CSSselect(selector, node, options);
  };

  var matches = function matches(node, selector) {
    return CSSselect.is(node, selector, options);
  };

  var api = {
    select: select, selectAll: selectAll, matches: matches
  };

  return api;
};

module.exports = Select;
},{"css-select":73}],141:[function(require,module,exports){
'use strict';

var Html = require('html-node');
var utils = require('mojule-utils');

var escapeHtml = utils.escapeHtml;


var info = Html();

var stringify = function stringify(node) {
  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  var html = '';

  var nodeType = node.value.nodeType;


  if (nodeType === 'text') html += escapeHtml(node.value.nodeValue);

  if (nodeType === 'comment') html += '<!--' + node.value.nodeValue + '-->';

  if (nodeType === 'element') {
    (function () {
      var _node$value = node.value,
          tagName = _node$value.tagName,
          attributes = _node$value.attributes;


      html += '<' + tagName;

      if (attributes) Object.keys(attributes).forEach(function (name) {
        var value = attributes[name];

        html += ' ' + name;

        if (value) html += '="' + value + '"';
      });

      html += info.isEmpty(tagName) ? ' />' : '>';

      depth++;
    })();
  }

  if (nodeType === 'documentType') {
    var _node$value2 = node.value,
        name = _node$value2.name,
        publicId = _node$value2.publicId,
        systemId = _node$value2.systemId;


    html += '<!doctype ' + name;

    if (publicId) {
      html += ' public "' + publicId + '"';
    }

    if (systemId) {
      html += ' "' + systemId + '"';
    }

    html += '>';
  }

  if (Array.isArray(node.children)) node.children.forEach(function (child) {
    return html += stringify(child, depth);
  });

  if (nodeType === 'element' && !info.isEmpty(node.value.tagName)) {
    html += '</' + node.value.tagName + '>';
  }

  return html;
};

module.exports = stringify;
},{"html-node":111,"mojule-utils":161}],142:[function(require,module,exports){
'use strict';

var Vnode = function Vnode(node) {
  if (node === null || node === undefined) {
    return node;
  }

  var vnode = {
    get firstChild() {
      return Vnode(node.firstChild());
    },

    get nextSibling() {
      return Vnode(node.nextSibling());
    },

    get nodeType() {
      return node.nodeType();
    },

    get nodeName() {
      return node.nodeName();
    },

    // should be something for svg or math etc.!
    get namespaceURI() {
      return 'http://www.w3.org/1999/xhtml';
    },

    get nodeValue() {
      var value = node.value();

      return value.nodeValue || '';
    },

    get value() {
      var value = node.value();

      return value.value;
    },

    get selected() {
      var value = node.value();

      return !!value.selected;
    },

    get disabled() {
      var value = node.value();

      return !!value.disabled;
    },

    // should be something for svg or math etc.!
    // hasAttributeNS: ( namespaceURI, name ) => {
    hasAttributeNS: function hasAttributeNS(namespaceURI) {
      return namespaceURI === vnode.namespaceURI;
    },

    assignAttributes: function assignAttributes(targetNode) {
      var attributes = node.attributes();

      Object.keys(attributes).forEach(function (name) {
        return targetNode.setAttribute(name, attributes[name]);
      });
    },

    actualize: function actualize(document) {
      return _actualize[vnode.nodeType](document, vnode);
    }
  };

  return vnode;
};

var addChildren = function addChildren(document, el, vnode) {
  var child = vnode.firstChild;

  while (child) {
    el.appendChild(child.actualize(document));
    child = child.nextSibling;
  }
};

var _actualize = {
  text: function text(document, vnode) {
    return document.createTextNode(vnode.nodeValue);
  },
  comment: function comment(document, vnode) {
    return document.createComment(vnode.nodeValue);
  },
  element: function element(document, vnode) {
    var el = document.createElement(vnode.nodeName);

    vnode.assignAttributes(el);

    addChildren(document, el, vnode);

    return el;
  },
  documentFragment: function documentFragment(document, vnode) {
    var el = document.createDocumentFragment();

    addChildren(document, el, vnode);

    return el;
  }
};

module.exports = Vnode;
},{}],143:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":124,"dup":3}],144:[function(require,module,exports){
module.exports={
  "id": "comment",
  "allOf": [
    { "$ref": "emptyNode" },
    {
      "properties": {
        "value": { "$ref": "commentValue" }
      }
    }
  ]
}

},{}],145:[function(require,module,exports){
module.exports={
  "id": "commentValue",
  "allOf":  [
    { "$ref": "entityNodeValue" },
    {
      "properties": {
        "nodeType": {
          "type": "string",
          "enum": [ "comment" ]
        },
        "nodeValue": { "type": "string" }
      },
      "required": [ "nodeType", "nodeValue" ]
    }
  ]
}
},{}],146:[function(require,module,exports){
module.exports={
  "id": "document",
  "allOf": [
    { "$ref": "parentNode" },
    {
      "properties": {
        "value": { "$ref": "documentValue" }
      }      
    }    
  ]
}

},{}],147:[function(require,module,exports){
module.exports={
  "id": "documentFragment",
  "allOf": [
    { "$ref": "parentNode" },
    {
      "properties": {
        "value": { "$ref": "documentFragmentValue" }
      }      
    }    
  ]
}

},{}],148:[function(require,module,exports){
module.exports={
  "id": "documentFragmentValue",
  "allOf":  [
    { "$ref": "entityNodeValue" },
    {
      "properties": {
        "nodeType": {
          "type": "string",
          "enum": [ "documentFragment" ]
        }
      },
      "required": [ "nodeType" ]
    }
  ]
}

},{}],149:[function(require,module,exports){
module.exports={
  "id": "documentType",
  "allOf": [
    { "$ref": "emptyNode" },
    {
      "properties": {
        "value": { "$ref": "documentTypeValue" }
      }
    }
  ]
}

},{}],150:[function(require,module,exports){
module.exports={
  "id": "documentTypeValue",
  "allOf":  [
    { "$ref": "entityNodeValue" },
    {
      "properties": {
        "nodeType": {
          "type": "string",
          "enum": [ "documentType" ]
        },
        "name": { "type": "string" },
        "publicId": { "type": "string" },
        "systemId": { "type": "string" }
      },
      "required": [ "nodeType", "name", "publicId", "systemId" ]
    }
  ]
}
},{}],151:[function(require,module,exports){
module.exports={
  "id": "documentValue",
  "allOf":  [
    { "$ref": "entityNodeValue" },
    {
      "properties": {
        "nodeType": {
          "type": "string",
          "enum": [ "document" ]
        }
      },
      "required": [ "nodeType" ]
    }
  ]
}

},{}],152:[function(require,module,exports){
module.exports={
  "id": "element",
  "allOf": [
    { "$ref": "parentNode" },
    {
      "properties": {
        "value": { "$ref": "elementValue" }
      }      
    }    
  ]
}

},{}],153:[function(require,module,exports){
module.exports={
  "id": "elementValue",
  "allOf":  [
    { "$ref": "entityNodeValue" },
    {
      "properties": {
        "nodeType": {
          "type": "string",
          "enum": [ "element" ]
        },
        "attributes": {
          "type": "object",
          "additionalProperties": { "type": "string" }
        }
      },
      "required": [ "nodeType", "attributes" ]
    }
  ]
}

},{}],154:[function(require,module,exports){
module.exports={
  "id": "text",
  "allOf": [
    { "$ref": "emptyNode" },
    {
      "properties": {
        "value": { "$ref": "textValue" }
      }
    }
  ]
}

},{}],155:[function(require,module,exports){
module.exports={
  "id": "textValue",
  "allOf":  [
    { "$ref": "entityNodeValue" },
    {
      "properties": {
        "nodeType": {
          "type": "string",
          "enum": [ "text" ]
        },
        "nodeValue": { "type": "string" }
      },
      "required": [ "nodeType", "nodeValue" ]
    }
  ]
}

},{}],156:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var Htree = require('mojule-dom');
var utils = require('mojule-utils');

var clone = utils.clone;


var tokens = ['tag', 'text', 'html', 'if', 'not', 'each', 'empty', 'context', 'include'];

var tokenSelector = function tokenSelector(token) {
  return '[data-' + token + ']';
};
var selectors = tokens.map(tokenSelector);

var resolve = function resolve(scope, propertyName) {
  if (_typeof(scope.current) === 'object' && propertyName in scope.current) return scope.current[propertyName];

  if (propertyName === '.') return scope.current;

  if (scope.parent) return resolve(scope.parent, propertyName);
};

var actionWhitelist = ['tagName', 'attr', 'removeAttr', 'addClass', 'removeClass', 'toggleClass', 'clearAttrs', 'clearClasses', 'attributes'];

var handleAction = function handleAction(el, action) {
  return Object.keys(action).filter(function (fname) {
    return actionWhitelist.includes(fname);
  }).forEach(function (fname) {
    var args = action[fname];

    if (!Array.isArray(args)) args = [args];

    el[fname].apply(el, _toConsumableArray(args));
  });
};

var Templating = function Templating(templates) {
  var getTemplateFragment = function getTemplateFragment(name) {
    return Htree(clone(templates[name]));
  };

  var populateEl = {
    tag: function tag(el, scope, value) {
      if (value === undefined) return;

      if (!Array.isArray(value)) value = [value];

      value.forEach(function (action) {
        return handleAction(el, action);
      });
    },
    text: function text(el, scope, value) {
      el.empty();

      if (value === undefined) return;

      var textNode = el.createText(value);

      el.append(textNode);
    },
    html: function html(el, scope, value) {
      if (value === undefined) {
        el.empty();
        return;
      }

      var children = el.parse(value);

      el.append(children);
    },
    if: function _if(el, scope, value) {
      if (!value) el.empty();
    },
    not: function not(el, scope, value) {
      if (value) el.empty();
    },
    each: function each(el, scope, value) {
      if (value === undefined) {
        el.empty();

        return;
      }

      if (!Array.isArray(value)) {
        populateEl.context(el, scope, value);

        return;
      }

      var children = el.empty();

      value.forEach(function (item) {
        var childScope = {
          parent: scope,
          current: item
        };

        children.forEach(function (child) {
          el.append(child.clone());
        });

        populateNext(el, childScope);
      });
    },
    empty: function empty(el, scope, value) {
      if (value === undefined) {
        el.empty();
        return;
      }

      if (!Array.isArray(value) || value.length > 0) el.empty();
    },
    context: function context(el, scope, value) {
      if (value === undefined) return;

      var newScope = {
        parent: null,
        current: value
      };

      populateNext(el, newScope);
    },
    include: function include(el, scope, value) {
      el.empty();

      if (value === undefined) return;

      el.append(getTemplateFragment(value));
    }
  };

  var populateNext = function populateNext(template, scope) {
    var next = template.select(selectors.join(', '));

    if (!next) return template;

    var currentToken = tokens.find(function (token) {
      return next.matches(tokenSelector(token));
    });

    var attrName = 'data-' + currentToken;
    var name = next.attr(attrName);

    if (currentToken === 'include') {
      populateEl[currentToken](next, scope, name);
    } else {
      var value = resolve(scope, name);

      populateEl[currentToken](next, scope, value);

      if (value !== undefined) {
        scope = {
          parent: scope,
          current: value
        };
      }
    }

    next.removeAttr(attrName);

    return populateNext(template, scope);
  };

  var unwrapFragmentChildren = function unwrapFragmentChildren(fragment) {
    var notFragment = fragment.find(function (n) {
      return !n.matches('fragment');
    });

    if (!notFragment) return fragment;

    var fragmentParent = fragment.getParent();

    fragmentParent.insertBefore(notFragment, fragment);

    return unwrapFragmentChildren(fragment);
  };

  var unwrapNextFragment = function unwrapNextFragment(template) {
    var fragment = template.select('fragment');

    if (!fragment) return template;

    unwrapFragmentChildren(fragment);

    fragment.remove();

    return unwrapNextFragment(template);
  };

  var populate = function populate(name, model) {
    var template = getTemplateFragment(name);

    var scope = {
      parent: null,
      current: model
    };

    populateNext(template, scope);
    unwrapNextFragment(template);

    return template;
  };

  return populate;
};

Templating.getTemplates = function (htree) {
  if (typeof htree === 'string') htree = Htree(htree);

  var templateEls = htree.clone().selectAll('template[id]:not([id=""])');

  return templateEls.reduce(function (templates, el) {
    var id = el.attr('id');

    var fragment = htree.createDocumentFragment();

    el.getChildren().forEach(function (child) {
      return fragment.append(child);
    });

    templates[id] = fragment.serialize();

    return templates;
  }, {});
};

module.exports = Templating;
},{"mojule-dom":143,"mojule-utils":161}],157:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":156,"dup":3}],158:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _require = require('mojule-utils'),
    clone = _require.clone;

var _require2 = require('1tree-json'),
    toTree = _require2.toTree,
    toJson = _require2.toJson;

var transforms = {
  values: function values(data) {
    var model = data.model,
        transform = data.transform;


    var transformTree = toTree(transform);

    var valuePropertyNodes = transformTree.findAll(function (n) {
      return n.value().propertyName === '$value';
    });

    if (valuePropertyNodes.length === 0) return data;

    valuePropertyNodes.forEach(function (propertyNode) {
      var objectNode = propertyNode.getParent();
      var objectNodeParent = objectNode.getParent();

      var value = propertyNode.value();
      var sourcePropertyName = value.nodeValue;

      var newValueNode = sourcePropertyName in model ? toTree(model[sourcePropertyName]) : toTree('$delete');

      var propertyName = objectNode.value().propertyName;

      if (propertyName) {
        var newValue = newValueNode.value();
        newValue.propertyName = propertyName;
        newValueNode.value(newValue);
      }

      objectNodeParent.replaceChild(newValueNode, objectNode);
    });

    transform = toJson(transformTree);

    return { model: model, transform: transform };
  },
  ifs: function ifs(data) {
    var model = data.model,
        transform = data.transform;


    var transformTree = toTree(transform);

    var ifPropertyNodes = transformTree.findAll(function (n) {
      return n.value().propertyName === '$if';
    });

    ifPropertyNodes.forEach(function (propertyNode) {
      var objectNode = propertyNode.getParent();
      var objectNodeParent = objectNode.getParent();

      var ifArgNodes = propertyNode.getChildren();

      var isValue = ifArgNodes[0].value().nodeValue;

      if (isValue && isValue !== '$delete') {
        var ifValueNode = ifArgNodes[1];

        var propertyName = objectNode.value().propertyName;

        if (propertyName) {
          var newValue = ifValueNode.value();
          newValue.propertyName = propertyName;
          ifValueNode.value(newValue);
        }

        objectNodeParent.insertBefore(ifValueNode, objectNode);
      }

      objectNode.remove();
    });

    transform = toJson(transformTree);

    return { model: model, transform: transform };
  },
  deletes: function deletes(data) {
    var model = data.model,
        transform = data.transform;


    var transformKeys = Object.keys(transform);

    transformKeys.forEach(function (propertyName) {
      if (transform[propertyName] === '$delete') {
        delete model[propertyName];
        delete transform[propertyName];
      }
    });

    return { model: model, transform: transform };
  },
  substitutes: function substitutes(data) {
    var model = data.model,
        transform = data.transform;


    var transformKeys = Object.keys(transform);

    transformKeys.forEach(function (propertyName) {
      model[propertyName] = transform[propertyName];
    });

    return { model: model, transform: transform };
  }
};

var transformMapper = function transformMapper(model, transform) {
  if (Array.isArray(model)) {
    return model.map(function (el) {
      return transformMapper(el, transform);
    });
  } else if ((typeof model === 'undefined' ? 'undefined' : _typeof(model)) !== 'object') {
    return model;
  }

  var data = clone({ model: model, transform: transform });

  Object.keys(transforms).forEach(function (transformName) {
    var fn = transforms[transformName];

    data = fn(data);
  });

  return data.model;
};

module.exports = transformMapper;
},{"1tree-json":6,"mojule-utils":161}],159:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":158,"dup":3}],160:[function(require,module,exports){
'use strict';

var clone = function clone() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return JSON.parse(JSON.stringify(obj));
};

var matches = function matches() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Object.keys(source).every(function (key) {
    return obj[key] === source[key];
  });
};

var id = function id() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;

  if (prefix) prefix = identifier(prefix) + '-';

  var str = prefix;

  for (var i = 0; i < length; i++) {
    str += Math.floor(Math.random() * 16).toString(16);
  }

  return str;
};

var identifier = function identifier() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var caseSensitive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var id = value.replace(/[^a-z0-9]/gi, '-').replace(/-{2,}/g, '-');

  if (!caseSensitive) id = id.toLowerCase();

  return id;
};

var escapeHtml = function escapeHtml() {
  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  var result = str.replace(/</g, '&lt;');
  return result;
};

var capitalizeFirstLetter = function capitalizeFirstLetter() {
  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return str.charAt(0).toUpperCase() + str.slice(1);
};

var utils = {
  id: id, identifier: identifier, matches: matches, clone: clone, escapeHtml: escapeHtml, capitalizeFirstLetter: capitalizeFirstLetter
};

module.exports = utils;
},{}],161:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":160,"dup":3}],162:[function(require,module,exports){
'use strict';

var range; // Create a range object for efficently rendering strings to elements.
var NS_XHTML = 'http://www.w3.org/1999/xhtml';

var doc = typeof document === 'undefined' ? undefined : document;

var testEl = doc ?
    doc.body || doc.createElement('div') :
    {};

// Fixes <https://github.com/patrick-steele-idem/morphdom/issues/32>
// (IE7+ support) <=IE7 does not support el.hasAttribute(name)
var actualHasAttributeNS;

if (testEl.hasAttributeNS) {
    actualHasAttributeNS = function(el, namespaceURI, name) {
        return el.hasAttributeNS(namespaceURI, name);
    };
} else if (testEl.hasAttribute) {
    actualHasAttributeNS = function(el, namespaceURI, name) {
        return el.hasAttribute(name);
    };
} else {
    actualHasAttributeNS = function(el, namespaceURI, name) {
        return el.getAttributeNode(namespaceURI, name) != null;
    };
}

var hasAttributeNS = actualHasAttributeNS;


function toElement(str) {
    if (!range && doc.createRange) {
        range = doc.createRange();
        range.selectNode(doc.body);
    }

    var fragment;
    if (range && range.createContextualFragment) {
        fragment = range.createContextualFragment(str);
    } else {
        fragment = doc.createElement('body');
        fragment.innerHTML = str;
    }
    return fragment.childNodes[0];
}

/**
 * Returns true if two node's names are the same.
 *
 * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same
 *       nodeName and different namespace URIs.
 *
 * @param {Element} a
 * @param {Element} b The target element
 * @return {boolean}
 */
function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;

    if (fromNodeName === toNodeName) {
        return true;
    }

    if (toEl.actualize &&
        fromNodeName.charCodeAt(0) < 91 && /* from tag name is upper case */
        toNodeName.charCodeAt(0) > 90 /* target tag name is lower case */) {
        // If the target element is a virtual DOM node then we may need to normalize the tag name
        // before comparing. Normal HTML elements that are in the "http://www.w3.org/1999/xhtml"
        // are converted to upper case
        return fromNodeName === toNodeName.toUpperCase();
    } else {
        return false;
    }
}

/**
 * Create an element, optionally with a known namespace URI.
 *
 * @param {string} name the element name, e.g. 'div' or 'svg'
 * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of
 * its `xmlns` attribute or its inferred namespace.
 *
 * @return {Element}
 */
function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ?
        doc.createElement(name) :
        doc.createElementNS(namespaceURI, name);
}

/**
 * Copies the children of one DOM element to another DOM element
 */
function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
        var nextChild = curChild.nextSibling;
        toEl.appendChild(curChild);
        curChild = nextChild;
    }
    return toEl;
}

function morphAttrs(fromNode, toNode) {
    var attrs = toNode.attributes;
    var i;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;

    for (i = attrs.length - 1; i >= 0; --i) {
        attr = attrs[i];
        attrName = attr.name;
        attrNamespaceURI = attr.namespaceURI;
        attrValue = attr.value;

        if (attrNamespaceURI) {
            attrName = attr.localName || attrName;
            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);

            if (fromValue !== attrValue) {
                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
            }
        } else {
            fromValue = fromNode.getAttribute(attrName);

            if (fromValue !== attrValue) {
                fromNode.setAttribute(attrName, attrValue);
            }
        }
    }

    // Remove any extra attributes found on the original DOM element that
    // weren't found on the target element.
    attrs = fromNode.attributes;

    for (i = attrs.length - 1; i >= 0; --i) {
        attr = attrs[i];
        if (attr.specified !== false) {
            attrName = attr.name;
            attrNamespaceURI = attr.namespaceURI;

            if (attrNamespaceURI) {
                attrName = attr.localName || attrName;

                if (!hasAttributeNS(toNode, attrNamespaceURI, attrName)) {
                    fromNode.removeAttributeNS(attrNamespaceURI, attrName);
                }
            } else {
                if (!hasAttributeNS(toNode, null, attrName)) {
                    fromNode.removeAttribute(attrName);
                }
            }
        }
    }
}

function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
        fromEl[name] = toEl[name];
        if (fromEl[name]) {
            fromEl.setAttribute(name, '');
        } else {
            fromEl.removeAttribute(name, '');
        }
    }
}

var specialElHandlers = {
    /**
     * Needed for IE. Apparently IE doesn't think that "selected" is an
     * attribute when reading over the attributes using selectEl.attributes
     */
    OPTION: function(fromEl, toEl) {
        syncBooleanAttrProp(fromEl, toEl, 'selected');
    },
    /**
     * The "value" attribute is special for the <input> element since it sets
     * the initial value. Changing the "value" attribute without changing the
     * "value" property will have no effect since it is only used to the set the
     * initial value.  Similar for the "checked" attribute, and "disabled".
     */
    INPUT: function(fromEl, toEl) {
        syncBooleanAttrProp(fromEl, toEl, 'checked');
        syncBooleanAttrProp(fromEl, toEl, 'disabled');

        if (fromEl.value !== toEl.value) {
            fromEl.value = toEl.value;
        }

        if (!hasAttributeNS(toEl, null, 'value')) {
            fromEl.removeAttribute('value');
        }
    },

    TEXTAREA: function(fromEl, toEl) {
        var newValue = toEl.value;
        if (fromEl.value !== newValue) {
            fromEl.value = newValue;
        }

        if (fromEl.firstChild) {
            // Needed for IE. Apparently IE sets the placeholder as the
            // node value and vise versa. This ignores an empty update.
            if (newValue === '' && fromEl.firstChild.nodeValue === fromEl.placeholder) {
                return;
            }

            fromEl.firstChild.nodeValue = newValue;
        }
    },
    SELECT: function(fromEl, toEl) {
        if (!hasAttributeNS(toEl, null, 'multiple')) {
            var selectedIndex = -1;
            var i = 0;
            var curChild = toEl.firstChild;
            while(curChild) {
                var nodeName = curChild.nodeName;
                if (nodeName && nodeName.toUpperCase() === 'OPTION') {
                    if (hasAttributeNS(curChild, null, 'selected')) {
                        selectedIndex = i;
                        break;
                    }
                    i++;
                }
                curChild = curChild.nextSibling;
            }

            fromEl.selectedIndex = i;
        }
    }
};

var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;

function noop() {}

function defaultGetNodeKey(node) {
    return node.id;
}

function morphdomFactory(morphAttrs) {

    return function morphdom(fromNode, toNode, options) {
        if (!options) {
            options = {};
        }

        if (typeof toNode === 'string') {
            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML') {
                var toNodeHtml = toNode;
                toNode = doc.createElement('html');
                toNode.innerHTML = toNodeHtml;
            } else {
                toNode = toElement(toNode);
            }
        }

        var getNodeKey = options.getNodeKey || defaultGetNodeKey;
        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
        var onNodeAdded = options.onNodeAdded || noop;
        var onBeforeElUpdated = options.onBeforeElUpdated || noop;
        var onElUpdated = options.onElUpdated || noop;
        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
        var onNodeDiscarded = options.onNodeDiscarded || noop;
        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
        var childrenOnly = options.childrenOnly === true;

        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.
        var fromNodesLookup = {};
        var keyedRemovalList;

        function addKeyedRemoval(key) {
            if (keyedRemovalList) {
                keyedRemovalList.push(key);
            } else {
                keyedRemovalList = [key];
            }
        }

        function walkDiscardedChildNodes(node, skipKeyedNodes) {
            if (node.nodeType === ELEMENT_NODE) {
                var curChild = node.firstChild;
                while (curChild) {

                    var key = undefined;

                    if (skipKeyedNodes && (key = getNodeKey(curChild))) {
                        // If we are skipping keyed nodes then we add the key
                        // to a list so that it can be handled at the very end.
                        addKeyedRemoval(key);
                    } else {
                        // Only report the node as discarded if it is not keyed. We do this because
                        // at the end we loop through all keyed elements that were unmatched
                        // and then discard them in one final pass.
                        onNodeDiscarded(curChild);
                        if (curChild.firstChild) {
                            walkDiscardedChildNodes(curChild, skipKeyedNodes);
                        }
                    }

                    curChild = curChild.nextSibling;
                }
            }
        }

        /**
         * Removes a DOM node out of the original DOM
         *
         * @param  {Node} node The node to remove
         * @param  {Node} parentNode The nodes parent
         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.
         * @return {undefined}
         */
        function removeNode(node, parentNode, skipKeyedNodes) {
            if (onBeforeNodeDiscarded(node) === false) {
                return;
            }

            if (parentNode) {
                parentNode.removeChild(node);
            }

            onNodeDiscarded(node);
            walkDiscardedChildNodes(node, skipKeyedNodes);
        }

        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future
        // function indexTree(root) {
        //     var treeWalker = document.createTreeWalker(
        //         root,
        //         NodeFilter.SHOW_ELEMENT);
        //
        //     var el;
        //     while((el = treeWalker.nextNode())) {
        //         var key = getNodeKey(el);
        //         if (key) {
        //             fromNodesLookup[key] = el;
        //         }
        //     }
        // }

        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future
        //
        // function indexTree(node) {
        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);
        //     var el;
        //     while((el = nodeIterator.nextNode())) {
        //         var key = getNodeKey(el);
        //         if (key) {
        //             fromNodesLookup[key] = el;
        //         }
        //     }
        // }

        function indexTree(node) {
            if (node.nodeType === ELEMENT_NODE) {
                var curChild = node.firstChild;
                while (curChild) {
                    var key = getNodeKey(curChild);
                    if (key) {
                        fromNodesLookup[key] = curChild;
                    }

                    // Walk recursively
                    indexTree(curChild);

                    curChild = curChild.nextSibling;
                }
            }
        }

        indexTree(fromNode);

        function handleNodeAdded(el) {
            onNodeAdded(el);

            var curChild = el.firstChild;
            while (curChild) {
                var nextSibling = curChild.nextSibling;

                var key = getNodeKey(curChild);
                if (key) {
                    var unmatchedFromEl = fromNodesLookup[key];
                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
                        morphEl(unmatchedFromEl, curChild);
                    }
                }

                handleNodeAdded(curChild);
                curChild = nextSibling;
            }
        }

        function morphEl(fromEl, toEl, childrenOnly) {
            var toElKey = getNodeKey(toEl);
            var curFromNodeKey;

            if (toElKey) {
                // If an element with an ID is being morphed then it is will be in the final
                // DOM so clear it out of the saved elements collection
                delete fromNodesLookup[toElKey];
            }

            if (toNode.isSameNode && toNode.isSameNode(fromNode)) {
                return;
            }

            if (!childrenOnly) {
                if (onBeforeElUpdated(fromEl, toEl) === false) {
                    return;
                }

                morphAttrs(fromEl, toEl);
                onElUpdated(fromEl);

                if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
                    return;
                }
            }

            if (fromEl.nodeName !== 'TEXTAREA') {
                var curToNodeChild = toEl.firstChild;
                var curFromNodeChild = fromEl.firstChild;
                var curToNodeKey;

                var fromNextSibling;
                var toNextSibling;
                var matchingFromEl;

                outer: while (curToNodeChild) {
                    toNextSibling = curToNodeChild.nextSibling;
                    curToNodeKey = getNodeKey(curToNodeChild);

                    while (curFromNodeChild) {
                        fromNextSibling = curFromNodeChild.nextSibling;

                        if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                            curToNodeChild = toNextSibling;
                            curFromNodeChild = fromNextSibling;
                            continue outer;
                        }

                        curFromNodeKey = getNodeKey(curFromNodeChild);

                        var curFromNodeType = curFromNodeChild.nodeType;

                        var isCompatible = undefined;

                        if (curFromNodeType === curToNodeChild.nodeType) {
                            if (curFromNodeType === ELEMENT_NODE) {
                                // Both nodes being compared are Element nodes

                                if (curToNodeKey) {
                                    // The target node has a key so we want to match it up with the correct element
                                    // in the original DOM tree
                                    if (curToNodeKey !== curFromNodeKey) {
                                        // The current element in the original DOM tree does not have a matching key so
                                        // let's check our lookup to see if there is a matching element in the original
                                        // DOM tree
                                        if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {
                                            if (curFromNodeChild.nextSibling === matchingFromEl) {
                                                // Special case for single element removals. To avoid removing the original
                                                // DOM node out of the tree (since that can break CSS transitions, etc.),
                                                // we will instead discard the current node and wait until the next
                                                // iteration to properly match up the keyed target element with its matching
                                                // element in the original tree
                                                isCompatible = false;
                                            } else {
                                                // We found a matching keyed element somewhere in the original DOM tree.
                                                // Let's moving the original DOM node into the current position and morph
                                                // it.

                                                // NOTE: We use insertBefore instead of replaceChild because we want to go through
                                                // the `removeNode()` function for the node that is being discarded so that
                                                // all lifecycle hooks are correctly invoked
                                                fromEl.insertBefore(matchingFromEl, curFromNodeChild);

                                                fromNextSibling = curFromNodeChild.nextSibling;

                                                if (curFromNodeKey) {
                                                    // Since the node is keyed it might be matched up later so we defer
                                                    // the actual removal to later
                                                    addKeyedRemoval(curFromNodeKey);
                                                } else {
                                                    // NOTE: we skip nested keyed nodes from being removed since there is
                                                    //       still a chance they will be matched up later
                                                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);
                                                }

                                                curFromNodeChild = matchingFromEl;
                                            }
                                        } else {
                                            // The nodes are not compatible since the "to" node has a key and there
                                            // is no matching keyed node in the source tree
                                            isCompatible = false;
                                        }
                                    }
                                } else if (curFromNodeKey) {
                                    // The original has a key
                                    isCompatible = false;
                                }

                                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                                if (isCompatible) {
                                    // We found compatible DOM elements so transform
                                    // the current "from" node to match the current
                                    // target DOM node.
                                    morphEl(curFromNodeChild, curToNodeChild);
                                }

                            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                                // Both nodes being compared are Text or Comment nodes
                                isCompatible = true;
                                // Simply update nodeValue on the original node to
                                // change the text value
                                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                            }
                        }

                        if (isCompatible) {
                            // Advance both the "to" child and the "from" child since we found a match
                            curToNodeChild = toNextSibling;
                            curFromNodeChild = fromNextSibling;
                            continue outer;
                        }

                        // No compatible match so remove the old node from the DOM and continue trying to find a
                        // match in the original DOM. However, we only do this if the from node is not keyed
                        // since it is possible that a keyed node might match up with a node somewhere else in the
                        // target tree and we don't want to discard it just yet since it still might find a
                        // home in the final DOM tree. After everything is done we will remove any keyed nodes
                        // that didn't find a home
                        if (curFromNodeKey) {
                            // Since the node is keyed it might be matched up later so we defer
                            // the actual removal to later
                            addKeyedRemoval(curFromNodeKey);
                        } else {
                            // NOTE: we skip nested keyed nodes from being removed since there is
                            //       still a chance they will be matched up later
                            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);
                        }

                        curFromNodeChild = fromNextSibling;
                    }

                    // If we got this far then we did not find a candidate match for
                    // our "to node" and we exhausted all of the children "from"
                    // nodes. Therefore, we will just append the current "to" node
                    // to the end
                    if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
                        fromEl.appendChild(matchingFromEl);
                        morphEl(matchingFromEl, curToNodeChild);
                    } else {
                        var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
                        if (onBeforeNodeAddedResult !== false) {
                            if (onBeforeNodeAddedResult) {
                                curToNodeChild = onBeforeNodeAddedResult;
                            }

                            if (curToNodeChild.actualize) {
                                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                            }
                            fromEl.appendChild(curToNodeChild);
                            handleNodeAdded(curToNodeChild);
                        }
                    }

                    curToNodeChild = toNextSibling;
                    curFromNodeChild = fromNextSibling;
                }

                // We have processed all of the "to nodes". If curFromNodeChild is
                // non-null then we still have some from nodes left over that need
                // to be removed
                while (curFromNodeChild) {
                    fromNextSibling = curFromNodeChild.nextSibling;
                    if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {
                        // Since the node is keyed it might be matched up later so we defer
                        // the actual removal to later
                        addKeyedRemoval(curFromNodeKey);
                    } else {
                        // NOTE: we skip nested keyed nodes from being removed since there is
                        //       still a chance they will be matched up later
                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);
                    }
                    curFromNodeChild = fromNextSibling;
                }
            }

            var specialElHandler = specialElHandlers[fromEl.nodeName];
            if (specialElHandler) {
                specialElHandler(fromEl, toEl);
            }
        } // END: morphEl(...)

        var morphedNode = fromNode;
        var morphedNodeType = morphedNode.nodeType;
        var toNodeType = toNode.nodeType;

        if (!childrenOnly) {
            // Handle the case where we are given two DOM nodes that are not
            // compatible (e.g. <div> --> <span> or <div> --> TEXT)
            if (morphedNodeType === ELEMENT_NODE) {
                if (toNodeType === ELEMENT_NODE) {
                    if (!compareNodeNames(fromNode, toNode)) {
                        onNodeDiscarded(fromNode);
                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
                    }
                } else {
                    // Going from an element node to a text node
                    morphedNode = toNode;
                }
            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node
                if (toNodeType === morphedNodeType) {
                    morphedNode.nodeValue = toNode.nodeValue;
                    return morphedNode;
                } else {
                    // Text node to something else
                    morphedNode = toNode;
                }
            }
        }

        if (morphedNode === toNode) {
            // The "to node" was not compatible with the "from node" so we had to
            // toss out the "from node" and use the "to node"
            onNodeDiscarded(fromNode);
        } else {
            morphEl(morphedNode, toNode, childrenOnly);

            // We now need to loop over any keyed nodes that might need to be
            // removed. We only do the removal if we know that the keyed node
            // never found a match. When a keyed node is matched up we remove
            // it out of fromNodesLookup and we use fromNodesLookup to determine
            // if a keyed node has been matched up or not
            if (keyedRemovalList) {
                for (var i=0, len=keyedRemovalList.length; i<len; i++) {
                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];
                    if (elToRemove) {
                        removeNode(elToRemove, elToRemove.parentNode, false);
                    }
                }
            }
        }

        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
            if (morphedNode.actualize) {
                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
            }
            // If we had to swap out the from node with a new node because the old
            // node was not compatible with the target node then we need to
            // replace the old DOM node in the original DOM tree. This is only
            // possible if the original DOM node was part of a DOM tree which
            // we know is the case if it has a parent node.
            fromNode.parentNode.replaceChild(morphedNode, fromNode);
        }

        return morphedNode;
    };
}

var morphdom = morphdomFactory(morphAttrs);

module.exports = morphdom;

},{}],163:[function(require,module,exports){
'use strict';

var Validator = require('mtype-tv4');
var utils = require('mojule-utils');
var schema = require('./schema');

var id = utils.id;


var validator = Validator(schema);
var t = Validator.mtype(validator);

var EntityNodeValue = function EntityNodeValue() {
  var nodeType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'entityNode';
  var additionalValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var value = Object.assign({ nodeType: nodeType }, additionalValues);

  if (typeof value._id !== 'string') value._id = id(value.nodeType);

  if (!t.is(value, 'entityNodeValue')) throw new TypeError('Cannot create an entityNodeValue with those arguments');

  return value;
};

var EntityNode = function EntityNode() {
  var nodeType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'entityNode';
  var additionalValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var value = EntityNodeValue(nodeType, additionalValues);
  var children = [];

  return { value: value, children: children };
};

EntityNode.Value = EntityNodeValue;
EntityNode.mtype = t;

module.exports = EntityNode;
},{"./schema":164,"mojule-utils":161,"mtype-tv4":171}],164:[function(require,module,exports){
'use strict';

var entityNode = require('../schema/entityNode.schema.json');
var entityNodeValue = require('../schema/entityNodeValue.schema.json');
var emptyNode = require('../schema/emptyNode.schema.json');
var parentNode = require('../schema/parentNode.schema.json');

var schema = {
  entityNode: entityNode, entityNodeValue: entityNodeValue, emptyNode: emptyNode, parentNode: parentNode
};

module.exports = schema;
},{"../schema/emptyNode.schema.json":166,"../schema/entityNode.schema.json":167,"../schema/entityNodeValue.schema.json":168,"../schema/parentNode.schema.json":169}],165:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":163,"dup":3}],166:[function(require,module,exports){
module.exports={
  "id": "emptyNode",
  "allOf": [
    { "$ref": "entityNode" },
    {
      "properties": {
        "value": { "$ref": "entityNodeValue" },
        "children": {
          "type": "array",
          "maxLength": 0
        }
      }
    }
  ]
}

},{}],167:[function(require,module,exports){
module.exports={
  "id": "entityNode",
  "type": "object",
  "properties": {
    "value": { "$ref": "entityNodeValue" }
  },
  "required": [ "value" ]
}

},{}],168:[function(require,module,exports){
module.exports={
  "id": "entityNodeValue",
  "type": "object",
  "properties": {
    "_id": {
      "type": "string",
      "minLength": 1
    },
    "nodeType": {
      "type": "string",
      "minLength": 1
    }
  },
  "required": [ "_id", "nodeType" ]
}

},{}],169:[function(require,module,exports){
module.exports={
  "id": "parentNode",
  "allOf": [
    { "$ref": "entityNode" },
    {
      "properties": {
        "children": {
          "type": "array",
          "items": { "$ref": "entityNode" }
        }
      },
      "required": [ "children" ]
    }
  ]
}

},{}],170:[function(require,module,exports){
'use strict';

var tv4 = require('tv4');
var T = require('mtype');

var Validator = function Validator() {
  var schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var validator = tv4.freshApi();

  var schemas = Object.keys(schema).map(function (name) {
    return schema[name];
  });

  schemas.forEach(function (schema) {
    return validator.addSchema(schema);
  });

  return validator;
};

Validator.mtype = function () {
  var validator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Validator();

  var schemaNames = validator.getSchemaUris();

  var is = schemaNames.reduce(function (map, name) {
    map[name] = function (obj) {
      return validator.validate(obj, name);
    };

    return map;
  }, {});

  return T(is);
};

module.exports = Validator;
},{"mtype":174,"tv4":194}],171:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":170,"dup":3}],172:[function(require,module,exports){
'use strict';

var jsonPredicates = require('./json-predicates');

var mtype = function mtype(typePredicates) {
  typePredicates = typePredicates || jsonPredicates;

  var keys = Object.keys(typePredicates);

  var is = function is(subject, typename) {
    return typePredicates[typename] && typePredicates[typename](subject);
  };

  var isOnly = function isOnly(subject, typename) {
    return is(subject, typename) && allOf(subject).length === 1;
  };

  var some = function some(subject) {
    for (var _len = arguments.length, typenames = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      typenames[_key - 1] = arguments[_key];
    }

    return typenames.some(function (typename) {
      return is(subject, typename);
    });
  };

  var every = function every(subject) {
    for (var _len2 = arguments.length, typenames = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      typenames[_key2 - 1] = arguments[_key2];
    }

    return typenames.every(function (typename) {
      return is(subject, typename);
    });
  };

  var of = function of(subject) {
    return keys.find(function (key) {
      return is(subject, key);
    });
  };

  var allOf = function allOf(subject) {
    return keys.filter(function (key) {
      return is(subject, key);
    });
  };

  var types = function types() {
    return keys.slice();
  };

  return { is: is, isOnly: isOnly, some: some, every: every, of: of, allOf: allOf, types: types };
};

module.exports = mtype;
},{"./json-predicates":173}],173:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var jsonPredicates = {
  number: function number(subject) {
    return typeof subject === 'number' && isFinite(subject);
  },
  string: function string(subject) {
    return typeof subject === 'string';
  },
  boolean: function boolean(subject) {
    return typeof subject === 'boolean';
  },
  array: function array(subject) {
    return Array.isArray(subject);
  },
  null: function _null(subject) {
    return subject === null;
  },
  object: function object(subject) {
    return (typeof subject === 'undefined' ? 'undefined' : _typeof(subject)) === 'object' && !jsonPredicates.null(subject) && !jsonPredicates.array(subject);
  }
};

module.exports = jsonPredicates;
},{}],174:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./dist":172,"dup":3}],175:[function(require,module,exports){
module.exports = compile;

var BaseFuncs = require("boolbase"),
    trueFunc  = BaseFuncs.trueFunc,
    falseFunc = BaseFuncs.falseFunc;

/*
	returns a function that checks if an elements index matches the given rule
	highly optimized to return the fastest solution
*/
function compile(parsed){
	var a = parsed[0],
	    b = parsed[1] - 1;

	//when b <= 0, a*n won't be possible for any matches when a < 0
	//besides, the specification says that no element is matched when a and b are 0
	if(b < 0 && a <= 0) return falseFunc;

	//when a is in the range -1..1, it matches any element (so only b is checked)
	if(a ===-1) return function(pos){ return pos <= b; };
	if(a === 0) return function(pos){ return pos === b; };
	//when b <= 0 and a === 1, they match any element
	if(a === 1) return b < 0 ? trueFunc : function(pos){ return pos >= b; };

	//when a > 0, modulo can be used to check if there is a match
	var bMod = b % a;
	if(bMod < 0) bMod += a;

	if(a > 1){
		return function(pos){
			return pos >= b && pos % a === bMod;
		};
	}

	a *= -1; //make `a` positive

	return function(pos){
		return pos <= b && pos % a === bMod;
	};
}
},{"boolbase":63}],176:[function(require,module,exports){
var parse = require("./parse.js"),
    compile = require("./compile.js");

module.exports = function nthCheck(formula){
	return compile(parse(formula));
};

module.exports.parse = parse;
module.exports.compile = compile;
},{"./compile.js":175,"./parse.js":177}],177:[function(require,module,exports){
module.exports = parse;

//following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo

//[ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
var re_nthElement = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;

/*
	parses a nth-check formula, returns an array of two numbers
*/
function parse(formula){
	formula = formula.trim().toLowerCase();

	if(formula === "even"){
		return [2, 0];
	} else if(formula === "odd"){
		return [2, 1];
	} else {
		var parsed = formula.match(re_nthElement);

		if(!parsed){
			throw new SyntaxError("n-th rule couldn't be parsed ('" + formula + "')");
		}

		var a;

		if(parsed[1]){
			a = parseInt(parsed[1], 10);
			if(isNaN(a)){
				if(parsed[1].charAt(0) === "-") a = -1;
				else a = 1;
			}
		} else a = 0;

		return [
			a,
			parsed[3] ? parseInt((parsed[2] || "") + parsed[3], 10) : 0
		];
	}
}

},{}],178:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,require('_process'))

},{"_process":179}],179:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],180:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":181}],181:[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":183,"./_stream_writable":185,"core-util-is":69,"inherits":121,"process-nextick-args":178}],182:[function(require,module,exports){
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":184,"core-util-is":69,"inherits":121}],183:[function(require,module,exports){
(function (process){
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var StringDecoder;

util.inherits(Readable, Stream);

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = bufferShim.from(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');
      stream.emit('error', _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = bufferShim.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'))

},{"./_stream_duplex":181,"./internal/streams/BufferList":186,"_process":179,"buffer":66,"buffer-shims":65,"core-util-is":69,"events":105,"inherits":121,"isarray":123,"process-nextick-args":178,"string_decoder/":192,"util":64}],184:[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":181,"core-util-is":69,"inherits":121}],185:[function(require,module,exports){
(function (process){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  // Always throw error if a null is written
  // if we are not in object mode then throw
  // if it is not a buffer, string, or undefined.
  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = bufferShim.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) processNextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
        afterWrite(stream, state, finished, cb);
      }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
}).call(this,require('_process'))

},{"./_stream_duplex":181,"_process":179,"buffer":66,"buffer-shims":65,"core-util-is":69,"events":105,"inherits":121,"process-nextick-args":178,"util-deprecate":195}],186:[function(require,module,exports){
'use strict';

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

module.exports = BufferList;

function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}

BufferList.prototype.push = function (v) {
  var entry = { data: v, next: null };
  if (this.length > 0) this.tail.next = entry;else this.head = entry;
  this.tail = entry;
  ++this.length;
};

BufferList.prototype.unshift = function (v) {
  var entry = { data: v, next: this.head };
  if (this.length === 0) this.tail = entry;
  this.head = entry;
  ++this.length;
};

BufferList.prototype.shift = function () {
  if (this.length === 0) return;
  var ret = this.head.data;
  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
  --this.length;
  return ret;
};

BufferList.prototype.clear = function () {
  this.head = this.tail = null;
  this.length = 0;
};

BufferList.prototype.join = function (s) {
  if (this.length === 0) return '';
  var p = this.head;
  var ret = '' + p.data;
  while (p = p.next) {
    ret += s + p.data;
  }return ret;
};

BufferList.prototype.concat = function (n) {
  if (this.length === 0) return bufferShim.alloc(0);
  if (this.length === 1) return this.head.data;
  var ret = bufferShim.allocUnsafe(n >>> 0);
  var p = this.head;
  var i = 0;
  while (p) {
    p.data.copy(ret, i);
    i += p.data.length;
    p = p.next;
  }
  return ret;
};
},{"buffer":66,"buffer-shims":65}],187:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":182}],188:[function(require,module,exports){
(function (process){
var Stream = (function (){
  try {
    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify
  } catch(_){}
}());
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream || exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
}

}).call(this,require('_process'))

},{"./lib/_stream_duplex.js":181,"./lib/_stream_passthrough.js":182,"./lib/_stream_readable.js":183,"./lib/_stream_transform.js":184,"./lib/_stream_writable.js":185,"_process":179}],189:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":184}],190:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":185}],191:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":105,"inherits":121,"readable-stream/duplex.js":180,"readable-stream/passthrough.js":187,"readable-stream/readable.js":188,"readable-stream/transform.js":189,"readable-stream/writable.js":190}],192:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":66}],193:[function(require,module,exports){
var si = typeof setImmediate === 'function', tick;
if (si) {
  tick = function (fn) { setImmediate(fn); };
} else {
  tick = function (fn) { setTimeout(fn, 0); };
}

module.exports = tick;
},{}],194:[function(require,module,exports){
/*
Author: Geraint Luff and others
Year: 2013

This code is released into the "public domain" by its author(s).  Anybody may use, alter and distribute the code without restriction.  The author makes no guarantees, and takes no liability of any kind for use of this code.

If you find a bug or make an improvement, it would be courteous to let the author know, but it is not compulsory.
*/
(function (global, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if (typeof module !== 'undefined' && module.exports){
    // CommonJS. Define export.
    module.exports = factory();
  } else {
    // Browser globals
    global.tv4 = factory();
  }
}(this, function () {

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FObject%2Fkeys
if (!Object.keys) {
	Object.keys = (function () {
		var hasOwnProperty = Object.prototype.hasOwnProperty,
			hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
			dontEnums = [
				'toString',
				'toLocaleString',
				'valueOf',
				'hasOwnProperty',
				'isPrototypeOf',
				'propertyIsEnumerable',
				'constructor'
			],
			dontEnumsLength = dontEnums.length;

		return function (obj) {
			if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) {
				throw new TypeError('Object.keys called on non-object');
			}

			var result = [];

			for (var prop in obj) {
				if (hasOwnProperty.call(obj, prop)) {
					result.push(prop);
				}
			}

			if (hasDontEnumBug) {
				for (var i=0; i < dontEnumsLength; i++) {
					if (hasOwnProperty.call(obj, dontEnums[i])) {
						result.push(dontEnums[i]);
					}
				}
			}
			return result;
		};
	})();
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
if (!Object.create) {
	Object.create = (function(){
		function F(){}

		return function(o){
			if (arguments.length !== 1) {
				throw new Error('Object.create implementation only accepts one parameter.');
			}
			F.prototype = o;
			return new F();
		};
	})();
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FisArray
if(!Array.isArray) {
	Array.isArray = function (vArg) {
		return Object.prototype.toString.call(vArg) === "[object Array]";
	};
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FindexOf
if (!Array.prototype.indexOf) {
	Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
		if (this === null) {
			throw new TypeError();
		}
		var t = Object(this);
		var len = t.length >>> 0;

		if (len === 0) {
			return -1;
		}
		var n = 0;
		if (arguments.length > 1) {
			n = Number(arguments[1]);
			if (n !== n) { // shortcut for verifying if it's NaN
				n = 0;
			} else if (n !== 0 && n !== Infinity && n !== -Infinity) {
				n = (n > 0 || -1) * Math.floor(Math.abs(n));
			}
		}
		if (n >= len) {
			return -1;
		}
		var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
		for (; k < len; k++) {
			if (k in t && t[k] === searchElement) {
				return k;
			}
		}
		return -1;
	};
}

// Grungey Object.isFrozen hack
if (!Object.isFrozen) {
	Object.isFrozen = function (obj) {
		var key = "tv4_test_frozen_key";
		while (obj.hasOwnProperty(key)) {
			key += Math.random();
		}
		try {
			obj[key] = true;
			delete obj[key];
			return false;
		} catch (e) {
			return true;
		}
	};
}
// Based on: https://github.com/geraintluff/uri-templates, but with all the de-substitution stuff removed

var uriTemplateGlobalModifiers = {
	"+": true,
	"#": true,
	".": true,
	"/": true,
	";": true,
	"?": true,
	"&": true
};
var uriTemplateSuffices = {
	"*": true
};

function notReallyPercentEncode(string) {
	return encodeURI(string).replace(/%25[0-9][0-9]/g, function (doubleEncoded) {
		return "%" + doubleEncoded.substring(3);
	});
}

function uriTemplateSubstitution(spec) {
	var modifier = "";
	if (uriTemplateGlobalModifiers[spec.charAt(0)]) {
		modifier = spec.charAt(0);
		spec = spec.substring(1);
	}
	var separator = "";
	var prefix = "";
	var shouldEscape = true;
	var showVariables = false;
	var trimEmptyString = false;
	if (modifier === '+') {
		shouldEscape = false;
	} else if (modifier === ".") {
		prefix = ".";
		separator = ".";
	} else if (modifier === "/") {
		prefix = "/";
		separator = "/";
	} else if (modifier === '#') {
		prefix = "#";
		shouldEscape = false;
	} else if (modifier === ';') {
		prefix = ";";
		separator = ";";
		showVariables = true;
		trimEmptyString = true;
	} else if (modifier === '?') {
		prefix = "?";
		separator = "&";
		showVariables = true;
	} else if (modifier === '&') {
		prefix = "&";
		separator = "&";
		showVariables = true;
	}

	var varNames = [];
	var varList = spec.split(",");
	var varSpecs = [];
	var varSpecMap = {};
	for (var i = 0; i < varList.length; i++) {
		var varName = varList[i];
		var truncate = null;
		if (varName.indexOf(":") !== -1) {
			var parts = varName.split(":");
			varName = parts[0];
			truncate = parseInt(parts[1], 10);
		}
		var suffices = {};
		while (uriTemplateSuffices[varName.charAt(varName.length - 1)]) {
			suffices[varName.charAt(varName.length - 1)] = true;
			varName = varName.substring(0, varName.length - 1);
		}
		var varSpec = {
			truncate: truncate,
			name: varName,
			suffices: suffices
		};
		varSpecs.push(varSpec);
		varSpecMap[varName] = varSpec;
		varNames.push(varName);
	}
	var subFunction = function (valueFunction) {
		var result = "";
		var startIndex = 0;
		for (var i = 0; i < varSpecs.length; i++) {
			var varSpec = varSpecs[i];
			var value = valueFunction(varSpec.name);
			if (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || (typeof value === 'object' && Object.keys(value).length === 0)) {
				startIndex++;
				continue;
			}
			if (i === startIndex) {
				result += prefix;
			} else {
				result += (separator || ",");
			}
			if (Array.isArray(value)) {
				if (showVariables) {
					result += varSpec.name + "=";
				}
				for (var j = 0; j < value.length; j++) {
					if (j > 0) {
						result += varSpec.suffices['*'] ? (separator || ",") : ",";
						if (varSpec.suffices['*'] && showVariables) {
							result += varSpec.name + "=";
						}
					}
					result += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, "%21") : notReallyPercentEncode(value[j]);
				}
			} else if (typeof value === "object") {
				if (showVariables && !varSpec.suffices['*']) {
					result += varSpec.name + "=";
				}
				var first = true;
				for (var key in value) {
					if (!first) {
						result += varSpec.suffices['*'] ? (separator || ",") : ",";
					}
					first = false;
					result += shouldEscape ? encodeURIComponent(key).replace(/!/g, "%21") : notReallyPercentEncode(key);
					result += varSpec.suffices['*'] ? '=' : ",";
					result += shouldEscape ? encodeURIComponent(value[key]).replace(/!/g, "%21") : notReallyPercentEncode(value[key]);
				}
			} else {
				if (showVariables) {
					result += varSpec.name;
					if (!trimEmptyString || value !== "") {
						result += "=";
					}
				}
				if (varSpec.truncate != null) {
					value = value.substring(0, varSpec.truncate);
				}
				result += shouldEscape ? encodeURIComponent(value).replace(/!/g, "%21"): notReallyPercentEncode(value);
			}
		}
		return result;
	};
	subFunction.varNames = varNames;
	return {
		prefix: prefix,
		substitution: subFunction
	};
}

function UriTemplate(template) {
	if (!(this instanceof UriTemplate)) {
		return new UriTemplate(template);
	}
	var parts = template.split("{");
	var textParts = [parts.shift()];
	var prefixes = [];
	var substitutions = [];
	var varNames = [];
	while (parts.length > 0) {
		var part = parts.shift();
		var spec = part.split("}")[0];
		var remainder = part.substring(spec.length + 1);
		var funcs = uriTemplateSubstitution(spec);
		substitutions.push(funcs.substitution);
		prefixes.push(funcs.prefix);
		textParts.push(remainder);
		varNames = varNames.concat(funcs.substitution.varNames);
	}
	this.fill = function (valueFunction) {
		var result = textParts[0];
		for (var i = 0; i < substitutions.length; i++) {
			var substitution = substitutions[i];
			result += substitution(valueFunction);
			result += textParts[i + 1];
		}
		return result;
	};
	this.varNames = varNames;
	this.template = template;
}
UriTemplate.prototype = {
	toString: function () {
		return this.template;
	},
	fillFromObject: function (obj) {
		return this.fill(function (varName) {
			return obj[varName];
		});
	}
};
var ValidatorContext = function ValidatorContext(parent, collectMultiple, errorReporter, checkRecursive, trackUnknownProperties) {
	this.missing = [];
	this.missingMap = {};
	this.formatValidators = parent ? Object.create(parent.formatValidators) : {};
	this.schemas = parent ? Object.create(parent.schemas) : {};
	this.collectMultiple = collectMultiple;
	this.errors = [];
	this.handleError = collectMultiple ? this.collectError : this.returnError;
	if (checkRecursive) {
		this.checkRecursive = true;
		this.scanned = [];
		this.scannedFrozen = [];
		this.scannedFrozenSchemas = [];
		this.scannedFrozenValidationErrors = [];
		this.validatedSchemasKey = 'tv4_validation_id';
		this.validationErrorsKey = 'tv4_validation_errors_id';
	}
	if (trackUnknownProperties) {
		this.trackUnknownProperties = true;
		this.knownPropertyPaths = {};
		this.unknownPropertyPaths = {};
	}
	this.errorReporter = errorReporter || defaultErrorReporter('en');
	if (typeof this.errorReporter === 'string') {
		throw new Error('debug');
	}
	this.definedKeywords = {};
	if (parent) {
		for (var key in parent.definedKeywords) {
			this.definedKeywords[key] = parent.definedKeywords[key].slice(0);
		}
	}
};
ValidatorContext.prototype.defineKeyword = function (keyword, keywordFunction) {
	this.definedKeywords[keyword] = this.definedKeywords[keyword] || [];
	this.definedKeywords[keyword].push(keywordFunction);
};
ValidatorContext.prototype.createError = function (code, messageParams, dataPath, schemaPath, subErrors, data, schema) {
	var error = new ValidationError(code, messageParams, dataPath, schemaPath, subErrors);
	error.message = this.errorReporter(error, data, schema);
	return error;
};
ValidatorContext.prototype.returnError = function (error) {
	return error;
};
ValidatorContext.prototype.collectError = function (error) {
	if (error) {
		this.errors.push(error);
	}
	return null;
};
ValidatorContext.prototype.prefixErrors = function (startIndex, dataPath, schemaPath) {
	for (var i = startIndex; i < this.errors.length; i++) {
		this.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);
	}
	return this;
};
ValidatorContext.prototype.banUnknownProperties = function (data, schema) {
	for (var unknownPath in this.unknownPropertyPaths) {
		var error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, {path: unknownPath}, unknownPath, "", null, data, schema);
		var result = this.handleError(error);
		if (result) {
			return result;
		}
	}
	return null;
};

ValidatorContext.prototype.addFormat = function (format, validator) {
	if (typeof format === 'object') {
		for (var key in format) {
			this.addFormat(key, format[key]);
		}
		return this;
	}
	this.formatValidators[format] = validator;
};
ValidatorContext.prototype.resolveRefs = function (schema, urlHistory) {
	if (schema['$ref'] !== undefined) {
		urlHistory = urlHistory || {};
		if (urlHistory[schema['$ref']]) {
			return this.createError(ErrorCodes.CIRCULAR_REFERENCE, {urls: Object.keys(urlHistory).join(', ')}, '', '', null, undefined, schema);
		}
		urlHistory[schema['$ref']] = true;
		schema = this.getSchema(schema['$ref'], urlHistory);
	}
	return schema;
};
ValidatorContext.prototype.getSchema = function (url, urlHistory) {
	var schema;
	if (this.schemas[url] !== undefined) {
		schema = this.schemas[url];
		return this.resolveRefs(schema, urlHistory);
	}
	var baseUrl = url;
	var fragment = "";
	if (url.indexOf('#') !== -1) {
		fragment = url.substring(url.indexOf("#") + 1);
		baseUrl = url.substring(0, url.indexOf("#"));
	}
	if (typeof this.schemas[baseUrl] === 'object') {
		schema = this.schemas[baseUrl];
		var pointerPath = decodeURIComponent(fragment);
		if (pointerPath === "") {
			return this.resolveRefs(schema, urlHistory);
		} else if (pointerPath.charAt(0) !== "/") {
			return undefined;
		}
		var parts = pointerPath.split("/").slice(1);
		for (var i = 0; i < parts.length; i++) {
			var component = parts[i].replace(/~1/g, "/").replace(/~0/g, "~");
			if (schema[component] === undefined) {
				schema = undefined;
				break;
			}
			schema = schema[component];
		}
		if (schema !== undefined) {
			return this.resolveRefs(schema, urlHistory);
		}
	}
	if (this.missing[baseUrl] === undefined) {
		this.missing.push(baseUrl);
		this.missing[baseUrl] = baseUrl;
		this.missingMap[baseUrl] = baseUrl;
	}
};
ValidatorContext.prototype.searchSchemas = function (schema, url) {
	if (Array.isArray(schema)) {
		for (var i = 0; i < schema.length; i++) {
			this.searchSchemas(schema[i], url);
		}
	} else if (schema && typeof schema === "object") {
		if (typeof schema.id === "string") {
			if (isTrustedUrl(url, schema.id)) {
				if (this.schemas[schema.id] === undefined) {
					this.schemas[schema.id] = schema;
				}
			}
		}
		for (var key in schema) {
			if (key !== "enum") {
				if (typeof schema[key] === "object") {
					this.searchSchemas(schema[key], url);
				} else if (key === "$ref") {
					var uri = getDocumentUri(schema[key]);
					if (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {
						this.missingMap[uri] = uri;
					}
				}
			}
		}
	}
};
ValidatorContext.prototype.addSchema = function (url, schema) {
	//overload
	if (typeof url !== 'string' || typeof schema === 'undefined') {
		if (typeof url === 'object' && typeof url.id === 'string') {
			schema = url;
			url = schema.id;
		}
		else {
			return;
		}
	}
	if (url === getDocumentUri(url) + "#") {
		// Remove empty fragment
		url = getDocumentUri(url);
	}
	this.schemas[url] = schema;
	delete this.missingMap[url];
	normSchema(schema, url);
	this.searchSchemas(schema, url);
};

ValidatorContext.prototype.getSchemaMap = function () {
	var map = {};
	for (var key in this.schemas) {
		map[key] = this.schemas[key];
	}
	return map;
};

ValidatorContext.prototype.getSchemaUris = function (filterRegExp) {
	var list = [];
	for (var key in this.schemas) {
		if (!filterRegExp || filterRegExp.test(key)) {
			list.push(key);
		}
	}
	return list;
};

ValidatorContext.prototype.getMissingUris = function (filterRegExp) {
	var list = [];
	for (var key in this.missingMap) {
		if (!filterRegExp || filterRegExp.test(key)) {
			list.push(key);
		}
	}
	return list;
};

ValidatorContext.prototype.dropSchemas = function () {
	this.schemas = {};
	this.reset();
};
ValidatorContext.prototype.reset = function () {
	this.missing = [];
	this.missingMap = {};
	this.errors = [];
};

ValidatorContext.prototype.validateAll = function (data, schema, dataPathParts, schemaPathParts, dataPointerPath) {
	var topLevel;
	schema = this.resolveRefs(schema);
	if (!schema) {
		return null;
	} else if (schema instanceof ValidationError) {
		this.errors.push(schema);
		return schema;
	}

	var startErrorCount = this.errors.length;
	var frozenIndex, scannedFrozenSchemaIndex = null, scannedSchemasIndex = null;
	if (this.checkRecursive && data && typeof data === 'object') {
		topLevel = !this.scanned.length;
		if (data[this.validatedSchemasKey]) {
			var schemaIndex = data[this.validatedSchemasKey].indexOf(schema);
			if (schemaIndex !== -1) {
				this.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);
				return null;
			}
		}
		if (Object.isFrozen(data)) {
			frozenIndex = this.scannedFrozen.indexOf(data);
			if (frozenIndex !== -1) {
				var frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);
				if (frozenSchemaIndex !== -1) {
					this.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);
					return null;
				}
			}
		}
		this.scanned.push(data);
		if (Object.isFrozen(data)) {
			if (frozenIndex === -1) {
				frozenIndex = this.scannedFrozen.length;
				this.scannedFrozen.push(data);
				this.scannedFrozenSchemas.push([]);
			}
			scannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;
			this.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;
			this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];
		} else {
			if (!data[this.validatedSchemasKey]) {
				try {
					Object.defineProperty(data, this.validatedSchemasKey, {
						value: [],
						configurable: true
					});
					Object.defineProperty(data, this.validationErrorsKey, {
						value: [],
						configurable: true
					});
				} catch (e) {
					//IE 7/8 workaround
					data[this.validatedSchemasKey] = [];
					data[this.validationErrorsKey] = [];
				}
			}
			scannedSchemasIndex = data[this.validatedSchemasKey].length;
			data[this.validatedSchemasKey][scannedSchemasIndex] = schema;
			data[this.validationErrorsKey][scannedSchemasIndex] = [];
		}
	}

	var errorCount = this.errors.length;
	var error = this.validateBasic(data, schema, dataPointerPath)
		|| this.validateNumeric(data, schema, dataPointerPath)
		|| this.validateString(data, schema, dataPointerPath)
		|| this.validateArray(data, schema, dataPointerPath)
		|| this.validateObject(data, schema, dataPointerPath)
		|| this.validateCombinations(data, schema, dataPointerPath)
		|| this.validateHypermedia(data, schema, dataPointerPath)
		|| this.validateFormat(data, schema, dataPointerPath)
		|| this.validateDefinedKeywords(data, schema, dataPointerPath)
		|| null;

	if (topLevel) {
		while (this.scanned.length) {
			var item = this.scanned.pop();
			delete item[this.validatedSchemasKey];
		}
		this.scannedFrozen = [];
		this.scannedFrozenSchemas = [];
	}

	if (error || errorCount !== this.errors.length) {
		while ((dataPathParts && dataPathParts.length) || (schemaPathParts && schemaPathParts.length)) {
			var dataPart = (dataPathParts && dataPathParts.length) ? "" + dataPathParts.pop() : null;
			var schemaPart = (schemaPathParts && schemaPathParts.length) ? "" + schemaPathParts.pop() : null;
			if (error) {
				error = error.prefixWith(dataPart, schemaPart);
			}
			this.prefixErrors(errorCount, dataPart, schemaPart);
		}
	}

	if (scannedFrozenSchemaIndex !== null) {
		this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);
	} else if (scannedSchemasIndex !== null) {
		data[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);
	}

	return this.handleError(error);
};
ValidatorContext.prototype.validateFormat = function (data, schema) {
	if (typeof schema.format !== 'string' || !this.formatValidators[schema.format]) {
		return null;
	}
	var errorMessage = this.formatValidators[schema.format].call(null, data, schema);
	if (typeof errorMessage === 'string' || typeof errorMessage === 'number') {
		return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage}, '', '/format', null, data, schema);
	} else if (errorMessage && typeof errorMessage === 'object') {
		return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage.message || "?"}, errorMessage.dataPath || '', errorMessage.schemaPath || "/format", null, data, schema);
	}
	return null;
};
ValidatorContext.prototype.validateDefinedKeywords = function (data, schema, dataPointerPath) {
	for (var key in this.definedKeywords) {
		if (typeof schema[key] === 'undefined') {
			continue;
		}
		var validationFunctions = this.definedKeywords[key];
		for (var i = 0; i < validationFunctions.length; i++) {
			var func = validationFunctions[i];
			var result = func(data, schema[key], schema, dataPointerPath);
			if (typeof result === 'string' || typeof result === 'number') {
				return this.createError(ErrorCodes.KEYWORD_CUSTOM, {key: key, message: result}, '', '', null, data, schema).prefixWith(null, key);
			} else if (result && typeof result === 'object') {
				var code = result.code;
				if (typeof code === 'string') {
					if (!ErrorCodes[code]) {
						throw new Error('Undefined error code (use defineError): ' + code);
					}
					code = ErrorCodes[code];
				} else if (typeof code !== 'number') {
					code = ErrorCodes.KEYWORD_CUSTOM;
				}
				var messageParams = (typeof result.message === 'object') ? result.message : {key: key, message: result.message || "?"};
				var schemaPath = result.schemaPath || ("/" + key.replace(/~/g, '~0').replace(/\//g, '~1'));
				return this.createError(code, messageParams, result.dataPath || null, schemaPath, null, data, schema);
			}
		}
	}
	return null;
};

function recursiveCompare(A, B) {
	if (A === B) {
		return true;
	}
	if (A && B && typeof A === "object" && typeof B === "object") {
		if (Array.isArray(A) !== Array.isArray(B)) {
			return false;
		} else if (Array.isArray(A)) {
			if (A.length !== B.length) {
				return false;
			}
			for (var i = 0; i < A.length; i++) {
				if (!recursiveCompare(A[i], B[i])) {
					return false;
				}
			}
		} else {
			var key;
			for (key in A) {
				if (B[key] === undefined && A[key] !== undefined) {
					return false;
				}
			}
			for (key in B) {
				if (A[key] === undefined && B[key] !== undefined) {
					return false;
				}
			}
			for (key in A) {
				if (!recursiveCompare(A[key], B[key])) {
					return false;
				}
			}
		}
		return true;
	}
	return false;
}

ValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {
	var error;
	if (error = this.validateType(data, schema, dataPointerPath)) {
		return error.prefixWith(null, "type");
	}
	if (error = this.validateEnum(data, schema, dataPointerPath)) {
		return error.prefixWith(null, "type");
	}
	return null;
};

ValidatorContext.prototype.validateType = function validateType(data, schema) {
	if (schema.type === undefined) {
		return null;
	}
	var dataType = typeof data;
	if (data === null) {
		dataType = "null";
	} else if (Array.isArray(data)) {
		dataType = "array";
	}
	var allowedTypes = schema.type;
	if (!Array.isArray(allowedTypes)) {
		allowedTypes = [allowedTypes];
	}

	for (var i = 0; i < allowedTypes.length; i++) {
		var type = allowedTypes[i];
		if (type === dataType || (type === "integer" && dataType === "number" && (data % 1 === 0))) {
			return null;
		}
	}
	return this.createError(ErrorCodes.INVALID_TYPE, {type: dataType, expected: allowedTypes.join("/")}, '', '', null, data, schema);
};

ValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {
	if (schema["enum"] === undefined) {
		return null;
	}
	for (var i = 0; i < schema["enum"].length; i++) {
		var enumVal = schema["enum"][i];
		if (recursiveCompare(data, enumVal)) {
			return null;
		}
	}
	return this.createError(ErrorCodes.ENUM_MISMATCH, {value: (typeof JSON !== 'undefined') ? JSON.stringify(data) : data}, '', '', null, data, schema);
};

ValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {
	return this.validateMultipleOf(data, schema, dataPointerPath)
		|| this.validateMinMax(data, schema, dataPointerPath)
		|| this.validateNaN(data, schema, dataPointerPath)
		|| null;
};

var CLOSE_ENOUGH_LOW = Math.pow(2, -51);
var CLOSE_ENOUGH_HIGH = 1 - CLOSE_ENOUGH_LOW;
ValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {
	var multipleOf = schema.multipleOf || schema.divisibleBy;
	if (multipleOf === undefined) {
		return null;
	}
	if (typeof data === "number") {
		var remainder = (data/multipleOf)%1;
		if (remainder >= CLOSE_ENOUGH_LOW && remainder < CLOSE_ENOUGH_HIGH) {
			return this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, {value: data, multipleOf: multipleOf}, '', '', null, data, schema);
		}
	}
	return null;
};

ValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {
	if (typeof data !== "number") {
		return null;
	}
	if (schema.minimum !== undefined) {
		if (data < schema.minimum) {
			return this.createError(ErrorCodes.NUMBER_MINIMUM, {value: data, minimum: schema.minimum}, '', '/minimum', null, data, schema);
		}
		if (schema.exclusiveMinimum && data === schema.minimum) {
			return this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, {value: data, minimum: schema.minimum}, '', '/exclusiveMinimum', null, data, schema);
		}
	}
	if (schema.maximum !== undefined) {
		if (data > schema.maximum) {
			return this.createError(ErrorCodes.NUMBER_MAXIMUM, {value: data, maximum: schema.maximum}, '', '/maximum', null, data, schema);
		}
		if (schema.exclusiveMaximum && data === schema.maximum) {
			return this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, {value: data, maximum: schema.maximum}, '', '/exclusiveMaximum', null, data, schema);
		}
	}
	return null;
};

ValidatorContext.prototype.validateNaN = function validateNaN(data, schema) {
	if (typeof data !== "number") {
		return null;
	}
	if (isNaN(data) === true || data === Infinity || data === -Infinity) {
		return this.createError(ErrorCodes.NUMBER_NOT_A_NUMBER, {value: data}, '', '/type', null, data, schema);
	}
	return null;
};

ValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {
	return this.validateStringLength(data, schema, dataPointerPath)
		|| this.validateStringPattern(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {
	if (typeof data !== "string") {
		return null;
	}
	if (schema.minLength !== undefined) {
		if (data.length < schema.minLength) {
			return this.createError(ErrorCodes.STRING_LENGTH_SHORT, {length: data.length, minimum: schema.minLength}, '', '/minLength', null, data, schema);
		}
	}
	if (schema.maxLength !== undefined) {
		if (data.length > schema.maxLength) {
			return this.createError(ErrorCodes.STRING_LENGTH_LONG, {length: data.length, maximum: schema.maxLength}, '', '/maxLength', null, data, schema);
		}
	}
	return null;
};

ValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {
	if (typeof data !== "string" || (typeof schema.pattern !== "string" && !(schema.pattern instanceof RegExp))) {
		return null;
	}
	var regexp;
	if (schema.pattern instanceof RegExp) {
	  regexp = schema.pattern;
	}
	else {
	  var body, flags = '';
	  // Check for regular expression literals
	  // @see http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.5
	  var literal = schema.pattern.match(/^\/(.+)\/([img]*)$/);
	  if (literal) {
	    body = literal[1];
	    flags = literal[2];
	  }
	  else {
	    body = schema.pattern;
	  }
	  regexp = new RegExp(body, flags);
	}
	if (!regexp.test(data)) {
		return this.createError(ErrorCodes.STRING_PATTERN, {pattern: schema.pattern}, '', '/pattern', null, data, schema);
	}
	return null;
};

ValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {
	if (!Array.isArray(data)) {
		return null;
	}
	return this.validateArrayLength(data, schema, dataPointerPath)
		|| this.validateArrayUniqueItems(data, schema, dataPointerPath)
		|| this.validateArrayItems(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {
	var error;
	if (schema.minItems !== undefined) {
		if (data.length < schema.minItems) {
			error = this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, {length: data.length, minimum: schema.minItems}, '', '/minItems', null, data, schema);
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	if (schema.maxItems !== undefined) {
		if (data.length > schema.maxItems) {
			error = this.createError(ErrorCodes.ARRAY_LENGTH_LONG, {length: data.length, maximum: schema.maxItems}, '', '/maxItems', null, data, schema);
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {
	if (schema.uniqueItems) {
		for (var i = 0; i < data.length; i++) {
			for (var j = i + 1; j < data.length; j++) {
				if (recursiveCompare(data[i], data[j])) {
					var error = this.createError(ErrorCodes.ARRAY_UNIQUE, {match1: i, match2: j}, '', '/uniqueItems', null, data, schema);
					if (this.handleError(error)) {
						return error;
					}
				}
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {
	if (schema.items === undefined) {
		return null;
	}
	var error, i;
	if (Array.isArray(schema.items)) {
		for (i = 0; i < data.length; i++) {
			if (i < schema.items.length) {
				if (error = this.validateAll(data[i], schema.items[i], [i], ["items", i], dataPointerPath + "/" + i)) {
					return error;
				}
			} else if (schema.additionalItems !== undefined) {
				if (typeof schema.additionalItems === "boolean") {
					if (!schema.additionalItems) {
						error = (this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {}, '/' + i, '/additionalItems', null, data, schema));
						if (this.handleError(error)) {
							return error;
						}
					}
				} else if (error = this.validateAll(data[i], schema.additionalItems, [i], ["additionalItems"], dataPointerPath + "/" + i)) {
					return error;
				}
			}
		}
	} else {
		for (i = 0; i < data.length; i++) {
			if (error = this.validateAll(data[i], schema.items, [i], ["items"], dataPointerPath + "/" + i)) {
				return error;
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {
	if (typeof data !== "object" || data === null || Array.isArray(data)) {
		return null;
	}
	return this.validateObjectMinMaxProperties(data, schema, dataPointerPath)
		|| this.validateObjectRequiredProperties(data, schema, dataPointerPath)
		|| this.validateObjectProperties(data, schema, dataPointerPath)
		|| this.validateObjectDependencies(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {
	var keys = Object.keys(data);
	var error;
	if (schema.minProperties !== undefined) {
		if (keys.length < schema.minProperties) {
			error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, {propertyCount: keys.length, minimum: schema.minProperties}, '', '/minProperties', null, data, schema);
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	if (schema.maxProperties !== undefined) {
		if (keys.length > schema.maxProperties) {
			error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, {propertyCount: keys.length, maximum: schema.maxProperties}, '', '/maxProperties', null, data, schema);
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {
	if (schema.required !== undefined) {
		for (var i = 0; i < schema.required.length; i++) {
			var key = schema.required[i];
			if (data[key] === undefined) {
				var error = this.createError(ErrorCodes.OBJECT_REQUIRED, {key: key}, '', '/required/' + i, null, data, schema);
				if (this.handleError(error)) {
					return error;
				}
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {
	var error;
	for (var key in data) {
		var keyPointerPath = dataPointerPath + "/" + key.replace(/~/g, '~0').replace(/\//g, '~1');
		var foundMatch = false;
		if (schema.properties !== undefined && schema.properties[key] !== undefined) {
			foundMatch = true;
			if (error = this.validateAll(data[key], schema.properties[key], [key], ["properties", key], keyPointerPath)) {
				return error;
			}
		}
		if (schema.patternProperties !== undefined) {
			for (var patternKey in schema.patternProperties) {
				var regexp = new RegExp(patternKey);
				if (regexp.test(key)) {
					foundMatch = true;
					if (error = this.validateAll(data[key], schema.patternProperties[patternKey], [key], ["patternProperties", patternKey], keyPointerPath)) {
						return error;
					}
				}
			}
		}
		if (!foundMatch) {
			if (schema.additionalProperties !== undefined) {
				if (this.trackUnknownProperties) {
					this.knownPropertyPaths[keyPointerPath] = true;
					delete this.unknownPropertyPaths[keyPointerPath];
				}
				if (typeof schema.additionalProperties === "boolean") {
					if (!schema.additionalProperties) {
						error = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, {key: key}, '', '/additionalProperties', null, data, schema).prefixWith(key, null);
						if (this.handleError(error)) {
							return error;
						}
					}
				} else {
					if (error = this.validateAll(data[key], schema.additionalProperties, [key], ["additionalProperties"], keyPointerPath)) {
						return error;
					}
				}
			} else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {
				this.unknownPropertyPaths[keyPointerPath] = true;
			}
		} else if (this.trackUnknownProperties) {
			this.knownPropertyPaths[keyPointerPath] = true;
			delete this.unknownPropertyPaths[keyPointerPath];
		}
	}
	return null;
};

ValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {
	var error;
	if (schema.dependencies !== undefined) {
		for (var depKey in schema.dependencies) {
			if (data[depKey] !== undefined) {
				var dep = schema.dependencies[depKey];
				if (typeof dep === "string") {
					if (data[dep] === undefined) {
						error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: dep}, '', '', null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");
						if (this.handleError(error)) {
							return error;
						}
					}
				} else if (Array.isArray(dep)) {
					for (var i = 0; i < dep.length; i++) {
						var requiredKey = dep[i];
						if (data[requiredKey] === undefined) {
							error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: requiredKey}, '', '/' + i, null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");
							if (this.handleError(error)) {
								return error;
							}
						}
					}
				} else {
					if (error = this.validateAll(data, dep, [], ["dependencies", depKey], dataPointerPath)) {
						return error;
					}
				}
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {
	return this.validateAllOf(data, schema, dataPointerPath)
		|| this.validateAnyOf(data, schema, dataPointerPath)
		|| this.validateOneOf(data, schema, dataPointerPath)
		|| this.validateNot(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {
	if (schema.allOf === undefined) {
		return null;
	}
	var error;
	for (var i = 0; i < schema.allOf.length; i++) {
		var subSchema = schema.allOf[i];
		if (error = this.validateAll(data, subSchema, [], ["allOf", i], dataPointerPath)) {
			return error;
		}
	}
	return null;
};

ValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {
	if (schema.anyOf === undefined) {
		return null;
	}
	var errors = [];
	var startErrorCount = this.errors.length;
	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
	}
	var errorAtEnd = true;
	for (var i = 0; i < schema.anyOf.length; i++) {
		if (this.trackUnknownProperties) {
			this.unknownPropertyPaths = {};
			this.knownPropertyPaths = {};
		}
		var subSchema = schema.anyOf[i];

		var errorCount = this.errors.length;
		var error = this.validateAll(data, subSchema, [], ["anyOf", i], dataPointerPath);

		if (error === null && errorCount === this.errors.length) {
			this.errors = this.errors.slice(0, startErrorCount);

			if (this.trackUnknownProperties) {
				for (var knownKey in this.knownPropertyPaths) {
					oldKnownPropertyPaths[knownKey] = true;
					delete oldUnknownPropertyPaths[knownKey];
				}
				for (var unknownKey in this.unknownPropertyPaths) {
					if (!oldKnownPropertyPaths[unknownKey]) {
						oldUnknownPropertyPaths[unknownKey] = true;
					}
				}
				// We need to continue looping so we catch all the property definitions, but we don't want to return an error
				errorAtEnd = false;
				continue;
			}

			return null;
		}
		if (error) {
			errors.push(error.prefixWith(null, "" + i).prefixWith(null, "anyOf"));
		}
	}
	if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	}
	if (errorAtEnd) {
		errors = errors.concat(this.errors.slice(startErrorCount));
		this.errors = this.errors.slice(0, startErrorCount);
		return this.createError(ErrorCodes.ANY_OF_MISSING, {}, "", "/anyOf", errors, data, schema);
	}
};

ValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {
	if (schema.oneOf === undefined) {
		return null;
	}
	var validIndex = null;
	var errors = [];
	var startErrorCount = this.errors.length;
	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
	}
	for (var i = 0; i < schema.oneOf.length; i++) {
		if (this.trackUnknownProperties) {
			this.unknownPropertyPaths = {};
			this.knownPropertyPaths = {};
		}
		var subSchema = schema.oneOf[i];

		var errorCount = this.errors.length;
		var error = this.validateAll(data, subSchema, [], ["oneOf", i], dataPointerPath);

		if (error === null && errorCount === this.errors.length) {
			if (validIndex === null) {
				validIndex = i;
			} else {
				this.errors = this.errors.slice(0, startErrorCount);
				return this.createError(ErrorCodes.ONE_OF_MULTIPLE, {index1: validIndex, index2: i}, "", "/oneOf", null, data, schema);
			}
			if (this.trackUnknownProperties) {
				for (var knownKey in this.knownPropertyPaths) {
					oldKnownPropertyPaths[knownKey] = true;
					delete oldUnknownPropertyPaths[knownKey];
				}
				for (var unknownKey in this.unknownPropertyPaths) {
					if (!oldKnownPropertyPaths[unknownKey]) {
						oldUnknownPropertyPaths[unknownKey] = true;
					}
				}
			}
		} else if (error) {
			errors.push(error);
		}
	}
	if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	}
	if (validIndex === null) {
		errors = errors.concat(this.errors.slice(startErrorCount));
		this.errors = this.errors.slice(0, startErrorCount);
		return this.createError(ErrorCodes.ONE_OF_MISSING, {}, "", "/oneOf", errors, data, schema);
	} else {
		this.errors = this.errors.slice(0, startErrorCount);
	}
	return null;
};

ValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {
	if (schema.not === undefined) {
		return null;
	}
	var oldErrorCount = this.errors.length;
	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
		this.unknownPropertyPaths = {};
		this.knownPropertyPaths = {};
	}
	var error = this.validateAll(data, schema.not, null, null, dataPointerPath);
	var notErrors = this.errors.slice(oldErrorCount);
	this.errors = this.errors.slice(0, oldErrorCount);
	if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	}
	if (error === null && notErrors.length === 0) {
		return this.createError(ErrorCodes.NOT_PASSED, {}, "", "/not", null, data, schema);
	}
	return null;
};

ValidatorContext.prototype.validateHypermedia = function validateCombinations(data, schema, dataPointerPath) {
	if (!schema.links) {
		return null;
	}
	var error;
	for (var i = 0; i < schema.links.length; i++) {
		var ldo = schema.links[i];
		if (ldo.rel === "describedby") {
			var template = new UriTemplate(ldo.href);
			var allPresent = true;
			for (var j = 0; j < template.varNames.length; j++) {
				if (!(template.varNames[j] in data)) {
					allPresent = false;
					break;
				}
			}
			if (allPresent) {
				var schemaUrl = template.fillFromObject(data);
				var subSchema = {"$ref": schemaUrl};
				if (error = this.validateAll(data, subSchema, [], ["links", i], dataPointerPath)) {
					return error;
				}
			}
		}
	}
};

// parseURI() and resolveUrl() are from https://gist.github.com/1088850
//   -  released as public domain by author ("Yaffle") - see comments on gist

function parseURI(url) {
	var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
	// authority = '//' + user + ':' + pass '@' + hostname + ':' port
	return (m ? {
		href     : m[0] || '',
		protocol : m[1] || '',
		authority: m[2] || '',
		host     : m[3] || '',
		hostname : m[4] || '',
		port     : m[5] || '',
		pathname : m[6] || '',
		search   : m[7] || '',
		hash     : m[8] || ''
	} : null);
}

function resolveUrl(base, href) {// RFC 3986

	function removeDotSegments(input) {
		var output = [];
		input.replace(/^(\.\.?(\/|$))+/, '')
			.replace(/\/(\.(\/|$))+/g, '/')
			.replace(/\/\.\.$/, '/../')
			.replace(/\/?[^\/]*/g, function (p) {
				if (p === '/..') {
					output.pop();
				} else {
					output.push(p);
				}
		});
		return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
	}

	href = parseURI(href || '');
	base = parseURI(base || '');

	return !href || !base ? null : (href.protocol || base.protocol) +
		(href.protocol || href.authority ? href.authority : base.authority) +
		removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +
		(href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +
		href.hash;
}

function getDocumentUri(uri) {
	return uri.split('#')[0];
}
function normSchema(schema, baseUri) {
	if (schema && typeof schema === "object") {
		if (baseUri === undefined) {
			baseUri = schema.id;
		} else if (typeof schema.id === "string") {
			baseUri = resolveUrl(baseUri, schema.id);
			schema.id = baseUri;
		}
		if (Array.isArray(schema)) {
			for (var i = 0; i < schema.length; i++) {
				normSchema(schema[i], baseUri);
			}
		} else {
			if (typeof schema['$ref'] === "string") {
				schema['$ref'] = resolveUrl(baseUri, schema['$ref']);
			}
			for (var key in schema) {
				if (key !== "enum") {
					normSchema(schema[key], baseUri);
				}
			}
		}
	}
}

function defaultErrorReporter(language) {
	language = language || 'en';

	var errorMessages = languages[language];

	return function (error) {
		var messageTemplate = errorMessages[error.code] || ErrorMessagesDefault[error.code];
		if (typeof messageTemplate !== 'string') {
			return "Unknown error code " + error.code + ": " + JSON.stringify(error.messageParams);
		}
		var messageParams = error.params;
		// Adapted from Crockford's supplant()
		return messageTemplate.replace(/\{([^{}]*)\}/g, function (whole, varName) {
			var subValue = messageParams[varName];
			return typeof subValue === 'string' || typeof subValue === 'number' ? subValue : whole;
		});
	};
}

var ErrorCodes = {
	INVALID_TYPE: 0,
	ENUM_MISMATCH: 1,
	ANY_OF_MISSING: 10,
	ONE_OF_MISSING: 11,
	ONE_OF_MULTIPLE: 12,
	NOT_PASSED: 13,
	// Numeric errors
	NUMBER_MULTIPLE_OF: 100,
	NUMBER_MINIMUM: 101,
	NUMBER_MINIMUM_EXCLUSIVE: 102,
	NUMBER_MAXIMUM: 103,
	NUMBER_MAXIMUM_EXCLUSIVE: 104,
	NUMBER_NOT_A_NUMBER: 105,
	// String errors
	STRING_LENGTH_SHORT: 200,
	STRING_LENGTH_LONG: 201,
	STRING_PATTERN: 202,
	// Object errors
	OBJECT_PROPERTIES_MINIMUM: 300,
	OBJECT_PROPERTIES_MAXIMUM: 301,
	OBJECT_REQUIRED: 302,
	OBJECT_ADDITIONAL_PROPERTIES: 303,
	OBJECT_DEPENDENCY_KEY: 304,
	// Array errors
	ARRAY_LENGTH_SHORT: 400,
	ARRAY_LENGTH_LONG: 401,
	ARRAY_UNIQUE: 402,
	ARRAY_ADDITIONAL_ITEMS: 403,
	// Custom/user-defined errors
	FORMAT_CUSTOM: 500,
	KEYWORD_CUSTOM: 501,
	// Schema structure
	CIRCULAR_REFERENCE: 600,
	// Non-standard validation options
	UNKNOWN_PROPERTY: 1000
};
var ErrorCodeLookup = {};
for (var key in ErrorCodes) {
	ErrorCodeLookup[ErrorCodes[key]] = key;
}
var ErrorMessagesDefault = {
	INVALID_TYPE: "Invalid type: {type} (expected {expected})",
	ENUM_MISMATCH: "No enum match for: {value}",
	ANY_OF_MISSING: "Data does not match any schemas from \"anyOf\"",
	ONE_OF_MISSING: "Data does not match any schemas from \"oneOf\"",
	ONE_OF_MULTIPLE: "Data is valid against more than one schema from \"oneOf\": indices {index1} and {index2}",
	NOT_PASSED: "Data matches schema from \"not\"",
	// Numeric errors
	NUMBER_MULTIPLE_OF: "Value {value} is not a multiple of {multipleOf}",
	NUMBER_MINIMUM: "Value {value} is less than minimum {minimum}",
	NUMBER_MINIMUM_EXCLUSIVE: "Value {value} is equal to exclusive minimum {minimum}",
	NUMBER_MAXIMUM: "Value {value} is greater than maximum {maximum}",
	NUMBER_MAXIMUM_EXCLUSIVE: "Value {value} is equal to exclusive maximum {maximum}",
	NUMBER_NOT_A_NUMBER: "Value {value} is not a valid number",
	// String errors
	STRING_LENGTH_SHORT: "String is too short ({length} chars), minimum {minimum}",
	STRING_LENGTH_LONG: "String is too long ({length} chars), maximum {maximum}",
	STRING_PATTERN: "String does not match pattern: {pattern}",
	// Object errors
	OBJECT_PROPERTIES_MINIMUM: "Too few properties defined ({propertyCount}), minimum {minimum}",
	OBJECT_PROPERTIES_MAXIMUM: "Too many properties defined ({propertyCount}), maximum {maximum}",
	OBJECT_REQUIRED: "Missing required property: {key}",
	OBJECT_ADDITIONAL_PROPERTIES: "Additional properties not allowed",
	OBJECT_DEPENDENCY_KEY: "Dependency failed - key must exist: {missing} (due to key: {key})",
	// Array errors
	ARRAY_LENGTH_SHORT: "Array is too short ({length}), minimum {minimum}",
	ARRAY_LENGTH_LONG: "Array is too long ({length}), maximum {maximum}",
	ARRAY_UNIQUE: "Array items are not unique (indices {match1} and {match2})",
	ARRAY_ADDITIONAL_ITEMS: "Additional items not allowed",
	// Format errors
	FORMAT_CUSTOM: "Format validation failed ({message})",
	KEYWORD_CUSTOM: "Keyword failed: {key} ({message})",
	// Schema structure
	CIRCULAR_REFERENCE: "Circular $refs: {urls}",
	// Non-standard validation options
	UNKNOWN_PROPERTY: "Unknown property (not in schema)"
};

function ValidationError(code, params, dataPath, schemaPath, subErrors) {
	Error.call(this);
	if (code === undefined) {
		throw new Error ("No error code supplied: " + schemaPath);
	}
	this.message = '';
	this.params = params;
	this.code = code;
	this.dataPath = dataPath || "";
	this.schemaPath = schemaPath || "";
	this.subErrors = subErrors || null;

	var err = new Error(this.message);
	this.stack = err.stack || err.stacktrace;
	if (!this.stack) {
		try {
			throw err;
		}
		catch(err) {
			this.stack = err.stack || err.stacktrace;
		}
	}
}
ValidationError.prototype = Object.create(Error.prototype);
ValidationError.prototype.constructor = ValidationError;
ValidationError.prototype.name = 'ValidationError';

ValidationError.prototype.prefixWith = function (dataPrefix, schemaPrefix) {
	if (dataPrefix !== null) {
		dataPrefix = dataPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
		this.dataPath = "/" + dataPrefix + this.dataPath;
	}
	if (schemaPrefix !== null) {
		schemaPrefix = schemaPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
		this.schemaPath = "/" + schemaPrefix + this.schemaPath;
	}
	if (this.subErrors !== null) {
		for (var i = 0; i < this.subErrors.length; i++) {
			this.subErrors[i].prefixWith(dataPrefix, schemaPrefix);
		}
	}
	return this;
};

function isTrustedUrl(baseUrl, testUrl) {
	if(testUrl.substring(0, baseUrl.length) === baseUrl){
		var remainder = testUrl.substring(baseUrl.length);
		if ((testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === "/")
			|| remainder.charAt(0) === "#"
			|| remainder.charAt(0) === "?") {
			return true;
		}
	}
	return false;
}

var languages = {};
function createApi(language) {
	var globalContext = new ValidatorContext();
	var currentLanguage;
	var customErrorReporter;
	var api = {
		setErrorReporter: function (reporter) {
			if (typeof reporter === 'string') {
				return this.language(reporter);
			}
			customErrorReporter = reporter;
			return true;
		},
		addFormat: function () {
			globalContext.addFormat.apply(globalContext, arguments);
		},
		language: function (code) {
			if (!code) {
				return currentLanguage;
			}
			if (!languages[code]) {
				code = code.split('-')[0]; // fall back to base language
			}
			if (languages[code]) {
				currentLanguage = code;
				return code; // so you can tell if fall-back has happened
			}
			return false;
		},
		addLanguage: function (code, messageMap) {
			var key;
			for (key in ErrorCodes) {
				if (messageMap[key] && !messageMap[ErrorCodes[key]]) {
					messageMap[ErrorCodes[key]] = messageMap[key];
				}
			}
			var rootCode = code.split('-')[0];
			if (!languages[rootCode]) { // use for base language if not yet defined
				languages[code] = messageMap;
				languages[rootCode] = messageMap;
			} else {
				languages[code] = Object.create(languages[rootCode]);
				for (key in messageMap) {
					if (typeof languages[rootCode][key] === 'undefined') {
						languages[rootCode][key] = messageMap[key];
					}
					languages[code][key] = messageMap[key];
				}
			}
			return this;
		},
		freshApi: function (language) {
			var result = createApi();
			if (language) {
				result.language(language);
			}
			return result;
		},
		validate: function (data, schema, checkRecursive, banUnknownProperties) {
			var def = defaultErrorReporter(currentLanguage);
			var errorReporter = customErrorReporter ? function (error, data, schema) {
				return customErrorReporter(error, data, schema) || def(error, data, schema);
			} : def;
			var context = new ValidatorContext(globalContext, false, errorReporter, checkRecursive, banUnknownProperties);
			if (typeof schema === "string") {
				schema = {"$ref": schema};
			}
			context.addSchema("", schema);
			var error = context.validateAll(data, schema, null, null, "");
			if (!error && banUnknownProperties) {
				error = context.banUnknownProperties(data, schema);
			}
			this.error = error;
			this.missing = context.missing;
			this.valid = (error === null);
			return this.valid;
		},
		validateResult: function () {
			var result = {};
			this.validate.apply(result, arguments);
			return result;
		},
		validateMultiple: function (data, schema, checkRecursive, banUnknownProperties) {
			var def = defaultErrorReporter(currentLanguage);
			var errorReporter = customErrorReporter ? function (error, data, schema) {
				return customErrorReporter(error, data, schema) || def(error, data, schema);
			} : def;
			var context = new ValidatorContext(globalContext, true, errorReporter, checkRecursive, banUnknownProperties);
			if (typeof schema === "string") {
				schema = {"$ref": schema};
			}
			context.addSchema("", schema);
			context.validateAll(data, schema, null, null, "");
			if (banUnknownProperties) {
				context.banUnknownProperties(data, schema);
			}
			var result = {};
			result.errors = context.errors;
			result.missing = context.missing;
			result.valid = (result.errors.length === 0);
			return result;
		},
		addSchema: function () {
			return globalContext.addSchema.apply(globalContext, arguments);
		},
		getSchema: function () {
			return globalContext.getSchema.apply(globalContext, arguments);
		},
		getSchemaMap: function () {
			return globalContext.getSchemaMap.apply(globalContext, arguments);
		},
		getSchemaUris: function () {
			return globalContext.getSchemaUris.apply(globalContext, arguments);
		},
		getMissingUris: function () {
			return globalContext.getMissingUris.apply(globalContext, arguments);
		},
		dropSchemas: function () {
			globalContext.dropSchemas.apply(globalContext, arguments);
		},
		defineKeyword: function () {
			globalContext.defineKeyword.apply(globalContext, arguments);
		},
		defineError: function (codeName, codeNumber, defaultMessage) {
			if (typeof codeName !== 'string' || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) {
				throw new Error('Code name must be a string in UPPER_CASE_WITH_UNDERSCORES');
			}
			if (typeof codeNumber !== 'number' || codeNumber%1 !== 0 || codeNumber < 10000) {
				throw new Error('Code number must be an integer > 10000');
			}
			if (typeof ErrorCodes[codeName] !== 'undefined') {
				throw new Error('Error already defined: ' + codeName + ' as ' + ErrorCodes[codeName]);
			}
			if (typeof ErrorCodeLookup[codeNumber] !== 'undefined') {
				throw new Error('Error code already used: ' + ErrorCodeLookup[codeNumber] + ' as ' + codeNumber);
			}
			ErrorCodes[codeName] = codeNumber;
			ErrorCodeLookup[codeNumber] = codeName;
			ErrorMessagesDefault[codeName] = ErrorMessagesDefault[codeNumber] = defaultMessage;
			for (var langCode in languages) {
				var language = languages[langCode];
				if (language[codeName]) {
					language[codeNumber] = language[codeNumber] || language[codeName];
				}
			}
		},
		reset: function () {
			globalContext.reset();
			this.error = null;
			this.missing = [];
			this.valid = true;
		},
		missing: [],
		error: null,
		valid: true,
		normSchema: normSchema,
		resolveUrl: resolveUrl,
		getDocumentUri: getDocumentUri,
		errorCodes: ErrorCodes
	};
	api.language(language || 'en');
	return api;
}

var tv4 = createApi();
tv4.addLanguage('en-gb', ErrorMessagesDefault);

//legacy property
tv4.tv4 = tv4;

return tv4; // used by _header.js to globalise.

}));
},{}],195:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],196:[function(require,module,exports){
'use strict';

// setup the drake (dragula instance) for our composer drag drop requirements

var Drake = function Drake(deps) {
  var cloneSelector = '.composer-node__toolbar [data-dragsource="composer"]';
  var containerSelector = '[data-dragsource="composer"]';
  var updateNode = deps.updateNode,
      dragula = deps.dragula,
      find = deps.find,
      ondrop = deps.ondrop;


  var isContainer = function isContainer(el) {
    return el.matches(containerSelector);
  };

  var accepts = function accepts(el, containerEl) {
    var accepts = containerEl.matches(containerSelector);

    if (accepts) {
      accepts = !containerEl.matches(cloneSelector);
    }

    if (accepts) {
      var node = find.elNode(el);
      var parentNode = find.containerElNode(containerEl);

      if (node === parentNode) return false;

      accepts = parentNode.accepts(node);
    }

    return accepts;
  };

  var options = { isContainer: isContainer, accepts: accepts };

  var drake = dragula(options);

  drake.on('drop', function (el, containerEl, sourceContainerEl, nextEl) {
    var node = find.elNode(el);
    var parentNode = find.containerElNode(containerEl);

    if (nextEl) {
      var referenceNode = find.elNode(nextEl);
      parentNode.insertBefore(node, referenceNode);
    } else {
      parentNode.append(node);
    }

    updateNode(node);

    ondrop(node, parentNode, el, containerEl, sourceContainerEl, nextEl);
  });

  return drake;
};

module.exports = Drake;

},{}],197:[function(require,module,exports){
'use strict';

// functions for finding different tree node types in the composer DOM

var Find = function Find(idMap) {
  var nodeEl = function nodeEl(el) {
    return el.querySelector('.composer-node');
  };
  var containerEl = function containerEl(el) {
    return el.closest('.composer-node');
  };
  var elNode = function elNode(el) {
    return idMap.findById(nodeEl(el).id);
  };
  var containerElNode = function containerElNode(el) {
    return idMap.findById(containerEl(el).id);
  };

  return { nodeEl: nodeEl, containerEl: containerEl, elNode: elNode, containerElNode: containerElNode };
};

module.exports = Find;

},{}],198:[function(require,module,exports){
'use strict';

/*
  cache that maps between tree nodes and their DOM representations using the id
  attribute
*/

var IdMap = function IdMap(tree) {
  var idMap = new Map();

  var findById = function findById(id) {
    if (idMap.has(id)) return idMap.get(id);

    var node = tree.find(function (n) {
      return n.id() === id;
    });

    idMap.set(id, node);

    return node;
  };

  var refresh = function refresh(node) {
    node.walk(function (n) {
      return idMap.set(n.id(), n);
    });
  };

  refresh(tree);

  return Object.assign(idMap, { findById: findById, refresh: refresh });
};

module.exports = IdMap;

},{}],199:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var dragula = require('dragula');
var morphdom = require('morphdom');
var IdMap = require('./idmap');
var Drake = require('./drake');
var Find = require('./find');

var defaultOptions = {
  document: typeof window === 'undefined' ? null : window.document,
  dragula: dragula,
  morphdom: morphdom,
  selector: '.composer'
};

var validateObj = function validateObj(obj, name, typeName) {
  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== typeName) throw new Error('A ' + name + ' ' + typeName + ' is required');
};

/*
  TODO

  * the expand/collapse children actions should be disabled if that action is
    not possible or necessary
  * the tree or options or something should be able to override the actions
    eg not all nodes may have all actions

*/
var Composer = function Composer(_tree, renderNode, options) {
  options = Object.assign({}, defaultOptions, options);

  var _options = options,
      document = _options.document,
      dragula = _options.dragula,
      morphdom = _options.morphdom,
      selector = _options.selector;


  validateObj(document, 'document', 'object');
  validateObj(renderNode, 'renderNode', 'function');
  validateObj(selector, 'selector', 'string');

  var _idMap = IdMap(_tree);
  var find = Find(_idMap);

  var composerView = document.querySelector(selector);

  var initialDom = renderNode(_tree);

  morphdom(composerView, initialDom.stringify());

  /*
   TODO the functions should take the actual el node, not the clicked node, any
   logic inside the various fns below for finding the el node should be moved
   here
  */
  var clickHandler = {
    '.composer-node__title, .composer-node__action > i': function composerNode__titleComposerNode__actionI(el) {
      return el.parentNode;
    },

    '.composer-node__toolbar': function composerNode__toolbar(el) {
      toggleEl(el);
    },

    '.composer-node__delete': function composerNode__delete(el) {
      var shouldDelete = window.confirm('Are you sure?');

      if (shouldDelete) removeEl(el);
    },

    '.composer-node__collapse-children': function composerNode__collapseChildren(el) {
      collapseElChildren(el);
    },

    '.composer-node__expand-children': function composerNode__expandChildren(el) {
      expandElChildren(el);
    }
  };

  var clickSelectors = Object.keys(clickHandler);

  var handleClick = function handleClick(el) {
    var selector = clickSelectors.find(function (sel) {
      return el.matches(sel);
    });

    if (selector) {
      el = clickHandler[selector](el);
    }

    if (el) handleClick(el);
  };

  composerView.addEventListener('click', function (e) {
    handleClick(e.target);
  });

  var toggleEl = function toggleEl(el) {
    var isNode = el.parentNode.matches('.composer-node');
    var key = isNode ? 'isCollapsed' : 'isChildrenCollapsed';
    var collapsedClass = isNode ? 'composer-node--collapsed' : 'composer-node__children--collapsed';

    el.parentNode.classList.toggle(collapsedClass);

    var node = isNode ? _idMap.findById(el.parentNode.id) : find.containerElNode(el.parentNode);

    var isCollapsed = el.parentNode.matches('.composer-node--collapsed, .composer-node__children--collapsed');

    toggle(node, key, isCollapsed);
    updateNode(node);
  };

  var collapseElChildren = function collapseElChildren(el) {
    var containerElNode = find.containerElNode(el);
    var children = containerElNode.getChildren();

    children.forEach(function (node) {
      toggle(node, 'isCollapsed', true);
    });

    updateNode(containerElNode);
  };

  var expandElChildren = function expandElChildren(el) {
    var containerElNode = find.containerElNode(el);
    var children = containerElNode.getChildren();

    children.forEach(function (node) {
      toggle(node, 'isCollapsed', false);
    });

    updateNode(containerElNode);
  };

  var removeEl = function removeEl(el) {
    var nodeEl = el.closest('.composer-node');
    var id = nodeEl.id;
    var node = _idMap.findById(id);
    var parentNode = node.getParent();

    node.remove();
    /*
      It may seem as though by just removing the node, the parentNode will be
      regenerated correctly, however this is not the case sometimes, like when
      the node is the first child of the element. Not sure if problem with
      morphdom or if I've made some mistaken assumption somewhere, but in any
      case also removing the node's element representation from the DOM ensures
      that this works correctly. Not removing the DOM node and calling
      updateNode twice also works - go figure :/
    */
    nodeEl.remove();

    updateNode(parentNode);
  };

  var toggle = function toggle(node, key, isCollapsed) {
    node.meta(key, isCollapsed);
  };

  var updateNode = function updateNode(node) {
    var nodeEl = document.getElementById(node.id());
    var parentNode = node.getParent();

    var depth = 0;
    var parentEl = void 0;

    if (parentNode) {
      parentEl = document.getElementById(parentNode.id());
      depth = parentEl.dataset.depth * 1 + 1;
    }

    var newElDom = renderNode(node, { depth: depth });
    var newElHtml = newElDom.stringify();

    morphdom(nodeEl, newElHtml);
  };

  var _dropHandler = void 0;

  var ondrop = function ondrop() {
    if (_dropHandler) _dropHandler.apply(undefined, arguments);
  };

  var drakeDeps = { dragula: dragula, updateNode: updateNode, find: find, ondrop: ondrop };

  var drake = Drake(drakeDeps);

  var api = {
    remove: function remove() {
      return composerView.innerHTML = '';
    },
    tree: function tree() {
      return _tree;
    },
    idMap: function idMap() {
      return _idMap;
    },
    dropHandler: function dropHandler(handler) {
      if (typeof handler === 'function') _dropHandler = handler;

      return _dropHandler;
    }
  };

  return api;
};

module.exports = Composer;

},{"./drake":196,"./find":197,"./idmap":198,"dragula":96,"morphdom":162}],200:[function(require,module,exports){
'use strict';

var Composer = require('./composer');

require('./polyfills');

window.mojule = { Composer: Composer };

/*
TODO this is test code to get the composer up and running, needs to be init'ed
properly as and where needed
*/

//const Tree = require( '1tree' )
var TreeFactory = require('1tree-factory');

//in reality this would be implemented by the specific tree type, this is just a
//hack for testing
var isEmptyPlugin = function isEmptyPlugin(fn) {
  var isEmpty = function isEmpty(fn, node) {
    var value = fn.value(node);

    return value.nodeType === 'file' || value.nodeType === 'text';
  };

  isEmpty.def = fn.isEmpty.def;

  return Object.assign(fn, { isEmpty: isEmpty });
};

var Tree = TreeFactory(isEmptyPlugin);

var componentDependencies = require('../../dist/dependencies.json');
var RenderNode = require('../composer-tree/renderNode');
var renderNode = RenderNode(componentDependencies);

var treeRaw = componentDependencies.datas['data-small'];
var tree = Tree(treeRaw);

var composerApi = Composer(tree, renderNode);

},{"../../dist/dependencies.json":1,"../composer-tree/renderNode":207,"./composer":199,"./polyfills":201,"1tree-factory":3}],201:[function(require,module,exports){
'use strict';

(function (ElementProto) {
	if (typeof ElementProto.matches !== 'function') {
		ElementProto.matches = ElementProto.msMatchesSelector || ElementProto.mozMatchesSelector || ElementProto.webkitMatchesSelector || function matches(selector) {
			var element = this;
			var elements = (element.document || element.ownerDocument).querySelectorAll(selector);
			var index = 0;

			while (elements[index] && elements[index] !== element) {
				++index;
			}

			return Boolean(elements[index]);
		};
	}

	if (typeof ElementProto.closest !== 'function') {
		ElementProto.closest = function closest(selector) {
			var element = this;

			while (element && element.nodeType === 1) {
				if (element.matches(selector)) {
					return element;
				}

				element = element.parentNode;
			}

			return null;
		};
	}
})(window.Element.prototype);

},{}],202:[function(require,module,exports){
'use strict';

var RenderCss = function RenderCss(dependencies) {
  var styles = dependencies.styles,
      transformCss = dependencies.transformCss;


  var renderCss = function renderCss(root) {
    var css = '';

    var alreadyAdded = new Set();

    root.walk(function (node) {
      var value = node.value();
      var componentName = value.name;

      if (alreadyAdded.has(componentName)) return;

      alreadyAdded.add(componentName);

      var style = styles[componentName];

      if (typeof style === 'string') {
        css += style;
        css += ' ';
      }
    });

    if (typeof transformCss === 'function') css = transformCss(css);

    return css;
  };

  return renderCss;
};

module.exports = RenderCss;

},{}],203:[function(require,module,exports){
'use strict';

var Templates = require('../../templates');
var RenderCss = require('./renderCss');

var RenderNode = function RenderNode(dependencies) {
  var renderCss = RenderCss(dependencies);
  var configs = dependencies.configs;

  var _Templates = Templates(dependencies),
      renderComponent = _Templates.renderComponent;

  var defaultConfig = {
    containerSelector: "[data-container]"
  };

  var addCssToDocumentHead = function addCssToDocumentHead(node) {
    var value = node.value();
    var componentName = value.name;
    var componentModel = value.model;

    var css = renderCss(node);

    if (!Array.isArray(componentModel.headStyles)) componentModel.headStyles = [];

    componentModel.headStyles.push({
      text: css
    });

    node.value(value);
  };

  var renderNode = function renderNode(node) {
    var value = node.value();
    var componentName = value.name;
    var componentModel = value.model;

    if (componentName === 'document') {
      addCssToDocumentHead(node);
    }

    var dom = renderComponent(componentName, componentModel);
    var config = Object.assign({}, defaultConfig, configs[componentName]);
    var childContainer = dom.select(config.containerSelector);
    var children = node.getChildren();

    if (childContainer && children.length) {
      children.forEach(function (childNode) {
        var childDom = renderNode(childNode);

        if (childContainer.nodeName() === 'ul' || childContainer.nodeName() === 'ol') {
          /*
            dom.parse always returns a fragment, because the html string could
            contain multiple elements
              perhaps if we see it only has one element, we should return that
            rather than a documentFragment with a single child, but continue to
            use current behaviour if the fragment has multiple children?
          */
          var liNode = dom.parse('<li></li>').select('li');

          liNode.append(childDom);
          childContainer.append(liNode);

          return;
        }

        childContainer.append(childDom);
      });
    }

    return dom;
  };

  return renderNode;
};

module.exports = RenderNode;

},{"../../templates":208,"./renderCss":202}],204:[function(require,module,exports){
'use strict';

var treeSchema = require('1tree-schema');
var treeJson = require('1tree-json');
var transformMapper = require('mojule-transform');
var utils = require('mojule-utils');

var clone = utils.clone;


var mapComponents = function mapComponents(dependencies, componentName, model) {
  model = clone(model);

  var modelTree = treeJson.toTree(model);

  var componentNames = dependencies.componentNames,
      schemas = dependencies.schemas,
      transforms = dependencies.transforms;


  var schemaNames = Object.keys(schemas);

  var findRefComponents = function findRefComponents(schemaNode) {
    return schemaNode.findAll(function (n) {
      return componentNames.includes(n.value().$ref);
    });
  };

  var transform = transforms[componentName];
  var componentSchema = schemas[componentName];

  if (transform && !componentSchema) {
    return transformMapper(model, transform);
  }

  if (!transform && !componentSchema) {
    return model;
  }

  var componentSchemaTree = treeSchema.toTree(componentSchema);
  var refComponents = findRefComponents(componentSchemaTree);

  refComponents.forEach(function (refComponentNode) {
    var value = refComponentNode.value();
    var componentName = value.$ref;
    var componentTransform = transforms[componentName];

    if (!componentTransform) return;

    var refNodePath = treeSchema.pathFromNode(refComponentNode);
    var modelNode = treeJson.nodeFromPath(modelTree, refNodePath);

    if (!modelNode) return;

    var modelNodeValue = modelNode.value();

    if (value.arrayItem) {
      var modelArray = treeJson.toJson(modelNode);

      var transformed = modelArray.map(function (item) {
        return mapComponents(dependencies, componentName, item);
      });

      var transformedNode = treeJson.toTree(transformed);
      var modelNodeParent = modelNode.getParent();

      if (modelNodeValue.propertyName) {
        var transformedNodeValue = transformedNode.value();
        transformedNodeValue.propertyName = modelNodeValue.propertyName;
        transformedNode.value(transformedNodeValue);
      }

      modelNodeParent.replaceChild(transformedNode, modelNode);
    } else {
      throw new Error('Non arrayitem not implemented yet');
    }
  });

  model = treeJson.toJson(modelTree);

  if (transform) model = transformMapper(model, transform);

  return model;
};

module.exports = mapComponents;

},{"1tree-json":6,"1tree-schema":11,"mojule-transform":159,"mojule-utils":161}],205:[function(require,module,exports){
'use strict';

var Tree = require('1tree');
var nodeToModel = require('./defaultNodeToModel');

var defaultOptions = {
  depth: 0,
  createNode: Tree.createRoot,
  alwaysRenderChildren: false,
  nodeToModel: nodeToModel
};

var nodeToComposerNode = function nodeToComposerNode(node, options) {
  options = Object.assign({}, defaultOptions, options);

  var _options = options,
      depth = _options.depth,
      createNode = _options.createNode,
      nodeToModel = _options.nodeToModel,
      alwaysRenderChildren = _options.alwaysRenderChildren;


  var model = nodeToModel(node, { depth: depth });

  var value = {
    name: 'composer-node',
    model: model
  };

  var componentNode = createNode(value);

  var shouldRenderChildren = alwaysRenderChildren || !model.isChildrenCollapsed;

  if (shouldRenderChildren) {
    var children = node.getChildren();

    children.forEach(function (childNode) {
      var childOptions = Object.assign({}, options, {
        depth: depth + 1
      });

      var componentChildNode = nodeToComposerNode(childNode, childOptions);

      componentNode.append(componentChildNode);
    });
  }

  return componentNode;
};

module.exports = nodeToComposerNode;

},{"./defaultNodeToModel":206,"1tree":60}],206:[function(require,module,exports){
'use strict';

var _require = require('mojule-utils'),
    escapeHtml = _require.escapeHtml;

var defaultOptions = {
  depth: 0
};

var nodeToModel = function nodeToModel(node, options) {
  options = Object.assign({}, defaultOptions, options);

  var _options = options,
      depth = _options.depth;


  var value = node.value();
  var children = node.getChildren();

  var id = node.id();
  var name = value.name || '';
  var treeType = '1tree';
  var nodeType = node.nodeType();
  var title = depth + ': ' + name + ' ' + nodeType + ' [ ' + children.length + ' ]';
  var isEmpty = node.isEmpty();

  var isCollapsed = node.meta('isCollapsed');

  isCollapsed = typeof isCollapsed === 'boolean' ? isCollapsed : depth > 0;

  var isChildrenCollapsed = isCollapsed || !!node.meta('isChildrenCollapsed');

  var preview = escapeHtml(JSON.stringify(value));
  var childrenTitle = depth + ': children';

  var model = {
    id: id, title: title, treeType: treeType, nodeType: nodeType, depth: depth, isEmpty: isEmpty, isCollapsed: isCollapsed,
    isChildrenCollapsed: isChildrenCollapsed, preview: preview, childrenTitle: childrenTitle
  };

  return model;
};

module.exports = nodeToModel;

},{"mojule-utils":161}],207:[function(require,module,exports){
'use strict';

var Tree = require('1tree');
var nodeToModel = require('./defaultNodeToModel');
var nodeToComposerNode = require('./defaultNodeToComposerNode');
var ComponentRenderNode = require('../components/component-tree/renderNode');

var defaultOptions = {
  depth: 0,
  createNode: Tree.createRoot,
  nodeToModel: nodeToModel,
  nodeToComposerNode: nodeToComposerNode
};

var RenderNode = function RenderNode(dependencies) {
  var componentRenderNode = ComponentRenderNode(dependencies);

  var renderNode = function renderNode(node, options) {
    options = Object.assign({}, defaultOptions, options);

    var _options = options,
        nodeToModel = _options.nodeToModel,
        nodeToComposerNode = _options.nodeToComposerNode,
        depth = _options.depth,
        createNode = _options.createNode;


    var toComposerNodeOptions = { depth: depth, createNode: createNode, nodeToModel: nodeToModel };
    var composerNode = nodeToComposerNode(node, toComposerNodeOptions);
    var componentNode = componentRenderNode(composerNode);

    return componentNode;
  };

  return renderNode;
};

module.exports = RenderNode;

},{"../components/component-tree/renderNode":203,"./defaultNodeToComposerNode":205,"./defaultNodeToModel":206,"1tree":60}],208:[function(require,module,exports){
'use strict';

var Templating = require('mojule-templating');
var Validator = require('mtype-tv4');
var componentTransformMapper = require('../components/componentTransformMapper');

var ensureModel = function ensureModel(validator, model, name) {
  var schemaNames = validator.getSchemaUris();

  if (!schemaNames.includes(name)) return;

  var result = validator.validateMultiple(model, name);

  if (result.valid) return;

  var message = 'Template model validation failed for ' + name + ': ' + JSON.stringify(result.errors);
  throw new Error(message);
};

var Templates = function Templates(dependencies) {
  var components = dependencies.components,
      templates = dependencies.templates,
      defaultModels = dependencies.defaultModels,
      schemas = dependencies.schemas;


  var templating = Templating(templates);
  var validator = Validator(schemas);

  var renderComponent = function renderComponent(name, model) {
    var templateModel = Object.assign({}, defaultModels[name] || {}, model);

    ensureModel(validator, templateModel, name);

    var viewModel = componentTransformMapper(dependencies, name, templateModel);

    return templating(name, viewModel);
  };

  //TODO I believe that this doesn't need to use callbacks anymore
  var renderTemplate = function renderTemplate(name, model, callback) {
    try {
      var documentModel = Object.assign({}, defaultModels.document, model);

      if (name !== 'document') {
        var body = renderComponent(name, model).stringify();

        Object.assign(documentModel, { body: body });
      }

      ensureModel(validator, documentModel, 'document');

      var viewModel = componentTransformMapper(dependencies, 'document', documentModel);

      var dom = templating('document', viewModel);

      callback(null, dom);
    } catch (e) {
      callback(e);
    }
  };

  return { renderTemplate: renderTemplate, renderComponent: renderComponent };
};

module.exports = Templates;

},{"../components/componentTransformMapper":204,"mojule-templating":157,"mtype-tv4":171}]},{},[200])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2RlcGVuZGVuY2llcy5qc29uIiwibm9kZV9tb2R1bGVzLzF0cmVlLWZhY3RvcnkvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS1mYWN0b3J5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlLWpzb24vZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS1qc29uL2Rpc3QvcGF0aHMuanMiLCJub2RlX21vZHVsZXMvMXRyZWUtc2NoZW1hL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvMXRyZWUtc2NoZW1hL2Rpc3QvcGF0aHMuanMiLCJub2RlX21vZHVsZXMvMXRyZWUtc2NoZW1hL2Rpc3QvdG9Kc29uLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlLXNjaGVtYS9kaXN0L3RvVHJlZS5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS1zY2hlbWEvaW5kZXguanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9hZGFwdGVyL2RlZmF1bHQvY3JlYXRlTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2FkYXB0ZXIvZGVmYXVsdC9nZXRDaGlsZHJlbi5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2FkYXB0ZXIvZGVmYXVsdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2FkYXB0ZXIvZGVmYXVsdC9pbnNlcnRCZWZvcmUuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9hZGFwdGVyL2RlZmF1bHQvcmVtb3ZlLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvYWRhcHRlci9kZWZhdWx0L3ZhbHVlLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy9hZGFwdGVyL2NyZWF0ZU5vZGUuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL2FkYXB0ZXIvZ2V0Q2hpbGRyZW4uanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL2FkYXB0ZXIvaW5zZXJ0QmVmb3JlLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy9hZGFwdGVyL3JlbW92ZS5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2RlZnMvYWRhcHRlci92YWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2RlZnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL21hbmlwdWxhdGlvbi9hcHBlbmQuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL21hbmlwdWxhdGlvbi9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2RlZnMvbWFuaXB1bGF0aW9uL2luc2VydEFmdGVyLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy9tYW5pcHVsYXRpb24vaW5zZXJ0QXQuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL21hbmlwdWxhdGlvbi9wcmVwZW5kLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy9tYW5pcHVsYXRpb24vcmVtb3ZlQXQuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL21hbmlwdWxhdGlvbi9yZXBsYWNlQ2hpbGQuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL21hbmlwdWxhdGlvbi91bndyYXAuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL21hbmlwdWxhdGlvbi93cmFwLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy90cmF2ZXJzYWwvYW5jZXN0b3JzLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy90cmF2ZXJzYWwvY2hpbGRBdC5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2RlZnMvdHJhdmVyc2FsL2Nsb3Nlc3QuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL3RyYXZlcnNhbC9jb250YWlucy5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2RlZnMvdHJhdmVyc2FsL2Rlc2NlbmRlbnRzLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy90cmF2ZXJzYWwvZmluZC5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2RlZnMvdHJhdmVyc2FsL2ZpbmRBbGwuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL3RyYXZlcnNhbC9maXJzdENoaWxkLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy90cmF2ZXJzYWwvZ2V0UGFyZW50LmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy90cmF2ZXJzYWwvaGFzQ2hpbGRyZW4uanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL3RyYXZlcnNhbC9pc0VtcHR5LmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy90cmF2ZXJzYWwvbGFzdENoaWxkLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvZGVmcy90cmF2ZXJzYWwvbmV4dFNpYmxpbmcuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL3RyYXZlcnNhbC9wcmV2aW91c1NpYmxpbmcuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL3RyYXZlcnNhbC9zaWJsaW5ncy5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L2RlZnMvdHJhdmVyc2FsL3dhbGsuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9kZWZzL3RyYXZlcnNhbC93YWxrVXAuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9mbi1mYWN0b3J5LmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9wbHVnaW5zL2FjY2VwdHMuanMiLCJub2RlX21vZHVsZXMvMXRyZWUvZGlzdC9wbHVnaW5zL2lkLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvcGx1Z2lucy9tZXRhLmpzIiwibm9kZV9tb2R1bGVzLzF0cmVlL2Rpc3QvcGx1Z2lucy9ub2RlVHlwZS5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L3BsdWdpbnMvcGFyZW50LW1hcC5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L3BsdWdpbnMvc2VyaWFsaXplci5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L3BsdWdpbnMvd3JhcC1ub2Rlcy5qcyIsIm5vZGVfbW9kdWxlcy8xdHJlZS9kaXN0L3BvbHlmaWxscy5qcyIsIm5vZGVfbW9kdWxlcy9hdG9hL2F0b2EuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jvb2xiYXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXItc2hpbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbnRyYS9kZWJvdW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jb250cmEvZW1pdHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvY3Jvc3N2ZW50L3NyYy9jcm9zc3ZlbnQuanMiLCJub2RlX21vZHVsZXMvY3Jvc3N2ZW50L3NyYy9ldmVudG1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jc3Mtc2VsZWN0LWJhc2UtYWRhcHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jc3Mtc2VsZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Nzcy1zZWxlY3QvbGliL2F0dHJpYnV0ZXMuanMiLCJub2RlX21vZHVsZXMvY3NzLXNlbGVjdC9saWIvY29tcGlsZS5qcyIsIm5vZGVfbW9kdWxlcy9jc3Mtc2VsZWN0L2xpYi9nZW5lcmFsLmpzIiwibm9kZV9tb2R1bGVzL2Nzcy1zZWxlY3QvbGliL3Byb2NlZHVyZS5qc29uIiwibm9kZV9tb2R1bGVzL2Nzcy1zZWxlY3QvbGliL3BzZXVkb3MuanMiLCJub2RlX21vZHVsZXMvY3NzLXNlbGVjdC9saWIvc29ydC5qcyIsIm5vZGVfbW9kdWxlcy9jc3Mtd2hhdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jdXN0b20tZXZlbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZG9tLXNlcmlhbGl6ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZG9tLXNlcmlhbGl6ZXIvbm9kZV9tb2R1bGVzL2RvbWVsZW1lbnR0eXBlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RvbWVsZW1lbnR0eXBlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RvbWhhbmRsZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZG9taGFuZGxlci9saWIvZWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9kb21oYW5kbGVyL2xpYi9ub2RlLmpzIiwibm9kZV9tb2R1bGVzL2RvbXV0aWxzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi9sZWdhY3kuanMiLCJub2RlX21vZHVsZXMvZG9tdXRpbHMvbGliL21hbmlwdWxhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9kb211dGlscy9saWIvcXVlcnlpbmcuanMiLCJub2RlX21vZHVsZXMvZG9tdXRpbHMvbGliL3N0cmluZ2lmeS5qcyIsIm5vZGVfbW9kdWxlcy9kb211dGlscy9saWIvdHJhdmVyc2FsLmpzIiwibm9kZV9tb2R1bGVzL2RyYWd1bGEvY2xhc3Nlcy5qcyIsIm5vZGVfbW9kdWxlcy9kcmFndWxhL2RyYWd1bGEuanMiLCJub2RlX21vZHVsZXMvZW50aXRpZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZW50aXRpZXMvbGliL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZGVjb2RlX2NvZGVwb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL2VudGl0aWVzL21hcHMvZGVjb2RlLmpzb24iLCJub2RlX21vZHVsZXMvZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uIiwibm9kZV9tb2R1bGVzL2VudGl0aWVzL21hcHMvbGVnYWN5Lmpzb24iLCJub2RlX21vZHVsZXMvZW50aXRpZXMvbWFwcy94bWwuanNvbiIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2hpbmZvL2RhdGEvZWxlbWVudHMuanNvbiIsIm5vZGVfbW9kdWxlcy9oaW5mby9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hpbmZvL3NjaGVtYS9oaW5mby5zY2hlbWEuanNvbiIsIm5vZGVfbW9kdWxlcy9odG1sLW5vZGUvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9odG1scGFyc2VyMi9saWIvQ29sbGVjdGluZ0hhbmRsZXIuanMiLCJub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbGliL0ZlZWRIYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL2xpYi9QYXJzZXIuanMiLCJub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbGliL1Byb3h5SGFuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9odG1scGFyc2VyMi9saWIvU3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL2xpYi9Ub2tlbml6ZXIuanMiLCJub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbGliL1dyaXRhYmxlU3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vZGlzdC9wYXJzZS9kb21oYW5kbGVyLWFkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9kaXN0L3BhcnNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vZGlzdC9wbHVnaW5zL2NyZWF0ZVRyZWUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9kaXN0L3BsdWdpbnMvZG9tL2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL2Rpc3QvcGx1Z2lucy9kb20vZWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL2Rpc3QvcGx1Z2lucy9kb20vaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9kaXN0L3BsdWdpbnMvZG9tL25vZGUuanMiLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9kaXN0L3BsdWdpbnMvaW5zZXJ0QmVmb3JlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vZGlzdC9wbHVnaW5zL3BhcnNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vZGlzdC9wbHVnaW5zL3NlbGVjdC9odG1scGFyc2VyMi1hZGFwdGVyLmpzIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vZGlzdC9wbHVnaW5zL3NlbGVjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL2Rpc3QvcGx1Z2lucy9zdHJpbmdpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9kaXN0L3BsdWdpbnMvdHlwZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9kaXN0L3BsdWdpbnMvdmRvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL2Rpc3Qvc2NoZW1hL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vZGlzdC9zZWxlY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9kaXN0L3N0cmluZ2lmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL2Rpc3QvdmRvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL3NjaGVtYS9jb21tZW50LnNjaGVtYS5qc29uIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vc2NoZW1hL2NvbW1lbnRWYWx1ZS5zY2hlbWEuanNvbiIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL3NjaGVtYS9kb2N1bWVudC5zY2hlbWEuanNvbiIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL3NjaGVtYS9kb2N1bWVudEZyYWdtZW50LnNjaGVtYS5qc29uIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vc2NoZW1hL2RvY3VtZW50RnJhZ21lbnRWYWx1ZS5zY2hlbWEuanNvbiIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL3NjaGVtYS9kb2N1bWVudFR5cGUuanNvbiIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL3NjaGVtYS9kb2N1bWVudFR5cGVWYWx1ZS5zY2hlbWEuanNvbiIsIm5vZGVfbW9kdWxlcy9tb2p1bGUtZG9tL3NjaGVtYS9kb2N1bWVudFZhbHVlLnNjaGVtYS5qc29uIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vc2NoZW1hL2VsZW1lbnQuc2NoZW1hLmpzb24iLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9zY2hlbWEvZWxlbWVudFZhbHVlLnNjaGVtYS5qc29uIiwibm9kZV9tb2R1bGVzL21vanVsZS1kb20vc2NoZW1hL3RleHQuc2NoZW1hLmpzb24iLCJub2RlX21vZHVsZXMvbW9qdWxlLWRvbS9zY2hlbWEvdGV4dFZhbHVlLnNjaGVtYS5qc29uIiwibm9kZV9tb2R1bGVzL21vanVsZS10ZW1wbGF0aW5nL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9qdWxlLXRyYW5zZm9ybS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vanVsZS11dGlscy9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vcnBoZG9tL2Rpc3QvbW9ycGhkb20uanMiLCJub2RlX21vZHVsZXMvbXR5cGUtbm9kZS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL210eXBlLW5vZGUvZGlzdC9zY2hlbWEuanMiLCJub2RlX21vZHVsZXMvbXR5cGUtbm9kZS9zY2hlbWEvZW1wdHlOb2RlLnNjaGVtYS5qc29uIiwibm9kZV9tb2R1bGVzL210eXBlLW5vZGUvc2NoZW1hL2VudGl0eU5vZGUuc2NoZW1hLmpzb24iLCJub2RlX21vZHVsZXMvbXR5cGUtbm9kZS9zY2hlbWEvZW50aXR5Tm9kZVZhbHVlLnNjaGVtYS5qc29uIiwibm9kZV9tb2R1bGVzL210eXBlLW5vZGUvc2NoZW1hL3BhcmVudE5vZGUuc2NoZW1hLmpzb24iLCJub2RlX21vZHVsZXMvbXR5cGUtdHY0L2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXR5cGUvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tdHlwZS9kaXN0L2pzb24tcHJlZGljYXRlcy5qcyIsIm5vZGVfbW9kdWxlcy9udGgtY2hlY2svY29tcGlsZS5qcyIsIm5vZGVfbW9kdWxlcy9udGgtY2hlY2svaW5kZXguanMiLCJub2RlX21vZHVsZXMvbnRoLWNoZWNrL3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RpY2t5L3RpY2t5LWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdHY0L3R2NC5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwic3JjXFxjbGllbnRcXGNvbXBvc2VyXFxkcmFrZS5qcyIsInNyY1xcY2xpZW50XFxjb21wb3NlclxcZmluZC5qcyIsInNyY1xcY2xpZW50XFxjb21wb3NlclxcaWRtYXAuanMiLCJzcmNcXGNsaWVudFxcY29tcG9zZXJcXGluZGV4LmpzIiwic3JjXFxjbGllbnRcXGluZGV4LmpzIiwic3JjXFxjbGllbnRcXHBvbHlmaWxscy5qcyIsInNyY1xcY29tcG9uZW50c1xcY29tcG9uZW50LXRyZWVcXHJlbmRlckNzcy5qcyIsInNyY1xcY29tcG9uZW50c1xcY29tcG9uZW50LXRyZWVcXHJlbmRlck5vZGUuanMiLCJzcmNcXGNvbXBvbmVudHNcXGNvbXBvbmVudFRyYW5zZm9ybU1hcHBlci5qcyIsInNyY1xcY29tcG9zZXItdHJlZVxcZGVmYXVsdE5vZGVUb0NvbXBvc2VyTm9kZS5qcyIsInNyY1xcY29tcG9zZXItdHJlZVxcZGVmYXVsdE5vZGVUb01vZGVsLmpzIiwic3JjXFxjb21wb3Nlci10cmVlXFxyZW5kZXJOb2RlLmpzIiwic3JjXFx0ZW1wbGF0ZXNcXGluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqQ0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3dkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaG1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBOztBQ0FBOztBQ0FBOztBQ0FBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ppQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoQkE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25FQTs7QUFFQTs7QUFDQSxJQUFNLFFBQVEsU0FBUixLQUFRLE9BQVE7QUFDcEIsTUFBTSxnQkFBZ0Isc0RBQXRCO0FBQ0EsTUFBTSxvQkFBb0IsOEJBQTFCO0FBRm9CLE1BR1osVUFIWSxHQUcwQixJQUgxQixDQUdaLFVBSFk7QUFBQSxNQUdBLE9BSEEsR0FHMEIsSUFIMUIsQ0FHQSxPQUhBO0FBQUEsTUFHUyxJQUhULEdBRzBCLElBSDFCLENBR1MsSUFIVDtBQUFBLE1BR2UsTUFIZixHQUcwQixJQUgxQixDQUdlLE1BSGY7OztBQUtwQixNQUFNLGNBQWMsU0FBZCxXQUFjO0FBQUEsV0FBTSxHQUFHLE9BQUgsQ0FBWSxpQkFBWixDQUFOO0FBQUEsR0FBcEI7O0FBRUEsTUFBTSxVQUFVLGlCQUFFLEVBQUYsRUFBTSxXQUFOLEVBQXVCO0FBQ3JDLFFBQUksVUFBVSxZQUFZLE9BQVosQ0FBcUIsaUJBQXJCLENBQWQ7O0FBRUEsUUFBSSxPQUFKLEVBQWE7QUFDWCxnQkFBVSxDQUFDLFlBQVksT0FBWixDQUFxQixhQUFyQixDQUFYO0FBQ0Q7O0FBRUQsUUFBSSxPQUFKLEVBQWE7QUFDWCxVQUFNLE9BQU8sS0FBSyxNQUFMLENBQWEsRUFBYixDQUFiO0FBQ0EsVUFBTSxhQUFhLEtBQUssZUFBTCxDQUFzQixXQUF0QixDQUFuQjs7QUFFQSxVQUFJLFNBQVMsVUFBYixFQUEwQixPQUFPLEtBQVA7O0FBRTFCLGdCQUFVLFdBQVcsT0FBWCxDQUFvQixJQUFwQixDQUFWO0FBQ0Q7O0FBRUQsV0FBTyxPQUFQO0FBQ0QsR0FqQkQ7O0FBbUJBLE1BQU0sVUFBVSxFQUFFLHdCQUFGLEVBQWUsZ0JBQWYsRUFBaEI7O0FBRUEsTUFBTSxRQUFRLFFBQVMsT0FBVCxDQUFkOztBQUVBLFFBQU0sRUFBTixDQUFVLE1BQVYsRUFBa0IsVUFBRSxFQUFGLEVBQU0sV0FBTixFQUFtQixpQkFBbkIsRUFBc0MsTUFBdEMsRUFBa0Q7QUFDbEUsUUFBTSxPQUFPLEtBQUssTUFBTCxDQUFhLEVBQWIsQ0FBYjtBQUNBLFFBQU0sYUFBYSxLQUFLLGVBQUwsQ0FBc0IsV0FBdEIsQ0FBbkI7O0FBRUEsUUFBSSxNQUFKLEVBQVk7QUFDVixVQUFNLGdCQUFnQixLQUFLLE1BQUwsQ0FBYSxNQUFiLENBQXRCO0FBQ0EsaUJBQVcsWUFBWCxDQUF5QixJQUF6QixFQUErQixhQUEvQjtBQUNELEtBSEQsTUFHTztBQUNMLGlCQUFXLE1BQVgsQ0FBbUIsSUFBbkI7QUFDRDs7QUFFRCxlQUFZLElBQVo7O0FBRUEsV0FBUSxJQUFSLEVBQWMsVUFBZCxFQUEwQixFQUExQixFQUE4QixXQUE5QixFQUEyQyxpQkFBM0MsRUFBOEQsTUFBOUQ7QUFDRCxHQWREOztBQWdCQSxTQUFPLEtBQVA7QUFDRCxDQS9DRDs7QUFpREEsT0FBTyxPQUFQLEdBQWlCLEtBQWpCOzs7QUNwREE7O0FBRUE7O0FBQ0EsSUFBTSxPQUFPLFNBQVAsSUFBTyxRQUFTO0FBQ3BCLE1BQU0sU0FBUyxTQUFULE1BQVM7QUFBQSxXQUFNLEdBQUcsYUFBSCxDQUFrQixnQkFBbEIsQ0FBTjtBQUFBLEdBQWY7QUFDQSxNQUFNLGNBQWMsU0FBZCxXQUFjO0FBQUEsV0FBTSxHQUFHLE9BQUgsQ0FBWSxnQkFBWixDQUFOO0FBQUEsR0FBcEI7QUFDQSxNQUFNLFNBQVMsU0FBVCxNQUFTO0FBQUEsV0FBTSxNQUFNLFFBQU4sQ0FBZ0IsT0FBUSxFQUFSLEVBQWEsRUFBN0IsQ0FBTjtBQUFBLEdBQWY7QUFDQSxNQUFNLGtCQUFrQixTQUFsQixlQUFrQjtBQUFBLFdBQU0sTUFBTSxRQUFOLENBQWdCLFlBQWEsRUFBYixFQUFrQixFQUFsQyxDQUFOO0FBQUEsR0FBeEI7O0FBRUEsU0FBTyxFQUFFLGNBQUYsRUFBVSx3QkFBVixFQUF1QixjQUF2QixFQUErQixnQ0FBL0IsRUFBUDtBQUNELENBUEQ7O0FBU0EsT0FBTyxPQUFQLEdBQWlCLElBQWpCOzs7QUNaQTs7QUFFQTs7Ozs7QUFJQSxJQUFNLFFBQVEsU0FBUixLQUFRLE9BQVE7QUFDcEIsTUFBTSxRQUFRLElBQUksR0FBSixFQUFkOztBQUVBLE1BQU0sV0FBVyxTQUFYLFFBQVcsS0FBTTtBQUNyQixRQUFJLE1BQU0sR0FBTixDQUFXLEVBQVgsQ0FBSixFQUFzQixPQUFPLE1BQU0sR0FBTixDQUFXLEVBQVgsQ0FBUDs7QUFFdEIsUUFBTSxPQUFPLEtBQUssSUFBTCxDQUFXO0FBQUEsYUFBSyxFQUFFLEVBQUYsT0FBVyxFQUFoQjtBQUFBLEtBQVgsQ0FBYjs7QUFFQSxVQUFNLEdBQU4sQ0FBVyxFQUFYLEVBQWUsSUFBZjs7QUFFQSxXQUFPLElBQVA7QUFDRCxHQVJEOztBQVVBLE1BQU0sVUFBVSxTQUFWLE9BQVUsT0FBUTtBQUN0QixTQUFLLElBQUwsQ0FBVztBQUFBLGFBQUssTUFBTSxHQUFOLENBQVcsRUFBRSxFQUFGLEVBQVgsRUFBbUIsQ0FBbkIsQ0FBTDtBQUFBLEtBQVg7QUFDRCxHQUZEOztBQUlBLFVBQVMsSUFBVDs7QUFFQSxTQUFPLE9BQU8sTUFBUCxDQUFlLEtBQWYsRUFBc0IsRUFBRSxrQkFBRixFQUFZLGdCQUFaLEVBQXRCLENBQVA7QUFDRCxDQXBCRDs7QUFzQkEsT0FBTyxPQUFQLEdBQWlCLEtBQWpCOzs7QUM1QkE7Ozs7QUFFQSxJQUFNLFVBQVUsUUFBUyxTQUFULENBQWhCO0FBQ0EsSUFBTSxXQUFXLFFBQVMsVUFBVCxDQUFqQjtBQUNBLElBQU0sUUFBUSxRQUFTLFNBQVQsQ0FBZDtBQUNBLElBQU0sUUFBUSxRQUFTLFNBQVQsQ0FBZDtBQUNBLElBQU0sT0FBTyxRQUFTLFFBQVQsQ0FBYjs7QUFFQSxJQUFNLGlCQUFpQjtBQUNyQixZQUFVLE9BQU8sTUFBUCxLQUFrQixXQUFsQixHQUFnQyxJQUFoQyxHQUF1QyxPQUFPLFFBRG5DO0FBRXJCLGtCQUZxQjtBQUdyQixvQkFIcUI7QUFJckIsWUFBVTtBQUpXLENBQXZCOztBQU9BLElBQU0sY0FBYyxTQUFkLFdBQWMsQ0FBRSxHQUFGLEVBQU8sSUFBUCxFQUFhLFFBQWIsRUFBMkI7QUFDN0MsTUFBSSxRQUFPLEdBQVAseUNBQU8sR0FBUCxPQUFlLFFBQW5CLEVBQ0UsTUFBTSxJQUFJLEtBQUosUUFBaUIsSUFBakIsU0FBMkIsUUFBM0Isa0JBQU47QUFDSCxDQUhEOztBQUtBOzs7Ozs7Ozs7QUFTQSxJQUFNLFdBQVcsU0FBWCxRQUFXLENBQUUsS0FBRixFQUFRLFVBQVIsRUFBb0IsT0FBcEIsRUFBaUM7QUFDaEQsWUFBVSxPQUFPLE1BQVAsQ0FBZSxFQUFmLEVBQW1CLGNBQW5CLEVBQW1DLE9BQW5DLENBQVY7O0FBRGdELGlCQUdFLE9BSEY7QUFBQSxNQUd4QyxRQUh3QyxZQUd4QyxRQUh3QztBQUFBLE1BRzlCLE9BSDhCLFlBRzlCLE9BSDhCO0FBQUEsTUFHckIsUUFIcUIsWUFHckIsUUFIcUI7QUFBQSxNQUdYLFFBSFcsWUFHWCxRQUhXOzs7QUFLaEQsY0FBYSxRQUFiLEVBQXVCLFVBQXZCLEVBQW1DLFFBQW5DO0FBQ0EsY0FBYSxVQUFiLEVBQXlCLFlBQXpCLEVBQXVDLFVBQXZDO0FBQ0EsY0FBYSxRQUFiLEVBQXVCLFVBQXZCLEVBQW1DLFFBQW5DOztBQUVBLE1BQU0sU0FBUSxNQUFPLEtBQVAsQ0FBZDtBQUNBLE1BQU0sT0FBTyxLQUFNLE1BQU4sQ0FBYjs7QUFFQSxNQUFNLGVBQWUsU0FBUyxhQUFULENBQXdCLFFBQXhCLENBQXJCOztBQUVBLE1BQU0sYUFBYSxXQUFZLEtBQVosQ0FBbkI7O0FBRUEsV0FBVSxZQUFWLEVBQXdCLFdBQVcsU0FBWCxFQUF4Qjs7QUFFQTs7Ozs7QUFLQSxNQUFNLGVBQWU7QUFDbkIseURBQ0U7QUFBQSxhQUFNLEdBQUcsVUFBVDtBQUFBLEtBRmlCOztBQUluQiwrQkFBMkIsbUNBQU07QUFDL0IsZUFBVSxFQUFWO0FBQ0QsS0FOa0I7O0FBUW5CLDhCQUEwQixrQ0FBTTtBQUM5QixVQUFNLGVBQWUsT0FBTyxPQUFQLENBQWdCLGVBQWhCLENBQXJCOztBQUVBLFVBQUksWUFBSixFQUNFLFNBQVUsRUFBVjtBQUNILEtBYmtCOztBQWVuQix5Q0FBcUMsNENBQU07QUFDekMseUJBQW9CLEVBQXBCO0FBQ0QsS0FqQmtCOztBQW1CbkIsdUNBQW1DLDBDQUFNO0FBQ3ZDLHVCQUFrQixFQUFsQjtBQUNEO0FBckJrQixHQUFyQjs7QUF3QkEsTUFBTSxpQkFBaUIsT0FBTyxJQUFQLENBQWEsWUFBYixDQUF2Qjs7QUFFQSxNQUFNLGNBQWMsU0FBZCxXQUFjLEtBQU07QUFDeEIsUUFBTSxXQUFXLGVBQWUsSUFBZixDQUFxQjtBQUFBLGFBQU8sR0FBRyxPQUFILENBQVksR0FBWixDQUFQO0FBQUEsS0FBckIsQ0FBakI7O0FBRUEsUUFBSSxRQUFKLEVBQWM7QUFDWixXQUFLLGFBQWMsUUFBZCxFQUEwQixFQUExQixDQUFMO0FBQ0Q7O0FBRUQsUUFBSSxFQUFKLEVBQ0UsWUFBYSxFQUFiO0FBQ0gsR0FURDs7QUFXQSxlQUFhLGdCQUFiLENBQStCLE9BQS9CLEVBQXdDLGFBQUs7QUFDM0MsZ0JBQWEsRUFBRSxNQUFmO0FBQ0QsR0FGRDs7QUFJQSxNQUFNLFdBQVcsU0FBWCxRQUFXLEtBQU07QUFDckIsUUFBTSxTQUFTLEdBQUcsVUFBSCxDQUFjLE9BQWQsQ0FBdUIsZ0JBQXZCLENBQWY7QUFDQSxRQUFNLE1BQU0sU0FBUyxhQUFULEdBQXlCLHFCQUFyQztBQUNBLFFBQU0saUJBQWlCLFNBQVMsMEJBQVQsR0FBc0Msb0NBQTdEOztBQUVBLE9BQUcsVUFBSCxDQUFjLFNBQWQsQ0FBd0IsTUFBeEIsQ0FBZ0MsY0FBaEM7O0FBRUEsUUFBTSxPQUFPLFNBQ1gsT0FBTSxRQUFOLENBQWdCLEdBQUcsVUFBSCxDQUFjLEVBQTlCLENBRFcsR0FFWCxLQUFLLGVBQUwsQ0FBc0IsR0FBRyxVQUF6QixDQUZGOztBQUlBLFFBQU0sY0FBYyxHQUFHLFVBQUgsQ0FBYyxPQUFkLENBQXVCLGdFQUF2QixDQUFwQjs7QUFFQSxXQUFRLElBQVIsRUFBYyxHQUFkLEVBQW1CLFdBQW5CO0FBQ0EsZUFBWSxJQUFaO0FBQ0QsR0FmRDs7QUFpQkEsTUFBTSxxQkFBcUIsU0FBckIsa0JBQXFCLEtBQU07QUFDL0IsUUFBTSxrQkFBa0IsS0FBSyxlQUFMLENBQXNCLEVBQXRCLENBQXhCO0FBQ0EsUUFBTSxXQUFXLGdCQUFnQixXQUFoQixFQUFqQjs7QUFFQSxhQUFTLE9BQVQsQ0FBa0IsZ0JBQVE7QUFDeEIsYUFBUSxJQUFSLEVBQWMsYUFBZCxFQUE2QixJQUE3QjtBQUNELEtBRkQ7O0FBSUEsZUFBWSxlQUFaO0FBQ0QsR0FURDs7QUFXQSxNQUFNLG1CQUFtQixTQUFuQixnQkFBbUIsS0FBTTtBQUM3QixRQUFNLGtCQUFrQixLQUFLLGVBQUwsQ0FBc0IsRUFBdEIsQ0FBeEI7QUFDQSxRQUFNLFdBQVcsZ0JBQWdCLFdBQWhCLEVBQWpCOztBQUVBLGFBQVMsT0FBVCxDQUFrQixnQkFBUTtBQUN4QixhQUFRLElBQVIsRUFBYyxhQUFkLEVBQTZCLEtBQTdCO0FBQ0QsS0FGRDs7QUFJQSxlQUFZLGVBQVo7QUFDRCxHQVREOztBQVdBLE1BQU0sV0FBVyxTQUFYLFFBQVcsS0FBTTtBQUNyQixRQUFNLFNBQVMsR0FBRyxPQUFILENBQVksZ0JBQVosQ0FBZjtBQUNBLFFBQU0sS0FBSyxPQUFPLEVBQWxCO0FBQ0EsUUFBTSxPQUFPLE9BQU0sUUFBTixDQUFnQixFQUFoQixDQUFiO0FBQ0EsUUFBTSxhQUFhLEtBQUssU0FBTCxFQUFuQjs7QUFFQSxTQUFLLE1BQUw7QUFDQTs7Ozs7Ozs7O0FBU0EsV0FBTyxNQUFQOztBQUVBLGVBQVksVUFBWjtBQUNELEdBbkJEOztBQXFCQSxNQUFNLFNBQVMsU0FBVCxNQUFTLENBQUUsSUFBRixFQUFRLEdBQVIsRUFBYSxXQUFiLEVBQThCO0FBQzNDLFNBQUssSUFBTCxDQUFXLEdBQVgsRUFBZ0IsV0FBaEI7QUFDRCxHQUZEOztBQUlBLE1BQU0sYUFBYSxTQUFiLFVBQWEsT0FBUTtBQUN6QixRQUFNLFNBQVMsU0FBUyxjQUFULENBQXlCLEtBQUssRUFBTCxFQUF6QixDQUFmO0FBQ0EsUUFBTSxhQUFhLEtBQUssU0FBTCxFQUFuQjs7QUFFQSxRQUFJLFFBQVEsQ0FBWjtBQUNBLFFBQUksaUJBQUo7O0FBRUEsUUFBSSxVQUFKLEVBQWdCO0FBQ2QsaUJBQVcsU0FBUyxjQUFULENBQXlCLFdBQVcsRUFBWCxFQUF6QixDQUFYO0FBQ0EsY0FBUSxTQUFTLE9BQVQsQ0FBaUIsS0FBakIsR0FBeUIsQ0FBekIsR0FBNkIsQ0FBckM7QUFDRDs7QUFFRCxRQUFNLFdBQVcsV0FBWSxJQUFaLEVBQWtCLEVBQUUsWUFBRixFQUFsQixDQUFqQjtBQUNBLFFBQU0sWUFBWSxTQUFTLFNBQVQsRUFBbEI7O0FBRUEsYUFBVSxNQUFWLEVBQWtCLFNBQWxCO0FBQ0QsR0FoQkQ7O0FBa0JBLE1BQUkscUJBQUo7O0FBRUEsTUFBTSxTQUFTLFNBQVQsTUFBUyxHQUFlO0FBQzVCLFFBQUksWUFBSixFQUFrQjtBQUNuQixHQUZEOztBQUlBLE1BQU0sWUFBWSxFQUFFLGdCQUFGLEVBQVcsc0JBQVgsRUFBdUIsVUFBdkIsRUFBNkIsY0FBN0IsRUFBbEI7O0FBRUEsTUFBTSxRQUFRLE1BQU8sU0FBUCxDQUFkOztBQUVBLE1BQU0sTUFBTTtBQUNWLFlBQVE7QUFBQSxhQUFNLGFBQWEsU0FBYixHQUF5QixFQUEvQjtBQUFBLEtBREU7QUFFVixVQUFNO0FBQUEsYUFBTSxLQUFOO0FBQUEsS0FGSTtBQUdWLFdBQU87QUFBQSxhQUFNLE1BQU47QUFBQSxLQUhHO0FBSVYsaUJBQWEsOEJBQVc7QUFDdEIsVUFBSSxPQUFPLE9BQVAsS0FBbUIsVUFBdkIsRUFDRSxlQUFjLE9BQWQ7O0FBRUYsYUFBTyxZQUFQO0FBQ0Q7QUFUUyxHQUFaOztBQVlBLFNBQU8sR0FBUDtBQUNELENBektEOztBQTJLQSxPQUFPLE9BQVAsR0FBaUIsUUFBakI7OztBQ3hNQTs7QUFFQSxJQUFNLFdBQVcsUUFBUyxZQUFULENBQWpCOztBQUVBLFFBQVMsYUFBVDs7QUFFQSxPQUFPLE1BQVAsR0FBZ0IsRUFBRSxrQkFBRixFQUFoQjs7QUFFQTs7Ozs7QUFLQTtBQUNBLElBQU0sY0FBYyxRQUFTLGVBQVQsQ0FBcEI7O0FBRUE7QUFDQTtBQUNBLElBQU0sZ0JBQWdCLFNBQWhCLGFBQWdCLEtBQU07QUFDMUIsTUFBTSxVQUFVLFNBQVYsT0FBVSxDQUFFLEVBQUYsRUFBTSxJQUFOLEVBQWdCO0FBQzlCLFFBQU0sUUFBUSxHQUFHLEtBQUgsQ0FBVSxJQUFWLENBQWQ7O0FBRUEsV0FBTyxNQUFNLFFBQU4sS0FBbUIsTUFBbkIsSUFBNkIsTUFBTSxRQUFOLEtBQW1CLE1BQXZEO0FBQ0QsR0FKRDs7QUFNQSxVQUFRLEdBQVIsR0FBYyxHQUFHLE9BQUgsQ0FBVyxHQUF6Qjs7QUFFQSxTQUFPLE9BQU8sTUFBUCxDQUFlLEVBQWYsRUFBbUIsRUFBRSxnQkFBRixFQUFuQixDQUFQO0FBQ0QsQ0FWRDs7QUFZQSxJQUFNLE9BQU8sWUFBYSxhQUFiLENBQWI7O0FBRUEsSUFBTSx3QkFBd0IsUUFBUyw4QkFBVCxDQUE5QjtBQUNBLElBQU0sYUFBYSxRQUFTLDZCQUFULENBQW5CO0FBQ0EsSUFBTSxhQUFhLFdBQVkscUJBQVosQ0FBbkI7O0FBRUEsSUFBTSxVQUFVLHNCQUFzQixLQUF0QixDQUE2QixZQUE3QixDQUFoQjtBQUNBLElBQU0sT0FBTyxLQUFNLE9BQU4sQ0FBYjs7QUFFQSxJQUFNLGNBQWMsU0FBVSxJQUFWLEVBQWdCLFVBQWhCLENBQXBCOzs7OztBQ3ZDQSxDQUFDLFVBQVUsWUFBVixFQUF3QjtBQUN4QixLQUFJLE9BQU8sYUFBYSxPQUFwQixLQUFnQyxVQUFwQyxFQUFnRDtBQUMvQyxlQUFhLE9BQWIsR0FBdUIsYUFBYSxpQkFBYixJQUFrQyxhQUFhLGtCQUEvQyxJQUFxRSxhQUFhLHFCQUFsRixJQUEyRyxTQUFTLE9BQVQsQ0FBaUIsUUFBakIsRUFBMkI7QUFDNUosT0FBSSxVQUFVLElBQWQ7QUFDQSxPQUFJLFdBQVcsQ0FBQyxRQUFRLFFBQVIsSUFBb0IsUUFBUSxhQUE3QixFQUE0QyxnQkFBNUMsQ0FBNkQsUUFBN0QsQ0FBZjtBQUNBLE9BQUksUUFBUSxDQUFaOztBQUVBLFVBQU8sU0FBUyxLQUFULEtBQW1CLFNBQVMsS0FBVCxNQUFvQixPQUE5QyxFQUF1RDtBQUN0RCxNQUFFLEtBQUY7QUFDQTs7QUFFRCxVQUFPLFFBQVEsU0FBUyxLQUFULENBQVIsQ0FBUDtBQUNBLEdBVkQ7QUFXQTs7QUFFRCxLQUFJLE9BQU8sYUFBYSxPQUFwQixLQUFnQyxVQUFwQyxFQUFnRDtBQUMvQyxlQUFhLE9BQWIsR0FBdUIsU0FBUyxPQUFULENBQWlCLFFBQWpCLEVBQTJCO0FBQ2pELE9BQUksVUFBVSxJQUFkOztBQUVBLFVBQU8sV0FBVyxRQUFRLFFBQVIsS0FBcUIsQ0FBdkMsRUFBMEM7QUFDekMsUUFBSSxRQUFRLE9BQVIsQ0FBZ0IsUUFBaEIsQ0FBSixFQUErQjtBQUM5QixZQUFPLE9BQVA7QUFDQTs7QUFFRCxjQUFVLFFBQVEsVUFBbEI7QUFDQTs7QUFFRCxVQUFPLElBQVA7QUFDQSxHQVpEO0FBYUE7QUFDRCxDQTlCRCxFQThCRyxPQUFPLE9BQVAsQ0FBZSxTQTlCbEI7OztBQ0FBOztBQUVBLElBQU0sWUFBWSxTQUFaLFNBQVksZUFBZ0I7QUFBQSxNQUN4QixNQUR3QixHQUNDLFlBREQsQ0FDeEIsTUFEd0I7QUFBQSxNQUNoQixZQURnQixHQUNDLFlBREQsQ0FDaEIsWUFEZ0I7OztBQUdoQyxNQUFNLFlBQVksU0FBWixTQUFZLE9BQVE7QUFDeEIsUUFBSSxNQUFNLEVBQVY7O0FBRUEsUUFBTSxlQUFlLElBQUksR0FBSixFQUFyQjs7QUFFQSxTQUFLLElBQUwsQ0FBVyxnQkFBUTtBQUNqQixVQUFNLFFBQVEsS0FBSyxLQUFMLEVBQWQ7QUFDQSxVQUFNLGdCQUFnQixNQUFNLElBQTVCOztBQUVBLFVBQUksYUFBYSxHQUFiLENBQWtCLGFBQWxCLENBQUosRUFDRTs7QUFFRixtQkFBYSxHQUFiLENBQWtCLGFBQWxCOztBQUVBLFVBQU0sUUFBUSxPQUFRLGFBQVIsQ0FBZDs7QUFFQSxVQUFJLE9BQU8sS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QixlQUFPLEtBQVA7QUFDQSxlQUFPLEdBQVA7QUFDRDtBQUNGLEtBZkQ7O0FBaUJBLFFBQUksT0FBTyxZQUFQLEtBQXdCLFVBQTVCLEVBQ0UsTUFBTSxhQUFjLEdBQWQsQ0FBTjs7QUFFRixXQUFPLEdBQVA7QUFDRCxHQTFCRDs7QUE0QkEsU0FBTyxTQUFQO0FBQ0QsQ0FoQ0Q7O0FBa0NBLE9BQU8sT0FBUCxHQUFpQixTQUFqQjs7O0FDcENBOztBQUVBLElBQU0sWUFBWSxRQUFTLGlCQUFULENBQWxCO0FBQ0EsSUFBTSxZQUFZLFFBQVMsYUFBVCxDQUFsQjs7QUFFQSxJQUFNLGFBQWEsU0FBYixVQUFhLGVBQWdCO0FBQ2pDLE1BQU0sWUFBWSxVQUFXLFlBQVgsQ0FBbEI7QUFEaUMsTUFFekIsT0FGeUIsR0FFYixZQUZhLENBRXpCLE9BRnlCOztBQUFBLG1CQUdMLFVBQVcsWUFBWCxDQUhLO0FBQUEsTUFHekIsZUFIeUIsY0FHekIsZUFIeUI7O0FBS2pDLE1BQU0sZ0JBQWdCO0FBQ3BCLHVCQUFtQjtBQURDLEdBQXRCOztBQUlBLE1BQU0sdUJBQXVCLFNBQXZCLG9CQUF1QixPQUFRO0FBQ25DLFFBQU0sUUFBUSxLQUFLLEtBQUwsRUFBZDtBQUNBLFFBQU0sZ0JBQWdCLE1BQU0sSUFBNUI7QUFDQSxRQUFNLGlCQUFpQixNQUFNLEtBQTdCOztBQUVBLFFBQU0sTUFBTSxVQUFXLElBQVgsQ0FBWjs7QUFFQSxRQUFJLENBQUMsTUFBTSxPQUFOLENBQWUsZUFBZSxVQUE5QixDQUFMLEVBQ0UsZUFBZSxVQUFmLEdBQTRCLEVBQTVCOztBQUVGLG1CQUFlLFVBQWYsQ0FBMEIsSUFBMUIsQ0FBK0I7QUFDN0IsWUFBTTtBQUR1QixLQUEvQjs7QUFJQSxTQUFLLEtBQUwsQ0FBWSxLQUFaO0FBQ0QsR0FmRDs7QUFpQkEsTUFBTSxhQUFhLFNBQWIsVUFBYSxPQUFRO0FBQ3pCLFFBQU0sUUFBUSxLQUFLLEtBQUwsRUFBZDtBQUNBLFFBQU0sZ0JBQWdCLE1BQU0sSUFBNUI7QUFDQSxRQUFNLGlCQUFpQixNQUFNLEtBQTdCOztBQUVBLFFBQUksa0JBQWtCLFVBQXRCLEVBQWtDO0FBQ2hDLDJCQUFzQixJQUF0QjtBQUNEOztBQUVELFFBQU0sTUFBTSxnQkFBaUIsYUFBakIsRUFBZ0MsY0FBaEMsQ0FBWjtBQUNBLFFBQU0sU0FBUyxPQUFPLE1BQVAsQ0FBZSxFQUFmLEVBQW1CLGFBQW5CLEVBQWtDLFFBQVMsYUFBVCxDQUFsQyxDQUFmO0FBQ0EsUUFBTSxpQkFBaUIsSUFBSSxNQUFKLENBQVksT0FBTyxpQkFBbkIsQ0FBdkI7QUFDQSxRQUFNLFdBQVcsS0FBSyxXQUFMLEVBQWpCOztBQUVBLFFBQUksa0JBQWtCLFNBQVMsTUFBL0IsRUFBdUM7QUFDckMsZUFBUyxPQUFULENBQWtCLHFCQUFhO0FBQzdCLFlBQU0sV0FBVyxXQUFZLFNBQVosQ0FBakI7O0FBRUEsWUFBSSxlQUFlLFFBQWYsT0FBOEIsSUFBOUIsSUFBc0MsZUFBZSxRQUFmLE9BQThCLElBQXhFLEVBQThFO0FBQzVFOzs7Ozs7O0FBUUEsY0FBTSxTQUFTLElBQUksS0FBSixDQUFXLFdBQVgsRUFBeUIsTUFBekIsQ0FBaUMsSUFBakMsQ0FBZjs7QUFFQSxpQkFBTyxNQUFQLENBQWUsUUFBZjtBQUNBLHlCQUFlLE1BQWYsQ0FBdUIsTUFBdkI7O0FBRUE7QUFDRDs7QUFFRCx1QkFBZSxNQUFmLENBQXVCLFFBQXZCO0FBQ0QsT0FyQkQ7QUFzQkQ7O0FBRUQsV0FBTyxHQUFQO0FBQ0QsR0F4Q0Q7O0FBMENBLFNBQU8sVUFBUDtBQUNELENBckVEOztBQXVFQSxPQUFPLE9BQVAsR0FBaUIsVUFBakI7OztBQzVFQTs7QUFFQSxJQUFNLGFBQWEsUUFBUyxjQUFULENBQW5CO0FBQ0EsSUFBTSxXQUFXLFFBQVMsWUFBVCxDQUFqQjtBQUNBLElBQU0sa0JBQWtCLFFBQVMsa0JBQVQsQ0FBeEI7QUFDQSxJQUFNLFFBQVEsUUFBUyxjQUFULENBQWQ7O0lBRVEsSyxHQUFVLEssQ0FBVixLOzs7QUFFUixJQUFNLGdCQUFnQixTQUFoQixhQUFnQixDQUFFLFlBQUYsRUFBZ0IsYUFBaEIsRUFBK0IsS0FBL0IsRUFBMEM7QUFDOUQsVUFBUSxNQUFPLEtBQVAsQ0FBUjs7QUFFQSxNQUFNLFlBQVksU0FBUyxNQUFULENBQWlCLEtBQWpCLENBQWxCOztBQUg4RCxNQUt0RCxjQUxzRCxHQUtkLFlBTGMsQ0FLdEQsY0FMc0Q7QUFBQSxNQUt0QyxPQUxzQyxHQUtkLFlBTGMsQ0FLdEMsT0FMc0M7QUFBQSxNQUs3QixVQUw2QixHQUtkLFlBTGMsQ0FLN0IsVUFMNkI7OztBQU85RCxNQUFNLGNBQWMsT0FBTyxJQUFQLENBQWEsT0FBYixDQUFwQjs7QUFFQSxNQUFNLG9CQUFvQixTQUFwQixpQkFBb0I7QUFBQSxXQUN4QixXQUFXLE9BQVgsQ0FBb0I7QUFBQSxhQUNsQixlQUFlLFFBQWYsQ0FBeUIsRUFBRSxLQUFGLEdBQVUsSUFBbkMsQ0FEa0I7QUFBQSxLQUFwQixDQUR3QjtBQUFBLEdBQTFCOztBQUtBLE1BQU0sWUFBWSxXQUFZLGFBQVosQ0FBbEI7QUFDQSxNQUFNLGtCQUFrQixRQUFTLGFBQVQsQ0FBeEI7O0FBRUEsTUFBSSxhQUFhLENBQUMsZUFBbEIsRUFBbUM7QUFDakMsV0FBTyxnQkFBaUIsS0FBakIsRUFBd0IsU0FBeEIsQ0FBUDtBQUNEOztBQUVELE1BQUksQ0FBQyxTQUFELElBQWMsQ0FBQyxlQUFuQixFQUFvQztBQUNsQyxXQUFPLEtBQVA7QUFDRDs7QUFFRCxNQUFNLHNCQUFzQixXQUFXLE1BQVgsQ0FBbUIsZUFBbkIsQ0FBNUI7QUFDQSxNQUFNLGdCQUFnQixrQkFBbUIsbUJBQW5CLENBQXRCOztBQUVBLGdCQUFjLE9BQWQsQ0FBdUIsNEJBQW9CO0FBQ3pDLFFBQU0sUUFBUSxpQkFBaUIsS0FBakIsRUFBZDtBQUNBLFFBQU0sZ0JBQWdCLE1BQU0sSUFBNUI7QUFDQSxRQUFNLHFCQUFxQixXQUFZLGFBQVosQ0FBM0I7O0FBRUEsUUFBSSxDQUFDLGtCQUFMLEVBQTBCOztBQUUxQixRQUFNLGNBQWMsV0FBVyxZQUFYLENBQXlCLGdCQUF6QixDQUFwQjtBQUNBLFFBQU0sWUFBWSxTQUFTLFlBQVQsQ0FBdUIsU0FBdkIsRUFBa0MsV0FBbEMsQ0FBbEI7O0FBRUEsUUFBSSxDQUFDLFNBQUwsRUFBaUI7O0FBRWpCLFFBQU0saUJBQWlCLFVBQVUsS0FBVixFQUF2Qjs7QUFFQSxRQUFJLE1BQU0sU0FBVixFQUFxQjtBQUNuQixVQUFNLGFBQWEsU0FBUyxNQUFULENBQWlCLFNBQWpCLENBQW5COztBQUVBLFVBQU0sY0FBYyxXQUFXLEdBQVgsQ0FBZ0I7QUFBQSxlQUNsQyxjQUFlLFlBQWYsRUFBNkIsYUFBN0IsRUFBNEMsSUFBNUMsQ0FEa0M7QUFBQSxPQUFoQixDQUFwQjs7QUFJQSxVQUFNLGtCQUFrQixTQUFTLE1BQVQsQ0FBaUIsV0FBakIsQ0FBeEI7QUFDQSxVQUFNLGtCQUFrQixVQUFVLFNBQVYsRUFBeEI7O0FBRUEsVUFBSSxlQUFlLFlBQW5CLEVBQWlDO0FBQy9CLFlBQU0sdUJBQXVCLGdCQUFnQixLQUFoQixFQUE3QjtBQUNBLDZCQUFxQixZQUFyQixHQUFvQyxlQUFlLFlBQW5EO0FBQ0Esd0JBQWdCLEtBQWhCLENBQXVCLG9CQUF2QjtBQUNEOztBQUVELHNCQUFnQixZQUFoQixDQUE4QixlQUE5QixFQUErQyxTQUEvQztBQUNELEtBakJELE1BaUJPO0FBQ0wsWUFBTSxJQUFJLEtBQUosQ0FBVyxtQ0FBWCxDQUFOO0FBQ0Q7QUFDRixHQWxDRDs7QUFvQ0EsVUFBUSxTQUFTLE1BQVQsQ0FBaUIsU0FBakIsQ0FBUjs7QUFFQSxNQUFJLFNBQUosRUFDRSxRQUFRLGdCQUFpQixLQUFqQixFQUF3QixTQUF4QixDQUFSOztBQUVGLFNBQU8sS0FBUDtBQUNELENBdEVEOztBQXdFQSxPQUFPLE9BQVAsR0FBaUIsYUFBakI7OztBQ2pGQTs7QUFFQSxJQUFNLE9BQU8sUUFBUyxPQUFULENBQWI7QUFDQSxJQUFNLGNBQWMsUUFBUyxzQkFBVCxDQUFwQjs7QUFFQSxJQUFNLGlCQUFpQjtBQUNyQixTQUFPLENBRGM7QUFFckIsY0FBWSxLQUFLLFVBRkk7QUFHckIsd0JBQXNCLEtBSEQ7QUFJckI7QUFKcUIsQ0FBdkI7O0FBT0EsSUFBTSxxQkFBcUIsU0FBckIsa0JBQXFCLENBQUUsSUFBRixFQUFRLE9BQVIsRUFBcUI7QUFDOUMsWUFBVSxPQUFPLE1BQVAsQ0FBZSxFQUFmLEVBQW1CLGNBQW5CLEVBQW1DLE9BQW5DLENBQVY7O0FBRDhDLGlCQUdtQixPQUhuQjtBQUFBLE1BR3RDLEtBSHNDLFlBR3RDLEtBSHNDO0FBQUEsTUFHL0IsVUFIK0IsWUFHL0IsVUFIK0I7QUFBQSxNQUduQixXQUhtQixZQUduQixXQUhtQjtBQUFBLE1BR04sb0JBSE0sWUFHTixvQkFITTs7O0FBSzlDLE1BQU0sUUFBUSxZQUFhLElBQWIsRUFBbUIsRUFBRSxZQUFGLEVBQW5CLENBQWQ7O0FBRUEsTUFBTSxRQUFRO0FBQ1osVUFBTSxlQURNO0FBRVo7QUFGWSxHQUFkOztBQUtBLE1BQU0sZ0JBQWdCLFdBQVksS0FBWixDQUF0Qjs7QUFFQSxNQUFNLHVCQUF1Qix3QkFBd0IsQ0FBQyxNQUFNLG1CQUE1RDs7QUFFQSxNQUFJLG9CQUFKLEVBQTJCO0FBQ3pCLFFBQU0sV0FBVyxLQUFLLFdBQUwsRUFBakI7O0FBRUEsYUFBUyxPQUFULENBQWtCLHFCQUFhO0FBQzdCLFVBQU0sZUFBZSxPQUFPLE1BQVAsQ0FDbkIsRUFEbUIsRUFFbkIsT0FGbUIsRUFHbkI7QUFDRSxlQUFPLFFBQVE7QUFEakIsT0FIbUIsQ0FBckI7O0FBUUEsVUFBTSxxQkFBcUIsbUJBQW9CLFNBQXBCLEVBQStCLFlBQS9CLENBQTNCOztBQUVBLG9CQUFjLE1BQWQsQ0FBc0Isa0JBQXRCO0FBQ0QsS0FaRDtBQWFEOztBQUVELFNBQU8sYUFBUDtBQUVELENBcENEOztBQXNDQSxPQUFPLE9BQVAsR0FBaUIsa0JBQWpCOzs7QUNsREE7O2VBRXVCLFFBQVMsY0FBVCxDO0lBQWYsVSxZQUFBLFU7O0FBRVIsSUFBTSxpQkFBaUI7QUFDckIsU0FBTztBQURjLENBQXZCOztBQUlBLElBQU0sY0FBYyxTQUFkLFdBQWMsQ0FBRSxJQUFGLEVBQVEsT0FBUixFQUFxQjtBQUN2QyxZQUFVLE9BQU8sTUFBUCxDQUFlLEVBQWYsRUFBbUIsY0FBbkIsRUFBbUMsT0FBbkMsQ0FBVjs7QUFEdUMsaUJBR3JCLE9BSHFCO0FBQUEsTUFHL0IsS0FIK0IsWUFHL0IsS0FIK0I7OztBQUt2QyxNQUFNLFFBQVEsS0FBSyxLQUFMLEVBQWQ7QUFDQSxNQUFNLFdBQVcsS0FBSyxXQUFMLEVBQWpCOztBQUVBLE1BQU0sS0FBSyxLQUFLLEVBQUwsRUFBWDtBQUNBLE1BQU0sT0FBTyxNQUFNLElBQU4sSUFBYyxFQUEzQjtBQUNBLE1BQU0sV0FBVyxPQUFqQjtBQUNBLE1BQU0sV0FBVyxLQUFLLFFBQUwsRUFBakI7QUFDQSxNQUFNLFFBQVksS0FBWixVQUF3QixJQUF4QixTQUFrQyxRQUFsQyxXQUFrRCxTQUFTLE1BQTNELE9BQU47QUFDQSxNQUFNLFVBQVUsS0FBSyxPQUFMLEVBQWhCOztBQUVBLE1BQUksY0FBYyxLQUFLLElBQUwsQ0FBVyxhQUFYLENBQWxCOztBQUVBLGdCQUFjLE9BQU8sV0FBUCxLQUF1QixTQUF2QixHQUFtQyxXQUFuQyxHQUFpRCxRQUFRLENBQXZFOztBQUVBLE1BQU0sc0JBQXNCLGVBQWUsQ0FBQyxDQUFDLEtBQUssSUFBTCxDQUFXLHFCQUFYLENBQTdDOztBQUVBLE1BQU0sVUFBVSxXQUFZLEtBQUssU0FBTCxDQUFnQixLQUFoQixDQUFaLENBQWhCO0FBQ0EsTUFBTSxnQkFBb0IsS0FBcEIsZUFBTjs7QUFFQSxNQUFNLFFBQVE7QUFDWixVQURZLEVBQ1IsWUFEUSxFQUNELGtCQURDLEVBQ1Msa0JBRFQsRUFDbUIsWUFEbkIsRUFDMEIsZ0JBRDFCLEVBQ21DLHdCQURuQztBQUVaLDRDQUZZLEVBRVMsZ0JBRlQsRUFFa0I7QUFGbEIsR0FBZDs7QUFLQSxTQUFPLEtBQVA7QUFDRCxDQTlCRDs7QUFnQ0EsT0FBTyxPQUFQLEdBQWlCLFdBQWpCOzs7QUN4Q0E7O0FBRUEsSUFBTSxPQUFPLFFBQVMsT0FBVCxDQUFiO0FBQ0EsSUFBTSxjQUFjLFFBQVMsc0JBQVQsQ0FBcEI7QUFDQSxJQUFNLHFCQUFxQixRQUFTLDZCQUFULENBQTNCO0FBQ0EsSUFBTSxzQkFBc0IsUUFBUyx5Q0FBVCxDQUE1Qjs7QUFFQSxJQUFNLGlCQUFpQjtBQUNyQixTQUFPLENBRGM7QUFFckIsY0FBWSxLQUFLLFVBRkk7QUFHckIsMEJBSHFCO0FBSXJCO0FBSnFCLENBQXZCOztBQU9BLElBQU0sYUFBYSxTQUFiLFVBQWEsZUFBZ0I7QUFDakMsTUFBTSxzQkFBc0Isb0JBQXFCLFlBQXJCLENBQTVCOztBQUVBLE1BQU0sYUFBYSxTQUFiLFVBQWEsQ0FBRSxJQUFGLEVBQVEsT0FBUixFQUFxQjtBQUN0QyxjQUFVLE9BQU8sTUFBUCxDQUFlLEVBQWYsRUFBbUIsY0FBbkIsRUFBbUMsT0FBbkMsQ0FBVjs7QUFEc0MsbUJBR3lCLE9BSHpCO0FBQUEsUUFHOUIsV0FIOEIsWUFHOUIsV0FIOEI7QUFBQSxRQUdqQixrQkFIaUIsWUFHakIsa0JBSGlCO0FBQUEsUUFHRyxLQUhILFlBR0csS0FISDtBQUFBLFFBR1UsVUFIVixZQUdVLFVBSFY7OztBQUt0QyxRQUFNLHdCQUF3QixFQUFFLFlBQUYsRUFBUyxzQkFBVCxFQUFxQix3QkFBckIsRUFBOUI7QUFDQSxRQUFNLGVBQWUsbUJBQW9CLElBQXBCLEVBQTBCLHFCQUExQixDQUFyQjtBQUNBLFFBQU0sZ0JBQWdCLG9CQUFxQixZQUFyQixDQUF0Qjs7QUFFQSxXQUFPLGFBQVA7QUFDRCxHQVZEOztBQVlBLFNBQU8sVUFBUDtBQUNELENBaEJEOztBQWtCQSxPQUFPLE9BQVAsR0FBaUIsVUFBakI7OztBQ2hDQTs7QUFFQSxJQUFNLGFBQWEsUUFBUyxtQkFBVCxDQUFuQjtBQUNBLElBQU0sWUFBWSxRQUFTLFdBQVQsQ0FBbEI7QUFDQSxJQUFNLDJCQUEyQixRQUFTLHdDQUFULENBQWpDOztBQUVBLElBQU0sY0FBYyxTQUFkLFdBQWMsQ0FBRSxTQUFGLEVBQWEsS0FBYixFQUFvQixJQUFwQixFQUE4QjtBQUNoRCxNQUFNLGNBQWMsVUFBVSxhQUFWLEVBQXBCOztBQUVBLE1BQUksQ0FBQyxZQUFZLFFBQVosQ0FBc0IsSUFBdEIsQ0FBTCxFQUFvQzs7QUFFcEMsTUFBTSxTQUFTLFVBQVUsZ0JBQVYsQ0FBNEIsS0FBNUIsRUFBbUMsSUFBbkMsQ0FBZjs7QUFFQSxNQUFJLE9BQU8sS0FBWCxFQUFtQjs7QUFFbkIsTUFBTSxvREFBbUQsSUFBbkQsVUFBOEQsS0FBSyxTQUFMLENBQWdCLE9BQU8sTUFBdkIsQ0FBcEU7QUFDQSxRQUFNLElBQUksS0FBSixDQUFXLE9BQVgsQ0FBTjtBQUNELENBWEQ7O0FBYUEsSUFBTSxZQUFZLFNBQVosU0FBWSxlQUFnQjtBQUFBLE1BQ3hCLFVBRHdCLEdBQzBCLFlBRDFCLENBQ3hCLFVBRHdCO0FBQUEsTUFDWixTQURZLEdBQzBCLFlBRDFCLENBQ1osU0FEWTtBQUFBLE1BQ0QsYUFEQyxHQUMwQixZQUQxQixDQUNELGFBREM7QUFBQSxNQUNjLE9BRGQsR0FDMEIsWUFEMUIsQ0FDYyxPQURkOzs7QUFHaEMsTUFBTSxhQUFhLFdBQVksU0FBWixDQUFuQjtBQUNBLE1BQU0sWUFBWSxVQUFXLE9BQVgsQ0FBbEI7O0FBRUEsTUFBTSxrQkFBa0IsU0FBbEIsZUFBa0IsQ0FBRSxJQUFGLEVBQVEsS0FBUixFQUFtQjtBQUN6QyxRQUFNLGdCQUFnQixPQUFPLE1BQVAsQ0FBZSxFQUFmLEVBQW1CLGNBQWUsSUFBZixLQUF5QixFQUE1QyxFQUFnRCxLQUFoRCxDQUF0Qjs7QUFFQSxnQkFBYSxTQUFiLEVBQXdCLGFBQXhCLEVBQXVDLElBQXZDOztBQUVBLFFBQU0sWUFBWSx5QkFBMEIsWUFBMUIsRUFBd0MsSUFBeEMsRUFBOEMsYUFBOUMsQ0FBbEI7O0FBRUEsV0FBTyxXQUFZLElBQVosRUFBa0IsU0FBbEIsQ0FBUDtBQUNELEdBUkQ7O0FBVUE7QUFDQSxNQUFNLGlCQUFpQixTQUFqQixjQUFpQixDQUFFLElBQUYsRUFBUSxLQUFSLEVBQWUsUUFBZixFQUE2QjtBQUNsRCxRQUFJO0FBQ0YsVUFBTSxnQkFBZ0IsT0FBTyxNQUFQLENBQWUsRUFBZixFQUFtQixjQUFjLFFBQWpDLEVBQTJDLEtBQTNDLENBQXRCOztBQUVBLFVBQUksU0FBUyxVQUFiLEVBQXlCO0FBQ3ZCLFlBQU0sT0FBTyxnQkFBaUIsSUFBakIsRUFBdUIsS0FBdkIsRUFBK0IsU0FBL0IsRUFBYjs7QUFFQSxlQUFPLE1BQVAsQ0FBZSxhQUFmLEVBQThCLEVBQUUsVUFBRixFQUE5QjtBQUNEOztBQUVELGtCQUFhLFNBQWIsRUFBd0IsYUFBeEIsRUFBdUMsVUFBdkM7O0FBRUEsVUFBTSxZQUFZLHlCQUEwQixZQUExQixFQUF3QyxVQUF4QyxFQUFvRCxhQUFwRCxDQUFsQjs7QUFFQSxVQUFNLE1BQU0sV0FBWSxVQUFaLEVBQXdCLFNBQXhCLENBQVo7O0FBRUEsZUFBVSxJQUFWLEVBQWdCLEdBQWhCO0FBQ0QsS0FoQkQsQ0FnQkUsT0FBTyxDQUFQLEVBQVU7QUFDVixlQUFVLENBQVY7QUFDRDtBQUNGLEdBcEJEOztBQXNCQSxTQUFPLEVBQUUsOEJBQUYsRUFBa0IsZ0NBQWxCLEVBQVA7QUFDRCxDQXhDRDs7QUEwQ0EsT0FBTyxPQUFQLEdBQWlCLFNBQWpCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzPXtcInN0eWxlc1wiOntcImNvbXBvc2VyXCI6XCIuY29tcG9zZXIge1xcbiAgbGluZS1oZWlnaHQ6IDI7XFxuICBmb250LXNpemU6IDFyZW07XFxufVxcblxcbiR0b29sYmFyLWNvbG9yOiBoc2woIDIxMCwgMTUlLCA0MCUgKTtcXG4kdG9vbGJhci1jaGlsZHJlbi1jb2xvcjogaHNsKCAyMTAsIDg1JSwgMzclICk7XFxuJHRvb2xiYXItZW1wdHktY29sb3I6IGhzbCggMjEwLCAxMCUsIDg4JSApO1xcbiRtYWluLWNvbG9yOiBoc2woIDIxMCwgNSUsIDk1JSApO1xcbiRjaGlsZHJlbi1jb2xvcjogaHNsKCAyMTAsIDk1JSwgOTUlICk7XFxuJGFjdGlvbi1jb2xvcjogaHNsKDIxMCwgODUlLCA2MCUgKTtcXG4kYWN0aW9uLWRlbGV0ZS1jb2xvcjogaHNsKCAwLCA4MyUsIDUwJSApO1xcblxcbi5jb21wb3Nlci1ub2RlX190b29sYmFyIHtcXG4gIG1pbi1oZWlnaHQ6IDNyZW07XFxuXFxuICBjb2xvcjogaHNsKCAyMTAsIDEwJSwgOTUlICk7XFxuICBAaW5jbHVkZSBjb2xvcml6ZS1lbCggJHRvb2xiYXItY29sb3IgKTtcXG4gIGJveC1zaGFkb3c6IDAuMTI1cmVtIDAuMTI1cmVtIDAuNXJlbSByZ2JhKCAwLCAwLCAwLCAwLjI1ICk7XFxufVxcblxcbi5jb21wb3Nlci1ub2RlX190aXRsZSB7XFxuICBsaW5lLWhlaWdodDogMztcXG4gIHBhZGRpbmc6IDAgMXJlbTtcXG59XFxuXFxuLmNvbXBvc2VyLW5vZGVfX2NoaWxkcmVuID4gLmNvbXBvc2VyLW5vZGVfX3Rvb2xiYXIge1xcbiAgQGluY2x1ZGUgY29sb3JpemUtZWwoICR0b29sYmFyLWNoaWxkcmVuLWNvbG9yICk7XFxuICBib3gtc2hhZG93OiAwLjEyNXJlbSAwLjEyNXJlbSAwLjVyZW0gcmdiYSggMCwgMCwgMCwgMC4yNSApO1xcbn1cXG5cXG4uY29tcG9zZXItbm9kZS0tZW1wdHkgPiAuY29tcG9zZXItbm9kZV9fdG9vbGJhciB7XFxuICBjb2xvcjogaHNsKCAyMTAsIDg1JSwgMTUlICk7XFxuICBAaW5jbHVkZSBjb2xvcml6ZS1lbCggJHRvb2xiYXItZW1wdHktY29sb3IgKTtcXG4gIGJveC1zaGFkb3c6IDAuMTI1cmVtIDAuMTI1cmVtIDAuNXJlbSByZ2JhKCAwLCAwLCAwLCAwLjI1ICk7XFxufVxcblxcbi5jb21wb3Nlci1ub2RlOm5vdCggW2RhdGEtZGVwdGg9XFxcIjBcXFwiXSApID4gLmNvbXBvc2VyLW5vZGVfX3Rvb2xiYXIge1xcbiAgY3Vyc29yOiBtb3ZlO1xcbn1cXG5cXG4uY29tcG9zZXItbm9kZV9fdmlldyB7XFxuICBtYXJnaW4tYm90dG9tOiAwLjVyZW07XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgcGFkZGluZzogMC41cmVtO1xcblxcbiAgY29sb3I6ICMxMTE7XFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgYm94LXNoYWRvdzogaW5zZXQgMC4wMzEyNXJlbSAwLjAzMTI1cmVtIDAuMTI1cmVtIHJnYmEoIDAsIDAsIDAsIDAuMjUgKTtcXG59XFxuXFxuLmNvbXBvc2VyLW5vZGVfX3ZpZXc6bGFzdC1jaGlsZCB7XFxuICBtYXJnaW4tYm90dG9tOiAwO1xcbn1cXG5cXG4uY29tcG9zZXItbm9kZV9fbWFpbiB7XFxuICBwYWRkaW5nOiAwLjc1cmVtO1xcbiAgbWFyZ2luOiAwLjI1cmVtO1xcbiAgbWFyZ2luLXRvcDogMDtcXG5cXG4gIEBpbmNsdWRlIGNvbG9yaXplLWVsLWJhY2tncm91bmQoICRtYWluLWNvbG9yICk7XFxuICBib3gtc2hhZG93OiAwLjEyNXJlbSAwLjEyNXJlbSAwLjVyZW0gcmdiYSggMCwgMCwgMCwgMC4yNSApO1xcbn1cXG5cXG4uY29tcG9zZXItbm9kZS0tY29sbGFwc2VkID4gLmNvbXBvc2VyLW5vZGVfX21haW4sXFxuLmNvbXBvc2VyLW5vZGVfX2NoaWxkcmVuLS1jb2xsYXBzZWQgPiAuY29tcG9zZXItbm9kZV9fbWFpbiB7XFxuICBoZWlnaHQ6IDA7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgYm9yZGVyOiAwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuLmNvbXBvc2VyLW5vZGVfX2NoaWxkcmVuIHtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuXFxuICBAaW5jbHVkZSBjb2xvcml6ZS1lbC1iYWNrZ3JvdW5kKCAkY2hpbGRyZW4tY29sb3IgKTtcXG4gIGJveC1zaGFkb3c6IGluc2V0IDAuMTI1cmVtIDAuMTI1cmVtIDAuNXJlbSByZ2JhKCAwLCAwLCAwLCAwLjI1ICk7XFxufVxcblxcbi5jb21wb3Nlci1ub2RlX19jaGlsZHJlbiA+IHVsIHtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDAuNXJlbTtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxufVxcblxcbi5jb21wb3Nlci1ub2RlX19jaGlsZHJlbi0tY29sbGFwc2VkID4gdWwge1xcbiAgaGVpZ2h0OiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcbi5jb21wb3Nlci1ub2RlX19jaGlsZHJlbiA+IHVsID4gbGkge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxuLmNvbXBvc2VyLW5vZGVfX2FjdGlvbnMge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmbG9hdDogcmlnaHQ7XFxufVxcblxcbi5jb21wb3Nlci1ub2RlX19hY3Rpb25zID4gbGkge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmbG9hdDogbGVmdDtcXG59XFxuXFxuLmNvbXBvc2VyLW5vZGVfX2FjdGlvbiB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHBhZGRpbmc6IDA7XFxuICBmb250LXNpemU6IDFyZW07XFxuICBsaW5lLWhlaWdodDogMS44NzVyZW07XFxuICB3aWR0aDogMS44NzVyZW07XFxuICBtYXJnaW46IDAuNXJlbSAwO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcblxcbiAgY29sb3I6IGhzbCggMjEwLCA1JSwgOTUlICk7XFxuICBAaW5jbHVkZSBjb2xvcml6ZS1lbCggJGFjdGlvbi1jb2xvciApO1xcbiAgYm94LXNoYWRvdzogMC4wNjI1cmVtIDAuMDYyNXJlbSAwLjI1cmVtIHJnYmEoIDAsIDAsIDAsIDAuMjUgKTtcXG59XFxuXFxuLmNvbXBvc2VyLW5vZGVfX2FjdGlvbi0tZGlzYWJsZWQge1xcbiAgb3BhY2l0eTogMC41O1xcbn1cXG5cXG4uY29tcG9zZXItbm9kZV9fYWN0aW9ucyA+IGxpOmxhc3QtY2hpbGQgLmNvbXBvc2VyLW5vZGVfX2FjdGlvbiB7XFxuICBtYXJnaW4tcmlnaHQ6IDAuNXJlbTtcXG59XFxuXFxuLmNvbXBvc2VyLW5vZGVfX2RlbGV0ZSB7XFxuICBjb2xvcjogaHNsKCAwLCA1JSwgOTUlICk7XFxuICBAaW5jbHVkZSBjb2xvcml6ZS1lbCggJGFjdGlvbi1kZWxldGUtY29sb3IgKTtcXG4gIGJveC1zaGFkb3c6IDAuMDYyNXJlbSAwLjA2MjVyZW0gMC4yNXJlbSByZ2JhKCAwLCAwLCAwLCAwLjI1ICk7XFxufVxcblwiLFwiZG9jdW1lbnRcIjpcIioge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbmh0bWwge1xcbiAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxufVxcblxcbi5ndS11bnNlbGVjdGFibGUge1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG59XFxuXFxuLmd1LW1pcnJvciB7XFxuICBwb3NpdGlvbjogZml4ZWQgIWltcG9ydGFudDtcXG4gIG1hcmdpbjogMCAhaW1wb3J0YW50O1xcbiAgei1pbmRleDogOTk5OSAhaW1wb3J0YW50O1xcbiAgb3BhY2l0eTogMC44O1xcbiAgLW1zLWZpbHRlcjogXFxcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYShPcGFjaXR5PTgwKVxcXCI7XFxuICBmaWx0ZXI6IGFscGhhKG9wYWNpdHk9ODApO1xcbn1cXG5cXG4uZ3UtaGlkZSB7XFxuICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxufVxcblxcbi5ndS11bnNlbGVjdGFibGUge1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZSAhaW1wb3J0YW50O1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZSAhaW1wb3J0YW50O1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lICFpbXBvcnRhbnQ7XFxuICB1c2VyLXNlbGVjdDogbm9uZSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uZ3UtdHJhbnNpdCB7XFxuICBvcGFjaXR5OiAwLjI7XFxuICAtbXMtZmlsdGVyOiBcXFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhKE9wYWNpdHk9MjApXFxcIjtcXG4gIGZpbHRlcjogYWxwaGEob3BhY2l0eT0yMCk7XFxufVxcblxcbi5yYXRpbyB7XFxuICB3aWR0aDogNHJlbTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuXFxuLnJhdGlvIC5zaGltIHtcXG4gIHBhZGRpbmctYm90dG9tOiAxMDAlO1xcbn1cXG5cXG4ucmF0aW8gLnZpZXdwb3J0IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDtcXG4gIGJvdHRvbTogMDtcXG59XFxuXFxuJGxpZ2h0ZW4taHVlOiA0MGRlZztcXG4kZGFya2VuLWh1ZTogMjEwZGVnO1xcblxcbiRhZGp1c3QtaHVlOiAyMCU7XFxuJGFkanVzdC1zYXR1cmF0aW9uOiA1JTtcXG4kYWRqdXN0LWxpZ2h0bmVzczogNSU7XFxuXFxuJGFkanVzdC1odWUtZ3JhZGllbnQtaGlnaGxpZ2h0OiAkYWRqdXN0LWh1ZSAvIDI7XFxuJGFkanVzdC1zYXR1cmF0aW9uLWdyYWRpZW50LWhpZ2hsaWdodDogJGFkanVzdC1zYXR1cmF0aW9uIC8gMjtcXG4kYWRqdXN0LWxpZ2h0bmVzcy1ncmFkaWVudC1oaWdobGlnaHQ6ICRhZGp1c3QtbGlnaHRuZXNzIC8gMjtcXG5cXG5AZnVuY3Rpb24gc2hpZnQtaHVlKCAkZnJvbS1odWUsICR0by1odWUsICRhbW91bnQgKXtcXG4gICRmcm9tLWNvbG9yOiBoc2woICRmcm9tLWh1ZSwgMTAwJSwgNTAlICk7XFxuICAkdG8tY29sb3I6IGhzbCggJHRvLWh1ZSwgMTAwJSwgNTAlICk7XFxuICAkbWl4ZWQ6IG1peCggJHRvLWNvbG9yLCAkZnJvbS1jb2xvciwgJGFtb3VudCApO1xcbiAgJG5ldy1odWU6IGh1ZSggJG1peGVkICk7XFxuXFxuICBAcmV0dXJuICRuZXctaHVlO1xcbn1cXG5cXG5AZnVuY3Rpb24gYWR2YW5jZWQtbGlnaHRlbiggJGZyb20tY29sb3IsICRodWUtYW1vdW50LCAkc2F0dXJhdGlvbi1hbW91bnQsICRsaWdodG5lc3MtYW1vdW50ICl7XFxuICAkaHVlOiBodWUoICRmcm9tLWNvbG9yICk7XFxuICAkbmV3LWh1ZTogc2hpZnQtaHVlKCAkaHVlLCAkbGlnaHRlbi1odWUsICRodWUtYW1vdW50ICk7XFxuXFxuICAkbGlnaHQtYW5kLXNhdHVyYXRpb246IGxpZ2h0ZW4oXFxuICAgIGRlc2F0dXJhdGUoXFxuICAgICAgJGZyb20tY29sb3IsXFxuICAgICAgJHNhdHVyYXRpb24tYW1vdW50XFxuICAgICksXFxuICAgICRsaWdodG5lc3MtYW1vdW50XFxuICApO1xcblxcbiAgQHJldHVybiBjaGFuZ2UtY29sb3IoICRsaWdodC1hbmQtc2F0dXJhdGlvbiwgJGh1ZTogJG5ldy1odWUgKTtcXG59XFxuXFxuQGZ1bmN0aW9uIGFkdmFuY2VkLWRhcmtlbiggJGZyb20tY29sb3IsICRodWUtYW1vdW50LCAkc2F0dXJhdGlvbi1hbW91bnQsICRsaWdodG5lc3MtYW1vdW50ICl7XFxuICAkaHVlOiBodWUoICRmcm9tLWNvbG9yICk7XFxuICAkbmV3LWh1ZTogc2hpZnQtaHVlKCAkaHVlLCAkZGFya2VuLWh1ZSwgJGh1ZS1hbW91bnQgKTtcXG5cXG4gICRsaWdodC1hbmQtc2F0dXJhdGlvbjogZGFya2VuKFxcbiAgICBzYXR1cmF0ZShcXG4gICAgICAkZnJvbS1jb2xvcixcXG4gICAgICAkc2F0dXJhdGlvbi1hbW91bnRcXG4gICAgKSxcXG4gICAgJGxpZ2h0bmVzcy1hbW91bnRcXG4gICk7XFxuXFxuICBAcmV0dXJuIGNoYW5nZS1jb2xvciggJGxpZ2h0LWFuZC1zYXR1cmF0aW9uLCAkaHVlOiAkbmV3LWh1ZSApO1xcbn1cXG5cXG5AbWl4aW4gY29sb3JpemUtZWwtYmFja2dyb3VuZCggJGJhc2UtY29sb3IgKXtcXG4gICRncmFkaWVudC1oaWdobGlnaHQ6IGFkdmFuY2VkLWxpZ2h0ZW4oXFxuICAgICRiYXNlLWNvbG9yLFxcbiAgICAkYWRqdXN0LWh1ZS1ncmFkaWVudC1oaWdobGlnaHQsXFxuICAgICRhZGp1c3QtbGlnaHRuZXNzLWdyYWRpZW50LWhpZ2hsaWdodCxcXG4gICAgJGFkanVzdC1zYXR1cmF0aW9uLWdyYWRpZW50LWhpZ2hsaWdodFxcbiAgKTtcXG4gICRncmFkaWVudC1iYXNlOiAkYmFzZS1jb2xvcjtcXG4gICRncmFkaWVudC1zaGFkb3c6IGFkdmFuY2VkLWRhcmtlbihcXG4gICAgJGJhc2UtY29sb3IsXFxuICAgICRhZGp1c3QtaHVlLFxcbiAgICAkYWRqdXN0LWxpZ2h0bmVzcyxcXG4gICAgJGFkanVzdC1zYXR1cmF0aW9uXFxuICApO1xcblxcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KFxcbiAgICB0byBib3R0b20sXFxuICAgICRncmFkaWVudC1oaWdobGlnaHQsXFxuICAgICRncmFkaWVudC1iYXNlLFxcbiAgICAkZ3JhZGllbnQtc2hhZG93XFxuICApO1xcbn1cXG5cXG5AbWl4aW4gY29sb3JpemUtZWwoICRiYXNlLWNvbG9yICl7XFxuICAkZ3JhZGllbnQtc2hhZG93OiBhZHZhbmNlZC1kYXJrZW4oXFxuICAgICRiYXNlLWNvbG9yLFxcbiAgICAkYWRqdXN0LWh1ZSxcXG4gICAgJGFkanVzdC1saWdodG5lc3MsXFxuICAgICRhZGp1c3Qtc2F0dXJhdGlvblxcbiAgKTtcXG5cXG4gICRib3JkZXItaGlnaGxpZ2h0OiBhZHZhbmNlZC1saWdodGVuKFxcbiAgICAkYmFzZS1jb2xvcixcXG4gICAgJGFkanVzdC1odWUsXFxuICAgICRhZGp1c3QtbGlnaHRuZXNzLFxcbiAgICAkYWRqdXN0LXNhdHVyYXRpb25cXG4gICk7XFxuICAkYm9yZGVyLXNoYWRvdzogYWR2YW5jZWQtZGFya2VuKFxcbiAgICAkZ3JhZGllbnQtc2hhZG93LFxcbiAgICAkYWRqdXN0LWh1ZSxcXG4gICAgJGFkanVzdC1saWdodG5lc3MsXFxuICAgICRhZGp1c3Qtc2F0dXJhdGlvblxcbiAgKTtcXG5cXG4gICR0ZXh0LXNoYWRvdzogYWR2YW5jZWQtZGFya2VuKFxcbiAgICAkYm9yZGVyLXNoYWRvdyxcXG4gICAgJGFkanVzdC1odWUsXFxuICAgICRhZGp1c3QtbGlnaHRuZXNzLFxcbiAgICAkYWRqdXN0LXNhdHVyYXRpb25cXG4gICk7XFxuXFxuICBAaW5jbHVkZSBjb2xvcml6ZS1lbC1iYWNrZ3JvdW5kKCAkYmFzZS1jb2xvciApO1xcbiAgYm9yZGVyOiAwLjA2MjVyZW0gc29saWQgJGJvcmRlci1oaWdobGlnaHQ7XFxuICBib3JkZXItYm90dG9tOiAwLjA2MjVyZW0gc29saWQgJGJvcmRlci1zaGFkb3c7XFxuICBib3JkZXItcmlnaHQ6IDAuMDYyNXJlbSBzb2xpZCAkYm9yZGVyLXNoYWRvdztcXG4gIHRleHQtc2hhZG93OiAwLjA2MjVyZW0gMC4wNjI1cmVtIDAgJHRleHQtc2hhZG93O1xcbn1cIn0sXCJ0ZW1wbGF0ZXNcIjp7XCJjb21wb3NlclwiOntcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImRvY3VtZW50RnJhZ21lbnRcIixcIl9pZFwiOlwiZG9jdW1lbnRmcmFnbWVudC0wNTYyNjU5YjNkYTZjNjBlM2U1ZjcwYmI2ZDdkODZhMlwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImRpdlwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJjb21wb3NlclwifSxcIl9pZFwiOlwiZWxlbWVudC04NDlkNWQ4MDFhOWIyYjM2YmFkZTU0MDIzN2VlYzc0NVwifSxcImNoaWxkcmVuXCI6W119XX0sXCJjb21wb3Nlci1ub2RlXCI6e1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZG9jdW1lbnRGcmFnbWVudFwiLFwiX2lkXCI6XCJkb2N1bWVudGZyYWdtZW50LTgzZTI1YWMyYWM0Y2E2OGFkMWQzMTA5ZmNiYTdkNTY0XCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZGl2XCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImNvbXBvc2VyLW5vZGVcIixcImRhdGEtdGFnXCI6XCJub2RlVGFnXCJ9LFwiX2lkXCI6XCJlbGVtZW50LWVmNDQ5Nzg1NjNmOWQ4MWE0MmMyMmNhZGUzOTI5NjQzXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gIFwiLFwiX2lkXCI6XCJ0ZXh0LThhMjc4ZWU5MmFmN2U2YTY4Mzc3OWYyYjdjNjNlODE5XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiaGVhZGVyXCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImNvbXBvc2VyLW5vZGVfX3Rvb2xiYXJcIn0sXCJfaWRcIjpcImVsZW1lbnQtY2JjNWQ4NTE2NWY2ODEzMTVlYWZiM2I3ZWRjYjY1MDJcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC0zMjNiNjVmZTBiOGFkMDZlNzUyM2RkYmQ2YjgwOGNjMlwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcInNwYW5cIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZV9fdGl0bGVcIixcImRhdGEtdGV4dFwiOlwidGl0bGVcIn0sXCJfaWRcIjpcImVsZW1lbnQtNDg1MGFlYTQ4Njk4YTQ0MTZiZmY2NTU0ZjUyY2E4MzNcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC0xYjFkYTYzZTk2OTJkZWJlMGZjNzkwYzYwYjNkYmRlNlwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcInVsXCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImNvbXBvc2VyLW5vZGVfX2FjdGlvbnNcIn0sXCJfaWRcIjpcImVsZW1lbnQtNWZkNTFjZTJkMGY4OTJjYmU2MjI5NTFhODY4NjY2NjBcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWUwZGE2YTQwYzBhYTNiZDQyZWM3NzZhYmMzMGMxNDQ1XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwibGlcIixcImF0dHJpYnV0ZXNcIjp7fSxcIl9pZFwiOlwiZWxlbWVudC04NjU1ZDRjYWEwOWM5ZThhMzZiOTc3N2NkOWI5YzExMlwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcInNwYW5cIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZV9fYWN0aW9uIGNvbXBvc2VyLW5vZGVfX2RlbGV0ZVwifSxcIl9pZFwiOlwiZWxlbWVudC1jM2E1YWIyMzdlYTlkNTI3MDAyM2RjNDZhZGJkMDYxMFwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImlcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiZmEgZmEtdHJhc2ggZmEtbGdcIn0sXCJfaWRcIjpcImVsZW1lbnQtNDJiZmY1M2IzYTg2NGNhODMxNmM3YTA2YTY3NTVhYTFcIn0sXCJjaGlsZHJlblwiOltdfV19XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtOTI4YTAzZjg3NmYyYjllMzExMWI0YTA2ZDg4NDI4MjBcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICBcIixcIl9pZFwiOlwidGV4dC1jYTgzZTQ3MzUzNjMwNGExMTRlYmI0NGQwNjBhMmJmZFwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG5cXHJcXG4gIFwiLFwiX2lkXCI6XCJ0ZXh0LTZiYTViMTUyNDZkNjlkNTY4MTdjMWU1MGU0Y2ZmZTRiXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZGl2XCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImNvbXBvc2VyLW5vZGVfX21haW5cIn0sXCJfaWRcIjpcImVsZW1lbnQtNzJlMjQyMTE3NTIyNDBiYWRjZGRmODAyYjM5MDdhMTVcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC05NzY0YjQxNDFkMzA5MjBjMjVkMGFjMDBiNjA2MWJlY1wifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImRpdlwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJjb21wb3Nlci1ub2RlX192aWV3XCJ9LFwiX2lkXCI6XCJlbGVtZW50LTc1MDc1ZmIwNzk3OWNkMzdlODAyNjgyYTg3ZjY1NTVmXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICBcIixcIl9pZFwiOlwidGV4dC1iMWI1M2I1ZmIwNjJjYWM3MmM0NWNlMjE1NzYzMTc4OVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImNvZGVcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLWh0bWxcIjpcInByZXZpZXdcIn0sXCJfaWRcIjpcImVsZW1lbnQtYTM5ODU1MWFhYzg5M2M5ZDEyZTQ0NGMwZjc3MzRjMTdcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC03NGJjZDkzODViMTM4NWE2NTIxYWEwMGY1NjI5NjU0NFwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG5cXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtNjQ0ZGNkMDc2ZmZkMzQ0NmJlNTM4MmIxYjU4MGMyNzdcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJmcmFnbWVudFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtbm90XCI6XCJpc0VtcHR5XCJ9LFwiX2lkXCI6XCJlbGVtZW50LWU2Y2ZkN2FlN2I3ODBiNjZlNDhjY2UyZWEyOGE2NzcxXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICBcIixcIl9pZFwiOlwidGV4dC1hODQyMzIxNGYwODFkMDA5Zjk1YTNmMGE1ZTAyNGI4MFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImRpdlwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJjb21wb3Nlci1ub2RlX19jaGlsZHJlblwiLFwiZGF0YS10YWdcIjpcImNoaWxkV3JhcHBlclRhZ1wifSxcIl9pZFwiOlwiZWxlbWVudC01NTUxNDgzMDNhMGU2MmM0NDg2NWFmZDhhZTRhNmEwNlwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgICBcIixcIl9pZFwiOlwidGV4dC0xYzc5MzdjNTM4Mzc2MjE3NmE3NTRlODc2YTMwMmMwZVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImhlYWRlclwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJjb21wb3Nlci1ub2RlX190b29sYmFyXCJ9LFwiX2lkXCI6XCJlbGVtZW50LWRiZWFkNmNhZjJiZmExYzA5YmM3YzgyODZhYTliYzBlXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICAgICAgXCIsXCJfaWRcIjpcInRleHQtNjczNmE5YWE3NmNiZjAwZmE2MWQ5NmM0ZmI2OWFmYzhcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJzcGFuXCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImNvbXBvc2VyLW5vZGVfX3RpdGxlXCIsXCJkYXRhLXRleHRcIjpcImNoaWxkcmVuVGl0bGVcIn0sXCJfaWRcIjpcImVsZW1lbnQtZWFkNzkxZTZiMjNjNDU3MjIwM2FkZDc3NDA2MzJhYzNcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICAgICAgICBcIixcIl9pZFwiOlwidGV4dC1kZWU4YTE3MWIwNGU0NzIxZDliZjc4MTA2ZDU4NDExZlwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcInVsXCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImNvbXBvc2VyLW5vZGVfX2FjdGlvbnNcIn0sXCJfaWRcIjpcImVsZW1lbnQtMDllYzk2ODJiMTQwMTIwNDBmZjg0YzQzOWE5N2M2MmFcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICAgICAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTE3ZGI3ZmFmNWMwMDMwZTAyMzVlOTk4NTdmMTkzNzE4XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwibGlcIixcImF0dHJpYnV0ZXNcIjp7fSxcIl9pZFwiOlwiZWxlbWVudC0zZmVjZDdhMjIyNmZhMTQ4NTk4Mzk2YTdhMjdlMmYyZFwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcInNwYW5cIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZV9fYWN0aW9uIGNvbXBvc2VyLW5vZGVfX2NvbGxhcHNlLWNoaWxkcmVuXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTc0YjcyMzQwYTI3YWRmYWZmMzNkMDYxZTdmZDBhYTEyXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiaVwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJmYSBmYS1taW51cy1zcXVhcmUgZmEtbGdcIn0sXCJfaWRcIjpcImVsZW1lbnQtMWQzNzA5OTg4NzY3MjUyZjE3NDNiM2FkZTRlYWVjZDNcIn0sXCJjaGlsZHJlblwiOltdfV19XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICAgICAgICBcIixcIl9pZFwiOlwidGV4dC03MzJkY2ViZjExNzBjODA2NmE3NDI0MzVmYjcxYTMxYlwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImxpXCIsXCJhdHRyaWJ1dGVzXCI6e30sXCJfaWRcIjpcImVsZW1lbnQtMGQ3YjVlMjM4Y2Y2ODUyZjNlYTgwNmJhMmRlZjM4MzZcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJzcGFuXCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImNvbXBvc2VyLW5vZGVfX2FjdGlvbiBjb21wb3Nlci1ub2RlX19leHBhbmQtY2hpbGRyZW5cIn0sXCJfaWRcIjpcImVsZW1lbnQtZGU4ZDZjMThjZjA2NTRkNDMxMmUyMTFlM2Y3ODJhM2RcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJpXCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImZhIGZhLXBsdXMtc3F1YXJlIGZhLWxnXCJ9LFwiX2lkXCI6XCJlbGVtZW50LWRhMTAwM2RlMTA1YTQ3Yzg4MGVlYjEyMDI3YTIzMzQzXCJ9LFwiY2hpbGRyZW5cIjpbXX1dfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTBhZDEyYTZmOWRjZTQ4OWE1NDE1OTVmZTUyYjQxNTI1XCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICAgICAgXCIsXCJfaWRcIjpcInRleHQtYTc2ZjcxMzZlMDIwOTFlODNjNTQyODAyMmEyZGRiZDZcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgICBcIixcIl9pZFwiOlwidGV4dC1hNTdhMDFiY2Q3M2Q0MWQ1MDE3YzZiODYwYWUyYjc1NFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcInVsXCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS1kcmFnc291cmNlXCI6XCJjb21wb3NlclwifSxcIl9pZFwiOlwiZWxlbWVudC1lNjQ0N2IwZDMyZTI0ZjQ2MzVlMGNkNzQ0MWJlMmIzYVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgXCIsXCJfaWRcIjpcInRleHQtNGJlZGQyZmZiNzA5OGEyZjEwNWUzOWU5M2RhMmJiYWFcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWJmODBmMDI0YTViMjVkNWY1N2UyN2YyZTkzOWE3MzYwXCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgXCIsXCJfaWRcIjpcInRleHQtYjU1MzVkNWQ1NmU5MTg0MTU3ZTlkMGJmNGFlZTZjMGNcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuXCIsXCJfaWRcIjpcInRleHQtZTA2MDNmOWUzZjkwMjFkNzE1YWNhMmUzNmNkYWQ1YmJcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuXCIsXCJfaWRcIjpcInRleHQtNDQ5M2ZkNDIwNzI2M2Y3NGIwNmFmYzZmYjIwY2M4MWNcIn0sXCJjaGlsZHJlblwiOltdfV19LFwiZG9jdW1lbnRcIjp7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJkb2N1bWVudEZyYWdtZW50XCIsXCJfaWRcIjpcImRvY3VtZW50ZnJhZ21lbnQtOWE1NjNmZDQyZDllOWM2ZWM0MGE3OTE3NzA5YThmZjRcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJkb2N1bWVudFR5cGVcIixcIl9pZFwiOlwiZG9jdW1lbnRUeXBlLWY1N2M2ZWYyYWIzMzk4ZTk2ZWY4YWMyZjdmNzU3YzZkXCIsXCJuYW1lXCI6XCJodG1sXCIsXCJwdWJsaWNJZFwiOlwiXCIsXCJzeXN0ZW1JZFwiOlwiXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG5cIixcIl9pZFwiOlwidGV4dC02YmU4YWU3ZWEyMzYwMWZmODk1MTg5MWMyMjY4NDQ4ZFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImh0bWxcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwibm8tanNcIixcImxhbmdcIjpcImVuXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTg3YzBmMTU4ZjJiODdmNmI4YjE1YTc5NzljMWMzOGRjXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gIFwiLFwiX2lkXCI6XCJ0ZXh0LWMzNzEwY2JjODk2MDRiOTllOTdiMTNlMmZhMjM0OGY1XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiaGVhZFwiLFwiYXR0cmlidXRlc1wiOnt9LFwiX2lkXCI6XCJlbGVtZW50LTVjYjE2OTI5ZGM5NDY1MTU1YzBiMDhhNDA5Yzg5OTZlXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtNTcxMjcxNGFmMTMxNmNlZTEzNDE4YmU1ZjBiN2FlMzVcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJtZXRhXCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2hhcnNldFwiOlwidXRmLThcIn0sXCJfaWRcIjpcImVsZW1lbnQtOWU1MzExZjNlOWUwNDg4MDcwNzIzOGE5MGRiY2ZkNDVcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC0yOTgzODM0MzdlNTdjNDkxMzk3OTAwYmVhODc2OWMzZVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcIm1ldGFcIixcImF0dHJpYnV0ZXNcIjp7XCJuYW1lXCI6XCJ2aWV3cG9ydFwiLFwiY29udGVudFwiOlwid2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMFwifSxcIl9pZFwiOlwiZWxlbWVudC00N2I0NWE3ZjQ2Zjg4NTYyZGQwNjYzMWUwN2FlMjYyMlwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWRlZGNhYWE5YjQ1OGQ0ODNjOWFhMjdiMjg1NWY1M2RhXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwidGl0bGVcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLXRleHRcIjpcImRvY3VtZW50VGl0bGVcIn0sXCJfaWRcIjpcImVsZW1lbnQtZjJlZTQzY2QxNjcxZjVhNWE4MWE5YjZmM2UyZDdjMzJcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC02MDUyNGU0ZjIzZjE5YzlkZmZmMTFkODE1ZGQwY2VhMVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImZyYWdtZW50XCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS1lYWNoXCI6XCJoZWFkU3R5bGVzXCJ9LFwiX2lkXCI6XCJlbGVtZW50LWE5MzE0OTliNDFmZTI1NDkzYzFmODJmOWUyOTY5ZTRhXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICBcIixcIl9pZFwiOlwidGV4dC0xNjJiY2IzNjVkMThmMmM0YWFlMjQ4MjNlOTcxMGQ1NlwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImZyYWdtZW50XCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS1pbmNsdWRlXCI6XCJzdHlsZVwifSxcIl9pZFwiOlwiZWxlbWVudC00ZDE0Yjg5ZGYyYTI5NTBiNTI1ZDcxY2QwNWM0NTlhOVwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWRlNmMxNmE1ODMzODFiNDUxMWIwZTE1YzQyMWMxYjY1XCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC1iMjNmZTBhZDRmNDE2YjhlYjI4YTRkNGFlNzM4MTc0M1wifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImZyYWdtZW50XCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS1lYWNoXCI6XCJoZWFkU2NyaXB0c1wifSxcIl9pZFwiOlwiZWxlbWVudC04YTY5Y2ZiMDM3YjAyZWNhNjE3MzAxYzY4ZmRhYTkyOVwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgXCIsXCJfaWRcIjpcInRleHQtMjFhZjk2NjgxODhlY2ExZjhkMjdjNTJhMzk3ODNiOTJcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJmcmFnbWVudFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtaW5jbHVkZVwiOlwic2NyaXB0XCJ9LFwiX2lkXCI6XCJlbGVtZW50LWU2NWNiNDE3YjIwYjI5MGZlM2QwOWU3MzJhZjBlZTYzXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtZWJkZDEwODA5ODk3YmU2MmIzY2I2ZTY4ZjMyNjJiNTJcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICBcIixcIl9pZFwiOlwidGV4dC03YTQwYTljNjJmOTBjMTkzYmFjMWFlOTk4MDY4MzE5NVwifSxcImNoaWxkcmVuXCI6W119XX1dfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICBcIixcIl9pZFwiOlwidGV4dC0zODhmNTg1Mzg2ZjJmYjlkYmEyNGRiZTFjN2Q1ODViYlwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImJvZHlcIixcImF0dHJpYnV0ZXNcIjp7fSxcIl9pZFwiOlwiZWxlbWVudC1iMThjNzFhOTVmNzZmZTQ1ZWQyZmM0MDdmOGY5MmU2NFwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTA5ZTE5ODUwNjZiMzI4NmM2Y2JiYzY1YWNlOGFhODIxXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZGl2XCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS1jb250YWluZXJcIjpcIlwiLFwiZGF0YS1odG1sXCI6XCJib2R5XCJ9LFwiX2lkXCI6XCJlbGVtZW50LWNmYTY3NGUxY2U4NmJkYzE2M2Q2NDMxNGY1YTQxMTRiXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtYWIxODMyODE2MmMyNmUyYzI2ZjE0MmM0ZWQ3ZGQwYzRcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJmcmFnbWVudFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtZWFjaFwiOlwic2NyaXB0c1wifSxcIl9pZFwiOlwiZWxlbWVudC05MjY0ODE5NWE5MDE0YTk4OTFiYmM1MWFmMWEwZTc2MFwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgXCIsXCJfaWRcIjpcInRleHQtZTk1NWU5YjMzYWE5NDM1MGE5Nzc2YjA1MWRiZTIyM2VcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJmcmFnbWVudFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtaW5jbHVkZVwiOlwic2NyaXB0XCJ9LFwiX2lkXCI6XCJlbGVtZW50LTE2MDMxMDI3NzljY2MyZTIxMGEzNWE1YzVhNzFlZWY0XCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtYzgyNDllNzQ5ZWE1ZjcyZGY4NzY2Zjc5MjRkYWQ3NTNcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICBcIixcIl9pZFwiOlwidGV4dC1kYThjYjgzNzlmOWFlODViYjU2ZTJmOGZjZDM3YTliZFwifSxcImNoaWxkcmVuXCI6W119XX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LTc1MDJiMTY1ZWE4MWZhYjExMDMzM2M5ZTMyOGU4MDM5XCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LWUwM2I4ZDllNmY3MTc4YzhlNGUwMTAyYzE5NjA1YTI5XCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSxcInNjcmlwdFwiOntcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImRvY3VtZW50RnJhZ21lbnRcIixcIl9pZFwiOlwiZG9jdW1lbnRmcmFnbWVudC00MjVhYmI2ZjU0ZTg0YzcyZjVkMTg3MzAwZDQyMDM3NFwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImZyYWdtZW50XCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS1pZlwiOlwidGV4dFwifSxcIl9pZFwiOlwiZWxlbWVudC1hMGI0NzEzNTM1MTQ1OWQxYzJkZTVkMzM0ZWI0MWMzYlwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICBcIixcIl9pZFwiOlwidGV4dC1hMmQyNmI3NTk0Mjc2NDUxZDNjYjA5ZjFmZDhkZjdkZFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcInNjcmlwdFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtaHRtbFwiOlwidGV4dFwifSxcIl9pZFwiOlwiZWxlbWVudC0yMmQyOTNiODllZTNlOGI0NGNhZDZhYjIyYWIzNDg0NlwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuXCIsXCJfaWRcIjpcInRleHQtMTQ0ZDRiYmI1YTZhMWM0YjVkY2RhMzg5YjlhOWZhOTVcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuXCIsXCJfaWRcIjpcInRleHQtMWIxNGUyZTU0YzhlYTUzN2QwNTE4MTI1OWM5ZWUxNWJcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJmcmFnbWVudFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtaWZcIjpcInNyY1wifSxcIl9pZFwiOlwiZWxlbWVudC0wNDYzZWI2MWFiNTlmM2EzYTczNDdhOGI1NzUyMTQ1NFwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICBcIixcIl9pZFwiOlwidGV4dC1iYmY5NDAyYjcyNGM5MjZmMDQ5Nzc2YTliMjg5ODc2MFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcInNjcmlwdFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtdGFnXCI6XCJzcmNcIn0sXCJfaWRcIjpcImVsZW1lbnQtZmViMGViMGMzMTYwOTgwNzFkOGQ3NzQ1N2EwMWZiMjVcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LTk3YmQwMGMzMjc5M2I3ZmM1ZDNhNjAzMDQxNTJiNTU3XCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LWFiZDRkYWYwNmJiNjQ5MTY2MDA4ODJlNjA3YzFlMzVlXCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSxcInN0eWxlXCI6e1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZG9jdW1lbnRGcmFnbWVudFwiLFwiX2lkXCI6XCJkb2N1bWVudGZyYWdtZW50LTBmYTAyZjdiZjM4N2NmN2RlOGJhNWMyYzAxNGE5ZGUzXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZnJhZ21lbnRcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLWlmXCI6XCJ0ZXh0XCJ9LFwiX2lkXCI6XCJlbGVtZW50LTJmOGRlN2JjYWFkMjUxZGE4MDBhMjBiNmEwNDYwMTc4XCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gIFwiLFwiX2lkXCI6XCJ0ZXh0LTNkZjk0MTQ5NzM4ZTdjM2EyM2Q2YmI0MDAzNjYwYzFjXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwic3R5bGVcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLWh0bWxcIjpcInRleHRcIn0sXCJfaWRcIjpcImVsZW1lbnQtMDRhYjkyMzIyYzlhMTM5YzRjZTY1OTJiMjFmYzM0ODRcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LTBmMjhhMWZiZGRmNTI3MjNhY2E4NzVjMDU0M2UyMWQ5XCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LTBkZjc1NDBiYTQzYzRkZmUwNTRkNjU0OWQzZTgyYjRiXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZnJhZ21lbnRcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLWlmXCI6XCJzcmNcIn0sXCJfaWRcIjpcImVsZW1lbnQtMDE1OGY4Yzk1NDQ4Y2UyZDc0MmZhMmYyNWU3NmM2OWJcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgXCIsXCJfaWRcIjpcInRleHQtMzg4NjUxMTM4YTVmOWQyOTUxMjIwMjA4ZjkyYmY4MjhcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJsaW5rXCIsXCJhdHRyaWJ1dGVzXCI6e1wicmVsXCI6XCJzdHlsZXNoZWV0XCIsXCJkYXRhLXRhZ1wiOlwic3JjXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTAwODAzOTQ0ZDAwYjM2NmQwOWE5ZDFmOGVhZmQzOGUyXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG5cIixcIl9pZFwiOlwidGV4dC0wZjEwMmZiZGFjM2VkOGI3ZWE4NGI5OThjODg5ZmJiYlwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG5cIixcIl9pZFwiOlwidGV4dC1jNDlmZWJiZTBiYmI2MjY0MzZkM2RhMWU0ODc2Zjg4Y1wifSxcImNoaWxkcmVuXCI6W119XX19LFwic2NoZW1hc1wiOntcImNvbXBvc2VyLW5vZGVcIjp7XCJpZFwiOlwiY29tcG9zZXItbm9kZVwiLFwidHlwZVwiOlwib2JqZWN0XCIsXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjp7XCIkcmVmXCI6XCJub25FbXB0eVN0cmluZ1wifSxcInRpdGxlXCI6e1wiJHJlZlwiOlwibm9uRW1wdHlTdHJpbmdcIn0sXCJ0cmVlVHlwZVwiOntcIiRyZWZcIjpcIm5vbkVtcHR5U3RyaW5nXCJ9LFwibm9kZVR5cGVcIjp7XCIkcmVmXCI6XCJub25FbXB0eVN0cmluZ1wifSxcImRlcHRoXCI6e1widHlwZVwiOlwiaW50ZWdlclwifSxcImlzRW1wdHlcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCJ9LFwiaXNDb2xsYXBzZWRcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCJ9LFwiaXNDaGlsZHJlbkNvbGxhcHNlZFwiOntcInR5cGVcIjpcImJvb2xlYW5cIn0sXCJwcmV2aWV3XCI6e1wiJHJlZlwiOlwibm9uRW1wdHlTdHJpbmdcIn0sXCJjaGlsZHJlblRpdGxlXCI6e1wiJHJlZlwiOlwibm9uRW1wdHlTdHJpbmdcIn19LFwicmVxdWlyZWRcIjpbXCJpZFwiLFwidGl0bGVcIixcInRyZWVUeXBlXCIsXCJub2RlVHlwZVwiLFwiZGVwdGhcIixcInByZXZpZXdcIixcImNoaWxkcmVuVGl0bGVcIl19LFwiZG9jdW1lbnRcIjp7XCJpZFwiOlwiZG9jdW1lbnRcIixcInR5cGVcIjpcIm9iamVjdFwiLFwicHJvcGVydGllc1wiOntcImRvY3VtZW50VGl0bGVcIjp7XCIkcmVmXCI6XCJub25FbXB0eVN0cmluZ1wifSxcImhlYWRTdHlsZXNcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwiaXRlbXNcIjp7XCIkcmVmXCI6XCJzdHlsZVwifX0sXCJoZWFkU2NyaXB0c1wiOntcInR5cGVcIjpcImFycmF5XCIsXCJpdGVtc1wiOntcIiRyZWZcIjpcInNjcmlwdFwifX0sXCJzY3JpcHRzXCI6e1widHlwZVwiOlwiYXJyYXlcIixcIml0ZW1zXCI6e1wiJHJlZlwiOlwic2NyaXB0XCJ9fX0sXCJyZXF1aXJlZFwiOltcImRvY3VtZW50VGl0bGVcIl19LFwic2NyaXB0XCI6e1wiaWRcIjpcInNjcmlwdFwiLFwiJHJlZlwiOlwiaHRtbFJlc291cmNlXCJ9LFwic3R5bGVcIjp7XCJpZFwiOlwic3R5bGVcIixcIiRyZWZcIjpcImh0bWxSZXNvdXJjZVwifSxcImNvbXBvbmVudENvbmZpZ1wiOntcImlkXCI6XCJjb21wb25lbnRDb25maWdcIixcInR5cGVcIjpcIm9iamVjdFwiLFwicHJvcGVydGllc1wiOntcImNvbnRhaW5lclNlbGVjdG9yXCI6e1wiJHJlZlwiOlwibm9uRW1wdHlTdHJpbmdcIn19fSxcImh0bWxSZXNvdXJjZVwiOntcImlkXCI6XCJodG1sUmVzb3VyY2VcIixcIm9uZU9mXCI6W3tcIiRyZWZcIjpcImh0bWxSZXNvdXJjZVRleHRcIn0se1wiJHJlZlwiOlwiaHRtbFJlc291cmNlU3JjXCJ9XX0sXCJodG1sUmVzb3VyY2VTcmNcIjp7XCJpZFwiOlwiaHRtbFJlc291cmNlU3JjXCIsXCJ0eXBlXCI6XCJvYmplY3RcIixcInByb3BlcnRpZXNcIjp7XCJzcmNcIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIn19LFwicmVxdWlyZWRcIjpbXCJzcmNcIl19LFwiaHRtbFJlc291cmNlVGV4dFwiOntcImlkXCI6XCJodG1sUmVzb3VyY2VUZXh0XCIsXCJ0eXBlXCI6XCJvYmplY3RcIixcInByb3BlcnRpZXNcIjp7XCJ0ZXh0XCI6e1widHlwZVwiOlwic3RyaW5nXCJ9fSxcInJlcXVpcmVkXCI6W1widGV4dFwiXX0sXCJub25FbXB0eVN0cmluZ1wiOntcImlkXCI6XCJub25FbXB0eVN0cmluZ1wiLFwidHlwZVwiOlwic3RyaW5nXCIsXCJwYXR0ZXJuXCI6XCJeKD8hXFxcXHMqJCkuK1wifX0sXCJkZWZhdWx0TW9kZWxzXCI6e1wiZG9jdW1lbnRcIjp7XCJkb2N1bWVudFRpdGxlXCI6XCJOZXcgRG9jdW1lbnRcIn19LFwiY29uZmlnc1wiOntcImNvbXBvc2VyXCI6e1wiY29udGFpbmVyU2VsZWN0b3JcIjpcIi5jb21wb3NlclwifSxcImNvbXBvc2VyLW5vZGVcIjp7XCJjb250YWluZXJTZWxlY3RvclwiOlwiLmNvbXBvc2VyLW5vZGVfX2NoaWxkcmVuID4gdWxcIn0sXCJkb2N1bWVudFwiOntcImNvbnRhaW5lclNlbGVjdG9yXCI6XCJib2R5ID4gW2RhdGEtY29udGFpbmVyXVwifX0sXCJ0cmFuc2Zvcm1zXCI6e1wiY29tcG9zZXItbm9kZVwiOntcIm5vZGVUYWdcIjpbe1wiJGlmXCI6W3tcIiR2YWx1ZVwiOlwiaXNDb2xsYXBzZWRcIn0se1wiYWRkQ2xhc3NcIjpcImNvbXBvc2VyLW5vZGUtLWNvbGxhcHNlZFwifV19LHtcIiRpZlwiOlt7XCIkdmFsdWVcIjpcImlzRW1wdHlcIn0se1wiYWRkQ2xhc3NcIjpcImNvbXBvc2VyLW5vZGUtLWVtcHR5XCJ9XX0se1wiYXR0clwiOltcImlkXCIse1wiJHZhbHVlXCI6XCJpZFwifV19LHtcImF0dHJcIjpbXCJkYXRhLXRyZWVUeXBlXCIse1wiJHZhbHVlXCI6XCJ0cmVlVHlwZVwifV19LHtcImF0dHJcIjpbXCJkYXRhLW5vZGVUeXBlXCIse1wiJHZhbHVlXCI6XCJub2RlVHlwZVwifV19LHtcImF0dHJcIjpbXCJkYXRhLWRlcHRoXCIse1wiJHZhbHVlXCI6XCJkZXB0aFwifV19XSxcImNoaWxkV3JhcHBlclRhZ1wiOlt7XCIkaWZcIjpbe1wiJHZhbHVlXCI6XCJpc0NoaWxkcmVuQ29sbGFwc2VkXCJ9LHtcImFkZENsYXNzXCI6XCJjb21wb3Nlci1ub2RlX19jaGlsZHJlbi0tY29sbGFwc2VkXCJ9XX0se1wiYXR0clwiOltcImlkXCIse1wiJHZhbHVlXCI6XCJpZFwifV19XX0sXCJzY3JpcHRcIjp7XCJzcmNcIjp7XCIkaWZcIjpbe1wiJHZhbHVlXCI6XCJzcmNcIn0se1wiYXR0clwiOltcInNyY1wiLHtcIiR2YWx1ZVwiOlwic3JjXCJ9XX1dfX0sXCJzdHlsZVwiOntcInNyY1wiOntcIiRpZlwiOlt7XCIkdmFsdWVcIjpcInNyY1wifSx7XCJhdHRyXCI6W1wiaHJlZlwiLHtcIiR2YWx1ZVwiOlwic3JjXCJ9XX1dfX19LFwiY29tcG9uZW50TmFtZXNcIjpbXCJjb21wb3NlclwiLFwiY29tcG9zZXItbm9kZVwiLFwiZG9jdW1lbnRcIixcInNjcmlwdFwiLFwic3R5bGVcIl0sXCJjb21wb25lbnRzXCI6e1wiY29tcG9zZXJcIjp7XCJjb25maWdcIjp7XCJjb250YWluZXJTZWxlY3RvclwiOlwiLmNvbXBvc2VyXCJ9LFwic3R5bGVcIjpcIi5jb21wb3NlciB7XFxuICBsaW5lLWhlaWdodDogMjtcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXG59XFxuXFxuJHRvb2xiYXItY29sb3I6IGhzbCggMjEwLCAxNSUsIDQwJSApO1xcbiR0b29sYmFyLWNoaWxkcmVuLWNvbG9yOiBoc2woIDIxMCwgODUlLCAzNyUgKTtcXG4kdG9vbGJhci1lbXB0eS1jb2xvcjogaHNsKCAyMTAsIDEwJSwgODglICk7XFxuJG1haW4tY29sb3I6IGhzbCggMjEwLCA1JSwgOTUlICk7XFxuJGNoaWxkcmVuLWNvbG9yOiBoc2woIDIxMCwgOTUlLCA5NSUgKTtcXG4kYWN0aW9uLWNvbG9yOiBoc2woMjEwLCA4NSUsIDYwJSApO1xcbiRhY3Rpb24tZGVsZXRlLWNvbG9yOiBoc2woIDAsIDgzJSwgNTAlICk7XFxuXFxuLmNvbXBvc2VyLW5vZGVfX3Rvb2xiYXIge1xcbiAgbWluLWhlaWdodDogM3JlbTtcXG5cXG4gIGNvbG9yOiBoc2woIDIxMCwgMTAlLCA5NSUgKTtcXG4gIEBpbmNsdWRlIGNvbG9yaXplLWVsKCAkdG9vbGJhci1jb2xvciApO1xcbiAgYm94LXNoYWRvdzogMC4xMjVyZW0gMC4xMjVyZW0gMC41cmVtIHJnYmEoIDAsIDAsIDAsIDAuMjUgKTtcXG59XFxuXFxuLmNvbXBvc2VyLW5vZGVfX3RpdGxlIHtcXG4gIGxpbmUtaGVpZ2h0OiAzO1xcbiAgcGFkZGluZzogMCAxcmVtO1xcbn1cXG5cXG4uY29tcG9zZXItbm9kZV9fY2hpbGRyZW4gPiAuY29tcG9zZXItbm9kZV9fdG9vbGJhciB7XFxuICBAaW5jbHVkZSBjb2xvcml6ZS1lbCggJHRvb2xiYXItY2hpbGRyZW4tY29sb3IgKTtcXG4gIGJveC1zaGFkb3c6IDAuMTI1cmVtIDAuMTI1cmVtIDAuNXJlbSByZ2JhKCAwLCAwLCAwLCAwLjI1ICk7XFxufVxcblxcbi5jb21wb3Nlci1ub2RlLS1lbXB0eSA+IC5jb21wb3Nlci1ub2RlX190b29sYmFyIHtcXG4gIGNvbG9yOiBoc2woIDIxMCwgODUlLCAxNSUgKTtcXG4gIEBpbmNsdWRlIGNvbG9yaXplLWVsKCAkdG9vbGJhci1lbXB0eS1jb2xvciApO1xcbiAgYm94LXNoYWRvdzogMC4xMjVyZW0gMC4xMjVyZW0gMC41cmVtIHJnYmEoIDAsIDAsIDAsIDAuMjUgKTtcXG59XFxuXFxuLmNvbXBvc2VyLW5vZGU6bm90KCBbZGF0YS1kZXB0aD1cXFwiMFxcXCJdICkgPiAuY29tcG9zZXItbm9kZV9fdG9vbGJhciB7XFxuICBjdXJzb3I6IG1vdmU7XFxufVxcblxcbi5jb21wb3Nlci1ub2RlX192aWV3IHtcXG4gIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBwYWRkaW5nOiAwLjVyZW07XFxuXFxuICBjb2xvcjogIzExMTtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBib3gtc2hhZG93OiBpbnNldCAwLjAzMTI1cmVtIDAuMDMxMjVyZW0gMC4xMjVyZW0gcmdiYSggMCwgMCwgMCwgMC4yNSApO1xcbn1cXG5cXG4uY29tcG9zZXItbm9kZV9fdmlldzpsYXN0LWNoaWxkIHtcXG4gIG1hcmdpbi1ib3R0b206IDA7XFxufVxcblxcbi5jb21wb3Nlci1ub2RlX19tYWluIHtcXG4gIHBhZGRpbmc6IDAuNzVyZW07XFxuICBtYXJnaW46IDAuMjVyZW07XFxuICBtYXJnaW4tdG9wOiAwO1xcblxcbiAgQGluY2x1ZGUgY29sb3JpemUtZWwtYmFja2dyb3VuZCggJG1haW4tY29sb3IgKTtcXG4gIGJveC1zaGFkb3c6IDAuMTI1cmVtIDAuMTI1cmVtIDAuNXJlbSByZ2JhKCAwLCAwLCAwLCAwLjI1ICk7XFxufVxcblxcbi5jb21wb3Nlci1ub2RlLS1jb2xsYXBzZWQgPiAuY29tcG9zZXItbm9kZV9fbWFpbixcXG4uY29tcG9zZXItbm9kZV9fY2hpbGRyZW4tLWNvbGxhcHNlZCA+IC5jb21wb3Nlci1ub2RlX19tYWluIHtcXG4gIGhlaWdodDogMDtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxuICBib3JkZXI6IDA7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG4uY29tcG9zZXItbm9kZV9fY2hpbGRyZW4ge1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG5cXG4gIEBpbmNsdWRlIGNvbG9yaXplLWVsLWJhY2tncm91bmQoICRjaGlsZHJlbi1jb2xvciApO1xcbiAgYm94LXNoYWRvdzogaW5zZXQgMC4xMjVyZW0gMC4xMjVyZW0gMC41cmVtIHJnYmEoIDAsIDAsIDAsIDAuMjUgKTtcXG59XFxuXFxuLmNvbXBvc2VyLW5vZGVfX2NoaWxkcmVuID4gdWwge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMC41cmVtO1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG59XFxuXFxuLmNvbXBvc2VyLW5vZGVfX2NoaWxkcmVuLS1jb2xsYXBzZWQgPiB1bCB7XFxuICBoZWlnaHQ6IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuLmNvbXBvc2VyLW5vZGVfX2NoaWxkcmVuID4gdWwgPiBsaSB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG4uY29tcG9zZXItbm9kZV9fYWN0aW9ucyB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiByaWdodDtcXG59XFxuXFxuLmNvbXBvc2VyLW5vZGVfX2FjdGlvbnMgPiBsaSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbn1cXG5cXG4uY29tcG9zZXItbm9kZV9fYWN0aW9uIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgcGFkZGluZzogMDtcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjg3NXJlbTtcXG4gIHdpZHRoOiAxLjg3NXJlbTtcXG4gIG1hcmdpbjogMC41cmVtIDA7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxuXFxuICBjb2xvcjogaHNsKCAyMTAsIDUlLCA5NSUgKTtcXG4gIEBpbmNsdWRlIGNvbG9yaXplLWVsKCAkYWN0aW9uLWNvbG9yICk7XFxuICBib3gtc2hhZG93OiAwLjA2MjVyZW0gMC4wNjI1cmVtIDAuMjVyZW0gcmdiYSggMCwgMCwgMCwgMC4yNSApO1xcbn1cXG5cXG4uY29tcG9zZXItbm9kZV9fYWN0aW9uLS1kaXNhYmxlZCB7XFxuICBvcGFjaXR5OiAwLjU7XFxufVxcblxcbi5jb21wb3Nlci1ub2RlX19hY3Rpb25zID4gbGk6bGFzdC1jaGlsZCAuY29tcG9zZXItbm9kZV9fYWN0aW9uIHtcXG4gIG1hcmdpbi1yaWdodDogMC41cmVtO1xcbn1cXG5cXG4uY29tcG9zZXItbm9kZV9fZGVsZXRlIHtcXG4gIGNvbG9yOiBoc2woIDAsIDUlLCA5NSUgKTtcXG4gIEBpbmNsdWRlIGNvbG9yaXplLWVsKCAkYWN0aW9uLWRlbGV0ZS1jb2xvciApO1xcbiAgYm94LXNoYWRvdzogMC4wNjI1cmVtIDAuMDYyNXJlbSAwLjI1cmVtIHJnYmEoIDAsIDAsIDAsIDAuMjUgKTtcXG59XFxuXCIsXCJ0ZW1wbGF0ZVwiOntcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImRvY3VtZW50RnJhZ21lbnRcIixcIl9pZFwiOlwiZG9jdW1lbnRmcmFnbWVudC0wNTYyNjU5YjNkYTZjNjBlM2U1ZjcwYmI2ZDdkODZhMlwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImRpdlwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJjb21wb3NlclwifSxcIl9pZFwiOlwiZWxlbWVudC04NDlkNWQ4MDFhOWIyYjM2YmFkZTU0MDIzN2VlYzc0NVwifSxcImNoaWxkcmVuXCI6W119XX19LFwiY29tcG9zZXItbm9kZVwiOntcImNvbmZpZ1wiOntcImNvbnRhaW5lclNlbGVjdG9yXCI6XCIuY29tcG9zZXItbm9kZV9fY2hpbGRyZW4gPiB1bFwifSxcInNjaGVtYVwiOntcImlkXCI6XCJjb21wb3Nlci1ub2RlXCIsXCJ0eXBlXCI6XCJvYmplY3RcIixcInByb3BlcnRpZXNcIjp7XCJpZFwiOntcIiRyZWZcIjpcIm5vbkVtcHR5U3RyaW5nXCJ9LFwidGl0bGVcIjp7XCIkcmVmXCI6XCJub25FbXB0eVN0cmluZ1wifSxcInRyZWVUeXBlXCI6e1wiJHJlZlwiOlwibm9uRW1wdHlTdHJpbmdcIn0sXCJub2RlVHlwZVwiOntcIiRyZWZcIjpcIm5vbkVtcHR5U3RyaW5nXCJ9LFwiZGVwdGhcIjp7XCJ0eXBlXCI6XCJpbnRlZ2VyXCJ9LFwiaXNFbXB0eVwiOntcInR5cGVcIjpcImJvb2xlYW5cIn0sXCJpc0NvbGxhcHNlZFwiOntcInR5cGVcIjpcImJvb2xlYW5cIn0sXCJpc0NoaWxkcmVuQ29sbGFwc2VkXCI6e1widHlwZVwiOlwiYm9vbGVhblwifSxcInByZXZpZXdcIjp7XCIkcmVmXCI6XCJub25FbXB0eVN0cmluZ1wifSxcImNoaWxkcmVuVGl0bGVcIjp7XCIkcmVmXCI6XCJub25FbXB0eVN0cmluZ1wifX0sXCJyZXF1aXJlZFwiOltcImlkXCIsXCJ0aXRsZVwiLFwidHJlZVR5cGVcIixcIm5vZGVUeXBlXCIsXCJkZXB0aFwiLFwicHJldmlld1wiLFwiY2hpbGRyZW5UaXRsZVwiXX0sXCJ0ZW1wbGF0ZVwiOntcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImRvY3VtZW50RnJhZ21lbnRcIixcIl9pZFwiOlwiZG9jdW1lbnRmcmFnbWVudC04M2UyNWFjMmFjNGNhNjhhZDFkMzEwOWZjYmE3ZDU2NFwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImRpdlwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJjb21wb3Nlci1ub2RlXCIsXCJkYXRhLXRhZ1wiOlwibm9kZVRhZ1wifSxcIl9pZFwiOlwiZWxlbWVudC1lZjQ0OTc4NTYzZjlkODFhNDJjMjJjYWRlMzkyOTY0M1wifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICBcIixcIl9pZFwiOlwidGV4dC04YTI3OGVlOTJhZjdlNmE2ODM3NzlmMmI3YzYzZTgxOVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImhlYWRlclwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJjb21wb3Nlci1ub2RlX190b29sYmFyXCJ9LFwiX2lkXCI6XCJlbGVtZW50LWNiYzVkODUxNjVmNjgxMzE1ZWFmYjNiN2VkY2I2NTAyXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtMzIzYjY1ZmUwYjhhZDA2ZTc1MjNkZGJkNmI4MDhjYzJcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJzcGFuXCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImNvbXBvc2VyLW5vZGVfX3RpdGxlXCIsXCJkYXRhLXRleHRcIjpcInRpdGxlXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTQ4NTBhZWE0ODY5OGE0NDE2YmZmNjU1NGY1MmNhODMzXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtMWIxZGE2M2U5NjkyZGViZTBmYzc5MGM2MGIzZGJkZTZcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJ1bFwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJjb21wb3Nlci1ub2RlX19hY3Rpb25zXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTVmZDUxY2UyZDBmODkyY2JlNjIyOTUxYTg2ODY2NjYwXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICBcIixcIl9pZFwiOlwidGV4dC1lMGRhNmE0MGMwYWEzYmQ0MmVjNzc2YWJjMzBjMTQ0NVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImxpXCIsXCJhdHRyaWJ1dGVzXCI6e30sXCJfaWRcIjpcImVsZW1lbnQtODY1NWQ0Y2FhMDljOWU4YTM2Yjk3NzdjZDliOWMxMTJcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJzcGFuXCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImNvbXBvc2VyLW5vZGVfX2FjdGlvbiBjb21wb3Nlci1ub2RlX19kZWxldGVcIn0sXCJfaWRcIjpcImVsZW1lbnQtYzNhNWFiMjM3ZWE5ZDUyNzAwMjNkYzQ2YWRiZDA2MTBcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJpXCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImZhIGZhLXRyYXNoIGZhLWxnXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTQyYmZmNTNiM2E4NjRjYTgzMTZjN2EwNmE2NzU1YWExXCJ9LFwiY2hpbGRyZW5cIjpbXX1dfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTkyOGEwM2Y4NzZmMmI5ZTMxMTFiNGEwNmQ4ODQyODIwXCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgXCIsXCJfaWRcIjpcInRleHQtY2E4M2U0NzM1MzYzMDRhMTE0ZWJiNDRkMDYwYTJiZmRcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuXFxyXFxuICBcIixcIl9pZFwiOlwidGV4dC02YmE1YjE1MjQ2ZDY5ZDU2ODE3YzFlNTBlNGNmZmU0YlwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImRpdlwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJjb21wb3Nlci1ub2RlX19tYWluXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTcyZTI0MjExNzUyMjQwYmFkY2RkZjgwMmIzOTA3YTE1XCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtOTc2NGI0MTQxZDMwOTIwYzI1ZDBhYzAwYjYwNjFiZWNcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJkaXZcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZV9fdmlld1wifSxcIl9pZFwiOlwiZWxlbWVudC03NTA3NWZiMDc5NzljZDM3ZTgwMjY4MmE4N2Y2NTU1ZlwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgXCIsXCJfaWRcIjpcInRleHQtYjFiNTNiNWZiMDYyY2FjNzJjNDVjZTIxNTc2MzE3ODlcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJjb2RlXCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS1odG1sXCI6XCJwcmV2aWV3XCJ9LFwiX2lkXCI6XCJlbGVtZW50LWEzOTg1NTFhYWM4OTNjOWQxMmU0NDRjMGY3NzM0YzE3XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtNzRiY2Q5Mzg1YjEzODVhNjUyMWFhMDBmNTYyOTY1NDRcIn0sXCJjaGlsZHJlblwiOltdfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTY0NGRjZDA3NmZmZDM0NDZiZTUzODJiMWI1ODBjMjc3XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZnJhZ21lbnRcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLW5vdFwiOlwiaXNFbXB0eVwifSxcIl9pZFwiOlwiZWxlbWVudC1lNmNmZDdhZTdiNzgwYjY2ZTQ4Y2NlMmVhMjhhNjc3MVwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgXCIsXCJfaWRcIjpcInRleHQtYTg0MjMyMTRmMDgxZDAwOWY5NWEzZjBhNWUwMjRiODBcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJkaXZcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZV9fY2hpbGRyZW5cIixcImRhdGEtdGFnXCI6XCJjaGlsZFdyYXBwZXJUYWdcIn0sXCJfaWRcIjpcImVsZW1lbnQtNTU1MTQ4MzAzYTBlNjJjNDQ4NjVhZmQ4YWU0YTZhMDZcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICAgICAgXCIsXCJfaWRcIjpcInRleHQtMWM3OTM3YzUzODM3NjIxNzZhNzU0ZTg3NmEzMDJjMGVcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJoZWFkZXJcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiY29tcG9zZXItbm9kZV9fdG9vbGJhclwifSxcIl9pZFwiOlwiZWxlbWVudC1kYmVhZDZjYWYyYmZhMWMwOWJjN2M4Mjg2YWE5YmMwZVwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTY3MzZhOWFhNzZjYmYwMGZhNjFkOTZjNGZiNjlhZmM4XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwic3BhblwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJjb21wb3Nlci1ub2RlX190aXRsZVwiLFwiZGF0YS10ZXh0XCI6XCJjaGlsZHJlblRpdGxlXCJ9LFwiX2lkXCI6XCJlbGVtZW50LWVhZDc5MWU2YjIzYzQ1NzIyMDNhZGQ3NzQwNjMyYWMzXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICAgICAgXCIsXCJfaWRcIjpcInRleHQtZGVlOGExNzFiMDRlNDcyMWQ5YmY3ODEwNmQ1ODQxMWZcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJ1bFwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJjb21wb3Nlci1ub2RlX19hY3Rpb25zXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTA5ZWM5NjgyYjE0MDEyMDQwZmY4NGM0MzlhOTdjNjJhXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICAgICAgICBcIixcIl9pZFwiOlwidGV4dC0xN2RiN2ZhZjVjMDAzMGUwMjM1ZTk5ODU3ZjE5MzcxOFwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImxpXCIsXCJhdHRyaWJ1dGVzXCI6e30sXCJfaWRcIjpcImVsZW1lbnQtM2ZlY2Q3YTIyMjZmYTE0ODU5ODM5NmE3YTI3ZTJmMmRcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJzcGFuXCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcImNvbXBvc2VyLW5vZGVfX2FjdGlvbiBjb21wb3Nlci1ub2RlX19jb2xsYXBzZS1jaGlsZHJlblwifSxcIl9pZFwiOlwiZWxlbWVudC03NGI3MjM0MGEyN2FkZmFmZjMzZDA2MWU3ZmQwYWExMlwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImlcIixcImF0dHJpYnV0ZXNcIjp7XCJjbGFzc1wiOlwiZmEgZmEtbWludXMtc3F1YXJlIGZhLWxnXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTFkMzcwOTk4ODc2NzI1MmYxNzQzYjNhZGU0ZWFlY2QzXCJ9LFwiY2hpbGRyZW5cIjpbXX1dfV19LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgICAgICAgXCIsXCJfaWRcIjpcInRleHQtNzMyZGNlYmYxMTcwYzgwNjZhNzQyNDM1ZmI3MWEzMWJcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJsaVwiLFwiYXR0cmlidXRlc1wiOnt9LFwiX2lkXCI6XCJlbGVtZW50LTBkN2I1ZTIzOGNmNjg1MmYzZWE4MDZiYTJkZWYzODM2XCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwic3BhblwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJjb21wb3Nlci1ub2RlX19hY3Rpb24gY29tcG9zZXItbm9kZV9fZXhwYW5kLWNoaWxkcmVuXCJ9LFwiX2lkXCI6XCJlbGVtZW50LWRlOGQ2YzE4Y2YwNjU0ZDQzMTJlMjExZTNmNzgyYTNkXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiaVwiLFwiYXR0cmlidXRlc1wiOntcImNsYXNzXCI6XCJmYSBmYS1wbHVzLXNxdWFyZSBmYS1sZ1wifSxcIl9pZFwiOlwiZWxlbWVudC1kYTEwMDNkZTEwNWE0N2M4ODBlZWIxMjAyN2EyMzM0M1wifSxcImNoaWxkcmVuXCI6W119XX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICAgICAgICBcIixcIl9pZFwiOlwidGV4dC0wYWQxMmE2ZjlkY2U0ODlhNTQxNTk1ZmU1MmI0MTUyNVwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWE3NmY3MTM2ZTAyMDkxZTgzYzU0MjgwMjJhMmRkYmQ2XCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICAgICAgXCIsXCJfaWRcIjpcInRleHQtYTU3YTAxYmNkNzNkNDFkNTAxN2M2Yjg2MGFlMmI3NTRcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJ1bFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtZHJhZ3NvdXJjZVwiOlwiY29tcG9zZXJcIn0sXCJfaWRcIjpcImVsZW1lbnQtZTY0NDdiMGQzMmUyNGY0NjM1ZTBjZDc0NDFiZTJiM2FcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTRiZWRkMmZmYjcwOThhMmYxMDVlMzllOTNkYTJiYmFhXCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC1iZjgwZjAyNGE1YjI1ZDVmNTdlMjdmMmU5MzlhNzM2MFwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gIFwiLFwiX2lkXCI6XCJ0ZXh0LWI1NTM1ZDVkNTZlOTE4NDE1N2U5ZDBiZjRhZWU2YzBjXCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LWUwNjAzZjllM2Y5MDIxZDcxNWFjYTJlMzZjZGFkNWJiXCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LTQ0OTNmZDQyMDcyNjNmNzRiMDZhZmM2ZmIyMGNjODFjXCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSxcInRyYW5zZm9ybVwiOntcIm5vZGVUYWdcIjpbe1wiJGlmXCI6W3tcIiR2YWx1ZVwiOlwiaXNDb2xsYXBzZWRcIn0se1wiYWRkQ2xhc3NcIjpcImNvbXBvc2VyLW5vZGUtLWNvbGxhcHNlZFwifV19LHtcIiRpZlwiOlt7XCIkdmFsdWVcIjpcImlzRW1wdHlcIn0se1wiYWRkQ2xhc3NcIjpcImNvbXBvc2VyLW5vZGUtLWVtcHR5XCJ9XX0se1wiYXR0clwiOltcImlkXCIse1wiJHZhbHVlXCI6XCJpZFwifV19LHtcImF0dHJcIjpbXCJkYXRhLXRyZWVUeXBlXCIse1wiJHZhbHVlXCI6XCJ0cmVlVHlwZVwifV19LHtcImF0dHJcIjpbXCJkYXRhLW5vZGVUeXBlXCIse1wiJHZhbHVlXCI6XCJub2RlVHlwZVwifV19LHtcImF0dHJcIjpbXCJkYXRhLWRlcHRoXCIse1wiJHZhbHVlXCI6XCJkZXB0aFwifV19XSxcImNoaWxkV3JhcHBlclRhZ1wiOlt7XCIkaWZcIjpbe1wiJHZhbHVlXCI6XCJpc0NoaWxkcmVuQ29sbGFwc2VkXCJ9LHtcImFkZENsYXNzXCI6XCJjb21wb3Nlci1ub2RlX19jaGlsZHJlbi0tY29sbGFwc2VkXCJ9XX0se1wiYXR0clwiOltcImlkXCIse1wiJHZhbHVlXCI6XCJpZFwifV19XX19LFwiZG9jdW1lbnRcIjp7XCJjb25maWdcIjp7XCJjb250YWluZXJTZWxlY3RvclwiOlwiYm9keSA+IFtkYXRhLWNvbnRhaW5lcl1cIn0sXCJkZWZhdWx0TW9kZWxcIjp7XCJkb2N1bWVudFRpdGxlXCI6XCJOZXcgRG9jdW1lbnRcIn0sXCJzY2hlbWFcIjp7XCJpZFwiOlwiZG9jdW1lbnRcIixcInR5cGVcIjpcIm9iamVjdFwiLFwicHJvcGVydGllc1wiOntcImRvY3VtZW50VGl0bGVcIjp7XCIkcmVmXCI6XCJub25FbXB0eVN0cmluZ1wifSxcImhlYWRTdHlsZXNcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwiaXRlbXNcIjp7XCIkcmVmXCI6XCJzdHlsZVwifX0sXCJoZWFkU2NyaXB0c1wiOntcInR5cGVcIjpcImFycmF5XCIsXCJpdGVtc1wiOntcIiRyZWZcIjpcInNjcmlwdFwifX0sXCJzY3JpcHRzXCI6e1widHlwZVwiOlwiYXJyYXlcIixcIml0ZW1zXCI6e1wiJHJlZlwiOlwic2NyaXB0XCJ9fX0sXCJyZXF1aXJlZFwiOltcImRvY3VtZW50VGl0bGVcIl19LFwic3R5bGVcIjpcIioge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbmh0bWwge1xcbiAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxufVxcblxcbi5ndS11bnNlbGVjdGFibGUge1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG59XFxuXFxuLmd1LW1pcnJvciB7XFxuICBwb3NpdGlvbjogZml4ZWQgIWltcG9ydGFudDtcXG4gIG1hcmdpbjogMCAhaW1wb3J0YW50O1xcbiAgei1pbmRleDogOTk5OSAhaW1wb3J0YW50O1xcbiAgb3BhY2l0eTogMC44O1xcbiAgLW1zLWZpbHRlcjogXFxcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYShPcGFjaXR5PTgwKVxcXCI7XFxuICBmaWx0ZXI6IGFscGhhKG9wYWNpdHk9ODApO1xcbn1cXG5cXG4uZ3UtaGlkZSB7XFxuICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxufVxcblxcbi5ndS11bnNlbGVjdGFibGUge1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZSAhaW1wb3J0YW50O1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZSAhaW1wb3J0YW50O1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lICFpbXBvcnRhbnQ7XFxuICB1c2VyLXNlbGVjdDogbm9uZSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uZ3UtdHJhbnNpdCB7XFxuICBvcGFjaXR5OiAwLjI7XFxuICAtbXMtZmlsdGVyOiBcXFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhKE9wYWNpdHk9MjApXFxcIjtcXG4gIGZpbHRlcjogYWxwaGEob3BhY2l0eT0yMCk7XFxufVxcblxcbi5yYXRpbyB7XFxuICB3aWR0aDogNHJlbTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuXFxuLnJhdGlvIC5zaGltIHtcXG4gIHBhZGRpbmctYm90dG9tOiAxMDAlO1xcbn1cXG5cXG4ucmF0aW8gLnZpZXdwb3J0IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDtcXG4gIGJvdHRvbTogMDtcXG59XFxuXFxuJGxpZ2h0ZW4taHVlOiA0MGRlZztcXG4kZGFya2VuLWh1ZTogMjEwZGVnO1xcblxcbiRhZGp1c3QtaHVlOiAyMCU7XFxuJGFkanVzdC1zYXR1cmF0aW9uOiA1JTtcXG4kYWRqdXN0LWxpZ2h0bmVzczogNSU7XFxuXFxuJGFkanVzdC1odWUtZ3JhZGllbnQtaGlnaGxpZ2h0OiAkYWRqdXN0LWh1ZSAvIDI7XFxuJGFkanVzdC1zYXR1cmF0aW9uLWdyYWRpZW50LWhpZ2hsaWdodDogJGFkanVzdC1zYXR1cmF0aW9uIC8gMjtcXG4kYWRqdXN0LWxpZ2h0bmVzcy1ncmFkaWVudC1oaWdobGlnaHQ6ICRhZGp1c3QtbGlnaHRuZXNzIC8gMjtcXG5cXG5AZnVuY3Rpb24gc2hpZnQtaHVlKCAkZnJvbS1odWUsICR0by1odWUsICRhbW91bnQgKXtcXG4gICRmcm9tLWNvbG9yOiBoc2woICRmcm9tLWh1ZSwgMTAwJSwgNTAlICk7XFxuICAkdG8tY29sb3I6IGhzbCggJHRvLWh1ZSwgMTAwJSwgNTAlICk7XFxuICAkbWl4ZWQ6IG1peCggJHRvLWNvbG9yLCAkZnJvbS1jb2xvciwgJGFtb3VudCApO1xcbiAgJG5ldy1odWU6IGh1ZSggJG1peGVkICk7XFxuXFxuICBAcmV0dXJuICRuZXctaHVlO1xcbn1cXG5cXG5AZnVuY3Rpb24gYWR2YW5jZWQtbGlnaHRlbiggJGZyb20tY29sb3IsICRodWUtYW1vdW50LCAkc2F0dXJhdGlvbi1hbW91bnQsICRsaWdodG5lc3MtYW1vdW50ICl7XFxuICAkaHVlOiBodWUoICRmcm9tLWNvbG9yICk7XFxuICAkbmV3LWh1ZTogc2hpZnQtaHVlKCAkaHVlLCAkbGlnaHRlbi1odWUsICRodWUtYW1vdW50ICk7XFxuXFxuICAkbGlnaHQtYW5kLXNhdHVyYXRpb246IGxpZ2h0ZW4oXFxuICAgIGRlc2F0dXJhdGUoXFxuICAgICAgJGZyb20tY29sb3IsXFxuICAgICAgJHNhdHVyYXRpb24tYW1vdW50XFxuICAgICksXFxuICAgICRsaWdodG5lc3MtYW1vdW50XFxuICApO1xcblxcbiAgQHJldHVybiBjaGFuZ2UtY29sb3IoICRsaWdodC1hbmQtc2F0dXJhdGlvbiwgJGh1ZTogJG5ldy1odWUgKTtcXG59XFxuXFxuQGZ1bmN0aW9uIGFkdmFuY2VkLWRhcmtlbiggJGZyb20tY29sb3IsICRodWUtYW1vdW50LCAkc2F0dXJhdGlvbi1hbW91bnQsICRsaWdodG5lc3MtYW1vdW50ICl7XFxuICAkaHVlOiBodWUoICRmcm9tLWNvbG9yICk7XFxuICAkbmV3LWh1ZTogc2hpZnQtaHVlKCAkaHVlLCAkZGFya2VuLWh1ZSwgJGh1ZS1hbW91bnQgKTtcXG5cXG4gICRsaWdodC1hbmQtc2F0dXJhdGlvbjogZGFya2VuKFxcbiAgICBzYXR1cmF0ZShcXG4gICAgICAkZnJvbS1jb2xvcixcXG4gICAgICAkc2F0dXJhdGlvbi1hbW91bnRcXG4gICAgKSxcXG4gICAgJGxpZ2h0bmVzcy1hbW91bnRcXG4gICk7XFxuXFxuICBAcmV0dXJuIGNoYW5nZS1jb2xvciggJGxpZ2h0LWFuZC1zYXR1cmF0aW9uLCAkaHVlOiAkbmV3LWh1ZSApO1xcbn1cXG5cXG5AbWl4aW4gY29sb3JpemUtZWwtYmFja2dyb3VuZCggJGJhc2UtY29sb3IgKXtcXG4gICRncmFkaWVudC1oaWdobGlnaHQ6IGFkdmFuY2VkLWxpZ2h0ZW4oXFxuICAgICRiYXNlLWNvbG9yLFxcbiAgICAkYWRqdXN0LWh1ZS1ncmFkaWVudC1oaWdobGlnaHQsXFxuICAgICRhZGp1c3QtbGlnaHRuZXNzLWdyYWRpZW50LWhpZ2hsaWdodCxcXG4gICAgJGFkanVzdC1zYXR1cmF0aW9uLWdyYWRpZW50LWhpZ2hsaWdodFxcbiAgKTtcXG4gICRncmFkaWVudC1iYXNlOiAkYmFzZS1jb2xvcjtcXG4gICRncmFkaWVudC1zaGFkb3c6IGFkdmFuY2VkLWRhcmtlbihcXG4gICAgJGJhc2UtY29sb3IsXFxuICAgICRhZGp1c3QtaHVlLFxcbiAgICAkYWRqdXN0LWxpZ2h0bmVzcyxcXG4gICAgJGFkanVzdC1zYXR1cmF0aW9uXFxuICApO1xcblxcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KFxcbiAgICB0byBib3R0b20sXFxuICAgICRncmFkaWVudC1oaWdobGlnaHQsXFxuICAgICRncmFkaWVudC1iYXNlLFxcbiAgICAkZ3JhZGllbnQtc2hhZG93XFxuICApO1xcbn1cXG5cXG5AbWl4aW4gY29sb3JpemUtZWwoICRiYXNlLWNvbG9yICl7XFxuICAkZ3JhZGllbnQtc2hhZG93OiBhZHZhbmNlZC1kYXJrZW4oXFxuICAgICRiYXNlLWNvbG9yLFxcbiAgICAkYWRqdXN0LWh1ZSxcXG4gICAgJGFkanVzdC1saWdodG5lc3MsXFxuICAgICRhZGp1c3Qtc2F0dXJhdGlvblxcbiAgKTtcXG5cXG4gICRib3JkZXItaGlnaGxpZ2h0OiBhZHZhbmNlZC1saWdodGVuKFxcbiAgICAkYmFzZS1jb2xvcixcXG4gICAgJGFkanVzdC1odWUsXFxuICAgICRhZGp1c3QtbGlnaHRuZXNzLFxcbiAgICAkYWRqdXN0LXNhdHVyYXRpb25cXG4gICk7XFxuICAkYm9yZGVyLXNoYWRvdzogYWR2YW5jZWQtZGFya2VuKFxcbiAgICAkZ3JhZGllbnQtc2hhZG93LFxcbiAgICAkYWRqdXN0LWh1ZSxcXG4gICAgJGFkanVzdC1saWdodG5lc3MsXFxuICAgICRhZGp1c3Qtc2F0dXJhdGlvblxcbiAgKTtcXG5cXG4gICR0ZXh0LXNoYWRvdzogYWR2YW5jZWQtZGFya2VuKFxcbiAgICAkYm9yZGVyLXNoYWRvdyxcXG4gICAgJGFkanVzdC1odWUsXFxuICAgICRhZGp1c3QtbGlnaHRuZXNzLFxcbiAgICAkYWRqdXN0LXNhdHVyYXRpb25cXG4gICk7XFxuXFxuICBAaW5jbHVkZSBjb2xvcml6ZS1lbC1iYWNrZ3JvdW5kKCAkYmFzZS1jb2xvciApO1xcbiAgYm9yZGVyOiAwLjA2MjVyZW0gc29saWQgJGJvcmRlci1oaWdobGlnaHQ7XFxuICBib3JkZXItYm90dG9tOiAwLjA2MjVyZW0gc29saWQgJGJvcmRlci1zaGFkb3c7XFxuICBib3JkZXItcmlnaHQ6IDAuMDYyNXJlbSBzb2xpZCAkYm9yZGVyLXNoYWRvdztcXG4gIHRleHQtc2hhZG93OiAwLjA2MjVyZW0gMC4wNjI1cmVtIDAgJHRleHQtc2hhZG93O1xcbn1cIixcInRlbXBsYXRlXCI6e1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZG9jdW1lbnRGcmFnbWVudFwiLFwiX2lkXCI6XCJkb2N1bWVudGZyYWdtZW50LTlhNTYzZmQ0MmQ5ZTljNmVjNDBhNzkxNzcwOWE4ZmY0XCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZG9jdW1lbnRUeXBlXCIsXCJfaWRcIjpcImRvY3VtZW50VHlwZS1mNTdjNmVmMmFiMzM5OGU5NmVmOGFjMmY3Zjc1N2M2ZFwiLFwibmFtZVwiOlwiaHRtbFwiLFwicHVibGljSWRcIjpcIlwiLFwic3lzdGVtSWRcIjpcIlwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuXCIsXCJfaWRcIjpcInRleHQtNmJlOGFlN2VhMjM2MDFmZjg5NTE4OTFjMjI2ODQ0OGRcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJodG1sXCIsXCJhdHRyaWJ1dGVzXCI6e1wiY2xhc3NcIjpcIm5vLWpzXCIsXCJsYW5nXCI6XCJlblwifSxcIl9pZFwiOlwiZWxlbWVudC04N2MwZjE1OGYyYjg3ZjZiOGIxNWE3OTc5YzFjMzhkY1wifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICBcIixcIl9pZFwiOlwidGV4dC1jMzcxMGNiYzg5NjA0Yjk5ZTk3YjEzZTJmYTIzNDhmNVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImhlYWRcIixcImF0dHJpYnV0ZXNcIjp7fSxcIl9pZFwiOlwiZWxlbWVudC01Y2IxNjkyOWRjOTQ2NTE1NWMwYjA4YTQwOWM4OTk2ZVwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTU3MTI3MTRhZjEzMTZjZWUxMzQxOGJlNWYwYjdhZTM1XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwibWV0YVwiLFwiYXR0cmlidXRlc1wiOntcImNoYXJzZXRcIjpcInV0Zi04XCJ9LFwiX2lkXCI6XCJlbGVtZW50LTllNTMxMWYzZTllMDQ4ODA3MDcyMzhhOTBkYmNmZDQ1XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtMjk4MzgzNDM3ZTU3YzQ5MTM5NzkwMGJlYTg3NjljM2VcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJtZXRhXCIsXCJhdHRyaWJ1dGVzXCI6e1wibmFtZVwiOlwidmlld3BvcnRcIixcImNvbnRlbnRcIjpcIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLjBcIn0sXCJfaWRcIjpcImVsZW1lbnQtNDdiNDVhN2Y0NmY4ODU2MmRkMDY2MzFlMDdhZTI2MjJcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC1kZWRjYWFhOWI0NThkNDgzYzlhYTI3YjI4NTVmNTNkYVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcInRpdGxlXCIsXCJhdHRyaWJ1dGVzXCI6e1wiZGF0YS10ZXh0XCI6XCJkb2N1bWVudFRpdGxlXCJ9LFwiX2lkXCI6XCJlbGVtZW50LWYyZWU0M2NkMTY3MWY1YTVhODFhOWI2ZjNlMmQ3YzMyXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtNjA1MjRlNGYyM2YxOWM5ZGZmZjExZDgxNWRkMGNlYTFcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJmcmFnbWVudFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtZWFjaFwiOlwiaGVhZFN0eWxlc1wifSxcIl9pZFwiOlwiZWxlbWVudC1hOTMxNDk5YjQxZmUyNTQ5M2MxZjgyZjllMjk2OWU0YVwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgICAgXCIsXCJfaWRcIjpcInRleHQtMTYyYmNiMzY1ZDE4ZjJjNGFhZTI0ODIzZTk3MTBkNTZcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJmcmFnbWVudFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtaW5jbHVkZVwiOlwic3R5bGVcIn0sXCJfaWRcIjpcImVsZW1lbnQtNGQxNGI4OWRmMmEyOTUwYjUyNWQ3MWNkMDVjNDU5YTlcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC1kZTZjMTZhNTgzMzgxYjQ1MTFiMGUxNWM0MjFjMWI2NVwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gICAgXCIsXCJfaWRcIjpcInRleHQtYjIzZmUwYWQ0ZjQxNmI4ZWIyOGE0ZDRhZTczODE3NDNcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJmcmFnbWVudFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtZWFjaFwiOlwiaGVhZFNjcmlwdHNcIn0sXCJfaWRcIjpcImVsZW1lbnQtOGE2OWNmYjAzN2IwMmVjYTYxNzMwMWM2OGZkYWE5MjlcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LTIxYWY5NjY4MTg4ZWNhMWY4ZDI3YzUyYTM5NzgzYjkyXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZnJhZ21lbnRcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLWluY2x1ZGVcIjpcInNjcmlwdFwifSxcIl9pZFwiOlwiZWxlbWVudC1lNjVjYjQxN2IyMGIyOTBmZTNkMDllNzMyYWYwZWU2M1wifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWViZGQxMDgwOTg5N2JlNjJiM2NiNmU2OGYzMjYyYjUyXCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgXCIsXCJfaWRcIjpcInRleHQtN2E0MGE5YzYyZjkwYzE5M2JhYzFhZTk5ODA2ODMxOTVcIn0sXCJjaGlsZHJlblwiOltdfV19XX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgXCIsXCJfaWRcIjpcInRleHQtMzg4ZjU4NTM4NmYyZmI5ZGJhMjRkYmUxYzdkNTg1YmJcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJib2R5XCIsXCJhdHRyaWJ1dGVzXCI6e30sXCJfaWRcIjpcImVsZW1lbnQtYjE4YzcxYTk1Zjc2ZmU0NWVkMmZjNDA3ZjhmOTJlNjRcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICBcIixcIl9pZFwiOlwidGV4dC0wOWUxOTg1MDY2YjMyODZjNmNiYmM2NWFjZThhYTgyMVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcImVsZW1lbnRcIixcInRhZ05hbWVcIjpcImRpdlwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtY29udGFpbmVyXCI6XCJcIixcImRhdGEtaHRtbFwiOlwiYm9keVwifSxcIl9pZFwiOlwiZWxlbWVudC1jZmE2NzRlMWNlODZiZGMxNjNkNjQzMTRmNWE0MTE0YlwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWFiMTgzMjgxNjJjMjZlMmMyNmYxNDJjNGVkN2RkMGM0XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZnJhZ21lbnRcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLWVhY2hcIjpcInNjcmlwdHNcIn0sXCJfaWRcIjpcImVsZW1lbnQtOTI2NDgxOTVhOTAxNGE5ODkxYmJjNTFhZjFhMGU3NjBcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWU5NTVlOWIzM2FhOTQzNTBhOTc3NmIwNTFkYmUyMjNlXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZnJhZ21lbnRcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLWluY2x1ZGVcIjpcInNjcmlwdFwifSxcIl9pZFwiOlwiZWxlbWVudC0xNjAzMTAyNzc5Y2NjMmUyMTBhMzVhNWM1YTcxZWVmNFwifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcIm5vZGVWYWx1ZVwiOlwiXFxyXFxuICAgIFwiLFwiX2lkXCI6XCJ0ZXh0LWM4MjQ5ZTc0OWVhNWY3MmRmODc2NmY3OTI0ZGFkNzUzXCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgXCIsXCJfaWRcIjpcInRleHQtZGE4Y2I4Mzc5ZjlhZTg1YmI1NmUyZjhmY2QzN2E5YmRcIn0sXCJjaGlsZHJlblwiOltdfV19XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG5cIixcIl9pZFwiOlwidGV4dC03NTAyYjE2NWVhODFmYWIxMTAzMzNjOWUzMjhlODAzOVwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG5cIixcIl9pZFwiOlwidGV4dC1lMDNiOGQ5ZTZmNzE3OGM4ZTRlMDEwMmMxOTYwNWEyOVwifSxcImNoaWxkcmVuXCI6W119XX19LFwic2NyaXB0XCI6e1wic2NoZW1hXCI6e1wiaWRcIjpcInNjcmlwdFwiLFwiJHJlZlwiOlwiaHRtbFJlc291cmNlXCJ9LFwidGVtcGxhdGVcIjp7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJkb2N1bWVudEZyYWdtZW50XCIsXCJfaWRcIjpcImRvY3VtZW50ZnJhZ21lbnQtNDI1YWJiNmY1NGU4NGM3MmY1ZDE4NzMwMGQ0MjAzNzRcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJmcmFnbWVudFwiLFwiYXR0cmlidXRlc1wiOntcImRhdGEtaWZcIjpcInRleHRcIn0sXCJfaWRcIjpcImVsZW1lbnQtYTBiNDcxMzUzNTE0NTlkMWMyZGU1ZDMzNGViNDFjM2JcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgXCIsXCJfaWRcIjpcInRleHQtYTJkMjZiNzU5NDI3NjQ1MWQzY2IwOWYxZmQ4ZGY3ZGRcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJzY3JpcHRcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLWh0bWxcIjpcInRleHRcIn0sXCJfaWRcIjpcImVsZW1lbnQtMjJkMjkzYjg5ZWUzZThiNDRjYWQ2YWIyMmFiMzQ4NDZcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LTE0NGQ0YmJiNWE2YTFjNGI1ZGNkYTM4OWI5YTlmYTk1XCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LTFiMTRlMmU1NGM4ZWE1MzdkMDUxODEyNTljOWVlMTViXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZnJhZ21lbnRcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLWlmXCI6XCJzcmNcIn0sXCJfaWRcIjpcImVsZW1lbnQtMDQ2M2ViNjFhYjU5ZjNhM2E3MzQ3YThiNTc1MjE0NTRcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgXCIsXCJfaWRcIjpcInRleHQtYmJmOTQwMmI3MjRjOTI2ZjA0OTc3NmE5YjI4OTg3NjBcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJzY3JpcHRcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLXRhZ1wiOlwic3JjXCJ9LFwiX2lkXCI6XCJlbGVtZW50LWZlYjBlYjBjMzE2MDk4MDcxZDhkNzc0NTdhMDFmYjI1XCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG5cIixcIl9pZFwiOlwidGV4dC05N2JkMDBjMzI3OTNiN2ZjNWQzYTYwMzA0MTUyYjU1N1wifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG5cIixcIl9pZFwiOlwidGV4dC1hYmQ0ZGFmMDZiYjY0OTE2NjAwODgyZTYwN2MxZTM1ZVwifSxcImNoaWxkcmVuXCI6W119XX0sXCJ0cmFuc2Zvcm1cIjp7XCJzcmNcIjp7XCIkaWZcIjpbe1wiJHZhbHVlXCI6XCJzcmNcIn0se1wiYXR0clwiOltcInNyY1wiLHtcIiR2YWx1ZVwiOlwic3JjXCJ9XX1dfX19LFwic3R5bGVcIjp7XCJzY2hlbWFcIjp7XCJpZFwiOlwic3R5bGVcIixcIiRyZWZcIjpcImh0bWxSZXNvdXJjZVwifSxcInRlbXBsYXRlXCI6e1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZG9jdW1lbnRGcmFnbWVudFwiLFwiX2lkXCI6XCJkb2N1bWVudGZyYWdtZW50LTBmYTAyZjdiZjM4N2NmN2RlOGJhNWMyYzAxNGE5ZGUzXCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZnJhZ21lbnRcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLWlmXCI6XCJ0ZXh0XCJ9LFwiX2lkXCI6XCJlbGVtZW50LTJmOGRlN2JjYWFkMjUxZGE4MDBhMjBiNmEwNDYwMTc4XCJ9LFwiY2hpbGRyZW5cIjpbe1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG4gIFwiLFwiX2lkXCI6XCJ0ZXh0LTNkZjk0MTQ5NzM4ZTdjM2EyM2Q2YmI0MDAzNjYwYzFjXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwic3R5bGVcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLWh0bWxcIjpcInRleHRcIn0sXCJfaWRcIjpcImVsZW1lbnQtMDRhYjkyMzIyYzlhMTM5YzRjZTY1OTJiMjFmYzM0ODRcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LTBmMjhhMWZiZGRmNTI3MjNhY2E4NzVjMDU0M2UyMWQ5XCJ9LFwiY2hpbGRyZW5cIjpbXX1dfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcblwiLFwiX2lkXCI6XCJ0ZXh0LTBkZjc1NDBiYTQzYzRkZmUwNTRkNjU0OWQzZTgyYjRiXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwiZWxlbWVudFwiLFwidGFnTmFtZVwiOlwiZnJhZ21lbnRcIixcImF0dHJpYnV0ZXNcIjp7XCJkYXRhLWlmXCI6XCJzcmNcIn0sXCJfaWRcIjpcImVsZW1lbnQtMDE1OGY4Yzk1NDQ4Y2UyZDc0MmZhMmYyNWU3NmM2OWJcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJ0ZXh0XCIsXCJub2RlVmFsdWVcIjpcIlxcclxcbiAgXCIsXCJfaWRcIjpcInRleHQtMzg4NjUxMTM4YTVmOWQyOTUxMjIwMjA4ZjkyYmY4MjhcIn0sXCJjaGlsZHJlblwiOltdfSx7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJlbGVtZW50XCIsXCJ0YWdOYW1lXCI6XCJsaW5rXCIsXCJhdHRyaWJ1dGVzXCI6e1wicmVsXCI6XCJzdHlsZXNoZWV0XCIsXCJkYXRhLXRhZ1wiOlwic3JjXCJ9LFwiX2lkXCI6XCJlbGVtZW50LTAwODAzOTQ0ZDAwYjM2NmQwOWE5ZDFmOGVhZmQzOGUyXCJ9LFwiY2hpbGRyZW5cIjpbXX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG5cIixcIl9pZFwiOlwidGV4dC0wZjEwMmZiZGFjM2VkOGI3ZWE4NGI5OThjODg5ZmJiYlwifSxcImNoaWxkcmVuXCI6W119XX0se1widmFsdWVcIjp7XCJub2RlVHlwZVwiOlwidGV4dFwiLFwibm9kZVZhbHVlXCI6XCJcXHJcXG5cIixcIl9pZFwiOlwidGV4dC1jNDlmZWJiZTBiYmI2MjY0MzZkM2RhMWU0ODc2Zjg4Y1wifSxcImNoaWxkcmVuXCI6W119XX0sXCJ0cmFuc2Zvcm1cIjp7XCJzcmNcIjp7XCIkaWZcIjpbe1wiJHZhbHVlXCI6XCJzcmNcIn0se1wiYXR0clwiOltcImhyZWZcIix7XCIkdmFsdWVcIjpcInNyY1wifV19XX19fX0sXCJkYXRhc1wiOntcImRhdGEtc21hbGxcIjp7XCJ2YWx1ZVwiOntcIm5vZGVUeXBlXCI6XCJmcmFnbWVudFwiLFwiX2lkXCI6XCJmcmFnbWVudC1lOGQwOTE1ZDZiMzYxY2RjNDVhZGU4MjQzYTkyNWZlM1wifSxcImNoaWxkcmVuXCI6W3tcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRhZ1wiLFwibmFtZVwiOlwic3Ryb25nXCIsXCJhdHRyXCI6e30sXCJfaWRcIjpcInRhZy05ZTE5YTRhNDljYjgyMGIzYzlkZTI2NTdkMTExMTA2ZVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRhZ1wiLFwibmFtZVwiOlwiaDJcIixcImF0dHJcIjp7XCJpZFwiOlwibXlIZWFkZXJcIixcImNsYXNzXCI6XCJwcmltYXJ5LWhlYWRlclwifSxcIl9pZFwiOlwiaDItZmMzYWQwMmU5NDNjYjg5NzllZDk1ZjAwODI1NGU3YzRcIn0sXCJjaGlsZHJlblwiOlt7XCJ2YWx1ZVwiOntcImRhdGFcIjpcIkhlbGxvIFwiLFwibm9kZVR5cGVcIjpcInRleHRcIixcIl9pZFwiOlwidGV4dC1lODQzMGU3Nzg1NzhkY2I4YTVjZWYxN2ZjZmRkOTY3NVwifSxcImNoaWxkcmVuXCI6W119LHtcInZhbHVlXCI6e1wibm9kZVR5cGVcIjpcInRleHRcIixcImRhdGFcIjpcIkNocmlzXCIsXCJfaWRcIjpcInRleHQtZGZkZWE3NzQyYTI0ZDdkY2NlY2UzZjBjNmNhOGVjODBcIn0sXCJjaGlsZHJlblwiOltdfV19XX19fSIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgVHJlZSA9IHJlcXVpcmUoJzF0cmVlJyk7XG52YXIgZGVmYXVsdEFkYXB0ZXIgPSByZXF1aXJlKCcxdHJlZS9kaXN0L2FkYXB0ZXIvZGVmYXVsdCcpO1xuXG52YXIgYmFzZVBsdWdpbnMgPSBPYmplY3Qua2V5cyhUcmVlLnBsdWdpbnMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBUcmVlLnBsdWdpbnNba2V5XTtcbn0pO1xuXG52YXIgTXRyZWUgPSBmdW5jdGlvbiBNdHJlZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGV4Y2x1ZGVCYXNlID0gYXJncy5zb21lKGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nICYmIGFyZztcbiAgfSk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBkZWZhdWx0QWRhcHRlcjtcbiAgdmFyIHBsdWdpbnMgPSBleGNsdWRlQmFzZSA/IFtdIDogYmFzZVBsdWdpbnM7XG5cbiAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICBwbHVnaW5zID0gYXJnLmNvbmNhdChwbHVnaW5zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbnMgPSBbYXJnXS5jb25jYXQocGx1Z2lucyk7XG4gICAgfSBlbHNlIGlmICgodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYXJnKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBhZGFwdGVyID0gYXJnO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFRyZWUuYWRhcHRlcihhZGFwdGVyLCBwbHVnaW5zKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTXRyZWU7IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSggJy4vZGlzdCcgKVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBUcmVlID0gcmVxdWlyZSgnMXRyZWUnKTtcbnZhciBUID0gcmVxdWlyZSgnbXR5cGUnKTtcbnZhciBwYXRocyA9IHJlcXVpcmUoJy4vcGF0aHMnKTtcblxudmFyIHBhdGhGcm9tTm9kZSA9IHBhdGhzLnBhdGhGcm9tTm9kZSxcbiAgICBub2RlRnJvbVBhdGggPSBwYXRocy5ub2RlRnJvbVBhdGg7XG5cblxudmFyIHQgPSBUKCk7XG5cbnZhciB2YWx1ZVR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcblxudmFyIGV4dGVuZFZhbHVlID0gZnVuY3Rpb24gZXh0ZW5kVmFsdWUobm9kZSwgdmFsdWUpIHtcbiAgcmV0dXJuIG5vZGUudmFsdWUoT2JqZWN0LmFzc2lnbih7fSwgbm9kZS52YWx1ZSgpLCB2YWx1ZSkpO1xufTtcblxudmFyIHRvTm9kZSA9IGZ1bmN0aW9uIHRvTm9kZShqc29uT2JqLCBwYXJlbnQpIHtcbiAgdmFyIGNyZWF0ZSA9IHBhcmVudCA/IHBhcmVudC5jcmVhdGVOb2RlIDogVHJlZS5jcmVhdGVSb290O1xuXG4gIHZhciBub2RlVHlwZSA9IHQub2YoanNvbk9iaik7XG4gIHZhciB2YWx1ZSA9IHsgbm9kZVR5cGU6IG5vZGVUeXBlIH07XG5cbiAgaWYgKHZhbHVlVHlwZXMuaW5jbHVkZXMobm9kZVR5cGUpKSB2YWx1ZS5ub2RlVmFsdWUgPSBqc29uT2JqO1xuXG4gIHZhciBub2RlID0gY3JlYXRlKHZhbHVlKTtcblxuICBpZiAobm9kZVR5cGUgPT09ICdhcnJheScpIHtcbiAgICBqc29uT2JqLmZvckVhY2goZnVuY3Rpb24gKGVsLCBpbmRleCkge1xuICAgICAgdmFyIGFycmF5SXRlbU5vZGUgPSB0b05vZGUoZWwsIG5vZGUpO1xuXG4gICAgICBleHRlbmRWYWx1ZShhcnJheUl0ZW1Ob2RlLCB7IGFycmF5SW5kZXg6IGluZGV4IH0pO1xuXG4gICAgICBub2RlLmFwcGVuZChhcnJheUl0ZW1Ob2RlKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChub2RlVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcHJvcGVydHlOYW1lcyA9IE9iamVjdC5rZXlzKGpzb25PYmopO1xuXG4gICAgcHJvcGVydHlOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgcHJvcGVydHlWYWx1ZSA9IGpzb25PYmpbbmFtZV07XG4gICAgICB2YXIgdmFsdWVOb2RlID0gdG9Ob2RlKHByb3BlcnR5VmFsdWUsIG5vZGUpO1xuXG4gICAgICBleHRlbmRWYWx1ZSh2YWx1ZU5vZGUsIHsgcHJvcGVydHlOYW1lOiBuYW1lIH0pO1xuXG4gICAgICBub2RlLmFwcGVuZCh2YWx1ZU5vZGUpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG52YXIgdG9UcmVlID0gZnVuY3Rpb24gdG9UcmVlKGpzb25PYmopIHtcbiAgcmV0dXJuIHRvTm9kZShqc29uT2JqLCBudWxsKTtcbn07XG5cbnZhciB0b0pzb24gPSBmdW5jdGlvbiB0b0pzb24odHJlZSkge1xuICB2YXIgdmFsdWUgPSB0cmVlLnZhbHVlKCk7XG4gIHZhciBub2RlVHlwZSA9IHZhbHVlLm5vZGVUeXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gJ251bGwnKSByZXR1cm4gbnVsbDtcblxuICBpZiAodmFsdWVUeXBlcy5pbmNsdWRlcyhub2RlVHlwZSkpIHJldHVybiB2YWx1ZS5ub2RlVmFsdWU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSAnYXJyYXknKSByZXR1cm4gdHJlZS5nZXRDaGlsZHJlbigpLm1hcCh0b0pzb24pO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgX3JldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvYmogPSB7fTtcblxuICAgICAgdHJlZS5nZXRDaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKG5hbWVWYWx1ZU5vZGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbmFtZVZhbHVlTm9kZS52YWx1ZSgpO1xuICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0gdmFsdWUucHJvcGVydHlOYW1lO1xuXG4gICAgICAgIHZhciBwcm9wZXJ0eVZhbHVlID0gdG9Kc29uKG5hbWVWYWx1ZU5vZGUpO1xuXG4gICAgICAgIG9ialtwcm9wZXJ0eU5hbWVdID0gcHJvcGVydHlWYWx1ZTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2OiBvYmpcbiAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgaWYgKCh0eXBlb2YgX3JldCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoX3JldCkpID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldC52O1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIG5vZGUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyB0b1RyZWU6IHRvVHJlZSwgdG9Kc29uOiB0b0pzb24sIHBhdGhGcm9tTm9kZTogcGF0aEZyb21Ob2RlLCBub2RlRnJvbVBhdGg6IG5vZGVGcm9tUGF0aCB9OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNsdWdGcm9tTm9kZSA9IGZ1bmN0aW9uIHNsdWdGcm9tTm9kZShub2RlKSB7XG4gIHZhciBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuXG4gIGlmICghcGFyZW50KSByZXR1cm4gJyQnO1xuXG4gIHZhciB2YWx1ZSA9IG5vZGUudmFsdWUoKTtcblxuICBpZiAodHlwZW9mIHZhbHVlLnByb3BlcnR5TmFtZSA9PT0gJ3N0cmluZycpIHJldHVybiB2YWx1ZS5wcm9wZXJ0eU5hbWU7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZS5hcnJheUluZGV4ID09PSAnbnVtYmVyJykgcmV0dXJuIHZhbHVlLmFycmF5SW5kZXggKyAnJztcbn07XG5cbnZhciBwYXRoRnJvbU5vZGUgPSBmdW5jdGlvbiBwYXRoRnJvbU5vZGUobm9kZSkge1xuICB2YXIgcGFyZW50V2l0aFNsdWcgPSBub2RlLmNsb3Nlc3QoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gISFzbHVnRnJvbU5vZGUobikgJiYgbi5nZXQoKSAhPT0gbm9kZS5nZXQoKTtcbiAgfSk7XG5cbiAgaWYgKCFwYXJlbnRXaXRoU2x1ZykgcmV0dXJuICckJztcblxuICB2YXIgcGFyZW50UGF0aCA9IHBhdGhGcm9tTm9kZShwYXJlbnRXaXRoU2x1Zyk7XG4gIHZhciBzbHVnID0gc2x1Z0Zyb21Ob2RlKG5vZGUpO1xuXG4gIGlmIChzbHVnKSByZXR1cm4gcGFyZW50UGF0aCArICcvJyArIHNsdWc7XG59O1xuXG52YXIgbm9kZUZyb21QYXRoID0gZnVuY3Rpb24gbm9kZUZyb21QYXRoKHRyZWUsIHBhdGgpIHtcbiAgcmV0dXJuIHRyZWUuZmluZChmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBwYXRoID09PSBwYXRoRnJvbU5vZGUobm9kZSk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IHBhdGhGcm9tTm9kZTogcGF0aEZyb21Ob2RlLCBub2RlRnJvbVBhdGg6IG5vZGVGcm9tUGF0aCB9OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvVHJlZSA9IHJlcXVpcmUoJy4vdG9UcmVlJyk7XG52YXIgdG9Kc29uID0gcmVxdWlyZSgnLi90b0pzb24nKTtcbnZhciBwYXRocyA9IHJlcXVpcmUoJy4vcGF0aHMnKTtcblxudmFyIHBhdGhGcm9tTm9kZSA9IHBhdGhzLnBhdGhGcm9tTm9kZSxcbiAgICBub2RlRnJvbVBhdGggPSBwYXRocy5ub2RlRnJvbVBhdGg7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7IHRvVHJlZTogdG9UcmVlLCB0b0pzb246IHRvSnNvbiwgcGF0aEZyb21Ob2RlOiBwYXRoRnJvbU5vZGUsIG5vZGVGcm9tUGF0aDogbm9kZUZyb21QYXRoIH07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2x1Z0Zyb21Ob2RlID0gZnVuY3Rpb24gc2x1Z0Zyb21Ob2RlKG5vZGUpIHtcbiAgdmFyIHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgaWYgKCFwYXJlbnQpIHJldHVybiAnJCc7XG5cbiAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZSgpO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUucHJvcGVydHlOYW1lID09PSAnc3RyaW5nJykgcmV0dXJuIHZhbHVlLnByb3BlcnR5TmFtZTtcblxuICBpZiAodHlwZW9mIHZhbHVlLmFycmF5SW5kZXggPT09ICdudW1iZXInKSByZXR1cm4gdmFsdWUuYXJyYXlJbmRleCArICcnO1xufTtcblxudmFyIHBhdGhGcm9tTm9kZSA9IGZ1bmN0aW9uIHBhdGhGcm9tTm9kZShub2RlKSB7XG4gIHZhciBwYXJlbnRXaXRoU2x1ZyA9IG5vZGUuY2xvc2VzdChmdW5jdGlvbiAobikge1xuICAgIHJldHVybiAhIXNsdWdGcm9tTm9kZShuKSAmJiBuLmdldCgpICE9PSBub2RlLmdldCgpO1xuICB9KTtcblxuICBpZiAoIXBhcmVudFdpdGhTbHVnKSByZXR1cm4gJyQnO1xuXG4gIHZhciBub2RlUGF0aCA9IHBhdGhGcm9tTm9kZShwYXJlbnRXaXRoU2x1Zyk7XG4gIHZhciBzbHVnID0gc2x1Z0Zyb21Ob2RlKG5vZGUpO1xuXG4gIGlmIChzbHVnKSBub2RlUGF0aCArPSAnLycgKyBzbHVnO1xuXG4gIHJldHVybiBub2RlUGF0aDtcbn07XG5cbi8vIHRoaXMgaXMgZWFzeSBidXQgaW5lZmZpY2VudCwgaXQncyB2ZXJ5IHNpbXBsZSB0byB1c2UgdGhlIHBhdGggc2VnbWVudHMgdG9cbi8vIHRyYXZlcnNlIHRoZSB0cmVlLCByZXBsYWNlIVxudmFyIG5vZGVGcm9tUGF0aCA9IGZ1bmN0aW9uIG5vZGVGcm9tUGF0aChzY2hlbWFUcmVlLCBwYXRoKSB7XG4gIHJldHVybiBzY2hlbWFUcmVlLmZpbmQoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gcGF0aCA9PT0gcGF0aEZyb21Ob2RlKG5vZGUpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyBwYXRoRnJvbU5vZGU6IHBhdGhGcm9tTm9kZSwgbm9kZUZyb21QYXRoOiBub2RlRnJvbVBhdGggfTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIHZhbHVlTWFwcGVyID0gZnVuY3Rpb24gdmFsdWVNYXBwZXIobm9kZSkge1xuICB2YXIgdmFsdWUgPSBub2RlLnZhbHVlKCk7XG5cbiAgdmFyIHNjaGVtYSA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlKTtcblxuICBpZiAodmFsdWUudHlwZSA9PT0gJ3VuaW9uJykge1xuICAgIHNjaGVtYS50eXBlID0gdmFsdWUudHlwZXNVbmlvbjtcblxuICAgIGRlbGV0ZSBzY2hlbWEudHlwZXNVbmlvbjtcbiAgfSBlbHNlIGlmICh2YWx1ZS50eXBlID09PSAnYW55Jykge1xuICAgIGRlbGV0ZSBzY2hlbWEudHlwZTtcbiAgfVxuXG4gIHJldHVybiBzY2hlbWE7XG59O1xuXG52YXIgZGVsZXRlRnJvbVZhbHVlID0gZnVuY3Rpb24gZGVsZXRlRnJvbVZhbHVlKG5vZGUsIHByb3BlcnR5TmFtZSkge1xuICB2YXIgdmFsdWUgPSBub2RlLnZhbHVlKCk7XG5cbiAgZGVsZXRlIHZhbHVlW3Byb3BlcnR5TmFtZV07XG5cbiAgbm9kZS52YWx1ZSh2YWx1ZSk7XG59O1xuXG52YXIgcHJvcGVydHlQb3B1bGF0b3JzID0ge1xuICBwcm9wZXJ0eU5hbWU6IGZ1bmN0aW9uIHByb3BlcnR5TmFtZShub2RlLCBzY2hlbWEpIHtcbiAgICBpZiAoX3R5cGVvZihzY2hlbWEucHJvcGVydGllcykgIT09ICdvYmplY3QnKSBzY2hlbWEucHJvcGVydGllcyA9IHt9O1xuXG4gICAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZSgpO1xuICAgIHZhciBwcm9wZXJ0eU5hbWUgPSB2YWx1ZS5wcm9wZXJ0eU5hbWU7XG5cblxuICAgIGRlbGV0ZUZyb21WYWx1ZShub2RlLCAncHJvcGVydHlOYW1lJyk7XG5cbiAgICBzY2hlbWEucHJvcGVydGllc1twcm9wZXJ0eU5hbWVdID0gdG9Kc29uKG5vZGUpO1xuICB9LFxuICBwcm9wZXJ0eVBhdHRlcm46IGZ1bmN0aW9uIHByb3BlcnR5UGF0dGVybihub2RlLCBzY2hlbWEpIHtcbiAgICBpZiAoX3R5cGVvZihzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpICE9PSAnb2JqZWN0Jykgc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzID0ge307XG5cbiAgICB2YXIgdmFsdWUgPSBub2RlLnZhbHVlKCk7XG4gICAgdmFyIHBhdHRlcm4gPSB2YWx1ZS5wcm9wZXJ0eVBhdHRlcm47XG5cbiAgICBkZWxldGVGcm9tVmFsdWUobm9kZSwgJ3Byb3BlcnR5UGF0dGVybicpO1xuXG4gICAgc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzW3BhdHRlcm5dID0gdG9Kc29uKG5vZGUpO1xuICB9LFxuICBhZGRpdGlvbmFsUHJvcGVydGllc1NjaGVtYTogZnVuY3Rpb24gYWRkaXRpb25hbFByb3BlcnRpZXNTY2hlbWEobm9kZSwgc2NoZW1hKSB7XG4gICAgZGVsZXRlRnJvbVZhbHVlKG5vZGUsICdhZGRpdGlvbmFsUHJvcGVydGllc1NjaGVtYScpO1xuXG4gICAgc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gdG9Kc29uKG5vZGUpO1xuICB9LFxuICBhcnJheUl0ZW06IGZ1bmN0aW9uIGFycmF5SXRlbShub2RlLCBzY2hlbWEpIHtcbiAgICBkZWxldGVGcm9tVmFsdWUobm9kZSwgJ2FycmF5SXRlbScpO1xuXG4gICAgc2NoZW1hLml0ZW1zID0gdG9Kc29uKG5vZGUpO1xuICB9LFxuICBhcnJheUluZGV4OiBmdW5jdGlvbiBhcnJheUluZGV4KG5vZGUsIHNjaGVtYSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpKSBzY2hlbWEuaXRlbXMgPSBbXTtcblxuICAgIHZhciB2YWx1ZSA9IG5vZGUudmFsdWUoKTtcbiAgICB2YXIgYXJyYXlJbmRleCA9IHZhbHVlLmFycmF5SW5kZXg7XG5cblxuICAgIGRlbGV0ZUZyb21WYWx1ZShub2RlLCAnYXJyYXlJbmRleCcpO1xuXG4gICAgc2NoZW1hLml0ZW1zW2FycmF5SW5kZXhdID0gdG9Kc29uKG5vZGUpO1xuICB9LFxuICBhbnlPZjogZnVuY3Rpb24gYW55T2Yobm9kZSwgc2NoZW1hKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYS5hbnlPZikpIHNjaGVtYS5hbnlPZiA9IFtdO1xuXG4gICAgZGVsZXRlRnJvbVZhbHVlKG5vZGUsICdhbnlPZicpO1xuXG4gICAgdmFyIGNoaWxkU2NoZW1hID0gdG9Kc29uKG5vZGUpO1xuXG4gICAgc2NoZW1hLmFueU9mLnB1c2goY2hpbGRTY2hlbWEpO1xuICB9LFxuICBhbGxPZjogZnVuY3Rpb24gYWxsT2Yobm9kZSwgc2NoZW1hKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYS5hbGxPZikpIHNjaGVtYS5hbGxPZiA9IFtdO1xuXG4gICAgZGVsZXRlRnJvbVZhbHVlKG5vZGUsICdhbGxPZicpO1xuXG4gICAgdmFyIGNoaWxkU2NoZW1hID0gdG9Kc29uKG5vZGUpO1xuXG4gICAgc2NoZW1hLmFsbE9mLnB1c2goY2hpbGRTY2hlbWEpO1xuICB9LFxuICBvbmVPZjogZnVuY3Rpb24gb25lT2Yobm9kZSwgc2NoZW1hKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYS5vbmVPZikpIHNjaGVtYS5vbmVPZiA9IFtdO1xuXG4gICAgZGVsZXRlRnJvbVZhbHVlKG5vZGUsICdvbmVPZicpO1xuXG4gICAgdmFyIGNoaWxkU2NoZW1hID0gdG9Kc29uKG5vZGUpO1xuXG4gICAgc2NoZW1hLm9uZU9mLnB1c2goY2hpbGRTY2hlbWEpO1xuICB9LFxuICBub3Q6IGZ1bmN0aW9uIG5vdChub2RlLCBzY2hlbWEpIHtcbiAgICBkZWxldGVGcm9tVmFsdWUobm9kZSwgJ25vdCcpO1xuXG4gICAgc2NoZW1hLm5vdCA9IHRvSnNvbihub2RlKTtcbiAgfVxufTtcblxudmFyIHBvcHVsYXRvclByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0eVBvcHVsYXRvcnMpO1xuXG52YXIgbmVzdGluZ01hcHBlciA9IGZ1bmN0aW9uIG5lc3RpbmdNYXBwZXIobm9kZSkge1xuICB2YXIgc2NoZW1hID0gdmFsdWVNYXBwZXIobm9kZSk7XG5cbiAgdmFyIGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuXG4gIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IGNoaWxkTm9kZS52YWx1ZSgpO1xuXG4gICAgdmFyIHBvcHVsYXRlRm9yID0gcG9wdWxhdG9yUHJvcGVydGllcy5maWx0ZXIoZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgICAgcmV0dXJuIHByb3BlcnR5TmFtZSBpbiB2YWx1ZTtcbiAgICB9KTtcblxuICAgIHBvcHVsYXRlRm9yLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgICAgdmFyIHBvcHVsYXRvciA9IHByb3BlcnR5UG9wdWxhdG9yc1twcm9wZXJ0eU5hbWVdO1xuXG4gICAgICBwb3B1bGF0b3IoY2hpbGROb2RlLCBzY2hlbWEpO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gc2NoZW1hO1xufTtcblxudmFyIHZhbHVlTWFwcGVycyA9IHtcbiAgb2JqZWN0OiBuZXN0aW5nTWFwcGVyLFxuICBhcnJheTogbmVzdGluZ01hcHBlcixcbiAgYW55OiBuZXN0aW5nTWFwcGVyLFxuICB1bmlvbjogbmVzdGluZ01hcHBlcixcbiAgc3RyaW5nOiB2YWx1ZU1hcHBlcixcbiAgbnVtYmVyOiB2YWx1ZU1hcHBlcixcbiAgYm9vbGVhbjogdmFsdWVNYXBwZXIsXG4gIGludGVnZXI6IHZhbHVlTWFwcGVyLFxuICBudWxsOiB2YWx1ZU1hcHBlclxufTtcblxudmFyIHRvSnNvbiA9IGZ1bmN0aW9uIHRvSnNvbihub2RlKSB7XG4gIG5vZGUgPSBub2RlLmNsb25lKCk7XG5cbiAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZSgpO1xuICB2YXIgc2NoZW1hVHlwZSA9IHZhbHVlLnR5cGU7XG4gIHZhciBtYXBwZXIgPSB2YWx1ZU1hcHBlcnNbc2NoZW1hVHlwZV07XG5cbiAgcmV0dXJuIG1hcHBlcihub2RlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Kc29uOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgVHJlZSA9IHJlcXVpcmUoJzF0cmVlJyk7XG5cbnZhciBjcmVhdGVzTmVzdGluZyA9IHtcbiAgb2JqZWN0OiBbJ3Byb3BlcnRpZXMnLCAnYWRkaXRpb25hbFByb3BlcnRpZXMnLCAnZGVmaW5pdGlvbnMnLCAncGF0dGVyblByb3BlcnRpZXMnLCAnZGVwZW5kZW5jaWVzJywgJ2FsbE9mJywgJ2FueU9mJywgJ29uZU9mJywgJ25vdCddLFxuICBhcnJheTogWydpdGVtcyddXG59O1xuXG5jcmVhdGVzTmVzdGluZy5hbnkgPSBjcmVhdGVzTmVzdGluZy5vYmplY3QuY29uY2F0KGNyZWF0ZXNOZXN0aW5nLmFycmF5KTtcbmNyZWF0ZXNOZXN0aW5nLnVuaW9uID0gY3JlYXRlc05lc3RpbmcuYW55O1xuXG52YXIgdmFsdWVNYXBwZXIgPSBmdW5jdGlvbiB2YWx1ZU1hcHBlcihzY2hlbWEpIHtcbiAgdmFyIHZhbHVlID0gT2JqZWN0LmFzc2lnbih7fSwgc2NoZW1hKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEudHlwZSkpIHtcbiAgICB2YWx1ZS50eXBlID0gJ3VuaW9uJztcbiAgICB2YWx1ZS50eXBlc1VuaW9uID0gc2NoZW1hLnR5cGUuc2xpY2UoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUudHlwZSA9ICdhbnknO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIG5lc3RpbmdNYXBwZXIgPSBmdW5jdGlvbiBuZXN0aW5nTWFwcGVyKHNjaGVtYSkge1xuICB2YXIgdmFsdWUgPSB2YWx1ZU1hcHBlcihzY2hlbWEpO1xuXG4gIHZhciBjcmVhdGVzTmVzdGluZ0RlZiA9IGNyZWF0ZXNOZXN0aW5nW3ZhbHVlLnR5cGVdO1xuXG4gIGNyZWF0ZXNOZXN0aW5nRGVmLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgIGRlbGV0ZSB2YWx1ZVtwcm9wZXJ0eU5hbWVdO1xuICB9KTtcblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgbm9kZVZhbHVlTWFwcGVycyA9IHtcbiAgc3RyaW5nOiB2YWx1ZU1hcHBlcixcbiAgbnVtYmVyOiB2YWx1ZU1hcHBlcixcbiAgaW50ZWdlcjogdmFsdWVNYXBwZXIsXG4gIGJvb2xlYW46IHZhbHVlTWFwcGVyLFxuICBudWxsOiB2YWx1ZU1hcHBlcixcbiAgb2JqZWN0OiBuZXN0aW5nTWFwcGVyLFxuICBhcnJheTogbmVzdGluZ01hcHBlcixcbiAgYW55OiBuZXN0aW5nTWFwcGVyXG59O1xuXG52YXIgZXh0ZW5kVmFsdWUgPSBmdW5jdGlvbiBleHRlbmRWYWx1ZShub2RlLCB2YWx1ZSkge1xuICByZXR1cm4gbm9kZS52YWx1ZShPYmplY3QuYXNzaWduKHt9LCBub2RlLnZhbHVlKCksIHZhbHVlKSk7XG59O1xuXG52YXIgY3JlYXRlUHJvcGVydHlOb2RlID0gZnVuY3Rpb24gY3JlYXRlUHJvcGVydHlOb2RlKHNjaGVtYSwgbm9kZSwgcHJvcGVydHlOYW1lKSB7XG4gIHZhciBwcm9wZXJ0eVNjaGVtYSA9IHNjaGVtYS5wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV07XG4gIHZhciBwcm9wZXJ0eU5vZGUgPSB0b05vZGUocHJvcGVydHlTY2hlbWEsIG5vZGUpO1xuXG4gIGV4dGVuZFZhbHVlKHByb3BlcnR5Tm9kZSwgeyBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSB9KTtcblxuICByZXR1cm4gcHJvcGVydHlOb2RlO1xufTtcblxudmFyIGNyZWF0ZUFkZGl0aW9uYWxQcm9wZXJ0aWVzTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZUFkZGl0aW9uYWxQcm9wZXJ0aWVzTm9kZShzY2hlbWEsIG5vZGUpIHtcbiAgdmFyIGFkZGl0aW9uYWxQcm9wZXJ0aWVzU2NoZW1hID0gc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xuICB2YXIgYWRkaXRpb25hbFByb3BlcnRpZXNOb2RlID0gdG9Ob2RlKGFkZGl0aW9uYWxQcm9wZXJ0aWVzU2NoZW1hLCBub2RlKTtcblxuICBleHRlbmRWYWx1ZShhZGRpdGlvbmFsUHJvcGVydGllc05vZGUsIHsgYWRkaXRpb25hbFByb3BlcnRpZXNTY2hlbWE6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGFkZGl0aW9uYWxQcm9wZXJ0aWVzTm9kZTtcbn07XG5cbnZhciBjcmVhdGVQYXR0ZXJuUHJvcGVydHlOb2RlID0gZnVuY3Rpb24gY3JlYXRlUGF0dGVyblByb3BlcnR5Tm9kZShzY2hlbWEsIG5vZGUsIHBhdHRlcm4pIHtcbiAgdmFyIHBhdHRlcm5Qcm9wZXJ0eVNjaGVtYSA9IHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllc1twYXR0ZXJuXTtcbiAgdmFyIHBhdHRlcm5Qcm9wZXJ0eU5vZGUgPSB0b05vZGUocGF0dGVyblByb3BlcnR5U2NoZW1hLCBub2RlKTtcblxuICBleHRlbmRWYWx1ZShwYXR0ZXJuUHJvcGVydHlOb2RlLCB7IHByb3BlcnR5UGF0dGVybjogcGF0dGVybiB9KTtcblxuICByZXR1cm4gcGF0dGVyblByb3BlcnR5Tm9kZTtcbn07XG5cbnZhciBjcmVhdGVDb21iaW5pbmdOb2RlID0gZnVuY3Rpb24gY3JlYXRlQ29tYmluaW5nTm9kZShjb21iaW5lU2NoZW1hLCBub2RlLCBjb21iaW5lTmFtZSkge1xuICB2YXIgY29tYmluZU5vZGUgPSB0b05vZGUoY29tYmluZVNjaGVtYSwgbm9kZSk7XG5cbiAgZXh0ZW5kVmFsdWUoY29tYmluZU5vZGUsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgY29tYmluZU5hbWUsIHRydWUpKTtcblxuICByZXR1cm4gY29tYmluZU5vZGU7XG59O1xuXG52YXIgY3JlYXRlSXRlbXNOb2RlID0gZnVuY3Rpb24gY3JlYXRlSXRlbXNOb2RlKHNjaGVtYSwgbm9kZSkge1xuICB2YXIgaXRlbXNTY2hlbWEgPSBzY2hlbWEuaXRlbXM7XG4gIHZhciBpdGVtc05vZGUgPSB0b05vZGUoaXRlbXNTY2hlbWEsIG5vZGUpO1xuXG4gIGV4dGVuZFZhbHVlKGl0ZW1zTm9kZSwgeyBhcnJheUl0ZW06IHRydWUgfSk7XG5cbiAgcmV0dXJuIGl0ZW1zTm9kZTtcbn07XG5cbnZhciBjcmVhdGVJdGVtVHVwbGVOb2RlID0gZnVuY3Rpb24gY3JlYXRlSXRlbVR1cGxlTm9kZSh0dXBsZVNjaGVtYSwgbm9kZSwgaW5kZXgpIHtcbiAgdmFyIGl0ZW1UdXBsZU5vZGUgPSB0b05vZGUodHVwbGVTY2hlbWEsIG5vZGUpO1xuXG4gIGV4dGVuZFZhbHVlKGl0ZW1UdXBsZU5vZGUsIHsgYXJyYXlJbmRleDogaW5kZXggfSk7XG5cbiAgcmV0dXJuIGl0ZW1UdXBsZU5vZGU7XG59O1xuXG52YXIgY29tYmluZUFycmF5VHlwZXMgPSBbJ2FueU9mJywgJ2FsbE9mJywgJ29uZU9mJ107XG5cbnZhciBjaGlsZHJlblBvcHVsYXRvcnMgPSB7XG4gIG9iamVjdDogZnVuY3Rpb24gb2JqZWN0KHNjaGVtYSwgbm9kZSkge1xuICAgIGlmIChzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgdmFyIHByb3BlcnR5TmFtZXMgPSBPYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcyk7XG5cbiAgICAgIHByb3BlcnR5TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eU5vZGUgPSBjcmVhdGVQcm9wZXJ0eU5vZGUoc2NoZW1hLCBub2RlLCBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICBub2RlLmFwcGVuZChwcm9wZXJ0eU5vZGUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09ICdib29sZWFuJykge1xuICAgICAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZSgpO1xuXG4gICAgICB2YWx1ZS5hZGRpdGlvbmFsUHJvcGVydGllcyA9IHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcztcblxuICAgICAgbm9kZS52YWx1ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcykgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkaXRpb25hbFByb3BlcnRpZXNOb2RlID0gY3JlYXRlQWRkaXRpb25hbFByb3BlcnRpZXNOb2RlKHNjaGVtYSwgbm9kZSk7XG5cbiAgICAgIG5vZGUuYXBwZW5kKGFkZGl0aW9uYWxQcm9wZXJ0aWVzTm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKHNjaGVtYS5kZWZpbml0aW9ucykgdGhyb3cgbmV3IEVycm9yKCdkZWZpbml0aW9ucyBub3Qgc3VwcG9ydGVkJyk7XG5cbiAgICBpZiAoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgcGF0dGVybnMgPSBPYmplY3Qua2V5cyhzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpO1xuXG4gICAgICBwYXR0ZXJucy5mb3JFYWNoKGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuUHJvcGVydHlOb2RlID0gY3JlYXRlUGF0dGVyblByb3BlcnR5Tm9kZShzY2hlbWEsIG5vZGUsIHBhdHRlcm4pO1xuICAgICAgICBub2RlLmFwcGVuZChwYXR0ZXJuUHJvcGVydHlOb2RlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChzY2hlbWEuZGVwZW5kZW5jaWVzKSB0aHJvdyBuZXcgRXJyb3IoJ2RlcGVuZGVuY2llcyBub3Qgc3VwcG9ydGVkJyk7XG5cbiAgICBjb21iaW5lQXJyYXlUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21iaW5lTmFtZSkge1xuICAgICAgaWYgKHNjaGVtYVtjb21iaW5lTmFtZV0pIHtcbiAgICAgICAgdmFyIGNvbWJpbmVEZWYgPSBzY2hlbWFbY29tYmluZU5hbWVdO1xuXG4gICAgICAgIGNvbWJpbmVEZWYuZm9yRWFjaChmdW5jdGlvbiAoY29tYmluZVNjaGVtYSkge1xuICAgICAgICAgIHZhciBjb21iaW5lTm9kZSA9IGNyZWF0ZUNvbWJpbmluZ05vZGUoY29tYmluZVNjaGVtYSwgbm9kZSwgY29tYmluZU5hbWUpO1xuXG4gICAgICAgICAgbm9kZS5hcHBlbmQoY29tYmluZU5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChzY2hlbWEubm90KSB7XG4gICAgICB2YXIgY29tYmluZVNjaGVtYSA9IHNjaGVtYS5ub3Q7XG4gICAgICB2YXIgY29tYmluZU5vZGUgPSBjcmVhdGVDb21iaW5pbmdOb2RlKGNvbWJpbmVTY2hlbWEsIG5vZGUsICdub3QnKTtcblxuICAgICAgbm9kZS5hcHBlbmQoY29tYmluZU5vZGUpO1xuICAgIH1cbiAgfSxcbiAgYXJyYXk6IGZ1bmN0aW9uIGFycmF5KHNjaGVtYSwgbm9kZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykpIHtcbiAgICAgIHNjaGVtYS5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uICh0dXBsZVNjaGVtYSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGl0ZW1UdXBsZU5vZGUgPSBjcmVhdGVJdGVtVHVwbGVOb2RlKHR1cGxlU2NoZW1hLCBub2RlLCBpbmRleCk7XG5cbiAgICAgICAgbm9kZS5hcHBlbmQoaXRlbVR1cGxlTm9kZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKF90eXBlb2Yoc2NoZW1hLml0ZW1zKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBpdGVtc05vZGUgPSBjcmVhdGVJdGVtc05vZGUoc2NoZW1hLCBub2RlKTtcblxuICAgICAgbm9kZS5hcHBlbmQoaXRlbXNOb2RlKTtcbiAgICB9XG4gIH0sXG4gIGFueTogZnVuY3Rpb24gYW55KHNjaGVtYSwgbm9kZSkge1xuICAgIGNoaWxkcmVuUG9wdWxhdG9ycy5vYmplY3Qoc2NoZW1hLCBub2RlKTtcbiAgICBjaGlsZHJlblBvcHVsYXRvcnMuYXJyYXkoc2NoZW1hLCBub2RlKTtcbiAgfVxufTtcblxudmFyIGNvbnRhaW5lck5vZGVUeXBlcyA9IE9iamVjdC5rZXlzKGNoaWxkcmVuUG9wdWxhdG9ycyk7XG5cbnZhciB0b05vZGUgPSBmdW5jdGlvbiB0b05vZGUoc2NoZW1hLCBwYXJlbnQpIHtcbiAgdmFyIGNyZWF0ZSA9IHBhcmVudCA/IHBhcmVudC5jcmVhdGVOb2RlIDogVHJlZS5jcmVhdGVSb290O1xuXG4gIHZhciBzY2hlbWFUeXBlID0gdHlwZW9mIHNjaGVtYS50eXBlID09PSAnc3RyaW5nJyA/IHNjaGVtYS50eXBlIDogJ2FueSc7XG4gIHZhciB2YWx1ZU1hcHBlciA9IG5vZGVWYWx1ZU1hcHBlcnNbc2NoZW1hVHlwZV07XG4gIHZhciB2YWx1ZSA9IHZhbHVlTWFwcGVyKHNjaGVtYSk7XG4gIHZhciBub2RlID0gY3JlYXRlKHZhbHVlKTtcblxuICBpZiAoY29udGFpbmVyTm9kZVR5cGVzLmluY2x1ZGVzKHNjaGVtYVR5cGUpKSB7XG4gICAgdmFyIGNoaWxkcmVuUG9wdWxhdG9yID0gY2hpbGRyZW5Qb3B1bGF0b3JzW3NjaGVtYVR5cGVdO1xuXG4gICAgY2hpbGRyZW5Qb3B1bGF0b3Ioc2NoZW1hLCBub2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufTtcblxudmFyIHRvVHJlZSA9IGZ1bmN0aW9uIHRvVHJlZShzY2hlbWEpIHtcbiAgcmV0dXJuIHRvTm9kZShzY2hlbWEsIG51bGwpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB0b1RyZWU7IiwiJ3VzZSBzdHJpY3QnXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoICcuL2Rpc3QnIClcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlTm9kZTogZnVuY3Rpb24gY3JlYXRlTm9kZSh2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xuICB9LFxuICBhcmdUeXBlczogWydub2RlVmFsdWUnXSxcbiAgcmV0dXJuVHlwZTogJ25vZGUnLFxuICBjYXRlZ29yaWVzOiBbJ21hbmlwdWxhdGlvbicsICdhZGFwdGVyJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q2hpbGRyZW46IGZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5jaGlsZHJlbjtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnW25vZGVdJyxcbiAgY2F0ZWdvcmllczogWyd0cmF2ZXJzYWwnLCAnYWRhcHRlciddXG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZU5vZGUgPSByZXF1aXJlKCcuL2NyZWF0ZU5vZGUnKTtcbnZhciBnZXRDaGlsZHJlbiA9IHJlcXVpcmUoJy4vZ2V0Q2hpbGRyZW4nKTtcbnZhciBpbnNlcnRCZWZvcmUgPSByZXF1aXJlKCcuL2luc2VydEJlZm9yZScpO1xudmFyIHJlbW92ZSA9IHJlcXVpcmUoJy4vcmVtb3ZlJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuL3ZhbHVlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0geyBjcmVhdGVOb2RlOiBjcmVhdGVOb2RlLCBnZXRDaGlsZHJlbjogZ2V0Q2hpbGRyZW4sIGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLCByZW1vdmU6IHJlbW92ZSwgdmFsdWU6IHZhbHVlIH07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiBpbnNlcnRCZWZvcmUoZm4sIHJvb3QsIHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAgIGlmIChyb290KSBmbi5yZW1vdmUoZm4sIHJvb3QsIGNoaWxkTm9kZSk7XG5cbiAgICBpZiAocmVmZXJlbmNlTm9kZSkge1xuICAgICAgdmFyIHJlZmVyZW5jZUluZGV4ID0gcGFyZW50Tm9kZS5jaGlsZHJlbi5pbmRleE9mKHJlZmVyZW5jZU5vZGUpO1xuXG4gICAgICBwYXJlbnROb2RlLmNoaWxkcmVuLnNwbGljZShyZWZlcmVuY2VJbmRleCwgMCwgY2hpbGROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlbi5wdXNoKGNoaWxkTm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkTm9kZTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAncm9vdE5vZGUnLCAnbm9kZScsICdub2RlJywgJ25vZGUnXSxcbiAgcmV0dXJuVHlwZTogJ25vZGUnLFxuICByZXF1aXJlczogWydyZW1vdmUnXSxcbiAgY2F0ZWdvcmllczogWydtYW5pcHVsYXRpb24nLCAnYWRhcHRlciddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGZuLCByb290LCBub2RlKSB7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBmbi5nZXRQYXJlbnQoZm4sIHJvb3QsIG5vZGUpO1xuXG4gICAgaWYgKCFwYXJlbnROb2RlKSByZXR1cm47XG5cbiAgICB2YXIgaW5kZXggPSBwYXJlbnROb2RlLmNoaWxkcmVuLmluZGV4T2Yobm9kZSk7XG5cbiAgICBwYXJlbnROb2RlLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAncm9vdE5vZGUnLCAnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnbm9kZScsXG4gIHJlcXVpcmVzOiBbJ2dldFBhcmVudCddLFxuICBjYXRlZ29yaWVzOiBbJ21hbmlwdWxhdGlvbicsICdhZGFwdGVyJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG5vZGUsIF92YWx1ZSkge1xuICAgIGlmIChfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9kZS52YWx1ZSA9IF92YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnbm9kZScsICdub2RlVmFsdWU/J10sXG4gIHJldHVyblR5cGU6ICdub2RlVmFsdWUnLFxuICBjYXRlZ29yaWVzOiBbJ21hbmlwdWxhdGlvbicsICdhZGFwdGVyJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlTm9kZTogZnVuY3Rpb24gY3JlYXRlTm9kZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkYXB0ZXIgZG9lcyBub3QgaW1wbGVtZW50IGNyZWF0ZU5vZGUnKTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnbm9kZVZhbHVlJ10sXG4gIHJldHVyblR5cGU6ICdub2RlJyxcbiAgY2F0ZWdvcmllczogWydtYW5pcHVsYXRpb24nLCAnYWRhcHRlciddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENoaWxkcmVuOiBmdW5jdGlvbiBnZXRDaGlsZHJlbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkYXB0ZXIgZG9lcyBub3QgaW1wbGVtZW50IGdldENoaWxkcmVuJyk7XG4gIH0sXG4gIGFyZ1R5cGVzOiBbJ25vZGUnXSxcbiAgcmV0dXJuVHlwZTogJ1tub2RlXScsXG4gIGNhdGVnb3JpZXM6IFsndHJhdmVyc2FsJywgJ2FkYXB0ZXInXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIGluc2VydEJlZm9yZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkYXB0ZXIgZG9lcyBub3QgaW1wbGVtZW50IGluc2VydEJlZm9yZScpO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdyb290Tm9kZScsICdub2RlJywgJ25vZGUnLCAnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnbm9kZScsXG4gIHJlcXVpcmVzOiBbJ3JlbW92ZSddLFxuICBjYXRlZ29yaWVzOiBbJ21hbmlwdWxhdGlvbicsICdhZGFwdGVyJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBZGFwdGVyIGRvZXMgbm90IGltcGxlbWVudCByZW1vdmUnKTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAncm9vdE5vZGUnLCAnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnbm9kZScsXG4gIHJlcXVpcmVzOiBbJ2dldFBhcmVudCddLFxuICBjYXRlZ29yaWVzOiBbJ21hbmlwdWxhdGlvbicsICdhZGFwdGVyJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQWRhcHRlciBkb2VzIG5vdCBpbXBsZW1lbnQgdmFsdWUnKTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnbm9kZScsICdub2RlVmFsdWU/J10sXG4gIHJldHVyblR5cGU6ICdub2RlVmFsdWUnLFxuICBjYXRlZ29yaWVzOiBbJ21hbmlwdWxhdGlvbicsICdhZGFwdGVyJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXBwZW5kID0gcmVxdWlyZSgnLi9tYW5pcHVsYXRpb24vYXBwZW5kJyk7XG52YXIgZW1wdHkgPSByZXF1aXJlKCcuL21hbmlwdWxhdGlvbi9lbXB0eScpO1xudmFyIGluc2VydEFmdGVyID0gcmVxdWlyZSgnLi9tYW5pcHVsYXRpb24vaW5zZXJ0QWZ0ZXInKTtcbnZhciBpbnNlcnRBdCA9IHJlcXVpcmUoJy4vbWFuaXB1bGF0aW9uL2luc2VydEF0Jyk7XG52YXIgcHJlcGVuZCA9IHJlcXVpcmUoJy4vbWFuaXB1bGF0aW9uL3ByZXBlbmQnKTtcbnZhciByZW1vdmVBdCA9IHJlcXVpcmUoJy4vbWFuaXB1bGF0aW9uL3JlbW92ZUF0Jyk7XG52YXIgcmVwbGFjZUNoaWxkID0gcmVxdWlyZSgnLi9tYW5pcHVsYXRpb24vcmVwbGFjZUNoaWxkJyk7XG52YXIgdW53cmFwID0gcmVxdWlyZSgnLi9tYW5pcHVsYXRpb24vdW53cmFwJyk7XG52YXIgd3JhcCA9IHJlcXVpcmUoJy4vbWFuaXB1bGF0aW9uL3dyYXAnKTtcblxudmFyIGFuY2VzdG9ycyA9IHJlcXVpcmUoJy4vdHJhdmVyc2FsL2FuY2VzdG9ycycpO1xudmFyIGNoaWxkQXQgPSByZXF1aXJlKCcuL3RyYXZlcnNhbC9jaGlsZEF0Jyk7XG52YXIgY2xvc2VzdCA9IHJlcXVpcmUoJy4vdHJhdmVyc2FsL2Nsb3Nlc3QnKTtcbnZhciBjb250YWlucyA9IHJlcXVpcmUoJy4vdHJhdmVyc2FsL2NvbnRhaW5zJyk7XG52YXIgZGVzY2VuZGVudHMgPSByZXF1aXJlKCcuL3RyYXZlcnNhbC9kZXNjZW5kZW50cycpO1xudmFyIGZpbmQgPSByZXF1aXJlKCcuL3RyYXZlcnNhbC9maW5kJyk7XG52YXIgZmluZEFsbCA9IHJlcXVpcmUoJy4vdHJhdmVyc2FsL2ZpbmRBbGwnKTtcbnZhciBmaXJzdENoaWxkID0gcmVxdWlyZSgnLi90cmF2ZXJzYWwvZmlyc3RDaGlsZCcpO1xudmFyIGdldFBhcmVudCA9IHJlcXVpcmUoJy4vdHJhdmVyc2FsL2dldFBhcmVudCcpO1xudmFyIGhhc0NoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzYWwvaGFzQ2hpbGRyZW4nKTtcbnZhciBpc0VtcHR5ID0gcmVxdWlyZSgnLi90cmF2ZXJzYWwvaXNFbXB0eScpO1xudmFyIGxhc3RDaGlsZCA9IHJlcXVpcmUoJy4vdHJhdmVyc2FsL2xhc3RDaGlsZCcpO1xudmFyIG5leHRTaWJsaW5nID0gcmVxdWlyZSgnLi90cmF2ZXJzYWwvbmV4dFNpYmxpbmcnKTtcbnZhciBwcmV2aW91c1NpYmxpbmcgPSByZXF1aXJlKCcuL3RyYXZlcnNhbC9wcmV2aW91c1NpYmxpbmcnKTtcbnZhciBzaWJsaW5ncyA9IHJlcXVpcmUoJy4vdHJhdmVyc2FsL3NpYmxpbmdzJyk7XG52YXIgd2FsayA9IHJlcXVpcmUoJy4vdHJhdmVyc2FsL3dhbGsnKTtcbnZhciB3YWxrVXAgPSByZXF1aXJlKCcuL3RyYXZlcnNhbC93YWxrVXAnKTtcblxudmFyIGNyZWF0ZU5vZGUgPSByZXF1aXJlKCcuL2FkYXB0ZXIvY3JlYXRlTm9kZScpO1xudmFyIGdldENoaWxkcmVuID0gcmVxdWlyZSgnLi9hZGFwdGVyL2dldENoaWxkcmVuJyk7XG52YXIgaW5zZXJ0QmVmb3JlID0gcmVxdWlyZSgnLi9hZGFwdGVyL2luc2VydEJlZm9yZScpO1xudmFyIHJlbW92ZSA9IHJlcXVpcmUoJy4vYWRhcHRlci9yZW1vdmUnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vYWRhcHRlci92YWx1ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXBwZW5kOiBhcHBlbmQsIGVtcHR5OiBlbXB0eSwgaW5zZXJ0QWZ0ZXI6IGluc2VydEFmdGVyLCBpbnNlcnRBdDogaW5zZXJ0QXQsIHByZXBlbmQ6IHByZXBlbmQsIHJlbW92ZUF0OiByZW1vdmVBdCwgcmVwbGFjZUNoaWxkOiByZXBsYWNlQ2hpbGQsXG4gIHVud3JhcDogdW53cmFwLCB3cmFwOiB3cmFwLCBhbmNlc3RvcnM6IGFuY2VzdG9ycywgY2hpbGRBdDogY2hpbGRBdCwgY2xvc2VzdDogY2xvc2VzdCwgY29udGFpbnM6IGNvbnRhaW5zLCBkZXNjZW5kZW50czogZGVzY2VuZGVudHMsIGZpbmQ6IGZpbmQsXG4gIGZpbmRBbGw6IGZpbmRBbGwsIGZpcnN0Q2hpbGQ6IGZpcnN0Q2hpbGQsIGdldFBhcmVudDogZ2V0UGFyZW50LCBoYXNDaGlsZHJlbjogaGFzQ2hpbGRyZW4sIGlzRW1wdHk6IGlzRW1wdHksIGxhc3RDaGlsZDogbGFzdENoaWxkLCBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gIHByZXZpb3VzU2libGluZzogcHJldmlvdXNTaWJsaW5nLCBzaWJsaW5nczogc2libGluZ3MsIHdhbGs6IHdhbGssIHdhbGtVcDogd2Fsa1VwLCBjcmVhdGVOb2RlOiBjcmVhdGVOb2RlLCBnZXRDaGlsZHJlbjogZ2V0Q2hpbGRyZW4sXG4gIGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLCByZW1vdmU6IHJlbW92ZSwgdmFsdWU6IHZhbHVlXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKGZuLCByb290LCBwYXJlbnROb2RlLCBjaGlsZE5vZGUpIHtcbiAgICByZXR1cm4gZm4uaW5zZXJ0QmVmb3JlKGZuLCByb290LCBwYXJlbnROb2RlLCBjaGlsZE5vZGUpO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdyb290Tm9kZScsICdub2RlJywgJ25vZGUnXSxcbiAgcmV0dXJuVHlwZTogJ25vZGUnLFxuICByZXF1aXJlczogWydpbnNlcnRCZWZvcmUnXSxcbiAgY2F0ZWdvcmllczogWydtYW5pcHVsYXRpb24nXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbXB0eTogZnVuY3Rpb24gZW1wdHkoZm4sIHJvb3QsIHBhcmVudE5vZGUpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBmbi5nZXRDaGlsZHJlbihwYXJlbnROb2RlKS5zbGljZSgpO1xuXG4gICAgcmV0dXJuIGNoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAocmVtb3ZlZCwgbm9kZSkge1xuICAgICAgcmVtb3ZlZC5wdXNoKGZuLnJlbW92ZShmbiwgcGFyZW50Tm9kZSwgbm9kZSkpO1xuXG4gICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9LCBbXSk7XG4gIH0sXG4gIGFyZ1R5cGVzOiBbJ2ZuJywgJ3Jvb3ROb2RlJywgJ25vZGUnXSxcbiAgcmV0dXJuVHlwZTogJ1tub2RlXScsXG4gIHJlcXVpcmVzOiBbJ2dldENoaWxkcmVuJywgJ3JlbW92ZSddLFxuICBjYXRlZ29yaWVzOiBbJ21hbmlwdWxhdGlvbiddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluc2VydEFmdGVyOiBmdW5jdGlvbiBpbnNlcnRBZnRlcihmbiwgcm9vdCwgcGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gZm4uZ2V0Q2hpbGRyZW4ocGFyZW50Tm9kZSk7XG4gICAgdmFyIHJlZmVyZW5jZUluZGV4ID0gY2hpbGRyZW4uaW5kZXhPZihyZWZlcmVuY2VOb2RlKTtcbiAgICB2YXIgYmVmb3JlTm9kZSA9IGNoaWxkcmVuW3JlZmVyZW5jZUluZGV4ICsgMV07XG5cbiAgICByZXR1cm4gZm4uaW5zZXJ0QmVmb3JlKGZuLCByb290LCBwYXJlbnROb2RlLCBjaGlsZE5vZGUsIGJlZm9yZU5vZGUpO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdyb290Tm9kZScsICdub2RlJywgJ25vZGUnLCAnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnbm9kZScsXG4gIHJlcXVpcmVzOiBbJ2dldENoaWxkcmVuJywgJ2luc2VydEJlZm9yZSddLFxuICBjYXRlZ29yaWVzOiBbJ21hbmlwdWxhdGlvbiddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluc2VydEF0OiBmdW5jdGlvbiBpbnNlcnRBdChmbiwgcm9vdCwgcGFyZW50Tm9kZSwgY2hpbGROb2RlLCBpbmRleCkge1xuICAgIHZhciBjaGlsZHJlbiA9IGZuLmdldENoaWxkcmVuKHBhcmVudE5vZGUpO1xuICAgIHZhciByZWZlcmVuY2VOb2RlID0gY2hpbGRyZW5baW5kZXhdO1xuXG4gICAgcmV0dXJuIGZuLmluc2VydEJlZm9yZShmbiwgcm9vdCwgcGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAncm9vdE5vZGUnLCAnbm9kZScsICdub2RlJywgJ2ludGVnZXInXSxcbiAgcmV0dXJuVHlwZTogJ25vZGUnLFxuICByZXF1aXJlczogWydnZXRDaGlsZHJlbicsICdpbnNlcnRCZWZvcmUnXSxcbiAgY2F0ZWdvcmllczogWydtYW5pcHVsYXRpb24nXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwcmVwZW5kOiBmdW5jdGlvbiBwcmVwZW5kKGZuLCByb290LCBwYXJlbnROb2RlLCBjaGlsZE5vZGUpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBmbi5nZXRDaGlsZHJlbihwYXJlbnROb2RlKTtcblxuICAgIC8vIGlmIGNoaWxkWyAwIF0gaXMgdW5kZWZpbmVkIHRoaXMgaXMgdGhlIHNhbWUgYXMgYXBwZW5kXG4gICAgcmV0dXJuIGZuLmluc2VydEJlZm9yZShmbiwgcm9vdCwgcGFyZW50Tm9kZSwgY2hpbGROb2RlLCBjaGlsZHJlblswXSk7XG4gIH0sXG4gIGFyZ1R5cGVzOiBbJ2ZuJywgJ3Jvb3ROb2RlJywgJ25vZGUnLCAnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnbm9kZScsXG4gIHJlcXVpcmVzOiBbJ2dldENoaWxkcmVuJywgJ2luc2VydEJlZm9yZSddLFxuICBjYXRlZ29yaWVzOiBbJ21hbmlwdWxhdGlvbiddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlbW92ZUF0OiBmdW5jdGlvbiByZW1vdmVBdChmbiwgcm9vdCwgcGFyZW50Tm9kZSwgaW5kZXgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBmbi5nZXRDaGlsZHJlbihwYXJlbnROb2RlKTtcbiAgICB2YXIgY2hpbGROb2RlID0gY2hpbGRyZW5baW5kZXhdO1xuXG4gICAgcmV0dXJuIGZuLnJlbW92ZShmbiwgcm9vdCwgY2hpbGROb2RlKTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAncm9vdE5vZGUnLCAnbm9kZScsICdpbnRlZ2VyJ10sXG4gIHJldHVyblR5cGU6ICdub2RlJyxcbiAgcmVxdWlyZXM6IFsnZ2V0Q2hpbGRyZW4nLCAncmVtb3ZlJ10sXG4gIGNhdGVnb3JpZXM6IFsnbWFuaXB1bGF0aW9uJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVwbGFjZUNoaWxkOiBmdW5jdGlvbiByZXBsYWNlQ2hpbGQoZm4sIHJvb3QsIHBhcmVudE5vZGUsIG5ld05vZGUsIG9sZE5vZGUpIHtcbiAgICBmbi5pbnNlcnRCZWZvcmUoZm4sIHJvb3QsIHBhcmVudE5vZGUsIG5ld05vZGUsIG9sZE5vZGUpO1xuXG4gICAgcmV0dXJuIGZuLnJlbW92ZShmbiwgcm9vdCwgb2xkTm9kZSk7XG4gIH0sXG4gIGFyZ1R5cGVzOiBbJ2ZuJywgJ3Jvb3ROb2RlJywgJ25vZGUnLCAnbm9kZScsICdub2RlJ10sXG4gIHJldHVyblR5cGU6ICdub2RlJyxcbiAgcmVxdWlyZXM6IFsnaW5zZXJ0QmVmb3JlJywgJ3JlbW92ZSddLFxuICBjYXRlZ29yaWVzOiBbJ21hbmlwdWxhdGlvbiddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHVud3JhcDogZnVuY3Rpb24gdW53cmFwKGZuLCByb290LCBub2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IGZuLmdldFBhcmVudChmbiwgcm9vdCwgbm9kZSk7XG4gICAgdmFyIGdyYW5kcGFyZW50ID0gZm4uZ2V0UGFyZW50KGZuLCByb290LCBwYXJlbnQpO1xuICAgIHZhciBjaGlsZHJlbiA9IGZuLmdldENoaWxkcmVuKHBhcmVudCk7XG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGZuLmluc2VydEJlZm9yZShmbiwgcm9vdCwgZ3JhbmRwYXJlbnQsIGNoaWxkLCBwYXJlbnQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZuLnJlbW92ZShmbiwgcm9vdCwgcGFyZW50KTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAncm9vdE5vZGUnLCAnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnbm9kZScsXG4gIHJlcXVpcmVzOiBbJ2dldFBhcmVudCcsICdnZXRDaGlsZHJlbicsICdpbnNlcnRCZWZvcmUnLCAncmVtb3ZlJ10sXG4gIGNhdGVnb3JpZXM6IFsnbWFuaXB1bGF0aW9uJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgd3JhcDogZnVuY3Rpb24gd3JhcChmbiwgcm9vdCwgbm9kZSwgbmV3Tm9kZSkge1xuICAgIHZhciBwYXJlbnQgPSBmbi5nZXRQYXJlbnQoZm4sIHJvb3QsIG5vZGUpO1xuXG4gICAgZm4uaW5zZXJ0QmVmb3JlKGZuLCByb290LCBwYXJlbnQsIG5ld05vZGUsIG5vZGUpO1xuICAgIGZuLmFwcGVuZChmbiwgcm9vdCwgbmV3Tm9kZSwgbm9kZSk7XG5cbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAncm9vdE5vZGUnLCAnbm9kZScsICdub2RlJ10sXG4gIHJldHVyblR5cGU6ICdub2RlJyxcbiAgcmVxdWlyZXM6IFsnZ2V0UGFyZW50JywgJ2luc2VydEJlZm9yZScsICdhcHBlbmQnXSxcbiAgY2F0ZWdvcmllczogWydtYW5pcHVsYXRpb24nXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhbmNlc3RvcnM6IGZ1bmN0aW9uIGFuY2VzdG9ycyhmbiwgcm9vdCwgbm9kZSkge1xuICAgIHZhciBwYXJlbnROb2RlcyA9IFtdO1xuXG4gICAgdmFyIHBhcmVudCA9IGZuLmdldFBhcmVudChmbiwgcm9vdCwgbm9kZSk7XG5cbiAgICBpZiAocGFyZW50KSBmbi53YWxrVXAoZm4sIHJvb3QsIHBhcmVudCwgZnVuY3Rpb24gKG4pIHtcbiAgICAgIHBhcmVudE5vZGVzLnB1c2gobik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcGFyZW50Tm9kZXM7XG4gIH0sXG4gIGFyZ1R5cGVzOiBbJ2ZuJywgJ3Jvb3ROb2RlJywgJ25vZGUnXSxcbiAgcmV0dXJuVHlwZTogJ1tub2RlXScsXG4gIHJlcXVpcmVzOiBbJ2dldFBhcmVudCcsICd3YWxrVXAnXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjaGlsZEF0OiBmdW5jdGlvbiBjaGlsZEF0KGZuLCBub2RlLCBpKSB7XG4gICAgcmV0dXJuIGZuLmdldENoaWxkcmVuKG5vZGUpW2ldO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdub2RlJywgJ2ludGVnZXInXSxcbiAgcmV0dXJuVHlwZTogJ25vZGUnLFxuICByZXF1aXJlczogWydnZXRDaGlsZHJlbiddLFxuICBjYXRlZ29yaWVzOiBbJ3RyYXZlcnNhbCddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNsb3Nlc3Q6IGZ1bmN0aW9uIGNsb3Nlc3QoZm4sIHJvb3QsIG5vZGUsIHByZWRpY2F0ZSkge1xuICAgIHZhciB0YXJnZXROb2RlID0gdm9pZCAwO1xuXG4gICAgZm4ud2Fsa1VwKGZuLCByb290LCBub2RlLCBmdW5jdGlvbiAoY3VycmVudE5vZGUpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoY3VycmVudE5vZGUpKSB7XG4gICAgICAgIHRhcmdldE5vZGUgPSBjdXJyZW50Tm9kZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0YXJnZXROb2RlO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdyb290Tm9kZScsICdub2RlJywgJ25vZGUgPT4gYm9vbGVhbiddLFxuICByZXR1cm5UeXBlOiAnbm9kZScsXG4gIHJlcXVpcmVzOiBbJ3dhbGtVcCddLFxuICBjYXRlZ29yaWVzOiBbJ3RyYXZlcnNhbCddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbnRhaW5zOiBmdW5jdGlvbiBjb250YWlucyhmbiwgbm9kZSwgcHJlZGljYXRlKSB7XG4gICAgcmV0dXJuICEhZm4uZmluZChmbiwgbm9kZSwgcHJlZGljYXRlKTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAnbm9kZScsICdub2RlID0+IGJvb2xlYW4nXSxcbiAgcmV0dXJuVHlwZTogJ2Jvb2xlYW4nLFxuICByZXF1aXJlczogWydmaW5kJ10sXG4gIGNhdGVnb3JpZXM6IFsndHJhdmVyc2FsJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzY2VuZGVudHM6IGZ1bmN0aW9uIGRlc2NlbmRlbnRzKGZuLCBub2RlKSB7XG4gICAgcmV0dXJuIGZuLmZpbmRBbGwoZm4sIG5vZGUsIGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gbiAhPT0gbm9kZTtcbiAgICB9KTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnW25vZGVdJyxcbiAgcmVxdWlyZXM6IFsnZmluZEFsbCddLFxuICBjYXRlZ29yaWVzOiBbJ3RyYXZlcnNhbCddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoZm4sIG5vZGUsIHByZWRpY2F0ZSkge1xuICAgIHZhciB0YXJnZXROb2RlID0gdm9pZCAwO1xuXG4gICAgZm4ud2Fsayhmbiwgbm9kZSwgZnVuY3Rpb24gKGN1cnJlbnROb2RlKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGN1cnJlbnROb2RlKSkge1xuICAgICAgICB0YXJnZXROb2RlID0gY3VycmVudE5vZGU7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGFyZ2V0Tm9kZTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAnbm9kZScsICdub2RlID0+IGJvb2xlYW4nXSxcbiAgcmV0dXJuVHlwZTogJ25vZGUnLFxuICByZXF1aXJlczogWyd3YWxrJ10sXG4gIGNhdGVnb3JpZXM6IFsndHJhdmVyc2FsJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmluZEFsbDogZnVuY3Rpb24gZmluZEFsbChmbiwgbm9kZSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIG5vZGVzID0gW107XG5cbiAgICBmbi53YWxrKGZuLCBub2RlLCBmdW5jdGlvbiAoY3VycmVudE5vZGUpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoY3VycmVudE5vZGUpKSB7XG4gICAgICAgIG5vZGVzLnB1c2goY3VycmVudE5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdub2RlJywgJ25vZGUgPT4gYm9vbGVhbiddLFxuICByZXR1cm5UeXBlOiAnW25vZGVdJyxcbiAgcmVxdWlyZXM6IFsnd2FsayddLFxuICBjYXRlZ29yaWVzOiBbJ3RyYXZlcnNhbCddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZpcnN0Q2hpbGQ6IGZ1bmN0aW9uIGZpcnN0Q2hpbGQoZm4sIG5vZGUpIHtcbiAgICByZXR1cm4gZm4uZ2V0Q2hpbGRyZW4obm9kZSlbMF07XG4gIH0sXG4gIGFyZ1R5cGVzOiBbJ2ZuJywgJ25vZGUnXSxcbiAgcmV0dXJuVHlwZTogJ25vZGUnLFxuICByZXF1aXJlczogWydnZXRDaGlsZHJlbiddLFxuICBjYXRlZ29yaWVzOiBbJ3RyYXZlcnNhbCddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldFBhcmVudDogZnVuY3Rpb24gZ2V0UGFyZW50KGZuLCByb290LCBub2RlKSB7XG4gICAgcmV0dXJuIGZuLmZpbmQoZm4sIHJvb3QsIGZ1bmN0aW9uIChjdXJyZW50Tm9kZSkge1xuICAgICAgcmV0dXJuIGZuLmdldENoaWxkcmVuKGN1cnJlbnROb2RlKS5pbmNsdWRlcyhub2RlKTtcbiAgICB9KTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAncm9vdE5vZGUnLCAnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnbm9kZScsXG4gIHJlcXVpcmVzOiBbJ2ZpbmQnLCAnZ2V0Q2hpbGRyZW4nXSxcbiAgY2F0ZWdvcmllczogWyd0cmF2ZXJzYWwnXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBoYXNDaGlsZHJlbjogZnVuY3Rpb24gaGFzQ2hpbGRyZW4oZm4sIG5vZGUpIHtcbiAgICByZXR1cm4gZm4uZ2V0Q2hpbGRyZW4obm9kZSkubGVuZ3RoID4gMDtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnYm9vbGVhbicsXG4gIHJlcXVpcmVzOiBbJ2dldENoaWxkcmVuJ10sXG4gIGNhdGVnb3JpZXM6IFsndHJhdmVyc2FsJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNFbXB0eTogZnVuY3Rpb24gaXNFbXB0eShmbiwgbm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIGFyZ1R5cGVzOiBbJ2ZuJywgJ25vZGUnXSxcbiAgcmV0dXJuVHlwZTogJ2Jvb2xlYW4nLFxuICByZXF1aXJlczogW10sXG4gIGNhdGVnb3JpZXM6IFsndHJhdmVyc2FsJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbGFzdENoaWxkOiBmdW5jdGlvbiBsYXN0Q2hpbGQoZm4sIG5vZGUpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBmbi5nZXRDaGlsZHJlbihub2RlKTtcblxuICAgIHJldHVybiBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnbm9kZScsXG4gIHJlcXVpcmVzOiBbJ2dldENoaWxkcmVuJ10sXG4gIGNhdGVnb3JpZXM6IFsndHJhdmVyc2FsJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmV4dFNpYmxpbmc6IGZ1bmN0aW9uIG5leHRTaWJsaW5nKGZuLCByb290LCBub2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IGZuLmdldFBhcmVudChmbiwgcm9vdCwgbm9kZSk7XG4gICAgdmFyIGNoaWxkcmVuID0gZm4uZ2V0Q2hpbGRyZW4ocGFyZW50KTtcblxuICAgIHZhciBpbmRleCA9IGNoaWxkcmVuLmluZGV4T2Yobm9kZSk7XG5cbiAgICByZXR1cm4gY2hpbGRyZW5baW5kZXggKyAxXTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAncm9vdE5vZGUnLCAnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnbm9kZScsXG4gIHJlcXVpcmVzOiBbJ2dldFBhcmVudCcsICdnZXRDaGlsZHJlbiddLFxuICBjYXRlZ29yaWVzOiBbJ3RyYXZlcnNhbCddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHByZXZpb3VzU2libGluZzogZnVuY3Rpb24gcHJldmlvdXNTaWJsaW5nKGZuLCByb290LCBub2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IGZuLmdldFBhcmVudChmbiwgcm9vdCwgbm9kZSk7XG4gICAgdmFyIGNoaWxkcmVuID0gZm4uZ2V0Q2hpbGRyZW4ocGFyZW50KTtcblxuICAgIHZhciBpbmRleCA9IGNoaWxkcmVuLmluZGV4T2Yobm9kZSk7XG5cbiAgICByZXR1cm4gY2hpbGRyZW5baW5kZXggLSAxXTtcbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAncm9vdE5vZGUnLCAnbm9kZSddLFxuICByZXR1cm5UeXBlOiAnbm9kZScsXG4gIHJlcXVpcmVzOiBbJ2dldFBhcmVudCcsICdnZXRDaGlsZHJlbiddLFxuICBjYXRlZ29yaWVzOiBbJ3RyYXZlcnNhbCddXG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNpYmxpbmdzOiBmdW5jdGlvbiBzaWJsaW5ncyhmbiwgcm9vdCwgbm9kZSkge1xuICAgIHZhciBwYXJlbnQgPSBmbi5nZXRQYXJlbnQoZm4sIHJvb3QsIG5vZGUpO1xuICAgIHZhciBjaGlsZHJlbiA9IGZuLmdldENoaWxkcmVuKHBhcmVudCk7XG5cbiAgICByZXR1cm4gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkICE9PSBub2RlO1xuICAgIH0pO1xuICB9LFxuICBhcmdUeXBlczogWydmbicsICdyb290Tm9kZScsICdub2RlJ10sXG4gIHJldHVyblR5cGU6ICdbbm9kZV0nLFxuICByZXF1aXJlczogWydnZXRQYXJlbnQnLCAnZ2V0Q2hpbGRyZW4nXSxcbiAgY2F0ZWdvcmllczogWyd0cmF2ZXJzYWwnXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3YWxrOiBmdW5jdGlvbiB3YWxrKGZuLCBub2RlLCBjYWxsYmFjaykge1xuICAgIHZhciBjdXJyZW50ID0gdm9pZCAwLFxuICAgICAgICBwYXJlbnQgPSB2b2lkIDAsXG4gICAgICAgIGRlcHRoID0gdm9pZCAwLFxuICAgICAgICBpID0gdm9pZCAwLFxuICAgICAgICBjaGlsZHJlbiA9IHZvaWQgMCxcbiAgICAgICAgc3RvcCA9IHZvaWQgMDtcbiAgICB2YXIgbm9kZXMgPSBbbm9kZV07XG4gICAgdmFyIHBhcmVudHMgPSBbbnVsbF07XG4gICAgdmFyIGRlcHRocyA9IFswXTtcblxuICAgIHdoaWxlIChub2Rlcy5sZW5ndGgpIHtcbiAgICAgIGN1cnJlbnQgPSBub2Rlcy5wb3AoKTtcbiAgICAgIHBhcmVudCA9IHBhcmVudHMucG9wKCk7XG4gICAgICBkZXB0aCA9IGRlcHRocy5wb3AoKTtcblxuICAgICAgc3RvcCA9IGNhbGxiYWNrKGN1cnJlbnQsIHBhcmVudCwgZGVwdGgpO1xuXG4gICAgICBpZiAoc3RvcCkgYnJlYWs7XG5cbiAgICAgIGNoaWxkcmVuID0gZm4uZ2V0Q2hpbGRyZW4oY3VycmVudCk7XG5cbiAgICAgIGZvciAoaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIG5vZGVzLnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgICBwYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgIGRlcHRocy5wdXNoKGRlcHRoICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBhcmdUeXBlczogWydmbicsICdub2RlJywgJyggbm9kZSwgbm9kZSwgaW50ZWdlciApID0+IGJvb2xlYW4nXSxcbiAgcmVxdWlyZXM6IFsnZ2V0Q2hpbGRyZW4nXSxcbiAgY2F0ZWdvcmllczogWyd0cmF2ZXJzYWwnXVxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3YWxrVXA6IGZ1bmN0aW9uIHdhbGtVcChmbiwgcm9vdCwgbm9kZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgc3RvcCA9IGNhbGxiYWNrKG5vZGUpO1xuXG4gICAgaWYgKCFzdG9wKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZm4uZ2V0UGFyZW50KGZuLCByb290LCBub2RlKTtcbiAgICAgIHdoaWxlIChwYXJlbnQgJiYgIXN0b3ApIHtcbiAgICAgICAgc3RvcCA9IGNhbGxiYWNrKHBhcmVudCk7XG4gICAgICAgIGlmICghc3RvcCkgcGFyZW50ID0gZm4uZ2V0UGFyZW50KGZuLCByb290LCBwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYXJnVHlwZXM6IFsnZm4nLCAncm9vdE5vZGUnLCAnbm9kZScsICdub2RlID0+IGJvb2xlYW4nXSxcbiAgcmVxdWlyZXM6IFsnZ2V0UGFyZW50J10sXG4gIGNhdGVnb3JpZXM6IFsndHJhdmVyc2FsJ11cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmFzZURlZnMgPSByZXF1aXJlKCcuL2RlZnMnKTtcblxudmFyIG1hcHBlciA9IGZ1bmN0aW9uIG1hcHBlcihkZWZzKSB7XG4gIHZhciBtYWtlRm4gPSBmdW5jdGlvbiBtYWtlRm4obmFtZSkge1xuICAgIHZhciBmbkRlZiA9IGRlZnNbbmFtZV07XG4gICAgdmFyIGZuID0gZm5EZWZbbmFtZV07XG5cbiAgICBmbi5kZWYgPSBmbkRlZjtcblxuICAgIHJldHVybiBmbjtcbiAgfTtcblxuICB2YXIgZm5hbWVzID0gT2JqZWN0LmtleXMoZGVmcyk7XG5cbiAgcmV0dXJuIGZuYW1lcy5yZWR1Y2UoZnVuY3Rpb24gKGZucywgbmFtZSkge1xuICAgIGZuc1tuYW1lXSA9IG1ha2VGbihuYW1lKTtcblxuICAgIHJldHVybiBmbnM7XG4gIH0sIHt9KTtcbn07XG5cbnZhciBmbkZhY3RvcnkgPSBmdW5jdGlvbiBmbkZhY3RvcnkoYWRhcHRlcikge1xuICB2YXIgYWRhcHRlckRlZnMgPSBPYmplY3Qua2V5cyhhZGFwdGVyKS5yZWR1Y2UoZnVuY3Rpb24gKGRlZnMsIGZuYW1lKSB7XG4gICAgdmFyIGFkYXB0ZXJEZWYgPSBhZGFwdGVyW2ZuYW1lXTtcblxuICAgIGlmICh0eXBlb2YgYWRhcHRlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGZuID0gYWRhcHRlckRlZjtcbiAgICAgIGFkYXB0ZXJEZWYgPSBhZGFwdGVyRGVmLmRlZiB8fCBiYXNlRGVmc1tmbmFtZV0gfHwge307XG4gICAgICBhZGFwdGVyRGVmW2ZuYW1lXSA9IGZuO1xuICAgIH1cblxuICAgIGRlZnNbZm5hbWVdID0gYWRhcHRlckRlZjtcblxuICAgIHJldHVybiBkZWZzO1xuICB9LCB7fSk7XG5cbiAgcmV0dXJuIG1hcHBlcihPYmplY3QuYXNzaWduKHt9LCBiYXNlRGVmcywgYWRhcHRlckRlZnMpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZm5GYWN0b3J5OyIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9wb2x5ZmlsbHMnKTtcblxudmFyIGRlZmF1bHRBZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVyL2RlZmF1bHQnKTtcbnZhciBmbkZhY3RvcnkgPSByZXF1aXJlKCcuL2ZuLWZhY3RvcnknKTtcblxudmFyIG1ldGEgPSByZXF1aXJlKCcuL3BsdWdpbnMvbWV0YScpO1xudmFyIHBhcmVudE1hcCA9IHJlcXVpcmUoJy4vcGx1Z2lucy9wYXJlbnQtbWFwJyk7XG52YXIgc2VyaWFsaXplciA9IHJlcXVpcmUoJy4vcGx1Z2lucy9zZXJpYWxpemVyJyk7XG52YXIgd3JhcE5vZGVzID0gcmVxdWlyZSgnLi9wbHVnaW5zL3dyYXAtbm9kZXMnKTtcbnZhciBhY2NlcHRzID0gcmVxdWlyZSgnLi9wbHVnaW5zL2FjY2VwdHMnKTtcbnZhciBub2RlVHlwZSA9IHJlcXVpcmUoJy4vcGx1Z2lucy9ub2RlVHlwZScpO1xudmFyIGlkID0gcmVxdWlyZSgnLi9wbHVnaW5zL2lkJyk7XG5cbnZhciBwbHVnaW5zID0geyBwYXJlbnRNYXA6IHBhcmVudE1hcCwgYWNjZXB0czogYWNjZXB0cywgbm9kZVR5cGU6IG5vZGVUeXBlLCBpZDogaWQsIHNlcmlhbGl6ZXI6IHNlcmlhbGl6ZXIsIG1ldGE6IG1ldGEsIHdyYXBOb2Rlczogd3JhcE5vZGVzIH07XG52YXIgcGx1Z2luQXJyYXkgPSBPYmplY3Qua2V5cyhwbHVnaW5zKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gcGx1Z2luc1trZXldO1xufSk7XG5cbnZhciB0cmVlRmFjdG9yeSA9IGZ1bmN0aW9uIHRyZWVGYWN0b3J5KGFkYXB0ZXIsIHBsdWdpbnMpIHtcbiAgdmFyIGZuID0gZm5GYWN0b3J5KGFkYXB0ZXIpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHBsdWdpbnMpKSBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIHJldHVybiBwbHVnaW4oZm4pO1xuICB9KTtcblxuICAvLyBjcmVhdGUgd3JhcHBlZCBBUElcbiAgdmFyIFRyZWUgPSBmdW5jdGlvbiBUcmVlKHJvb3QpIHtcbiAgICByZXR1cm4gZm4uY3JlYXRlVHJlZShyb290KTtcbiAgfTtcblxuICB2YXIgZm5hbWVzID0gT2JqZWN0LmtleXMoZm4pO1xuXG4gIGZuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChmbmFtZSkge1xuICAgIHZhciBmdW5jID0gZm5bZm5hbWVdO1xuICAgIHZhciBkZWYgPSBmdW5jLmRlZiB8fCB7fTtcbiAgICB2YXIgYXJnVHlwZXMgPSBBcnJheS5pc0FycmF5KGRlZi5hcmdUeXBlcykgPyBkZWYuYXJnVHlwZXMgOiBbXTtcblxuICAgIFRyZWVbZm5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ1R5cGVzLmluY2x1ZGVzKCdmbicpKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgW2ZuXS5jb25jYXQoYXJncykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH07XG4gIH0pO1xuXG4gIFRyZWUuY3JlYXRlUm9vdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBUcmVlKFRyZWUuY3JlYXRlTm9kZSh2YWx1ZSkpO1xuICB9O1xuICBUcmVlLmZuID0gZm47XG4gIFRyZWUuYWRhcHRlciA9IHRyZWVGYWN0b3J5O1xuICBUcmVlLnBsdWdpbiA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICByZXR1cm4gcGx1Z2luKGZuKTtcbiAgfTtcbiAgVHJlZS5wbHVnaW5zID0gcGx1Z2lucztcblxuICByZXR1cm4gVHJlZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdHJlZUZhY3RvcnkoZGVmYXVsdEFkYXB0ZXIsIHBsdWdpbkFycmF5KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhY2NlcHRzTm9kZSA9IGZ1bmN0aW9uIGFjY2VwdHNOb2RlKGZuKSB7XG4gIHZhciBhY2NlcHRzID0gZnVuY3Rpb24gYWNjZXB0cyhmbiwgbm9kZSwgY2hpbGROb2RlKSB7XG4gICAgcmV0dXJuICFmbi5pc0VtcHR5KGZuLCBub2RlKTtcbiAgfTsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgYWNjZXB0cy5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnZm4nLCAnbm9kZScsICdub2RlJ10sXG4gICAgcmV0dXJuVHlwZTogJ2Jvb2xlYW4nLFxuICAgIHJlcXVpcmU6IFsnaXNFbXB0eSddLFxuICAgIGNhdGVnb3JpZXM6IFsnbm9kZScsICdwbHVnaW4nXVxuICB9O1xuXG4gIHZhciBvcmlnaW5hbEluc2VydEJlZm9yZSA9IGZuLmluc2VydEJlZm9yZTtcblxuICB2YXIgaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKGZuLCByb290LCBwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgICBpZiAoIWZuLmFjY2VwdHMoZm4sIHBhcmVudE5vZGUsIGNoaWxkTm9kZSkpIHRocm93IG5ldyBFcnJvcignTm9kZSBjYW5ub3QgYWNjZXB0IHRoaXMgY2hpbGQnKTtcblxuICAgIHJldHVybiBvcmlnaW5hbEluc2VydEJlZm9yZShmbiwgcm9vdCwgcGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgfTtcblxuICBpbnNlcnRCZWZvcmUuZGVmID0gb3JpZ2luYWxJbnNlcnRCZWZvcmUuZGVmO1xuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKGZuLCB7IGFjY2VwdHM6IGFjY2VwdHMsIGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhY2NlcHRzTm9kZTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJ21vanVsZS11dGlscycpO1xuXG52YXIgbGF6eUlkID0gZnVuY3Rpb24gbGF6eUlkKGZuKSB7XG4gIHZhciBpZCA9IGZ1bmN0aW9uIGlkKGZuLCBub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gZm4udmFsdWUobm9kZSk7XG5cbiAgICBpZiAodmFsdWUuX2lkKSByZXR1cm4gdmFsdWUuX2lkO1xuXG4gICAgdmFyIG5vZGVUeXBlID0gZm4ubm9kZVR5cGUoZm4sIG5vZGUpO1xuICAgIHZhciBpZCA9IHV0aWxzLmlkKG5vZGVUeXBlKTtcblxuICAgIHZhbHVlLl9pZCA9IGlkO1xuXG4gICAgZm4udmFsdWUobm9kZSwgdmFsdWUpO1xuXG4gICAgcmV0dXJuIGlkO1xuICB9O1xuXG4gIGlkLmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydmbicsICdub2RlJ10sXG4gICAgcmV0dXJuVHlwZTogJ3N0cmluZycsXG4gICAgcmVxdWlyZTogWyd2YWx1ZScsICdub2RlVHlwZSddLFxuICAgIGNhdGVnb3JpZXM6IFsnbm9kZScsICdwbHVnaW4nXVxuICB9O1xuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKGZuLCB7IGlkOiBpZCB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbGF6eUlkOyIsIid1c2Ugc3RyaWN0JztcblxuLypcbiAgR2V0L3NldCBydW50aW1lIGRhdGEgZm9yIG5vZGVzIHRoYXQgYXJlbid0IHdyaXR0ZW4gdG8gdGhlIG5vZGVzIHRoZW1zZWx2ZXNcblxuICBGb3IgZXhhbXBsZSwgd2hlbiB2aXN1YWxpc2luZyB0cmVlcyB5b3UgbWlnaHQgd2FudCB0byBhbGxvdyB0aGUgdXNlciB0b1xuICBjb2xsYXBzZSBvciBleHBhbmQgbm9kZXMgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgc2Vzc2lvbiwgYnV0IG5vdCBhY3R1YWxseVxuICBtb2RpZnkgdGhlIG5vZGVzIHRoZW1zZWx2ZXNcbiovXG5cbnZhciBtZXRhUGx1Z2luID0gZnVuY3Rpb24gbWV0YVBsdWdpbihmbikge1xuICB2YXIgbWV0YU1hcCA9IG5ldyBNYXAoKTtcblxuICB2YXIgbWV0YSA9IGZ1bmN0aW9uIG1ldGEoZm4sIG5vZGUsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIW1ldGFNYXAuaGFzKG5vZGUpKSB7XG4gICAgICBtZXRhTWFwLnNldChub2RlLCB7fSk7XG4gICAgfVxuXG4gICAgdmFyIG9iaiA9IG1ldGFNYXAuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIG1ldGEuZGVmID0ge1xuICAgIGFyZ1R5cGVzOiBbJ2ZuJywgJ25vZGUnLCAnc3RyaW5nJywgJ2FueSddLFxuICAgIHJldHVyblR5cGU6ICdhbnknLFxuICAgIHJlcXVpcmVzOiBbXSxcbiAgICBjYXRlZ29yaWVzOiBbJ21ldGEnLCAncGx1Z2luJ11cbiAgfTtcblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihmbiwgeyBtZXRhOiBtZXRhIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXRhUGx1Z2luOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldE5vZGVUeXBlID0gZnVuY3Rpb24gZ2V0Tm9kZVR5cGUoZm4pIHtcbiAgdmFyIG5vZGVUeXBlID0gZnVuY3Rpb24gbm9kZVR5cGUoZm4sIG5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSBmbi52YWx1ZShub2RlKTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUubm9kZVR5cGUgPT09ICdzdHJpbmcnICYmIHZhbHVlLm5vZGVUeXBlLmxlbmd0aCA+IDApIHJldHVybiB2YWx1ZS5ub2RlVHlwZTtcblxuICAgIHJldHVybiAndHJlZU5vZGUnO1xuICB9O1xuXG4gIG5vZGVUeXBlLmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydmbicsICdub2RlJ10sXG4gICAgcmV0dXJuVHlwZTogJ3N0cmluZycsXG4gICAgcmVxdWlyZTogWyd2YWx1ZSddLFxuICAgIGNhdGVnb3JpZXM6IFsnbm9kZScsICdwbHVnaW4nXVxuICB9O1xuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKGZuLCB7IG5vZGVUeXBlOiBub2RlVHlwZSB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Tm9kZVR5cGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyZW50TWFwID0gZnVuY3Rpb24gcGFyZW50TWFwKGZuKSB7XG4gIHZhciBwYXJlbnRzID0gbmV3IE1hcCgpO1xuXG4gIHZhciBvcmlnaW5hbCA9IHtcbiAgICBpbnNlcnRCZWZvcmU6IGZuLmluc2VydEJlZm9yZSxcbiAgICByZW1vdmU6IGZuLnJlbW92ZSxcbiAgICBnZXRQYXJlbnQ6IGZuLmdldFBhcmVudFxuICB9O1xuXG4gIHZhciBpbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiBpbnNlcnRCZWZvcmUoZm4sIHJvb3QsIHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IG9yaWdpbmFsLmluc2VydEJlZm9yZShmbiwgcm9vdCwgcGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKTtcblxuICAgIHBhcmVudHMuc2V0KGNoaWxkTm9kZSwgcGFyZW50Tm9kZSk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgdmFyIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShmbiwgcm9vdCwgbm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IG9yaWdpbmFsLnJlbW92ZShmbiwgcm9vdCwgbm9kZSk7XG5cbiAgICBwYXJlbnRzLnNldChub2RlLCBudWxsKTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICB2YXIgZ2V0UGFyZW50ID0gZnVuY3Rpb24gZ2V0UGFyZW50KGZuLCByb290LCBub2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IHBhcmVudHMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFwYXJlbnQgJiYgb3JpZ2luYWwuZ2V0UGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBvcmlnaW5hbC5nZXRQYXJlbnQoZm4sIHJvb3QsIG5vZGUpO1xuICAgICAgcGFyZW50cy5zZXQobm9kZSwgcGFyZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50O1xuICB9O1xuXG4gIHZhciB3cmFwcGVkID0geyBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSwgcmVtb3ZlOiByZW1vdmUsIGdldFBhcmVudDogZ2V0UGFyZW50IH07XG5cbiAgT2JqZWN0LmtleXMod3JhcHBlZCkuZm9yRWFjaChmdW5jdGlvbiAoZm5hbWUpIHtcbiAgICB3cmFwcGVkW2ZuYW1lXS5kZWYgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHdyYXBzOiBvcmlnaW5hbFtmbmFtZV1cbiAgICB9LCBvcmlnaW5hbFtmbmFtZV0uZGVmKTtcblxuICAgIHdyYXBwZWRbZm5hbWVdLmRlZi5jYXRlZ29yaWVzLnB1c2goJ3BhcmVudE1hcCcsICdwbHVnaW4nKTtcbiAgfSk7XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZm4sIHdyYXBwZWQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnRNYXA7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xvbmVPYmogPSBmdW5jdGlvbiBjbG9uZU9iaihvYmopIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59O1xuXG52YXIgc2VyaWFsaXplciA9IGZ1bmN0aW9uIHNlcmlhbGl6ZXIoZm4pIHtcbiAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZShub2RlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBmbi52YWx1ZShub2RlKSxcbiAgICAgIGNoaWxkcmVuOiBmbi5nZXRDaGlsZHJlbihub2RlKS5tYXAoc2VyaWFsaXplKVxuICAgIH07XG4gIH07XG5cbiAgc2VyaWFsaXplLmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydub2RlJ10sXG4gICAgcmV0dXJuVHlwZTogJ29iamVjdCcsXG4gICAgcmVxdWlyZXM6IFsndmFsdWUnLCAnZ2V0Q2hpbGRyZW4nXSxcbiAgICBjYXRlZ29yaWVzOiBbJ3NlcmlhbGl6ZXInLCAncGx1Z2luJ11cbiAgfTtcblxuICB2YXIgZGVzZXJpYWxpemUgPSBmdW5jdGlvbiBkZXNlcmlhbGl6ZShvYmopIHtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IGZuLmNyZWF0ZU5vZGUob2JqLnZhbHVlKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iai5jaGlsZHJlbikpIHtcbiAgICAgIG9iai5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBmbi5hcHBlbmQoZm4sIG51bGwsIHBhcmVudE5vZGUsIGRlc2VyaWFsaXplKGNoaWxkKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50Tm9kZTtcbiAgfTtcblxuICBkZXNlcmlhbGl6ZS5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnb2JqZWN0J10sXG4gICAgcmV0dXJuVHlwZTogJ25vZGUnLFxuICAgIHJlcXVpcmVzOiBbJ2NyZWF0ZU5vZGUnLCAnYXBwZW5kJ10sXG4gICAgY2F0ZWdvcmllczogWydzZXJpYWxpemVyJywgJ3BsdWdpbiddXG4gIH07XG5cbiAgdmFyIGNsb25lID0gZnVuY3Rpb24gY2xvbmUoZm4sIG5vZGUpIHtcbiAgICByZXR1cm4gZm4uZGVzZXJpYWxpemUoY2xvbmVPYmooZm4uc2VyaWFsaXplKG5vZGUpKSk7XG4gIH07XG5cbiAgY2xvbmUuZGVmID0ge1xuICAgIGFyZ1R5cGVzOiBbJ2ZuJywgJ25vZGUnXSxcbiAgICByZXR1cm5UeXBlOiAnbm9kZScsXG4gICAgcmVxdWlyZXM6IFsnc2VyaWFsaXplJywgJ2Rlc2VyaWFsaXplJ10sXG4gICAgY2F0ZWdvcmllczogWydjbG9uZScsICdwbHVnaW4nXVxuICB9O1xuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKGZuLCB7IHNlcmlhbGl6ZTogc2VyaWFsaXplLCBkZXNlcmlhbGl6ZTogZGVzZXJpYWxpemUsIGNsb25lOiBjbG9uZSB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc2VyaWFsaXplcjsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG52YXIgc2lnbmF0dXJlVG9EZWYgPSBmdW5jdGlvbiBzaWduYXR1cmVUb0RlZihzaWcpIHtcbiAgdmFyIHNlZ3MgPSBzaWcuc3BsaXQoJz0+Jyk7XG4gIHZhciBhcmdUeXBlcyA9IHNlZ3NbMF0ucmVwbGFjZSgnKCcsICcnKS5yZXBsYWNlKCcpJywgJycpLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gYXJnLnRyaW0oKTtcbiAgfSk7XG4gIHZhciByZXR1cm5UeXBlID0gc2Vnc1sxXS50cmltKCk7XG5cbiAgcmV0dXJuIHsgYXJnVHlwZXM6IGFyZ1R5cGVzLCByZXR1cm5UeXBlOiByZXR1cm5UeXBlIH07XG59O1xuXG52YXIgYXJnc01hcCA9IGZ1bmN0aW9uIGFyZ3NNYXAoZm4sIGFyZ1R5cGVzLCBtYXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgd3JhcHBlZEFyZ3MgPSBhcmdUeXBlcy5tYXAoZnVuY3Rpb24gKHR5cGVOYW1lLCBpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcmdzW2ldO1xuXG4gICAgICBpZiAobWFwW3R5cGVOYW1lXSkge1xuICAgICAgICByZXR1cm4gbWFwW3R5cGVOYW1lXSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcblxuICAgIHJldHVybiBmbi5hcHBseSh1bmRlZmluZWQsIF90b0NvbnN1bWFibGVBcnJheSh3cmFwcGVkQXJncykpO1xuICB9O1xufTtcblxudmFyIGNsb25lID0gZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufTtcblxudmFyIHdyYXBOb2RlcyA9IGZ1bmN0aW9uIHdyYXBOb2RlcyhfZm4pIHtcbiAgdmFyIGZuYW1lcyA9IE9iamVjdC5rZXlzKF9mbik7XG5cbiAgdmFyIHdyYXBwZWRGbiA9IGZ1bmN0aW9uIHdyYXBwZWRGbihyb290LCBfbm9kZSwgZm5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnVuYyA9IF9mbltmbmFtZV07XG4gICAgICB2YXIgZGVmID0gZnVuYy5kZWYgfHwge307XG4gICAgICB2YXIgYXJnVHlwZXMgPSBkZWYgJiYgQXJyYXkuaXNBcnJheShkZWYuYXJnVHlwZXMpID8gZGVmLmFyZ1R5cGVzIDogW107XG5cbiAgICAgIHZhciBmaXJzdE5vZGUgPSBmYWxzZTtcblxuICAgICAgdmFyIGN1cnJ5TWFwID0ge1xuICAgICAgICBmbjogZnVuY3Rpb24gZm4oKSB7XG4gICAgICAgICAgcmV0dXJuIF9mbjtcbiAgICAgICAgfSxcbiAgICAgICAgcm9vdE5vZGU6IGZ1bmN0aW9uIHJvb3ROb2RlKCkge1xuICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9LFxuICAgICAgICBub2RlOiBmdW5jdGlvbiBub2RlKCkge1xuICAgICAgICAgIGlmICghZmlyc3ROb2RlKSB7XG4gICAgICAgICAgICBmaXJzdE5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIF9ub2RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhcmdzLnNoaWZ0KCkuZ2V0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFueTogZnVuY3Rpb24gYW55KCkge1xuICAgICAgICAgIHJldHVybiBhcmdzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBhcmdNYXAgPSB7XG4gICAgICAgIHJvb3ROb2RlOiBmdW5jdGlvbiByb290Tm9kZShuKSB7XG4gICAgICAgICAgcmV0dXJuIHdyYXBwZWROb2RlKHJvb3QsIG4pO1xuICAgICAgICB9LFxuICAgICAgICBub2RlOiBmdW5jdGlvbiBub2RlKG4pIHtcbiAgICAgICAgICByZXR1cm4gd3JhcHBlZE5vZGUocm9vdCwgbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBjdXJyaWVkID0gYXJnVHlwZXMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmIChjdXJyeU1hcFt0XSkgcmV0dXJuIGN1cnJ5TWFwW3RdKCk7XG5cbiAgICAgICAgaWYgKHQuaW5kZXhPZignPT4nKSAhPT0gLTEpIHtcbiAgICAgICAgICB2YXIgX2RlZiA9IHNpZ25hdHVyZVRvRGVmKHQpO1xuICAgICAgICAgIHZhciBmbkFyZyA9IGFyZ3Muc2hpZnQoKTtcblxuICAgICAgICAgIHJldHVybiBhcmdzTWFwKGZuQXJnLCBfZGVmLmFyZ1R5cGVzLCBhcmdNYXApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1cnJ5TWFwLmFueSgpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgX3RvQ29uc3VtYWJsZUFycmF5KGN1cnJpZWQpKTtcblxuICAgICAgaWYgKGRlZi5yZXR1cm5UeXBlID09PSAnbm9kZScpIHtcbiAgICAgICAgcmVzdWx0ID0gd3JhcHBlZE5vZGUocm9vdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAoZGVmLnJldHVyblR5cGUgPT09ICdbbm9kZV0nKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gd3JhcHBlZE5vZGUocm9vdCwgbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgdmFyIHdyYXBwZWROb2RlID0gZnVuY3Rpb24gd3JhcHBlZE5vZGUocm9vdCwgbm9kZSkge1xuICAgIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG5vZGU7XG5cbiAgICB2YXIgd3JhcHBlZCA9IGZuYW1lcy5yZWR1Y2UoZnVuY3Rpb24gKHdyYXBwZWROb2RlLCBmbmFtZSkge1xuICAgICAgd3JhcHBlZE5vZGVbZm5hbWVdID0gd3JhcHBlZEZuKHJvb3QsIG5vZGUsIGZuYW1lKTtcblxuICAgICAgcmV0dXJuIHdyYXBwZWROb2RlO1xuICAgIH0sIHt9KTtcblxuICAgIHdyYXBwZWQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICB3cmFwcGVkLmdldFJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9O1xuXG4gICAgLy8gYXNzaXN0IHdpdGggZGVidWdnaW5nXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdyYXBwZWQsICdfdmFsdWUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lKF9mbi52YWx1ZShub2RlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdyYXBwZWQsICdfY2hpbGRyZW4nLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lKF9mbi5nZXRDaGlsZHJlbihub2RlKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gd3JhcHBlZDtcbiAgfTtcblxuICB2YXIgY3JlYXRlVHJlZSA9IGZ1bmN0aW9uIGNyZWF0ZVRyZWUocm9vdCkge1xuICAgIHJldHVybiB3cmFwcGVkTm9kZShyb290LCByb290KTtcbiAgfTtcblxuICBjcmVhdGVUcmVlLmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydub2RlVmFsdWUnXSxcbiAgICByZXR1cm5UeXBlOiAnd3JhcHBlZE5vZGUnLFxuICAgIHJlcXVpcmVzOiBbJ2NyZWF0ZU5vZGUnXSxcbiAgICBjYXRlZ29yaWVzOiBbJ3dyYXBwZWQtbm9kZXMnLCAncGx1Z2luJ11cbiAgfTtcblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihfZm4sIHsgY3JlYXRlVHJlZTogY3JlYXRlVHJlZSB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gd3JhcE5vZGVzOyIsIid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQtZGlzYWJsZSAqL1xuaWYgKCFBcnJheS5wcm90b3R5cGUuaW5jbHVkZXMpIHtcbiAgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCovKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIE8gPSBPYmplY3QodGhpcyk7XG4gICAgdmFyIGxlbiA9IHBhcnNlSW50KE8ubGVuZ3RoKSB8fCAwO1xuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG4gPSBwYXJzZUludChhcmd1bWVudHNbMV0pIHx8IDA7XG4gICAgdmFyIGs7XG4gICAgaWYgKG4gPj0gMCkge1xuICAgICAgayA9IG47XG4gICAgfSBlbHNlIHtcbiAgICAgIGsgPSBsZW4gKyBuO1xuICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY3VycmVudEVsZW1lbnQ7XG4gICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgIGN1cnJlbnRFbGVtZW50ID0gT1trXTtcbiAgICAgIGlmIChzZWFyY2hFbGVtZW50ID09PSBjdXJyZW50RWxlbWVudCB8fCBzZWFyY2hFbGVtZW50ICE9PSBzZWFyY2hFbGVtZW50ICYmIGN1cnJlbnRFbGVtZW50ICE9PSBjdXJyZW50RWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGsrKztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufVxuLyplc2xpbnQtZW5hYmxlICovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdG9hIChhLCBuKSB7IHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhLCBuKTsgfVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdHRydWVGdW5jOiBmdW5jdGlvbiB0cnVlRnVuYygpe1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRmYWxzZUZ1bmM6IGZ1bmN0aW9uIGZhbHNlRnVuYygpe1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTsiLCIiLCIndXNlIHN0cmljdCc7XG5cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKTtcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyO1xudmFyIFNsb3dCdWZmZXIgPSBidWZmZXIuU2xvd0J1ZmZlcjtcbnZhciBNQVhfTEVOID0gYnVmZmVyLmtNYXhMZW5ndGggfHwgMjE0NzQ4MzY0NztcbmV4cG9ydHMuYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpO1xuICB9XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBub3QgYmUgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID4gTUFYX0xFTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIHZhciBlbmMgPSBlbmNvZGluZztcbiAgdmFyIF9maWxsID0gZmlsbDtcbiAgaWYgKF9maWxsID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmMgPSB1bmRlZmluZWQ7XG4gICAgX2ZpbGwgPSAwO1xuICB9XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHNpemUpO1xuICBpZiAodHlwZW9mIF9maWxsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBmaWxsQnVmID0gbmV3IEJ1ZmZlcihfZmlsbCwgZW5jKTtcbiAgICB2YXIgZmxlbiA9IGZpbGxCdWYubGVuZ3RoO1xuICAgIHZhciBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IHNpemUpIHtcbiAgICAgIGJ1ZltpXSA9IGZpbGxCdWZbaSAlIGZsZW5dO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbChfZmlsbCk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cbmV4cG9ydHMuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiBhbGxvY1Vuc2FmZShzaXplKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jVW5zYWZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHNpemUgPiBNQVhfTEVOKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpemUgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG59XG5leHBvcnRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuZnJvbSA9PT0gJ2Z1bmN0aW9uJyAmJiAoIWdsb2JhbC5VaW50OEFycmF5IHx8IFVpbnQ4QXJyYXkuZnJvbSAhPT0gQnVmZmVyLmZyb20pKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHZhciBvZmZzZXQgPSBlbmNvZGluZ09yT2Zmc2V0O1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgdmFyIGxlbiA9IGxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGxlbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxlbiA9IHZhbHVlLmJ5dGVMZW5ndGggLSBvZmZzZXQ7XG4gICAgfVxuICAgIGlmIChvZmZzZXQgPj0gdmFsdWUuYnl0ZUxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmIChsZW4gPiB2YWx1ZS5ieXRlTGVuZ3RoIC0gb2Zmc2V0KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pKTtcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHZhciBvdXQgPSBuZXcgQnVmZmVyKHZhbHVlLmxlbmd0aCk7XG4gICAgdmFsdWUuY29weShvdXQsIDAsIDAsIHZhbHVlLmxlbmd0aCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlLmRhdGEpKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZS5kYXRhKTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsICcgKyAnQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKTtcbn1cbmV4cG9ydHMuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gYWxsb2NVbnNhZmVTbG93KHNpemUpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3coc2l6ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID49IE1BWF9MRU4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICByZXR1cm4gbmV3IFNsb3dCdWZmZXIoc2l6ZSk7XG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0aWNreSA9IHJlcXVpcmUoJ3RpY2t5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVib3VuY2UgKGZuLCBhcmdzLCBjdHgpIHtcbiAgaWYgKCFmbikgeyByZXR1cm47IH1cbiAgdGlja3koZnVuY3Rpb24gcnVuICgpIHtcbiAgICBmbi5hcHBseShjdHggfHwgbnVsbCwgYXJncyB8fCBbXSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGF0b2EgPSByZXF1aXJlKCdhdG9hJyk7XG52YXIgZGVib3VuY2UgPSByZXF1aXJlKCcuL2RlYm91bmNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW1pdHRlciAodGhpbmcsIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgZXZ0ID0ge307XG4gIGlmICh0aGluZyA9PT0gdW5kZWZpbmVkKSB7IHRoaW5nID0ge307IH1cbiAgdGhpbmcub24gPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgICBpZiAoIWV2dFt0eXBlXSkge1xuICAgICAgZXZ0W3R5cGVdID0gW2ZuXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZ0W3R5cGVdLnB1c2goZm4pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpbmc7XG4gIH07XG4gIHRoaW5nLm9uY2UgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgICBmbi5fb25jZSA9IHRydWU7IC8vIHRoaW5nLm9mZihmbikgc3RpbGwgd29ya3MhXG4gICAgdGhpbmcub24odHlwZSwgZm4pO1xuICAgIHJldHVybiB0aGluZztcbiAgfTtcbiAgdGhpbmcub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChjID09PSAxKSB7XG4gICAgICBkZWxldGUgZXZ0W3R5cGVdO1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gMCkge1xuICAgICAgZXZ0ID0ge307XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBldCA9IGV2dFt0eXBlXTtcbiAgICAgIGlmICghZXQpIHsgcmV0dXJuIHRoaW5nOyB9XG4gICAgICBldC5zcGxpY2UoZXQuaW5kZXhPZihmbiksIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpbmc7XG4gIH07XG4gIHRoaW5nLmVtaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBhdG9hKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaW5nLmVtaXR0ZXJTbmFwc2hvdChhcmdzLnNoaWZ0KCkpLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xuICB0aGluZy5lbWl0dGVyU25hcHNob3QgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBldCA9IChldnRbdHlwZV0gfHwgW10pLnNsaWNlKDApO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IGF0b2EoYXJndW1lbnRzKTtcbiAgICAgIHZhciBjdHggPSB0aGlzIHx8IHRoaW5nO1xuICAgICAgaWYgKHR5cGUgPT09ICdlcnJvcicgJiYgb3B0cy50aHJvd3MgIT09IGZhbHNlICYmICFldC5sZW5ndGgpIHsgdGhyb3cgYXJncy5sZW5ndGggPT09IDEgPyBhcmdzWzBdIDogYXJnczsgfVxuICAgICAgZXQuZm9yRWFjaChmdW5jdGlvbiBlbWl0dGVyIChsaXN0ZW4pIHtcbiAgICAgICAgaWYgKG9wdHMuYXN5bmMpIHsgZGVib3VuY2UobGlzdGVuLCBhcmdzLCBjdHgpOyB9IGVsc2UgeyBsaXN0ZW4uYXBwbHkoY3R4LCBhcmdzKTsgfVxuICAgICAgICBpZiAobGlzdGVuLl9vbmNlKSB7IHRoaW5nLm9mZih0eXBlLCBsaXN0ZW4pOyB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGluZztcbiAgICB9O1xuICB9O1xuICByZXR1cm4gdGhpbmc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VzdG9tRXZlbnQgPSByZXF1aXJlKCdjdXN0b20tZXZlbnQnKTtcbnZhciBldmVudG1hcCA9IHJlcXVpcmUoJy4vZXZlbnRtYXAnKTtcbnZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG52YXIgYWRkRXZlbnQgPSBhZGRFdmVudEVhc3k7XG52YXIgcmVtb3ZlRXZlbnQgPSByZW1vdmVFdmVudEVhc3k7XG52YXIgaGFyZENhY2hlID0gW107XG5cbmlmICghZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgYWRkRXZlbnQgPSBhZGRFdmVudEhhcmQ7XG4gIHJlbW92ZUV2ZW50ID0gcmVtb3ZlRXZlbnRIYXJkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkOiBhZGRFdmVudCxcbiAgcmVtb3ZlOiByZW1vdmVFdmVudCxcbiAgZmFicmljYXRlOiBmYWJyaWNhdGVFdmVudFxufTtcblxuZnVuY3Rpb24gYWRkRXZlbnRFYXN5IChlbCwgdHlwZSwgZm4sIGNhcHR1cmluZykge1xuICByZXR1cm4gZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgY2FwdHVyaW5nKTtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRIYXJkIChlbCwgdHlwZSwgZm4pIHtcbiAgcmV0dXJuIGVsLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCB3cmFwKGVsLCB0eXBlLCBmbikpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVFdmVudEVhc3kgKGVsLCB0eXBlLCBmbiwgY2FwdHVyaW5nKSB7XG4gIHJldHVybiBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBjYXB0dXJpbmcpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVFdmVudEhhcmQgKGVsLCB0eXBlLCBmbikge1xuICB2YXIgbGlzdGVuZXIgPSB1bndyYXAoZWwsIHR5cGUsIGZuKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIGVsLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmFicmljYXRlRXZlbnQgKGVsLCB0eXBlLCBtb2RlbCkge1xuICB2YXIgZSA9IGV2ZW50bWFwLmluZGV4T2YodHlwZSkgPT09IC0xID8gbWFrZUN1c3RvbUV2ZW50KCkgOiBtYWtlQ2xhc3NpY0V2ZW50KCk7XG4gIGlmIChlbC5kaXNwYXRjaEV2ZW50KSB7XG4gICAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5maXJlRXZlbnQoJ29uJyArIHR5cGUsIGUpO1xuICB9XG4gIGZ1bmN0aW9uIG1ha2VDbGFzc2ljRXZlbnQgKCkge1xuICAgIHZhciBlO1xuICAgIGlmIChkb2MuY3JlYXRlRXZlbnQpIHtcbiAgICAgIGUgPSBkb2MuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGRvYy5jcmVhdGVFdmVudE9iamVjdCkge1xuICAgICAgZSA9IGRvYy5jcmVhdGVFdmVudE9iamVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxuICBmdW5jdGlvbiBtYWtlQ3VzdG9tRXZlbnQgKCkge1xuICAgIHJldHVybiBuZXcgY3VzdG9tRXZlbnQodHlwZSwgeyBkZXRhaWw6IG1vZGVsIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdyYXBwZXJGYWN0b3J5IChlbCwgdHlwZSwgZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXBwZXIgKG9yaWdpbmFsRXZlbnQpIHtcbiAgICB2YXIgZSA9IG9yaWdpbmFsRXZlbnQgfHwgZ2xvYmFsLmV2ZW50O1xuICAgIGUudGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgIGUucHJldmVudERlZmF1bHQgPSBlLnByZXZlbnREZWZhdWx0IHx8IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0ICgpIHsgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlOyB9O1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uID0gZS5zdG9wUHJvcGFnYXRpb24gfHwgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uICgpIHsgZS5jYW5jZWxCdWJibGUgPSB0cnVlOyB9O1xuICAgIGUud2hpY2ggPSBlLndoaWNoIHx8IGUua2V5Q29kZTtcbiAgICBmbi5jYWxsKGVsLCBlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gd3JhcCAoZWwsIHR5cGUsIGZuKSB7XG4gIHZhciB3cmFwcGVyID0gdW53cmFwKGVsLCB0eXBlLCBmbikgfHwgd3JhcHBlckZhY3RvcnkoZWwsIHR5cGUsIGZuKTtcbiAgaGFyZENhY2hlLnB1c2goe1xuICAgIHdyYXBwZXI6IHdyYXBwZXIsXG4gICAgZWxlbWVudDogZWwsXG4gICAgdHlwZTogdHlwZSxcbiAgICBmbjogZm5cbiAgfSk7XG4gIHJldHVybiB3cmFwcGVyO1xufVxuXG5mdW5jdGlvbiB1bndyYXAgKGVsLCB0eXBlLCBmbikge1xuICB2YXIgaSA9IGZpbmQoZWwsIHR5cGUsIGZuKTtcbiAgaWYgKGkpIHtcbiAgICB2YXIgd3JhcHBlciA9IGhhcmRDYWNoZVtpXS53cmFwcGVyO1xuICAgIGhhcmRDYWNoZS5zcGxpY2UoaSwgMSk7IC8vIGZyZWUgdXAgYSB0YWQgb2YgbWVtb3J5XG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZCAoZWwsIHR5cGUsIGZuKSB7XG4gIHZhciBpLCBpdGVtO1xuICBmb3IgKGkgPSAwOyBpIDwgaGFyZENhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgaXRlbSA9IGhhcmRDYWNoZVtpXTtcbiAgICBpZiAoaXRlbS5lbGVtZW50ID09PSBlbCAmJiBpdGVtLnR5cGUgPT09IHR5cGUgJiYgaXRlbS5mbiA9PT0gZm4pIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRtYXAgPSBbXTtcbnZhciBldmVudG5hbWUgPSAnJztcbnZhciByb24gPSAvXm9uLztcblxuZm9yIChldmVudG5hbWUgaW4gZ2xvYmFsKSB7XG4gIGlmIChyb24udGVzdChldmVudG5hbWUpKSB7XG4gICAgZXZlbnRtYXAucHVzaChldmVudG5hbWUuc2xpY2UoMikpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXZlbnRtYXA7XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBhZGFwdGVyRmFjdG9yeTtcblxuZnVuY3Rpb24gYWRhcHRlckZhY3RvcnkoaW1wbGVtZW50YXRpb24pe1xuXHRlbnN1cmVJbXBsZW1lbnRhdGlvbihpbXBsZW1lbnRhdGlvbik7XG5cblx0dmFyIGFkYXB0ZXIgPSB7fVxuXG5cdHZhciBiYXNlQWRhcHRlciA9IHtcblx0XHRyZW1vdmVTdWJzZXRzOiBmdW5jdGlvbiAobm9kZXMpe1xuXHRcdFx0cmV0dXJuIHJlbW92ZVN1YnNldHMoYWRhcHRlciwgbm9kZXMpO1xuXHRcdH0sXG5cdFx0ZXhpc3RzT25lOiBmdW5jdGlvbih0ZXN0LCBlbGVtcyl7XG5cdFx0XHRyZXR1cm4gZXhpc3RzT25lKGFkYXB0ZXIsIHRlc3QsIGVsZW1zKTtcblx0XHR9LFxuXHRcdGdldFNpYmxpbmdzOiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdHJldHVybiBnZXRTaWJsaW5ncyhhZGFwdGVyLCBlbGVtKTtcblx0XHR9LFxuXHRcdGhhc0F0dHJpYjogZnVuY3Rpb24oZWxlbSwgbmFtZSl7XG5cdFx0XHRyZXR1cm4gaGFzQXR0cmliKGFkYXB0ZXIsIGVsZW0sIG5hbWUpO1xuXHRcdH0sXG5cdFx0ZmluZE9uZTogZnVuY3Rpb24odGVzdCwgYXJyKXtcblx0XHRcdHJldHVybiBmaW5kT25lKGFkYXB0ZXIsIHRlc3QsIGFycik7XG5cdFx0fSxcblx0XHRmaW5kQWxsOiBmdW5jdGlvbih0ZXN0LCBlbGVtcyl7XG5cdFx0XHRyZXR1cm4gZmluZEFsbChhZGFwdGVyLCB0ZXN0LCBlbGVtcylcblx0XHR9XG5cdH07XG5cblx0T2JqZWN0LmFzc2lnbihhZGFwdGVyLCBiYXNlQWRhcHRlciwgaW1wbGVtZW50YXRpb24pO1xuXG5cdHJldHVybiBhZGFwdGVyO1xufVxuXG52YXIgZXhwZWN0SW1wbGVtZW50ZWQgPSBbXG5cdFwiaXNUYWdcIiwgXCJnZXRBdHRyaWJ1dGVWYWx1ZVwiLCBcImdldENoaWxkcmVuXCIsIFwiZ2V0TmFtZVwiLCBcImdldFBhcmVudFwiLFxuXHRcImdldFRleHRcIlxuXTtcblxuZnVuY3Rpb24gZW5zdXJlSW1wbGVtZW50YXRpb24oaW1wbGVtZW50YXRpb24pe1xuXHRpZighaW1wbGVtZW50YXRpb24pXHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgaW1wbGVtZW50YXRpb25cIilcblxuXHR2YXIgbm90SW1wbGVtZW50ZWQgPSBleHBlY3RJbXBsZW1lbnRlZC5maWx0ZXIoZnVuY3Rpb24oZm5hbWUpe1xuXHRcdHJldHVybiB0eXBlb2YgaW1wbGVtZW50YXRpb25bZm5hbWVdICE9PSBcImZ1bmN0aW9uXCI7XG5cdH0pO1xuXG5cdGlmKG5vdEltcGxlbWVudGVkLmxlbmd0aCl7XG5cdFx0dmFyIG5vdExpc3QgPSBcIihcIiArIG5vdEltcGxlbWVudGVkLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuXHRcdHZhciBtZXNzYWdlID0gXCJFeHBlY3RlZCBmdW5jdGlvbnMgXCIgKyBub3RMaXN0ICsgXCIgdG8gYmUgaW1wbGVtZW50ZWRcIjtcblx0XHR0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3Vic2V0cyhhZGFwdGVyLCBub2Rlcyl7XG5cdHZhciBpZHggPSBub2Rlcy5sZW5ndGgsIG5vZGUsIGFuY2VzdG9yLCByZXBsYWNlO1xuXG5cdC8vIENoZWNrIGlmIGVhY2ggbm9kZSAob3Igb25lIG9mIGl0cyBhbmNlc3RvcnMpIGlzIGFscmVhZHkgY29udGFpbmVkIGluIHRoZVxuXHQvLyBhcnJheS5cblx0d2hpbGUoLS1pZHggPiAtMSl7XG5cdFx0bm9kZSA9IGFuY2VzdG9yID0gbm9kZXNbaWR4XTtcblxuXHRcdC8vIFRlbXBvcmFyaWx5IHJlbW92ZSB0aGUgbm9kZSB1bmRlciBjb25zaWRlcmF0aW9uXG5cdFx0bm9kZXNbaWR4XSA9IG51bGw7XG5cdFx0cmVwbGFjZSA9IHRydWU7XG5cblx0XHR3aGlsZShhbmNlc3Rvcil7XG5cdFx0XHRpZihub2Rlcy5pbmRleE9mKGFuY2VzdG9yKSA+IC0xKXtcblx0XHRcdFx0cmVwbGFjZSA9IGZhbHNlO1xuXHRcdFx0XHRub2Rlcy5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRhbmNlc3RvciA9IGFkYXB0ZXIuZ2V0UGFyZW50KGFuY2VzdG9yKVxuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBub2RlIGhhcyBiZWVuIGZvdW5kIHRvIGJlIHVuaXF1ZSwgcmUtaW5zZXJ0IGl0LlxuXHRcdGlmKHJlcGxhY2Upe1xuXHRcdFx0bm9kZXNbaWR4XSA9IG5vZGU7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5vZGVzO1xufVxuXG5mdW5jdGlvbiBleGlzdHNPbmUoYWRhcHRlciwgdGVzdCwgZWxlbXMpe1xuXHRyZXR1cm4gZWxlbXMuc29tZShmdW5jdGlvbihlbGVtKXtcblx0XHRyZXR1cm4gYWRhcHRlci5pc1RhZyhlbGVtKSA/XG5cdFx0XHR0ZXN0KGVsZW0pIHx8IGFkYXB0ZXIuZXhpc3RzT25lKHRlc3QsIGFkYXB0ZXIuZ2V0Q2hpbGRyZW4oZWxlbSkpIDpcblx0XHRcdGZhbHNlO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2libGluZ3MoYWRhcHRlciwgZWxlbSl7XG5cdHZhciBwYXJlbnQgPSBhZGFwdGVyLmdldFBhcmVudChlbGVtKTtcblx0cmV0dXJuIHBhcmVudCAmJiBhZGFwdGVyLmdldENoaWxkcmVuKHBhcmVudCk7XG59XG5cblxuZnVuY3Rpb24gaGFzQXR0cmliKGFkYXB0ZXIsIGVsZW0sIG5hbWUpe1xuXHRyZXR1cm4gYWRhcHRlci5nZXRBdHRyaWJ1dGVWYWx1ZShlbGVtLG5hbWUpICE9PSB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gZmluZE9uZShhZGFwdGVyLCB0ZXN0LCBhcnIpe1xuXHR2YXIgZWxlbSA9IG51bGw7XG5cblx0Zm9yKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsICYmICFlbGVtOyBpKyspe1xuXHRcdGlmKHRlc3QoYXJyW2ldKSl7XG5cdFx0XHRlbGVtID0gYXJyW2ldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY2hpbGRzID0gYWRhcHRlci5nZXRDaGlsZHJlbihhcnJbaV0pO1xuXHRcdFx0aWYoY2hpbGRzICYmIGNoaWxkcy5sZW5ndGggPiAwKXtcblx0XHRcdFx0ZWxlbSA9IGFkYXB0ZXIuZmluZE9uZSh0ZXN0LCBjaGlsZHMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBmaW5kQWxsKGFkYXB0ZXIsIHRlc3QsIGVsZW1zKXtcblx0dmFyIHJlc3VsdCA9IFtdO1xuXG5cdGZvcih2YXIgaSA9IDAsIGogPSBlbGVtcy5sZW5ndGg7IGkgPCBqOyBpKyspe1xuXHRcdGlmKCFhZGFwdGVyLmlzVGFnKGVsZW1zW2ldKSkgY29udGludWU7XG5cdFx0aWYodGVzdChlbGVtc1tpXSkpIHJlc3VsdC5wdXNoKGVsZW1zW2ldKTtcblx0XHR2YXIgY2hpbGRzID0gYWRhcHRlci5nZXRDaGlsZHJlbihlbGVtc1tpXSk7XG5cdFx0aWYoY2hpbGRzKSByZXN1bHQgPSByZXN1bHQuY29uY2F0KGFkYXB0ZXIuZmluZEFsbCh0ZXN0LCBjaGlsZHMpKTtcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBDU1NzZWxlY3Q7XG5cbnZhciBEb21VdGlscyAgICAgICA9IHJlcXVpcmUoXCJkb211dGlsc1wiKSxcblx0ZmFsc2VGdW5jICAgICAgPSByZXF1aXJlKFwiYm9vbGJhc2VcIikuZmFsc2VGdW5jLFxuXHRjb21waWxlRmFjdG9yeSA9IHJlcXVpcmUoXCIuL2xpYi9jb21waWxlLmpzXCIpLFxuXHRkZWZhdWx0Q29tcGlsZSA9IGNvbXBpbGVGYWN0b3J5KERvbVV0aWxzKTtcblxuZnVuY3Rpb24gYWRhcHRlckNvbXBpbGUoYWRhcHRlcil7XG5cdHJldHVybiBhZGFwdGVyID09PSBEb21VdGlscyA/IGRlZmF1bHRDb21waWxlIDogY29tcGlsZUZhY3RvcnkoYWRhcHRlcik7XG59XG5cbmZ1bmN0aW9uIGdldFNlbGVjdG9yRnVuYyhzZWFyY2hGdW5jKXtcblx0cmV0dXJuIGZ1bmN0aW9uIHNlbGVjdChxdWVyeSwgZWxlbXMsIG9wdGlvbnMpe1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cdFx0b3B0aW9ucy5hZGFwdGVyID0gb3B0aW9ucy5hZGFwdGVyIHx8IERvbVV0aWxzO1xuXHRcdHZhciBjb21waWxlID0gYWRhcHRlckNvbXBpbGUob3B0aW9ucy5hZGFwdGVyKTtcblxuXHRcdGlmKHR5cGVvZiBxdWVyeSAhPT0gXCJmdW5jdGlvblwiKSBxdWVyeSA9IGNvbXBpbGUuY29tcGlsZVVuc2FmZShxdWVyeSwgb3B0aW9ucywgZWxlbXMpO1xuXHRcdGlmKHF1ZXJ5LnNob3VsZFRlc3ROZXh0U2libGluZ3MpIGVsZW1zID0gYXBwZW5kTmV4dFNpYmxpbmdzKChvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCkgfHwgZWxlbXMsIG9wdGlvbnMuYWRhcHRlcik7XG5cdFx0aWYoIUFycmF5LmlzQXJyYXkoZWxlbXMpKSBlbGVtcyA9IG9wdGlvbnMuYWRhcHRlci5nZXRDaGlsZHJlbihlbGVtcyk7XG5cdFx0ZWxzZSBlbGVtcyA9IG9wdGlvbnMuYWRhcHRlci5yZW1vdmVTdWJzZXRzKGVsZW1zKTtcblx0XHRyZXR1cm4gc2VhcmNoRnVuYyhxdWVyeSwgZWxlbXMsIG9wdGlvbnMpO1xuXHR9O1xufVxuXG5mdW5jdGlvbiBnZXROZXh0U2libGluZ3MoZWxlbSwgYWRhcHRlcil7XG5cdHZhciBzaWJsaW5ncyA9IGFkYXB0ZXIuZ2V0U2libGluZ3MoZWxlbSk7XG5cdGlmKCFBcnJheS5pc0FycmF5KHNpYmxpbmdzKSkgcmV0dXJuIFtdO1xuXHRzaWJsaW5ncyA9IHNpYmxpbmdzLnNsaWNlKDApO1xuXHR3aGlsZShzaWJsaW5ncy5zaGlmdCgpICE9PSBlbGVtKTtcblx0cmV0dXJuIHNpYmxpbmdzO1xufVxuXG5mdW5jdGlvbiBhcHBlbmROZXh0U2libGluZ3MoZWxlbXMsIGFkYXB0ZXIpe1xuXHQvLyBPcmRlciBtYXR0ZXJzIGJlY2F1c2UgalF1ZXJ5IHNlZW1zIHRvIGNoZWNrIHRoZSBjaGlsZHJlbiBiZWZvcmUgdGhlIHNpYmxpbmdzXG5cdGlmKCFBcnJheS5pc0FycmF5KGVsZW1zKSkgZWxlbXMgPSBbZWxlbXNdO1xuXHR2YXIgbmV3RWxlbXMgPSBlbGVtcy5zbGljZSgwKTtcblxuXHRmb3IodmFyIGkgPSAwLCBsZW4gPSBlbGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG5cdFx0dmFyIG5leHRTaWJsaW5ncyA9IGdldE5leHRTaWJsaW5ncyhuZXdFbGVtc1tpXSwgYWRhcHRlcik7XG5cdFx0bmV3RWxlbXMucHVzaC5hcHBseShuZXdFbGVtcywgbmV4dFNpYmxpbmdzKTtcblx0fVxuXHRyZXR1cm4gbmV3RWxlbXM7XG59XG5cbnZhciBzZWxlY3RBbGwgPSBnZXRTZWxlY3RvckZ1bmMoZnVuY3Rpb24gc2VsZWN0QWxsKHF1ZXJ5LCBlbGVtcywgb3B0aW9ucyl7XG5cdHJldHVybiAocXVlcnkgPT09IGZhbHNlRnVuYyB8fCAhZWxlbXMgfHwgZWxlbXMubGVuZ3RoID09PSAwKSA/IFtdIDogb3B0aW9ucy5hZGFwdGVyLmZpbmRBbGwocXVlcnksIGVsZW1zKTtcbn0pO1xuXG52YXIgc2VsZWN0T25lID0gZ2V0U2VsZWN0b3JGdW5jKGZ1bmN0aW9uIHNlbGVjdE9uZShxdWVyeSwgZWxlbXMsIG9wdGlvbnMpe1xuXHRyZXR1cm4gKHF1ZXJ5ID09PSBmYWxzZUZ1bmMgfHwgIWVsZW1zIHx8IGVsZW1zLmxlbmd0aCA9PT0gMCkgPyBudWxsIDogb3B0aW9ucy5hZGFwdGVyLmZpbmRPbmUocXVlcnksIGVsZW1zKTtcbn0pO1xuXG5mdW5jdGlvbiBpcyhlbGVtLCBxdWVyeSwgb3B0aW9ucyl7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cdG9wdGlvbnMuYWRhcHRlciA9IG9wdGlvbnMuYWRhcHRlciB8fCBEb21VdGlscztcblx0dmFyIGNvbXBpbGUgPSBhZGFwdGVyQ29tcGlsZShvcHRpb25zLmFkYXB0ZXIpO1xuXHRyZXR1cm4gKHR5cGVvZiBxdWVyeSA9PT0gXCJmdW5jdGlvblwiID8gcXVlcnkgOiBjb21waWxlKHF1ZXJ5LCBvcHRpb25zKSkoZWxlbSk7XG59XG5cbi8qXG5cdHRoZSBleHBvcnRlZCBpbnRlcmZhY2VcbiovXG5mdW5jdGlvbiBDU1NzZWxlY3QocXVlcnksIGVsZW1zLCBvcHRpb25zKXtcblx0cmV0dXJuIHNlbGVjdEFsbChxdWVyeSwgZWxlbXMsIG9wdGlvbnMpO1xufVxuXG5DU1NzZWxlY3QuY29tcGlsZSA9IGRlZmF1bHRDb21waWxlO1xuQ1NTc2VsZWN0LmZpbHRlcnMgPSBkZWZhdWx0Q29tcGlsZS5Qc2V1ZG9zLmZpbHRlcnM7XG5DU1NzZWxlY3QucHNldWRvcyA9IGRlZmF1bHRDb21waWxlLlBzZXVkb3MucHNldWRvcztcblxuQ1NTc2VsZWN0LnNlbGVjdEFsbCA9IHNlbGVjdEFsbDtcbkNTU3NlbGVjdC5zZWxlY3RPbmUgPSBzZWxlY3RPbmU7XG5cbkNTU3NlbGVjdC5pcyA9IGlzO1xuXG4vL2xlZ2FjeSBtZXRob2RzIChtaWdodCBiZSByZW1vdmVkKVxuQ1NTc2VsZWN0LnBhcnNlID0gZGVmYXVsdENvbXBpbGU7XG5DU1NzZWxlY3QuaXRlcmF0ZSA9IHNlbGVjdEFsbDtcblxuLy9ob29rc1xuQ1NTc2VsZWN0Ll9jb21waWxlVW5zYWZlID0gZGVmYXVsdENvbXBpbGUuY29tcGlsZVVuc2FmZTtcbkNTU3NlbGVjdC5fY29tcGlsZVRva2VuID0gZGVmYXVsdENvbXBpbGUuY29tcGlsZVRva2VuO1xuIiwidmFyIGZhbHNlRnVuYyA9IHJlcXVpcmUoXCJib29sYmFzZVwiKS5mYWxzZUZ1bmM7XG5cbi8vaHR0cHM6Ly9naXRodWIuY29tL3NsZXZpdGhhbi9YUmVnRXhwL2Jsb2IvbWFzdGVyL3NyYy94cmVnZXhwLmpzI0w0NjlcbnZhciByZUNoYXJzID0gL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nO1xuXG5mdW5jdGlvbiBmYWN0b3J5KGFkYXB0ZXIpe1xuXHQvKlxuXHRcdGF0dHJpYnV0ZSBzZWxlY3RvcnNcblx0Ki9cblx0dmFyIGF0dHJpYnV0ZVJ1bGVzID0ge1xuXHRcdF9fcHJvdG9fXzogbnVsbCxcblx0XHRlcXVhbHM6IGZ1bmN0aW9uKG5leHQsIGRhdGEpe1xuXHRcdFx0dmFyIG5hbWUgID0gZGF0YS5uYW1lLFxuXHRcdFx0XHR2YWx1ZSA9IGRhdGEudmFsdWU7XG5cblx0XHRcdGlmKGRhdGEuaWdub3JlQ2FzZSl7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gZXF1YWxzSUMoZWxlbSl7XG5cdFx0XHRcdFx0dmFyIGF0dHIgPSBhZGFwdGVyLmdldEF0dHJpYnV0ZVZhbHVlKGVsZW0sIG5hbWUpO1xuXHRcdFx0XHRcdHJldHVybiBhdHRyICE9IG51bGwgJiYgYXR0ci50b0xvd2VyQ2FzZSgpID09PSB2YWx1ZSAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gZXF1YWxzKGVsZW0pe1xuXHRcdFx0XHRyZXR1cm4gYWRhcHRlci5nZXRBdHRyaWJ1dGVWYWx1ZShlbGVtLCBuYW1lKSA9PT0gdmFsdWUgJiYgbmV4dChlbGVtKTtcblx0XHRcdH07XG5cdFx0fSxcblx0XHRoeXBoZW46IGZ1bmN0aW9uKG5leHQsIGRhdGEpe1xuXHRcdFx0dmFyIG5hbWUgID0gZGF0YS5uYW1lLFxuXHRcdFx0XHR2YWx1ZSA9IGRhdGEudmFsdWUsXG5cdFx0XHRcdGxlbiA9IHZhbHVlLmxlbmd0aDtcblxuXHRcdFx0aWYoZGF0YS5pZ25vcmVDYXNlKXtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiBoeXBoZW5JQyhlbGVtKXtcblx0XHRcdFx0XHR2YXIgYXR0ciA9IGFkYXB0ZXIuZ2V0QXR0cmlidXRlVmFsdWUoZWxlbSwgbmFtZSk7XG5cdFx0XHRcdFx0cmV0dXJuIGF0dHIgIT0gbnVsbCAmJlxuXHRcdFx0XHRcdFx0XHQoYXR0ci5sZW5ndGggPT09IGxlbiB8fCBhdHRyLmNoYXJBdChsZW4pID09PSBcIi1cIikgJiZcblx0XHRcdFx0XHRcdFx0YXR0ci5zdWJzdHIoMCwgbGVuKS50b0xvd2VyQ2FzZSgpID09PSB2YWx1ZSAmJlxuXHRcdFx0XHRcdFx0XHRuZXh0KGVsZW0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gaHlwaGVuKGVsZW0pe1xuXHRcdFx0XHR2YXIgYXR0ciA9IGFkYXB0ZXIuZ2V0QXR0cmlidXRlVmFsdWUoZWxlbSwgbmFtZSk7XG5cdFx0XHRcdHJldHVybiBhdHRyICE9IG51bGwgJiZcblx0XHRcdFx0XHRcdGF0dHIuc3Vic3RyKDAsIGxlbikgPT09IHZhbHVlICYmXG5cdFx0XHRcdFx0XHQoYXR0ci5sZW5ndGggPT09IGxlbiB8fCBhdHRyLmNoYXJBdChsZW4pID09PSBcIi1cIikgJiZcblx0XHRcdFx0XHRcdG5leHQoZWxlbSk7XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0ZWxlbWVudDogZnVuY3Rpb24obmV4dCwgZGF0YSl7XG5cdFx0XHR2YXIgbmFtZSA9IGRhdGEubmFtZSxcblx0XHRcdFx0dmFsdWUgPSBkYXRhLnZhbHVlO1xuXG5cdFx0XHRpZigvXFxzLy50ZXN0KHZhbHVlKSl7XG5cdFx0XHRcdHJldHVybiBmYWxzZUZ1bmM7XG5cdFx0XHR9XG5cblx0XHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZShyZUNoYXJzLCBcIlxcXFwkJlwiKTtcblxuXHRcdFx0dmFyIHBhdHRlcm4gPSBcIig/Ol58XFxcXHMpXCIgKyB2YWx1ZSArIFwiKD86JHxcXFxccylcIixcblx0XHRcdFx0ZmxhZ3MgPSBkYXRhLmlnbm9yZUNhc2UgPyBcImlcIiA6IFwiXCIsXG5cdFx0XHRcdHJlZ2V4ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBlbGVtZW50KGVsZW0pe1xuXHRcdFx0XHR2YXIgYXR0ciA9IGFkYXB0ZXIuZ2V0QXR0cmlidXRlVmFsdWUoZWxlbSwgbmFtZSk7XG5cdFx0XHRcdHJldHVybiBhdHRyICE9IG51bGwgJiYgcmVnZXgudGVzdChhdHRyKSAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0fTtcblx0XHR9LFxuXHRcdGV4aXN0czogZnVuY3Rpb24obmV4dCwgZGF0YSl7XG5cdFx0XHR2YXIgbmFtZSA9IGRhdGEubmFtZTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiBleGlzdHMoZWxlbSl7XG5cdFx0XHRcdHJldHVybiBhZGFwdGVyLmhhc0F0dHJpYihlbGVtLCBuYW1lKSAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0fTtcblx0XHR9LFxuXHRcdHN0YXJ0OiBmdW5jdGlvbihuZXh0LCBkYXRhKXtcblx0XHRcdHZhciBuYW1lICA9IGRhdGEubmFtZSxcblx0XHRcdFx0dmFsdWUgPSBkYXRhLnZhbHVlLFxuXHRcdFx0XHRsZW4gPSB2YWx1ZS5sZW5ndGg7XG5cblx0XHRcdGlmKGxlbiA9PT0gMCl7XG5cdFx0XHRcdHJldHVybiBmYWxzZUZ1bmM7XG5cdFx0XHR9XG5cblx0XHRcdGlmKGRhdGEuaWdub3JlQ2FzZSl7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gc3RhcnRJQyhlbGVtKXtcblx0XHRcdFx0XHR2YXIgYXR0ciA9IGFkYXB0ZXIuZ2V0QXR0cmlidXRlVmFsdWUoZWxlbSwgbmFtZSk7XG5cdFx0XHRcdFx0cmV0dXJuIGF0dHIgIT0gbnVsbCAmJiBhdHRyLnN1YnN0cigwLCBsZW4pLnRvTG93ZXJDYXNlKCkgPT09IHZhbHVlICYmIG5leHQoZWxlbSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBzdGFydChlbGVtKXtcblx0XHRcdFx0dmFyIGF0dHIgPSBhZGFwdGVyLmdldEF0dHJpYnV0ZVZhbHVlKGVsZW0sIG5hbWUpO1xuXHRcdFx0XHRyZXR1cm4gYXR0ciAhPSBudWxsICYmIGF0dHIuc3Vic3RyKDAsIGxlbikgPT09IHZhbHVlICYmIG5leHQoZWxlbSk7XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0ZW5kOiBmdW5jdGlvbihuZXh0LCBkYXRhKXtcblx0XHRcdHZhciBuYW1lICA9IGRhdGEubmFtZSxcblx0XHRcdFx0dmFsdWUgPSBkYXRhLnZhbHVlLFxuXHRcdFx0XHRsZW4gICA9IC12YWx1ZS5sZW5ndGg7XG5cblx0XHRcdGlmKGxlbiA9PT0gMCl7XG5cdFx0XHRcdHJldHVybiBmYWxzZUZ1bmM7XG5cdFx0XHR9XG5cblx0XHRcdGlmKGRhdGEuaWdub3JlQ2FzZSl7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gZW5kSUMoZWxlbSl7XG5cdFx0XHRcdFx0dmFyIGF0dHIgPSBhZGFwdGVyLmdldEF0dHJpYnV0ZVZhbHVlKGVsZW0sIG5hbWUpO1xuXHRcdFx0XHRcdHJldHVybiBhdHRyICE9IG51bGwgJiYgYXR0ci5zdWJzdHIobGVuKS50b0xvd2VyQ2FzZSgpID09PSB2YWx1ZSAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gZW5kKGVsZW0pe1xuXHRcdFx0XHR2YXIgYXR0ciA9IGFkYXB0ZXIuZ2V0QXR0cmlidXRlVmFsdWUoZWxlbSwgbmFtZSk7XG5cdFx0XHRcdHJldHVybiBhdHRyICE9IG51bGwgJiYgYXR0ci5zdWJzdHIobGVuKSA9PT0gdmFsdWUgJiYgbmV4dChlbGVtKTtcblx0XHRcdH07XG5cdFx0fSxcblx0XHRhbnk6IGZ1bmN0aW9uKG5leHQsIGRhdGEpe1xuXHRcdFx0dmFyIG5hbWUgID0gZGF0YS5uYW1lLFxuXHRcdFx0XHR2YWx1ZSA9IGRhdGEudmFsdWU7XG5cblx0XHRcdGlmKHZhbHVlID09PSBcIlwiKXtcblx0XHRcdFx0cmV0dXJuIGZhbHNlRnVuYztcblx0XHRcdH1cblxuXHRcdFx0aWYoZGF0YS5pZ25vcmVDYXNlKXtcblx0XHRcdFx0dmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCh2YWx1ZS5yZXBsYWNlKHJlQ2hhcnMsIFwiXFxcXCQmXCIpLCBcImlcIik7XG5cblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGFueUlDKGVsZW0pe1xuXHRcdFx0XHRcdHZhciBhdHRyID0gYWRhcHRlci5nZXRBdHRyaWJ1dGVWYWx1ZShlbGVtLCBuYW1lKTtcblx0XHRcdFx0XHRyZXR1cm4gYXR0ciAhPSBudWxsICYmIHJlZ2V4LnRlc3QoYXR0cikgJiYgbmV4dChlbGVtKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGFueShlbGVtKXtcblx0XHRcdFx0dmFyIGF0dHIgPSBhZGFwdGVyLmdldEF0dHJpYnV0ZVZhbHVlKGVsZW0sIG5hbWUpO1xuXHRcdFx0XHRyZXR1cm4gYXR0ciAhPSBudWxsICYmIGF0dHIuaW5kZXhPZih2YWx1ZSkgPj0gMCAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0fTtcblx0XHR9LFxuXHRcdG5vdDogZnVuY3Rpb24obmV4dCwgZGF0YSl7XG5cdFx0XHR2YXIgbmFtZSAgPSBkYXRhLm5hbWUsXG5cdFx0XHRcdHZhbHVlID0gZGF0YS52YWx1ZTtcblxuXHRcdFx0aWYodmFsdWUgPT09IFwiXCIpe1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gbm90RW1wdHkoZWxlbSl7XG5cdFx0XHRcdFx0cmV0dXJuICEhYWRhcHRlci5nZXRBdHRyaWJ1dGVWYWx1ZShlbGVtLCBuYW1lKSAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmKGRhdGEuaWdub3JlQ2FzZSl7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gbm90SUMoZWxlbSl7XG5cdFx0XHRcdFx0dmFyIGF0dHIgPSBhZGFwdGVyLmdldEF0dHJpYnV0ZVZhbHVlKGVsZW0sIG5hbWUpO1xuXHRcdFx0XHRcdHJldHVybiBhdHRyICE9IG51bGwgJiYgYXR0ci50b0xvd2VyQ2FzZSgpICE9PSB2YWx1ZSAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gbm90KGVsZW0pe1xuXHRcdFx0XHRyZXR1cm4gYWRhcHRlci5nZXRBdHRyaWJ1dGVWYWx1ZShlbGVtLCBuYW1lKSAhPT0gdmFsdWUgJiYgbmV4dChlbGVtKTtcblx0XHRcdH07XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiB7XG5cdFx0Y29tcGlsZTogZnVuY3Rpb24obmV4dCwgZGF0YSwgb3B0aW9ucyl7XG5cdFx0XHRpZihvcHRpb25zICYmIG9wdGlvbnMuc3RyaWN0ICYmIChcblx0XHRcdFx0ZGF0YS5pZ25vcmVDYXNlIHx8IGRhdGEuYWN0aW9uID09PSBcIm5vdFwiXG5cdFx0XHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBhdHRyaWJ1dGUgc2VsZWN0b3JcIik7XG5cdFx0XHRyZXR1cm4gYXR0cmlidXRlUnVsZXNbZGF0YS5hY3Rpb25dKG5leHQsIGRhdGEpO1xuXHRcdH0sXG5cdFx0cnVsZXM6IGF0dHJpYnV0ZVJ1bGVzXG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcbiIsIi8qXG5cdGNvbXBpbGVzIGEgc2VsZWN0b3IgdG8gYW4gZXhlY3V0YWJsZSBmdW5jdGlvblxuKi9cblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlRmFjdG9yeTtcblxudmFyIHBhcnNlICAgICAgICAgID0gcmVxdWlyZShcImNzcy13aGF0XCIpLFxuXHRCYXNlRnVuY3MgICAgICA9IHJlcXVpcmUoXCJib29sYmFzZVwiKSxcblx0c29ydFJ1bGVzICAgICAgPSByZXF1aXJlKFwiLi9zb3J0LmpzXCIpLFxuXHRwcm9jZWR1cmUgICAgICA9IHJlcXVpcmUoXCIuL3Byb2NlZHVyZS5qc29uXCIpLFxuXHRydWxlc0ZhY3RvcnkgICA9IHJlcXVpcmUoXCIuL2dlbmVyYWwuanNcIiksXG5cdHBzZXVkb3NGYWN0b3J5ID0gcmVxdWlyZShcIi4vcHNldWRvcy5qc1wiKSxcblx0dHJ1ZUZ1bmMgICAgICAgPSBCYXNlRnVuY3MudHJ1ZUZ1bmMsXG5cdGZhbHNlRnVuYyAgICAgID0gQmFzZUZ1bmNzLmZhbHNlRnVuYztcblxuZnVuY3Rpb24gY29tcGlsZUZhY3RvcnkoYWRhcHRlcil7XG5cdHZhciBQc2V1ZG9zICAgICA9IHBzZXVkb3NGYWN0b3J5KGFkYXB0ZXIpLFxuXHRcdGZpbHRlcnMgICAgID0gUHNldWRvcy5maWx0ZXJzLFxuXHRcdFJ1bGVzIFx0XHRcdD0gcnVsZXNGYWN0b3J5KGFkYXB0ZXIsIFBzZXVkb3MpO1xuXG5cdGZ1bmN0aW9uIGNvbXBpbGUoc2VsZWN0b3IsIG9wdGlvbnMsIGNvbnRleHQpe1xuXHRcdHZhciBuZXh0ID0gY29tcGlsZVVuc2FmZShzZWxlY3Rvciwgb3B0aW9ucywgY29udGV4dCk7XG5cdFx0cmV0dXJuIHdyYXAobmV4dCk7XG5cdH1cblxuXHRmdW5jdGlvbiB3cmFwKG5leHQpe1xuXHRcdHJldHVybiBmdW5jdGlvbiBiYXNlKGVsZW0pe1xuXHRcdFx0cmV0dXJuIGFkYXB0ZXIuaXNUYWcoZWxlbSkgJiYgbmV4dChlbGVtKTtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gY29tcGlsZVVuc2FmZShzZWxlY3Rvciwgb3B0aW9ucywgY29udGV4dCl7XG5cdFx0dmFyIHRva2VuID0gcGFyc2Uoc2VsZWN0b3IsIG9wdGlvbnMpO1xuXHRcdHJldHVybiBjb21waWxlVG9rZW4odG9rZW4sIG9wdGlvbnMsIGNvbnRleHQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5jbHVkZXNTY29wZVBzZXVkbyh0KXtcblx0XHRyZXR1cm4gdC50eXBlID09PSBcInBzZXVkb1wiICYmIChcblx0XHRcdHQubmFtZSA9PT0gXCJzY29wZVwiIHx8IChcblx0XHRcdFx0QXJyYXkuaXNBcnJheSh0LmRhdGEpICYmXG5cdFx0XHRcdHQuZGF0YS5zb21lKGZ1bmN0aW9uKGRhdGEpe1xuXHRcdFx0XHRcdHJldHVybiBkYXRhLnNvbWUoaW5jbHVkZXNTY29wZVBzZXVkbyk7XG5cdFx0XHRcdH0pXG5cdFx0XHQpXG5cdFx0KTtcblx0fVxuXG5cdHZhciBERVNDRU5EQU5UX1RPS0VOID0ge3R5cGU6IFwiZGVzY2VuZGFudFwifSxcblx0XHRGTEVYSUJMRV9ERVNDRU5EQU5UX1RPS0VOID0ge3R5cGU6IFwiX2ZsZXhpYmxlRGVzY2VuZGFudFwifSxcblx0XHRTQ09QRV9UT0tFTiA9IHt0eXBlOiBcInBzZXVkb1wiLCBuYW1lOiBcInNjb3BlXCJ9LFxuXHRcdFBMQUNFSE9MREVSX0VMRU1FTlQgPSB7fTtcblxuXHQvL0NTUyA0IFNwZWMgKERyYWZ0KTogMy4zLjEuIEFic29sdXRpemluZyBhIFNjb3BlLXJlbGF0aXZlIFNlbGVjdG9yXG5cdC8vaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzNC8jYWJzb2x1dGl6aW5nXG5cdGZ1bmN0aW9uIGFic29sdXRpemUodG9rZW4sIGNvbnRleHQpe1xuXHRcdC8vVE9ETyBiZXR0ZXIgY2hlY2sgaWYgY29udGV4dCBpcyBkb2N1bWVudFxuXHRcdHZhciBoYXNDb250ZXh0ID0gISFjb250ZXh0ICYmICEhY29udGV4dC5sZW5ndGggJiYgY29udGV4dC5ldmVyeShmdW5jdGlvbihlKXtcblx0XHRcdHJldHVybiBlID09PSBQTEFDRUhPTERFUl9FTEVNRU5UIHx8ICEhYWRhcHRlci5nZXRQYXJlbnQoZSk7XG5cdFx0fSk7XG5cblxuXHRcdHRva2VuLmZvckVhY2goZnVuY3Rpb24odCl7XG5cdFx0XHRpZih0Lmxlbmd0aCA+IDAgJiYgaXNUcmF2ZXJzYWwodFswXSkgJiYgdFswXS50eXBlICE9PSBcImRlc2NlbmRhbnRcIil7XG5cdFx0XHRcdC8vZG9uJ3QgcmV0dXJuIGluIGVsc2UgYnJhbmNoXG5cdFx0XHR9IGVsc2UgaWYoaGFzQ29udGV4dCAmJiAhaW5jbHVkZXNTY29wZVBzZXVkbyh0KSl7XG5cdFx0XHRcdHQudW5zaGlmdChERVNDRU5EQU5UX1RPS0VOKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dC51bnNoaWZ0KFNDT1BFX1RPS0VOKTtcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXBpbGVUb2tlbih0b2tlbiwgb3B0aW9ucywgY29udGV4dCl7XG5cdFx0dG9rZW4gPSB0b2tlbi5maWx0ZXIoZnVuY3Rpb24odCl7IHJldHVybiB0Lmxlbmd0aCA+IDA7IH0pO1xuXG5cdFx0dG9rZW4uZm9yRWFjaChzb3J0UnVsZXMpO1xuXG5cdFx0dmFyIGlzQXJyYXlDb250ZXh0ID0gQXJyYXkuaXNBcnJheShjb250ZXh0KTtcblxuXHRcdGNvbnRleHQgPSAob3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQpIHx8IGNvbnRleHQ7XG5cblx0XHRpZihjb250ZXh0ICYmICFpc0FycmF5Q29udGV4dCkgY29udGV4dCA9IFtjb250ZXh0XTtcblxuXHRcdGFic29sdXRpemUodG9rZW4sIGNvbnRleHQpO1xuXG5cdFx0dmFyIHNob3VsZFRlc3ROZXh0U2libGluZ3MgPSBmYWxzZTtcblxuXHRcdHZhciBxdWVyeSA9IHRva2VuXG5cdFx0XHQubWFwKGZ1bmN0aW9uKHJ1bGVzKXtcblx0XHRcdFx0aWYocnVsZXNbMF0gJiYgcnVsZXNbMV0gJiYgcnVsZXNbMF0ubmFtZSA9PT0gXCJzY29wZVwiKXtcblx0XHRcdFx0XHR2YXIgcnVsZVR5cGUgPSBydWxlc1sxXS50eXBlO1xuXHRcdFx0XHRcdGlmKGlzQXJyYXlDb250ZXh0ICYmIHJ1bGVUeXBlID09PSBcImRlc2NlbmRhbnRcIikgcnVsZXNbMV0gPSBGTEVYSUJMRV9ERVNDRU5EQU5UX1RPS0VOO1xuXHRcdFx0XHRcdGVsc2UgaWYocnVsZVR5cGUgPT09IFwiYWRqYWNlbnRcIiB8fCBydWxlVHlwZSA9PT0gXCJzaWJsaW5nXCIpIHNob3VsZFRlc3ROZXh0U2libGluZ3MgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjb21waWxlUnVsZXMocnVsZXMsIG9wdGlvbnMsIGNvbnRleHQpO1xuXHRcdFx0fSlcblx0XHRcdC5yZWR1Y2UocmVkdWNlUnVsZXMsIGZhbHNlRnVuYyk7XG5cblx0XHRxdWVyeS5zaG91bGRUZXN0TmV4dFNpYmxpbmdzID0gc2hvdWxkVGVzdE5leHRTaWJsaW5ncztcblxuXHRcdHJldHVybiBxdWVyeTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzVHJhdmVyc2FsKHQpe1xuXHRcdHJldHVybiBwcm9jZWR1cmVbdC50eXBlXSA8IDA7XG5cdH1cblxuXHRmdW5jdGlvbiBjb21waWxlUnVsZXMocnVsZXMsIG9wdGlvbnMsIGNvbnRleHQpe1xuXHRcdHJldHVybiBydWxlcy5yZWR1Y2UoZnVuY3Rpb24oZnVuYywgcnVsZSl7XG5cdFx0XHRpZihmdW5jID09PSBmYWxzZUZ1bmMpIHJldHVybiBmdW5jO1xuXHRcdFx0cmV0dXJuIFJ1bGVzW3J1bGUudHlwZV0oZnVuYywgcnVsZSwgb3B0aW9ucywgY29udGV4dCk7XG5cdFx0fSwgb3B0aW9ucyAmJiBvcHRpb25zLnJvb3RGdW5jIHx8IHRydWVGdW5jKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlZHVjZVJ1bGVzKGEsIGIpe1xuXHRcdGlmKGIgPT09IGZhbHNlRnVuYyB8fCBhID09PSB0cnVlRnVuYyl7XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9XG5cdFx0aWYoYSA9PT0gZmFsc2VGdW5jIHx8IGIgPT09IHRydWVGdW5jKXtcblx0XHRcdHJldHVybiBiO1xuXHRcdH1cblxuXHRcdHJldHVybiBmdW5jdGlvbiBjb21iaW5lKGVsZW0pe1xuXHRcdFx0cmV0dXJuIGEoZWxlbSkgfHwgYihlbGVtKTtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gY29udGFpbnNUcmF2ZXJzYWwodCl7XG5cdFx0cmV0dXJuIHQuc29tZShpc1RyYXZlcnNhbCk7XG5cdH1cblxuXHQvLzpub3QsIDpoYXMgYW5kIDptYXRjaGVzIGhhdmUgdG8gY29tcGlsZSBzZWxlY3RvcnNcblx0Ly9kb2luZyB0aGlzIGluIGxpYi9wc2V1ZG9zLmpzIHdvdWxkIGxlYWQgdG8gY2lyY3VsYXIgZGVwZW5kZW5jaWVzLFxuXHQvL3NvIHdlIGFkZCB0aGVtIGhlcmVcblx0ZmlsdGVycy5ub3QgPSBmdW5jdGlvbihuZXh0LCB0b2tlbiwgb3B0aW9ucywgY29udGV4dCl7XG5cdFx0dmFyIG9wdHMgPSB7XG5cdFx0XHR4bWxNb2RlOiAhIShvcHRpb25zICYmIG9wdGlvbnMueG1sTW9kZSksXG5cdFx0XHRzdHJpY3Q6ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5zdHJpY3QpXG5cdFx0fTtcblxuXHRcdGlmKG9wdHMuc3RyaWN0KXtcblx0XHRcdGlmKHRva2VuLmxlbmd0aCA+IDEgfHwgdG9rZW4uc29tZShjb250YWluc1RyYXZlcnNhbCkpe1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjb21wbGV4IHNlbGVjdG9ycyBpbiA6bm90IGFyZW4ndCBhbGxvd2VkIGluIHN0cmljdCBtb2RlXCIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBmdW5jID0gY29tcGlsZVRva2VuKHRva2VuLCBvcHRzLCBjb250ZXh0KTtcblxuXHRcdGlmKGZ1bmMgPT09IGZhbHNlRnVuYykgcmV0dXJuIG5leHQ7XG5cdFx0aWYoZnVuYyA9PT0gdHJ1ZUZ1bmMpICByZXR1cm4gZmFsc2VGdW5jO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0cmV0dXJuICFmdW5jKGVsZW0pICYmIG5leHQoZWxlbSk7XG5cdFx0fTtcblx0fTtcblxuXHRmaWx0ZXJzLmhhcyA9IGZ1bmN0aW9uKG5leHQsIHRva2VuLCBvcHRpb25zKXtcblx0XHR2YXIgb3B0cyA9IHtcblx0XHRcdHhtbE1vZGU6ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy54bWxNb2RlKSxcblx0XHRcdHN0cmljdDogISEob3B0aW9ucyAmJiBvcHRpb25zLnN0cmljdClcblx0XHR9O1xuXG5cdFx0Ly9GSVhNRTogVXNlcyBhbiBhcnJheSBhcyBhIHBvaW50ZXIgdG8gdGhlIGN1cnJlbnQgZWxlbWVudCAoc2lkZSBlZmZlY3RzKVxuXHRcdHZhciBjb250ZXh0ID0gdG9rZW4uc29tZShjb250YWluc1RyYXZlcnNhbCkgPyBbUExBQ0VIT0xERVJfRUxFTUVOVF0gOiBudWxsO1xuXG5cdFx0dmFyIGZ1bmMgPSBjb21waWxlVG9rZW4odG9rZW4sIG9wdHMsIGNvbnRleHQpO1xuXG5cdFx0aWYoZnVuYyA9PT0gZmFsc2VGdW5jKSByZXR1cm4gZmFsc2VGdW5jO1xuXHRcdGlmKGZ1bmMgPT09IHRydWVGdW5jKXtcblx0XHRcdHJldHVybiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdFx0cmV0dXJuIGFkYXB0ZXIuZ2V0Q2hpbGRyZW4oZWxlbSkuc29tZShhZGFwdGVyLmlzVGFnKSAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRmdW5jID0gd3JhcChmdW5jKTtcblxuXHRcdGlmKGNvbnRleHQpe1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGhhcyhlbGVtKXtcblx0XHRcdFx0cmV0dXJuIG5leHQoZWxlbSkgJiYgKFxuXHRcdFx0XHRcdChjb250ZXh0WzBdID0gZWxlbSksIGFkYXB0ZXIuZXhpc3RzT25lKGZ1bmMsIGFkYXB0ZXIuZ2V0Q2hpbGRyZW4oZWxlbSkpXG5cdFx0XHRcdCk7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiBmdW5jdGlvbiBoYXMoZWxlbSl7XG5cdFx0XHRyZXR1cm4gbmV4dChlbGVtKSAmJiBhZGFwdGVyLmV4aXN0c09uZShmdW5jLCBhZGFwdGVyLmdldENoaWxkcmVuKGVsZW0pKTtcblx0XHR9O1xuXHR9O1xuXG5cdGZpbHRlcnMubWF0Y2hlcyA9IGZ1bmN0aW9uKG5leHQsIHRva2VuLCBvcHRpb25zLCBjb250ZXh0KXtcblx0XHR2YXIgb3B0cyA9IHtcblx0XHRcdHhtbE1vZGU6ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy54bWxNb2RlKSxcblx0XHRcdHN0cmljdDogISEob3B0aW9ucyAmJiBvcHRpb25zLnN0cmljdCksXG5cdFx0XHRyb290RnVuYzogbmV4dFxuXHRcdH07XG5cblx0XHRyZXR1cm4gY29tcGlsZVRva2VuKHRva2VuLCBvcHRzLCBjb250ZXh0KTtcblx0fTtcblxuXHRjb21waWxlLmNvbXBpbGVUb2tlbiA9IGNvbXBpbGVUb2tlbjtcblx0Y29tcGlsZS5jb21waWxlVW5zYWZlID0gY29tcGlsZVVuc2FmZTtcblx0Y29tcGlsZS5Qc2V1ZG9zID0gUHNldWRvcztcblxuXHRyZXR1cm4gY29tcGlsZTtcbn1cbiIsInZhciBhdHRyaWJ1dGVGYWN0b3J5ID0gcmVxdWlyZShcIi4vYXR0cmlidXRlcy5qc1wiKTtcblxuZnVuY3Rpb24gZ2VuZXJhbEZhY3RvcnkoYWRhcHRlciwgUHNldWRvcyl7XG5cdC8qXG5cdFx0YWxsIGF2YWlsYWJsZSBydWxlc1xuXHQqL1xuXHRyZXR1cm4ge1xuXHRcdF9fcHJvdG9fXzogbnVsbCxcblxuXHRcdGF0dHJpYnV0ZTogYXR0cmlidXRlRmFjdG9yeShhZGFwdGVyKS5jb21waWxlLFxuXHRcdHBzZXVkbzogUHNldWRvcy5jb21waWxlLFxuXG5cdFx0Ly90YWdzXG5cdFx0dGFnOiBmdW5jdGlvbihuZXh0LCBkYXRhKXtcblx0XHRcdHZhciBuYW1lID0gZGF0YS5uYW1lO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHRhZyhlbGVtKXtcblx0XHRcdFx0cmV0dXJuIGFkYXB0ZXIuZ2V0TmFtZShlbGVtKSA9PT0gbmFtZSAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0Ly90cmF2ZXJzYWxcblx0XHRkZXNjZW5kYW50OiBmdW5jdGlvbihuZXh0KXtcblx0XHRcdHJldHVybiBmdW5jdGlvbiBkZXNjZW5kYW50KGVsZW0pe1xuXG5cdFx0XHRcdHZhciBmb3VuZCA9IGZhbHNlO1xuXG5cdFx0XHRcdHdoaWxlKCFmb3VuZCAmJiAoZWxlbSA9IGFkYXB0ZXIuZ2V0UGFyZW50KGVsZW0pKSl7XG5cdFx0XHRcdFx0Zm91bmQgPSBuZXh0KGVsZW0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZvdW5kO1xuXHRcdFx0fTtcblx0XHR9LFxuXHRcdF9mbGV4aWJsZURlc2NlbmRhbnQ6IGZ1bmN0aW9uKG5leHQpe1xuXHRcdFx0Ly8gSW5jbHVkZSBlbGVtZW50IGl0c2VsZiwgb25seSB1c2VkIHdoaWxlIHF1ZXJ5aW5nIGFuIGFycmF5XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gZGVzY2VuZGFudChlbGVtKXtcblxuXHRcdFx0XHR2YXIgZm91bmQgPSBuZXh0KGVsZW0pO1xuXG5cdFx0XHRcdHdoaWxlKCFmb3VuZCAmJiAoZWxlbSA9IGFkYXB0ZXIuZ2V0UGFyZW50KGVsZW0pKSl7XG5cdFx0XHRcdFx0Zm91bmQgPSBuZXh0KGVsZW0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZvdW5kO1xuXHRcdFx0fTtcblx0XHR9LFxuXHRcdHBhcmVudDogZnVuY3Rpb24obmV4dCwgZGF0YSwgb3B0aW9ucyl7XG5cdFx0XHRpZihvcHRpb25zICYmIG9wdGlvbnMuc3RyaWN0KSB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQgc2VsZWN0b3IgaXNuJ3QgcGFydCBvZiBDU1MzXCIpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcGFyZW50KGVsZW0pe1xuXHRcdFx0XHRyZXR1cm4gYWRhcHRlci5nZXRDaGlsZHJlbihlbGVtKS5zb21lKHRlc3QpO1xuXHRcdFx0fTtcblxuXHRcdFx0ZnVuY3Rpb24gdGVzdChlbGVtKXtcblx0XHRcdFx0cmV0dXJuIGFkYXB0ZXIuaXNUYWcoZWxlbSkgJiYgbmV4dChlbGVtKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGNoaWxkOiBmdW5jdGlvbihuZXh0KXtcblx0XHRcdHJldHVybiBmdW5jdGlvbiBjaGlsZChlbGVtKXtcblx0XHRcdFx0dmFyIHBhcmVudCA9IGFkYXB0ZXIuZ2V0UGFyZW50KGVsZW0pO1xuXHRcdFx0XHRyZXR1cm4gISFwYXJlbnQgJiYgbmV4dChwYXJlbnQpO1xuXHRcdFx0fTtcblx0XHR9LFxuXHRcdHNpYmxpbmc6IGZ1bmN0aW9uKG5leHQpe1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHNpYmxpbmcoZWxlbSl7XG5cdFx0XHRcdHZhciBzaWJsaW5ncyA9IGFkYXB0ZXIuZ2V0U2libGluZ3MoZWxlbSk7XG5cblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHNpYmxpbmdzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0XHRpZihhZGFwdGVyLmlzVGFnKHNpYmxpbmdzW2ldKSl7XG5cdFx0XHRcdFx0XHRpZihzaWJsaW5nc1tpXSA9PT0gZWxlbSkgYnJlYWs7XG5cdFx0XHRcdFx0XHRpZihuZXh0KHNpYmxpbmdzW2ldKSkgcmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXHRcdGFkamFjZW50OiBmdW5jdGlvbihuZXh0KXtcblx0XHRcdHJldHVybiBmdW5jdGlvbiBhZGphY2VudChlbGVtKXtcblx0XHRcdFx0dmFyIHNpYmxpbmdzID0gYWRhcHRlci5nZXRTaWJsaW5ncyhlbGVtKSxcblx0XHRcdFx0XHRsYXN0RWxlbWVudDtcblxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2libGluZ3MubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRcdGlmKGFkYXB0ZXIuaXNUYWcoc2libGluZ3NbaV0pKXtcblx0XHRcdFx0XHRcdGlmKHNpYmxpbmdzW2ldID09PSBlbGVtKSBicmVhaztcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50ID0gc2libGluZ3NbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuICEhbGFzdEVsZW1lbnQgJiYgbmV4dChsYXN0RWxlbWVudCk7XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0dW5pdmVyc2FsOiBmdW5jdGlvbihuZXh0KXtcblx0XHRcdHJldHVybiBuZXh0O1xuXHRcdH1cblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmFsRmFjdG9yeTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJ1bml2ZXJzYWxcIjogNTAsXG4gIFwidGFnXCI6IDMwLFxuICBcImF0dHJpYnV0ZVwiOiAxLFxuICBcInBzZXVkb1wiOiAwLFxuICBcImRlc2NlbmRhbnRcIjogLTEsXG4gIFwiY2hpbGRcIjogLTEsXG4gIFwicGFyZW50XCI6IC0xLFxuICBcInNpYmxpbmdcIjogLTEsXG4gIFwiYWRqYWNlbnRcIjogLTFcbn1cbiIsIi8qXG5cdHBzZXVkbyBzZWxlY3RvcnNcblxuXHQtLS1cblxuXHR0aGV5IGFyZSBhdmFpbGFibGUgaW4gdHdvIGZvcm1zOlxuXHQqIGZpbHRlcnMgY2FsbGVkIHdoZW4gdGhlIHNlbGVjdG9yXG5cdCAgaXMgY29tcGlsZWQgYW5kIHJldHVybiBhIGZ1bmN0aW9uXG5cdCAgdGhhdCBuZWVkcyB0byByZXR1cm4gbmV4dCgpXG5cdCogcHNldWRvcyBnZXQgY2FsbGVkIG9uIGV4ZWN1dGlvblxuXHQgIHRoZXkgbmVlZCB0byByZXR1cm4gYSBib29sZWFuXG4qL1xuXG52YXIgZ2V0TkNoZWNrICAgICAgICAgPSByZXF1aXJlKFwibnRoLWNoZWNrXCIpLFxuXHRCYXNlRnVuY3MgICAgICAgICA9IHJlcXVpcmUoXCJib29sYmFzZVwiKSxcblx0YXR0cmlidXRlc0ZhY3RvcnkgPSByZXF1aXJlKFwiLi9hdHRyaWJ1dGVzLmpzXCIpLFxuXHR0cnVlRnVuYyAgICAgICAgICA9IEJhc2VGdW5jcy50cnVlRnVuYyxcblx0ZmFsc2VGdW5jICAgICAgICAgPSBCYXNlRnVuY3MuZmFsc2VGdW5jO1xuXG5mdW5jdGlvbiBmaWx0ZXJzRmFjdG9yeShhZGFwdGVyKXtcblx0dmFyIGF0dHJpYnV0ZXMgID0gYXR0cmlidXRlc0ZhY3RvcnkoYWRhcHRlciksXG5cdFx0Y2hlY2tBdHRyaWIgPSBhdHRyaWJ1dGVzLnJ1bGVzLmVxdWFscztcblxuXHQvL2hlbHBlciBtZXRob2RzXG5cdGZ1bmN0aW9uIGVxdWFscyhhLCBiKXtcblx0XHRpZih0eXBlb2YgYWRhcHRlci5lcXVhbHMgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGFkYXB0ZXIuZXF1YWxzKGEsIGIpO1xuXG5cdFx0cmV0dXJuIGEgPT09IGI7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRBdHRyaWJGdW5jKG5hbWUsIHZhbHVlKXtcblx0XHR2YXIgZGF0YSA9IHtuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWV9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBhdHRyaWJGdW5jKG5leHQpe1xuXHRcdFx0cmV0dXJuIGNoZWNrQXR0cmliKG5leHQsIGRhdGEpO1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRDaGlsZEZ1bmMobmV4dCl7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0cmV0dXJuICEhYWRhcHRlci5nZXRQYXJlbnQoZWxlbSkgJiYgbmV4dChlbGVtKTtcblx0XHR9O1xuXHR9XG5cblx0dmFyIGZpbHRlcnMgPSB7XG5cdFx0Y29udGFpbnM6IGZ1bmN0aW9uKG5leHQsIHRleHQpe1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGNvbnRhaW5zKGVsZW0pe1xuXHRcdFx0XHRyZXR1cm4gbmV4dChlbGVtKSAmJiBhZGFwdGVyLmdldFRleHQoZWxlbSkuaW5kZXhPZih0ZXh0KSA+PSAwO1xuXHRcdFx0fTtcblx0XHR9LFxuXHRcdGljb250YWluczogZnVuY3Rpb24obmV4dCwgdGV4dCl7XG5cdFx0XHR2YXIgaXRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gaWNvbnRhaW5zKGVsZW0pe1xuXHRcdFx0XHRyZXR1cm4gbmV4dChlbGVtKSAmJlxuXHRcdFx0XHRcdGFkYXB0ZXIuZ2V0VGV4dChlbGVtKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoaXRleHQpID49IDA7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHQvL2xvY2F0aW9uIHNwZWNpZmljIG1ldGhvZHNcblx0XHRcIm50aC1jaGlsZFwiOiBmdW5jdGlvbihuZXh0LCBydWxlKXtcblx0XHRcdHZhciBmdW5jID0gZ2V0TkNoZWNrKHJ1bGUpO1xuXG5cdFx0XHRpZihmdW5jID09PSBmYWxzZUZ1bmMpIHJldHVybiBmdW5jO1xuXHRcdFx0aWYoZnVuYyA9PT0gdHJ1ZUZ1bmMpICByZXR1cm4gZ2V0Q2hpbGRGdW5jKG5leHQpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gbnRoQ2hpbGQoZWxlbSl7XG5cdFx0XHRcdHZhciBzaWJsaW5ncyA9IGFkYXB0ZXIuZ2V0U2libGluZ3MoZWxlbSk7XG5cblx0XHRcdFx0Zm9yKHZhciBpID0gMCwgcG9zID0gMDsgaSA8IHNpYmxpbmdzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0XHRpZihhZGFwdGVyLmlzVGFnKHNpYmxpbmdzW2ldKSl7XG5cdFx0XHRcdFx0XHRpZihzaWJsaW5nc1tpXSA9PT0gZWxlbSkgYnJlYWs7XG5cdFx0XHRcdFx0XHRlbHNlIHBvcysrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBmdW5jKHBvcykgJiYgbmV4dChlbGVtKTtcblx0XHRcdH07XG5cdFx0fSxcblx0XHRcIm50aC1sYXN0LWNoaWxkXCI6IGZ1bmN0aW9uKG5leHQsIHJ1bGUpe1xuXHRcdFx0dmFyIGZ1bmMgPSBnZXROQ2hlY2socnVsZSk7XG5cblx0XHRcdGlmKGZ1bmMgPT09IGZhbHNlRnVuYykgcmV0dXJuIGZ1bmM7XG5cdFx0XHRpZihmdW5jID09PSB0cnVlRnVuYykgIHJldHVybiBnZXRDaGlsZEZ1bmMobmV4dCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBudGhMYXN0Q2hpbGQoZWxlbSl7XG5cdFx0XHRcdHZhciBzaWJsaW5ncyA9IGFkYXB0ZXIuZ2V0U2libGluZ3MoZWxlbSk7XG5cblx0XHRcdFx0Zm9yKHZhciBwb3MgPSAwLCBpID0gc2libGluZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuXHRcdFx0XHRcdGlmKGFkYXB0ZXIuaXNUYWcoc2libGluZ3NbaV0pKXtcblx0XHRcdFx0XHRcdGlmKHNpYmxpbmdzW2ldID09PSBlbGVtKSBicmVhaztcblx0XHRcdFx0XHRcdGVsc2UgcG9zKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZ1bmMocG9zKSAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0fTtcblx0XHR9LFxuXHRcdFwibnRoLW9mLXR5cGVcIjogZnVuY3Rpb24obmV4dCwgcnVsZSl7XG5cdFx0XHR2YXIgZnVuYyA9IGdldE5DaGVjayhydWxlKTtcblxuXHRcdFx0aWYoZnVuYyA9PT0gZmFsc2VGdW5jKSByZXR1cm4gZnVuYztcblx0XHRcdGlmKGZ1bmMgPT09IHRydWVGdW5jKSAgcmV0dXJuIGdldENoaWxkRnVuYyhuZXh0KTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIG50aE9mVHlwZShlbGVtKXtcblx0XHRcdFx0dmFyIHNpYmxpbmdzID0gYWRhcHRlci5nZXRTaWJsaW5ncyhlbGVtKTtcblxuXHRcdFx0XHRmb3IodmFyIHBvcyA9IDAsIGkgPSAwOyBpIDwgc2libGluZ3MubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRcdGlmKGFkYXB0ZXIuaXNUYWcoc2libGluZ3NbaV0pKXtcblx0XHRcdFx0XHRcdGlmKHNpYmxpbmdzW2ldID09PSBlbGVtKSBicmVhaztcblx0XHRcdFx0XHRcdGlmKGFkYXB0ZXIuZ2V0TmFtZShzaWJsaW5nc1tpXSkgPT09IGFkYXB0ZXIuZ2V0TmFtZShlbGVtKSkgcG9zKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZ1bmMocG9zKSAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0fTtcblx0XHR9LFxuXHRcdFwibnRoLWxhc3Qtb2YtdHlwZVwiOiBmdW5jdGlvbihuZXh0LCBydWxlKXtcblx0XHRcdHZhciBmdW5jID0gZ2V0TkNoZWNrKHJ1bGUpO1xuXG5cdFx0XHRpZihmdW5jID09PSBmYWxzZUZ1bmMpIHJldHVybiBmdW5jO1xuXHRcdFx0aWYoZnVuYyA9PT0gdHJ1ZUZ1bmMpICByZXR1cm4gZ2V0Q2hpbGRGdW5jKG5leHQpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gbnRoTGFzdE9mVHlwZShlbGVtKXtcblx0XHRcdFx0dmFyIHNpYmxpbmdzID0gYWRhcHRlci5nZXRTaWJsaW5ncyhlbGVtKTtcblxuXHRcdFx0XHRmb3IodmFyIHBvcyA9IDAsIGkgPSBzaWJsaW5ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG5cdFx0XHRcdFx0aWYoYWRhcHRlci5pc1RhZyhzaWJsaW5nc1tpXSkpe1xuXHRcdFx0XHRcdFx0aWYoc2libGluZ3NbaV0gPT09IGVsZW0pIGJyZWFrO1xuXHRcdFx0XHRcdFx0aWYoYWRhcHRlci5nZXROYW1lKHNpYmxpbmdzW2ldKSA9PT0gYWRhcHRlci5nZXROYW1lKGVsZW0pKSBwb3MrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZnVuYyhwb3MpICYmIG5leHQoZWxlbSk7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHQvL1RPRE8gZGV0ZXJtaW5lIHRoZSBhY3R1YWwgcm9vdCBlbGVtZW50XG5cdFx0cm9vdDogZnVuY3Rpb24obmV4dCl7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHRcdHJldHVybiAhYWRhcHRlci5nZXRQYXJlbnQoZWxlbSkgJiYgbmV4dChlbGVtKTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdHNjb3BlOiBmdW5jdGlvbihuZXh0LCBydWxlLCBvcHRpb25zLCBjb250ZXh0KXtcblx0XHRcdGlmKCFjb250ZXh0IHx8IGNvbnRleHQubGVuZ3RoID09PSAwKXtcblx0XHRcdFx0Ly9lcXVpdmFsZW50IHRvIDpyb290XG5cdFx0XHRcdHJldHVybiBmaWx0ZXJzLnJvb3QobmV4dCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKGNvbnRleHQubGVuZ3RoID09PSAxKXtcblx0XHRcdFx0Ly9OT1RFOiBjYW4ndCBiZSB1bnBhY2tlZCwgYXMgOmhhcyB1c2VzIHRoaXMgZm9yIHNpZGUtZWZmZWN0c1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHRcdFx0cmV0dXJuIGVxdWFscyhjb250ZXh0WzBdLCBlbGVtKSAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmluZGV4T2YoZWxlbSkgPj0gMCAmJiBuZXh0KGVsZW0pO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0Ly9qUXVlcnkgZXh0ZW5zaW9ucyAob3RoZXJzIGZvbGxvdyBhcyBwc2V1ZG9zKVxuXHRcdGNoZWNrYm94OiBnZXRBdHRyaWJGdW5jKFwidHlwZVwiLCBcImNoZWNrYm94XCIpLFxuXHRcdGZpbGU6IGdldEF0dHJpYkZ1bmMoXCJ0eXBlXCIsIFwiZmlsZVwiKSxcblx0XHRwYXNzd29yZDogZ2V0QXR0cmliRnVuYyhcInR5cGVcIiwgXCJwYXNzd29yZFwiKSxcblx0XHRyYWRpbzogZ2V0QXR0cmliRnVuYyhcInR5cGVcIiwgXCJyYWRpb1wiKSxcblx0XHRyZXNldDogZ2V0QXR0cmliRnVuYyhcInR5cGVcIiwgXCJyZXNldFwiKSxcblx0XHRpbWFnZTogZ2V0QXR0cmliRnVuYyhcInR5cGVcIiwgXCJpbWFnZVwiKSxcblx0XHRzdWJtaXQ6IGdldEF0dHJpYkZ1bmMoXCJ0eXBlXCIsIFwic3VibWl0XCIpXG5cdH07XG5cdHJldHVybiBmaWx0ZXJzO1xufVxuXG5mdW5jdGlvbiBwc2V1ZG9zRmFjdG9yeShhZGFwdGVyKXtcblx0Ly9oZWxwZXIgbWV0aG9kc1xuXHRmdW5jdGlvbiBnZXRGaXJzdEVsZW1lbnQoZWxlbXMpe1xuXHRcdGZvcih2YXIgaSA9IDA7IGVsZW1zICYmIGkgPCBlbGVtcy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRpZihhZGFwdGVyLmlzVGFnKGVsZW1zW2ldKSkgcmV0dXJuIGVsZW1zW2ldO1xuXHRcdH1cblx0fVxuXG5cdC8vd2hpbGUgZmlsdGVycyBhcmUgcHJlY29tcGlsZWQsIHBzZXVkb3MgZ2V0IGNhbGxlZCB3aGVuIHRoZXkgYXJlIG5lZWRlZFxuXHR2YXIgcHNldWRvcyA9IHtcblx0XHRlbXB0eTogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHRyZXR1cm4gIWFkYXB0ZXIuZ2V0Q2hpbGRyZW4oZWxlbSkuc29tZShmdW5jdGlvbihlbGVtKXtcblx0XHRcdFx0cmV0dXJuIGFkYXB0ZXIuaXNUYWcoZWxlbSkgfHwgZWxlbS50eXBlID09PSBcInRleHRcIjtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcImZpcnN0LWNoaWxkXCI6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0cmV0dXJuIGdldEZpcnN0RWxlbWVudChhZGFwdGVyLmdldFNpYmxpbmdzKGVsZW0pKSA9PT0gZWxlbTtcblx0XHR9LFxuXHRcdFwibGFzdC1jaGlsZFwiOiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdHZhciBzaWJsaW5ncyA9IGFkYXB0ZXIuZ2V0U2libGluZ3MoZWxlbSk7XG5cblx0XHRcdGZvcih2YXIgaSA9IHNpYmxpbmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcblx0XHRcdFx0aWYoc2libGluZ3NbaV0gPT09IGVsZW0pIHJldHVybiB0cnVlO1xuXHRcdFx0XHRpZihhZGFwdGVyLmlzVGFnKHNpYmxpbmdzW2ldKSkgYnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdFwiZmlyc3Qtb2YtdHlwZVwiOiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdHZhciBzaWJsaW5ncyA9IGFkYXB0ZXIuZ2V0U2libGluZ3MoZWxlbSk7XG5cblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzaWJsaW5ncy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdGlmKGFkYXB0ZXIuaXNUYWcoc2libGluZ3NbaV0pKXtcblx0XHRcdFx0XHRpZihzaWJsaW5nc1tpXSA9PT0gZWxlbSkgcmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0aWYoYWRhcHRlci5nZXROYW1lKHNpYmxpbmdzW2ldKSA9PT0gYWRhcHRlci5nZXROYW1lKGVsZW0pKSBicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRcImxhc3Qtb2YtdHlwZVwiOiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdHZhciBzaWJsaW5ncyA9IGFkYXB0ZXIuZ2V0U2libGluZ3MoZWxlbSk7XG5cblx0XHRcdGZvcih2YXIgaSA9IHNpYmxpbmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcblx0XHRcdFx0aWYoYWRhcHRlci5pc1RhZyhzaWJsaW5nc1tpXSkpe1xuXHRcdFx0XHRcdGlmKHNpYmxpbmdzW2ldID09PSBlbGVtKSByZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRpZihhZGFwdGVyLmdldE5hbWUoc2libGluZ3NbaV0pID09PSBhZGFwdGVyLmdldE5hbWUoZWxlbSkpIGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdFwib25seS1vZi10eXBlXCI6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0dmFyIHNpYmxpbmdzID0gYWRhcHRlci5nZXRTaWJsaW5ncyhlbGVtKTtcblxuXHRcdFx0Zm9yKHZhciBpID0gMCwgaiA9IHNpYmxpbmdzLmxlbmd0aDsgaSA8IGo7IGkrKyl7XG5cdFx0XHRcdGlmKGFkYXB0ZXIuaXNUYWcoc2libGluZ3NbaV0pKXtcblx0XHRcdFx0XHRpZihzaWJsaW5nc1tpXSA9PT0gZWxlbSkgY29udGludWU7XG5cdFx0XHRcdFx0aWYoYWRhcHRlci5nZXROYW1lKHNpYmxpbmdzW2ldKSA9PT0gYWRhcHRlci5nZXROYW1lKGVsZW0pKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHRcIm9ubHktY2hpbGRcIjogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHR2YXIgc2libGluZ3MgPSBhZGFwdGVyLmdldFNpYmxpbmdzKGVsZW0pO1xuXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2libGluZ3MubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRpZihhZGFwdGVyLmlzVGFnKHNpYmxpbmdzW2ldKSAmJiBzaWJsaW5nc1tpXSAhPT0gZWxlbSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly86bWF0Y2hlcyhhLCBhcmVhLCBsaW5rKVtocmVmXVxuXHRcdGxpbms6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0cmV0dXJuIGFkYXB0ZXIuaGFzQXR0cmliKGVsZW0sIFwiaHJlZlwiKTtcblx0XHR9LFxuXHRcdHZpc2l0ZWQ6IGZhbHNlRnVuYywgLy9zZWVtcyB0byBiZSBhIHZhbGlkIGltcGxlbWVudGF0aW9uXG5cdFx0Ly9UT0RPOiA6YW55LWxpbmsgb25jZSB0aGUgbmFtZSBpcyBmaW5hbGl6ZWQgKGFzIGFuIGFsaWFzIG9mIDpsaW5rKVxuXG5cdFx0Ly9mb3Jtc1xuXHRcdC8vdG8gY29uc2lkZXI6IDp0YXJnZXRcblxuXHRcdC8vOm1hdGNoZXMoW3NlbGVjdGVkXSwgc2VsZWN0Om5vdChbbXVsdGlwbGVdKTpub3QoPiBvcHRpb25bc2VsZWN0ZWRdKSA+IG9wdGlvbjpmaXJzdC1vZi10eXBlKVxuXHRcdHNlbGVjdGVkOiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdGlmKGFkYXB0ZXIuaGFzQXR0cmliKGVsZW0sIFwic2VsZWN0ZWRcIikpIHJldHVybiB0cnVlO1xuXHRcdFx0ZWxzZSBpZihhZGFwdGVyLmdldE5hbWUoZWxlbSkgIT09IFwib3B0aW9uXCIpIHJldHVybiBmYWxzZTtcblxuXHRcdFx0Ly90aGUgZmlyc3QgPG9wdGlvbj4gaW4gYSA8c2VsZWN0PiBpcyBhbHNvIHNlbGVjdGVkXG5cdFx0XHR2YXIgcGFyZW50ID0gYWRhcHRlci5nZXRQYXJlbnQoZWxlbSk7XG5cblx0XHRcdGlmKFxuXHRcdFx0XHQhcGFyZW50IHx8XG5cdFx0XHRcdGFkYXB0ZXIuZ2V0TmFtZShwYXJlbnQpICE9PSBcInNlbGVjdFwiIHx8XG5cdFx0XHRcdGFkYXB0ZXIuaGFzQXR0cmliKHBhcmVudCwgXCJtdWx0aXBsZVwiKVxuXHRcdFx0KSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdHZhciBzaWJsaW5ncyA9IGFkYXB0ZXIuZ2V0Q2hpbGRyZW4ocGFyZW50KSxcblx0XHRcdFx0c2F3RWxlbSAgPSBmYWxzZTtcblxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHNpYmxpbmdzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0aWYoYWRhcHRlci5pc1RhZyhzaWJsaW5nc1tpXSkpe1xuXHRcdFx0XHRcdGlmKHNpYmxpbmdzW2ldID09PSBlbGVtKXtcblx0XHRcdFx0XHRcdHNhd0VsZW0gPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZighc2F3RWxlbSl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fSBlbHNlIGlmKGFkYXB0ZXIuaGFzQXR0cmliKHNpYmxpbmdzW2ldLCBcInNlbGVjdGVkXCIpKXtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNhd0VsZW07XG5cdFx0fSxcblx0XHQvL2h0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI2Rpc2FibGVkLWVsZW1lbnRzXG5cdFx0Ly86bWF0Y2hlcyhcblx0XHQvLyAgOm1hdGNoZXMoYnV0dG9uLCBpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgbWVudWl0ZW0sIG9wdGdyb3VwLCBvcHRpb24pW2Rpc2FibGVkXSxcblx0XHQvLyAgb3B0Z3JvdXBbZGlzYWJsZWRdID4gb3B0aW9uKSxcblx0XHQvLyBmaWVsZHNldFtkaXNhYmxlZF0gKiAvL1RPRE8gbm90IGNoaWxkIG9mIGZpcnN0IDxsZWdlbmQ+XG5cdFx0Ly8pXG5cdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0cmV0dXJuIGFkYXB0ZXIuaGFzQXR0cmliKGVsZW0sIFwiZGlzYWJsZWRcIik7XG5cdFx0fSxcblx0XHRlbmFibGVkOiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdHJldHVybiAhYWRhcHRlci5oYXNBdHRyaWIoZWxlbSwgXCJkaXNhYmxlZFwiKTtcblx0XHR9LFxuXHRcdC8vOm1hdGNoZXMoOm1hdGNoZXMoOnJhZGlvLCA6Y2hlY2tib3gpW2NoZWNrZWRdLCA6c2VsZWN0ZWQpIChUT0RPIG1lbnVpdGVtKVxuXHRcdGNoZWNrZWQ6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0cmV0dXJuIGFkYXB0ZXIuaGFzQXR0cmliKGVsZW0sIFwiY2hlY2tlZFwiKSB8fCBwc2V1ZG9zLnNlbGVjdGVkKGVsZW0pO1xuXHRcdH0sXG5cdFx0Ly86bWF0Y2hlcyhpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSlbcmVxdWlyZWRdXG5cdFx0cmVxdWlyZWQ6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0cmV0dXJuIGFkYXB0ZXIuaGFzQXR0cmliKGVsZW0sIFwicmVxdWlyZWRcIik7XG5cdFx0fSxcblx0XHQvLzptYXRjaGVzKGlucHV0LCBzZWxlY3QsIHRleHRhcmVhKTpub3QoW3JlcXVpcmVkXSlcblx0XHRvcHRpb25hbDogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHRyZXR1cm4gIWFkYXB0ZXIuaGFzQXR0cmliKGVsZW0sIFwicmVxdWlyZWRcIik7XG5cdFx0fSxcblxuXHRcdC8valF1ZXJ5IGV4dGVuc2lvbnNcblxuXHRcdC8vOm5vdCg6ZW1wdHkpXG5cdFx0cGFyZW50OiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdHJldHVybiAhcHNldWRvcy5lbXB0eShlbGVtKTtcblx0XHR9LFxuXHRcdC8vOm1hdGNoZXMoaDEsIGgyLCBoMywgaDQsIGg1LCBoNilcblx0XHRoZWFkZXI6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0dmFyIG5hbWUgPSBhZGFwdGVyLmdldE5hbWUoZWxlbSk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJoMVwiIHx8XG5cdFx0XHRcdFx0bmFtZSA9PT0gXCJoMlwiIHx8XG5cdFx0XHRcdFx0bmFtZSA9PT0gXCJoM1wiIHx8XG5cdFx0XHRcdFx0bmFtZSA9PT0gXCJoNFwiIHx8XG5cdFx0XHRcdFx0bmFtZSA9PT0gXCJoNVwiIHx8XG5cdFx0XHRcdFx0bmFtZSA9PT0gXCJoNlwiO1xuXHRcdH0sXG5cblx0XHQvLzptYXRjaGVzKGJ1dHRvbiwgaW5wdXRbdHlwZT1idXR0b25dKVxuXHRcdGJ1dHRvbjogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHR2YXIgbmFtZSA9IGFkYXB0ZXIuZ2V0TmFtZShlbGVtKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImJ1dHRvblwiIHx8XG5cdFx0XHRcdFx0bmFtZSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdFx0YWRhcHRlci5nZXRBdHRyaWJ1dGVWYWx1ZShlbGVtLCBcInR5cGVcIikgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblx0XHQvLzptYXRjaGVzKGlucHV0LCB0ZXh0YXJlYSwgc2VsZWN0LCBidXR0b24pXG5cdFx0aW5wdXQ6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0dmFyIG5hbWUgPSBhZGFwdGVyLmdldE5hbWUoZWxlbSk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiIHx8XG5cdFx0XHRcdFx0bmFtZSA9PT0gXCJ0ZXh0YXJlYVwiIHx8XG5cdFx0XHRcdFx0bmFtZSA9PT0gXCJzZWxlY3RcIiB8fFxuXHRcdFx0XHRcdG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblx0XHQvL2lucHV0Om1hdGNoZXMoOm5vdChbdHlwZSE9JyddKSwgW3R5cGU9J3RleHQnIGldKVxuXHRcdHRleHQ6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gYWRhcHRlci5nZXROYW1lKGVsZW0pID09PSBcImlucHV0XCIgJiYgKFxuXHRcdFx0XHQhKGF0dHIgPSBhZGFwdGVyLmdldEF0dHJpYnV0ZVZhbHVlKGVsZW0sIFwidHlwZVwiKSkgfHxcblx0XHRcdFx0YXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIlxuXHRcdFx0KTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIHBzZXVkb3M7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeUFyZ3MoZnVuYywgbmFtZSwgc3Vic2VsZWN0KXtcblx0aWYoc3Vic2VsZWN0ID09PSBudWxsKXtcblx0XHRpZihmdW5jLmxlbmd0aCA+IDEgJiYgbmFtZSAhPT0gXCJzY29wZVwiKXtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInBzZXVkby1zZWxlY3RvciA6XCIgKyBuYW1lICsgXCIgcmVxdWlyZXMgYW4gYXJndW1lbnRcIik7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmKGZ1bmMubGVuZ3RoID09PSAxKXtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInBzZXVkby1zZWxlY3RvciA6XCIgKyBuYW1lICsgXCIgZG9lc24ndCBoYXZlIGFueSBhcmd1bWVudHNcIik7XG5cdFx0fVxuXHR9XG59XG5cbi8vRklYTUUgdGhpcyBmZWVscyBoYWNreVxudmFyIHJlX0NTUzMgPSAvXig/Oig/Om50aHxsYXN0fGZpcnN0fG9ubHkpLSg/OmNoaWxkfG9mLXR5cGUpfHJvb3R8ZW1wdHl8KD86ZW58ZGlzKWFibGVkfGNoZWNrZWR8bm90KSQvO1xuXG5mdW5jdGlvbiBmYWN0b3J5KGFkYXB0ZXIpe1xuXHR2YXIgcHNldWRvcyA9IHBzZXVkb3NGYWN0b3J5KGFkYXB0ZXIpO1xuXHR2YXIgZmlsdGVycyA9IGZpbHRlcnNGYWN0b3J5KGFkYXB0ZXIpO1xuXG5cdHJldHVybiB7XG5cdFx0Y29tcGlsZTogZnVuY3Rpb24obmV4dCwgZGF0YSwgb3B0aW9ucywgY29udGV4dCl7XG5cdFx0XHR2YXIgbmFtZSA9IGRhdGEubmFtZSxcblx0XHRcdFx0c3Vic2VsZWN0ID0gZGF0YS5kYXRhO1xuXG5cdFx0XHRpZihvcHRpb25zICYmIG9wdGlvbnMuc3RyaWN0ICYmICFyZV9DU1MzLnRlc3QobmFtZSkpe1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCI6XCIgKyBuYW1lICsgXCIgaXNuJ3QgcGFydCBvZiBDU1MzXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZih0eXBlb2YgZmlsdGVyc1tuYW1lXSA9PT0gXCJmdW5jdGlvblwiKXtcblx0XHRcdFx0dmVyaWZ5QXJncyhmaWx0ZXJzW25hbWVdLCBuYW1lLCAgc3Vic2VsZWN0KTtcblx0XHRcdFx0cmV0dXJuIGZpbHRlcnNbbmFtZV0obmV4dCwgc3Vic2VsZWN0LCBvcHRpb25zLCBjb250ZXh0KTtcblx0XHRcdH0gZWxzZSBpZih0eXBlb2YgcHNldWRvc1tuYW1lXSA9PT0gXCJmdW5jdGlvblwiKXtcblx0XHRcdFx0dmFyIGZ1bmMgPSBwc2V1ZG9zW25hbWVdO1xuXHRcdFx0XHR2ZXJpZnlBcmdzKGZ1bmMsIG5hbWUsIHN1YnNlbGVjdCk7XG5cblx0XHRcdFx0aWYobmV4dCA9PT0gdHJ1ZUZ1bmMpIHJldHVybiBmdW5jO1xuXG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiBwc2V1ZG9BcmdzKGVsZW0pe1xuXHRcdFx0XHRcdHJldHVybiBmdW5jKGVsZW0sIHN1YnNlbGVjdCkgJiYgbmV4dChlbGVtKTtcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInVubWF0Y2hlZCBwc2V1ZG8tY2xhc3MgOlwiICsgbmFtZSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRmaWx0ZXJzOiBmaWx0ZXJzLFxuXHRcdHBzZXVkb3M6IHBzZXVkb3Ncblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBzb3J0QnlQcm9jZWR1cmU7XG5cbi8qXG5cdHNvcnQgdGhlIHBhcnRzIG9mIHRoZSBwYXNzZWQgc2VsZWN0b3IsXG5cdGFzIHRoZXJlIGlzIHBvdGVudGlhbCBmb3Igb3B0aW1pemF0aW9uXG5cdChzb21lIHR5cGVzIG9mIHNlbGVjdG9ycyBhcmUgZmFzdGVyIHRoYW4gb3RoZXJzKVxuKi9cblxudmFyIHByb2NlZHVyZSA9IHJlcXVpcmUoXCIuL3Byb2NlZHVyZS5qc29uXCIpO1xuXG52YXIgYXR0cmlidXRlcyA9IHtcblx0X19wcm90b19fOiBudWxsLFxuXHRleGlzdHM6IDEwLFxuXHRlcXVhbHM6IDgsXG5cdG5vdDogNyxcblx0c3RhcnQ6IDYsXG5cdGVuZDogNixcblx0YW55OiA1LFxuXHRoeXBoZW46IDQsXG5cdGVsZW1lbnQ6IDRcbn07XG5cbmZ1bmN0aW9uIHNvcnRCeVByb2NlZHVyZShhcnIpe1xuXHR2YXIgcHJvY3MgPSBhcnIubWFwKGdldFByb2NlZHVyZSk7XG5cdGZvcih2YXIgaSA9IDE7IGkgPCBhcnIubGVuZ3RoOyBpKyspe1xuXHRcdHZhciBwcm9jTmV3ID0gcHJvY3NbaV07XG5cblx0XHRpZihwcm9jTmV3IDwgMCkgY29udGludWU7XG5cblx0XHRmb3IodmFyIGogPSBpIC0gMTsgaiA+PSAwICYmIHByb2NOZXcgPCBwcm9jc1tqXTsgai0tKXtcblx0XHRcdHZhciB0b2tlbiA9IGFycltqICsgMV07XG5cdFx0XHRhcnJbaiArIDFdID0gYXJyW2pdO1xuXHRcdFx0YXJyW2pdID0gdG9rZW47XG5cdFx0XHRwcm9jc1tqICsgMV0gPSBwcm9jc1tqXTtcblx0XHRcdHByb2NzW2pdID0gcHJvY05ldztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJvY2VkdXJlKHRva2VuKXtcblx0dmFyIHByb2MgPSBwcm9jZWR1cmVbdG9rZW4udHlwZV07XG5cblx0aWYocHJvYyA9PT0gcHJvY2VkdXJlLmF0dHJpYnV0ZSl7XG5cdFx0cHJvYyA9IGF0dHJpYnV0ZXNbdG9rZW4uYWN0aW9uXTtcblxuXHRcdGlmKHByb2MgPT09IGF0dHJpYnV0ZXMuZXF1YWxzICYmIHRva2VuLm5hbWUgPT09IFwiaWRcIil7XG5cdFx0XHQvL3ByZWZlciBJRCBzZWxlY3RvcnMgKGVnLiAjSUQpXG5cdFx0XHRwcm9jID0gOTtcblx0XHR9XG5cblx0XHRpZih0b2tlbi5pZ25vcmVDYXNlKXtcblx0XHRcdC8vaWdub3JlQ2FzZSBhZGRzIHNvbWUgb3ZlcmhlYWQsIHByZWZlciBcIm5vcm1hbFwiIHRva2VuXG5cdFx0XHQvL3RoaXMgaXMgYSBiaW5hcnkgb3BlcmF0aW9uLCB0byBlbnN1cmUgaXQncyBzdGlsbCBhbiBpbnRcblx0XHRcdHByb2MgPj49IDE7XG5cdFx0fVxuXHR9IGVsc2UgaWYocHJvYyA9PT0gcHJvY2VkdXJlLnBzZXVkbyl7XG5cdFx0aWYoIXRva2VuLmRhdGEpe1xuXHRcdFx0cHJvYyA9IDM7XG5cdFx0fSBlbHNlIGlmKHRva2VuLm5hbWUgPT09IFwiaGFzXCIgfHwgdG9rZW4ubmFtZSA9PT0gXCJjb250YWluc1wiKXtcblx0XHRcdHByb2MgPSAwOyAvL2V4cGVuc2l2ZSBpbiBhbnkgY2FzZVxuXHRcdH0gZWxzZSBpZih0b2tlbi5uYW1lID09PSBcIm1hdGNoZXNcIiB8fCB0b2tlbi5uYW1lID09PSBcIm5vdFwiKXtcblx0XHRcdHByb2MgPSAwO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRva2VuLmRhdGEubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHQvL1RPRE8gYmV0dGVyIGhhbmRsaW5nIG9mIGNvbXBsZXggc2VsZWN0b3JzXG5cdFx0XHRcdGlmKHRva2VuLmRhdGFbaV0ubGVuZ3RoICE9PSAxKSBjb250aW51ZTtcblx0XHRcdFx0dmFyIGN1ciA9IGdldFByb2NlZHVyZSh0b2tlbi5kYXRhW2ldWzBdKTtcblx0XHRcdFx0Ly9hdm9pZCBleGVjdXRpbmcgOmhhcyBvciA6Y29udGFpbnNcblx0XHRcdFx0aWYoY3VyID09PSAwKXtcblx0XHRcdFx0XHRwcm9jID0gMDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihjdXIgPiBwcm9jKSBwcm9jID0gY3VyO1xuXHRcdFx0fVxuXHRcdFx0aWYodG9rZW4uZGF0YS5sZW5ndGggPiAxICYmIHByb2MgPiAwKSBwcm9jIC09IDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb2MgPSAxO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcHJvYztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xuXG52YXIgcmVfbmFtZSA9IC9eKD86XFxcXC58W1xcd1xcLVxcdTAwYzAtXFx1RkZGRl0pKy8sXG4gICAgcmVfZXNjYXBlID0gL1xcXFwoW1xcZGEtZl17MSw2fVxccz98KFxccyl8LikvaWcsXG4gICAgLy9tb2RpZmllZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL2Jsb2IvbWFzdGVyL3NyYy9zaXp6bGUuanMjTDg3XG4gICAgcmVfYXR0ciA9IC9eXFxzKigoPzpcXFxcLnxbXFx3XFx1MDBjMC1cXHVGRkZGXFwtXSkrKVxccyooPzooXFxTPyk9XFxzKig/OihbJ1wiXSkoLio/KVxcM3woIz8oPzpcXFxcLnxbXFx3XFx1MDBjMC1cXHVGRkZGXFwtXSkqKXwpfClcXHMqKGkpP1xcXS87XG5cbnZhciBhY3Rpb25UeXBlcyA9IHtcblx0X19wcm90b19fOiBudWxsLFxuXHRcInVuZGVmaW5lZFwiOiBcImV4aXN0c1wiLFxuXHRcIlwiOiAgXCJlcXVhbHNcIixcblx0XCJ+XCI6IFwiZWxlbWVudFwiLFxuXHRcIl5cIjogXCJzdGFydFwiLFxuXHRcIiRcIjogXCJlbmRcIixcblx0XCIqXCI6IFwiYW55XCIsXG5cdFwiIVwiOiBcIm5vdFwiLFxuXHRcInxcIjogXCJoeXBoZW5cIlxufTtcblxudmFyIHNpbXBsZVNlbGVjdG9ycyA9IHtcblx0X19wcm90b19fOiBudWxsLFxuXHRcIj5cIjogXCJjaGlsZFwiLFxuXHRcIjxcIjogXCJwYXJlbnRcIixcblx0XCJ+XCI6IFwic2libGluZ1wiLFxuXHRcIitcIjogXCJhZGphY2VudFwiXG59O1xuXG52YXIgYXR0cmliU2VsZWN0b3JzID0ge1xuXHRfX3Byb3RvX186IG51bGwsXG5cdFwiI1wiOiBbXCJpZFwiLCBcImVxdWFsc1wiXSxcblx0XCIuXCI6IFtcImNsYXNzXCIsIFwiZWxlbWVudFwiXVxufTtcblxuLy9wc2V1ZG9zLCB3aG9zZSBkYXRhLXByb3BlcnR5IGlzIHBhcnNlZCBhcyB3ZWxsXG52YXIgdW5wYWNrUHNldWRvcyA9IHtcblx0X19wcm90b19fOiBudWxsLFxuXHRcImhhc1wiOiB0cnVlLFxuXHRcIm5vdFwiOiB0cnVlLFxuXHRcIm1hdGNoZXNcIjogdHJ1ZVxufTtcblxudmFyIHN0cmlwUXVvdGVzRnJvbVBzZXVkb3MgPSB7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0XCJjb250YWluc1wiOiB0cnVlLFxuXHRcImljb250YWluc1wiOiB0cnVlXG59O1xuXG52YXIgcXVvdGVzID0ge1xuXHRfX3Byb3RvX186IG51bGwsXG5cdFwiXFxcIlwiOiB0cnVlLFxuXHRcIidcIjogdHJ1ZVxufTtcblxuLy91bmVzY2FwZSBmdW5jdGlvbiB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL2Jsb2IvbWFzdGVyL3NyYy9zaXp6bGUuanMjTDEzOVxuZnVuY3Rpb24gZnVuZXNjYXBlKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0Ly8gU3VwcG9ydDogRmlyZWZveFxuXHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdGVzY2FwZWQgOlxuXHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRoaWdoIDwgMCA/XG5cdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlQ1NTKHN0cil7XG5cdHJldHVybiBzdHIucmVwbGFjZShyZV9lc2NhcGUsIGZ1bmVzY2FwZSk7XG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjKXtcblx0cmV0dXJuIGMgPT09IFwiIFwiIHx8IGMgPT09IFwiXFxuXCIgfHwgYyA9PT0gXCJcXHRcIiB8fCBjID09PSBcIlxcZlwiIHx8IGMgPT09IFwiXFxyXCI7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHNlbGVjdG9yLCBvcHRpb25zKXtcblx0dmFyIHN1YnNlbGVjdHMgPSBbXTtcblxuXHRzZWxlY3RvciA9IHBhcnNlU2VsZWN0b3Ioc3Vic2VsZWN0cywgc2VsZWN0b3IgKyBcIlwiLCBvcHRpb25zKTtcblxuXHRpZihzZWxlY3RvciAhPT0gXCJcIil7XG5cdFx0dGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVW5tYXRjaGVkIHNlbGVjdG9yOiBcIiArIHNlbGVjdG9yKTtcblx0fVxuXG5cdHJldHVybiBzdWJzZWxlY3RzO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNlbGVjdG9yKHN1YnNlbGVjdHMsIHNlbGVjdG9yLCBvcHRpb25zKXtcblx0dmFyIHRva2VucyA9IFtdLFxuXHRcdHNhd1dTID0gZmFsc2UsXG5cdFx0ZGF0YSwgZmlyc3RDaGFyLCBuYW1lLCBxdW90O1xuXG5cdGZ1bmN0aW9uIGdldE5hbWUoKXtcblx0XHR2YXIgc3ViID0gc2VsZWN0b3IubWF0Y2gocmVfbmFtZSlbMF07XG5cdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zdWJzdHIoc3ViLmxlbmd0aCk7XG5cdFx0cmV0dXJuIHVuZXNjYXBlQ1NTKHN1Yik7XG5cdH1cblxuXHRmdW5jdGlvbiBzdHJpcFdoaXRlc3BhY2Uoc3RhcnQpe1xuXHRcdHdoaWxlKGlzV2hpdGVzcGFjZShzZWxlY3Rvci5jaGFyQXQoc3RhcnQpKSkgc3RhcnQrKztcblx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnN1YnN0cihzdGFydCk7XG5cdH1cblxuXHRzdHJpcFdoaXRlc3BhY2UoMCk7XG5cblx0d2hpbGUoc2VsZWN0b3IgIT09IFwiXCIpe1xuXHRcdGZpcnN0Q2hhciA9IHNlbGVjdG9yLmNoYXJBdCgwKTtcblxuXHRcdGlmKGlzV2hpdGVzcGFjZShmaXJzdENoYXIpKXtcblx0XHRcdHNhd1dTID0gdHJ1ZTtcblx0XHRcdHN0cmlwV2hpdGVzcGFjZSgxKTtcblx0XHR9IGVsc2UgaWYoZmlyc3RDaGFyIGluIHNpbXBsZVNlbGVjdG9ycyl7XG5cdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogc2ltcGxlU2VsZWN0b3JzW2ZpcnN0Q2hhcl19KTtcblx0XHRcdHNhd1dTID0gZmFsc2U7XG5cblx0XHRcdHN0cmlwV2hpdGVzcGFjZSgxKTtcblx0XHR9IGVsc2UgaWYoZmlyc3RDaGFyID09PSBcIixcIil7XG5cdFx0XHRpZih0b2tlbnMubGVuZ3RoID09PSAwKXtcblx0XHRcdFx0dGhyb3cgbmV3IFN5bnRheEVycm9yKFwiZW1wdHkgc3ViLXNlbGVjdG9yXCIpO1xuXHRcdFx0fVxuXHRcdFx0c3Vic2VsZWN0cy5wdXNoKHRva2Vucyk7XG5cdFx0XHR0b2tlbnMgPSBbXTtcblx0XHRcdHNhd1dTID0gZmFsc2U7XG5cdFx0XHRzdHJpcFdoaXRlc3BhY2UoMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmKHNhd1dTKXtcblx0XHRcdFx0aWYodG9rZW5zLmxlbmd0aCA+IDApe1xuXHRcdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBcImRlc2NlbmRhbnRcIn0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNhd1dTID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmKGZpcnN0Q2hhciA9PT0gXCIqXCIpe1xuXHRcdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnN1YnN0cigxKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFwidW5pdmVyc2FsXCJ9KTtcblx0XHRcdH0gZWxzZSBpZihmaXJzdENoYXIgaW4gYXR0cmliU2VsZWN0b3JzKXtcblx0XHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zdWJzdHIoMSk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR0eXBlOiBcImF0dHJpYnV0ZVwiLFxuXHRcdFx0XHRcdG5hbWU6IGF0dHJpYlNlbGVjdG9yc1tmaXJzdENoYXJdWzBdLFxuXHRcdFx0XHRcdGFjdGlvbjogYXR0cmliU2VsZWN0b3JzW2ZpcnN0Q2hhcl1bMV0sXG5cdFx0XHRcdFx0dmFsdWU6IGdldE5hbWUoKSxcblx0XHRcdFx0XHRpZ25vcmVDYXNlOiBmYWxzZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSBpZihmaXJzdENoYXIgPT09IFwiW1wiKXtcblx0XHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zdWJzdHIoMSk7XG5cdFx0XHRcdGRhdGEgPSBzZWxlY3Rvci5tYXRjaChyZV9hdHRyKTtcblx0XHRcdFx0aWYoIWRhdGEpe1xuXHRcdFx0XHRcdHRocm93IG5ldyBTeW50YXhFcnJvcihcIk1hbGZvcm1lZCBhdHRyaWJ1dGUgc2VsZWN0b3I6IFwiICsgc2VsZWN0b3IpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc3Vic3RyKGRhdGFbMF0ubGVuZ3RoKTtcblx0XHRcdFx0bmFtZSA9IHVuZXNjYXBlQ1NTKGRhdGFbMV0pO1xuXG5cdFx0XHRcdGlmKFxuXHRcdFx0XHRcdCFvcHRpb25zIHx8IChcblx0XHRcdFx0XHRcdFwibG93ZXJDYXNlQXR0cmlidXRlTmFtZXNcIiBpbiBvcHRpb25zID9cblx0XHRcdFx0XHRcdFx0b3B0aW9ucy5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lcyA6XG5cdFx0XHRcdFx0XHRcdCFvcHRpb25zLnhtbE1vZGVcblx0XHRcdFx0XHQpXG5cdFx0XHRcdCl7XG5cdFx0XHRcdFx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR0eXBlOiBcImF0dHJpYnV0ZVwiLFxuXHRcdFx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHRcdFx0YWN0aW9uOiBhY3Rpb25UeXBlc1tkYXRhWzJdXSxcblx0XHRcdFx0XHR2YWx1ZTogdW5lc2NhcGVDU1MoZGF0YVs0XSB8fCBkYXRhWzVdIHx8IFwiXCIpLFxuXHRcdFx0XHRcdGlnbm9yZUNhc2U6ICEhZGF0YVs2XVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0fSBlbHNlIGlmKGZpcnN0Q2hhciA9PT0gXCI6XCIpe1xuXHRcdFx0XHRpZihzZWxlY3Rvci5jaGFyQXQoMSkgPT09IFwiOlwiKXtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnN1YnN0cigyKTtcblx0XHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogXCJwc2V1ZG8tZWxlbWVudFwiLCBuYW1lOiBnZXROYW1lKCkudG9Mb3dlckNhc2UoKX0pO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zdWJzdHIoMSk7XG5cblx0XHRcdFx0bmFtZSA9IGdldE5hbWUoKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRkYXRhID0gbnVsbDtcblxuXHRcdFx0XHRpZihzZWxlY3Rvci5jaGFyQXQoMCkgPT09IFwiKFwiKXtcblx0XHRcdFx0XHRpZihuYW1lIGluIHVucGFja1BzZXVkb3Mpe1xuXHRcdFx0XHRcdFx0cXVvdCA9IHNlbGVjdG9yLmNoYXJBdCgxKTtcblx0XHRcdFx0XHRcdHZhciBxdW90ZWQgPSBxdW90IGluIHF1b3RlcztcblxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zdWJzdHIocXVvdGVkICsgMSk7XG5cblx0XHRcdFx0XHRcdGRhdGEgPSBbXTtcblx0XHRcdFx0XHRcdHNlbGVjdG9yID0gcGFyc2VTZWxlY3RvcihkYXRhLCBzZWxlY3Rvciwgb3B0aW9ucyk7XG5cblx0XHRcdFx0XHRcdGlmKHF1b3RlZCl7XG5cdFx0XHRcdFx0XHRcdGlmKHNlbGVjdG9yLmNoYXJBdCgwKSAhPT0gcXVvdCl7XG5cdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFN5bnRheEVycm9yKFwidW5tYXRjaGVkIHF1b3RlcyBpbiA6XCIgKyBuYW1lKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnN1YnN0cigxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZihzZWxlY3Rvci5jaGFyQXQoMCkgIT09IFwiKVwiKXtcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFN5bnRheEVycm9yKFwibWlzc2luZyBjbG9zaW5nIHBhcmVudGhlc2lzIGluIDpcIiArIG5hbWUgKyBcIiBcIiArIHNlbGVjdG9yKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zdWJzdHIoMSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBwb3MgPSAxLCBjb3VudGVyID0gMTtcblxuXHRcdFx0XHRcdFx0Zm9yKDsgY291bnRlciA+IDAgJiYgcG9zIDwgc2VsZWN0b3IubGVuZ3RoOyBwb3MrKyl7XG5cdFx0XHRcdFx0XHRcdGlmKHNlbGVjdG9yLmNoYXJBdChwb3MpID09PSBcIihcIikgY291bnRlcisrO1xuXHRcdFx0XHRcdFx0XHRlbHNlIGlmKHNlbGVjdG9yLmNoYXJBdChwb3MpID09PSBcIilcIikgY291bnRlci0tO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZihjb3VudGVyKXtcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFN5bnRheEVycm9yKFwicGFyZW50aGVzaXMgbm90IG1hdGNoZWRcIik7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGRhdGEgPSBzZWxlY3Rvci5zdWJzdHIoMSwgcG9zIC0gMik7XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnN1YnN0cihwb3MpO1xuXG5cdFx0XHRcdFx0XHRpZihuYW1lIGluIHN0cmlwUXVvdGVzRnJvbVBzZXVkb3Mpe1xuXHRcdFx0XHRcdFx0XHRxdW90ID0gZGF0YS5jaGFyQXQoMCk7XG5cblx0XHRcdFx0XHRcdFx0aWYocXVvdCA9PT0gZGF0YS5zbGljZSgtMSkgJiYgcXVvdCBpbiBxdW90ZXMpe1xuXHRcdFx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhLnNsaWNlKDEsIC0xKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGRhdGEgPSB1bmVzY2FwZUNTUyhkYXRhKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogXCJwc2V1ZG9cIiwgbmFtZTogbmFtZSwgZGF0YTogZGF0YX0pO1xuXHRcdFx0fSBlbHNlIGlmKHJlX25hbWUudGVzdChzZWxlY3Rvcikpe1xuXHRcdFx0XHRuYW1lID0gZ2V0TmFtZSgpO1xuXG5cdFx0XHRcdGlmKCFvcHRpb25zIHx8IChcImxvd2VyQ2FzZVRhZ3NcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5sb3dlckNhc2VUYWdzIDogIW9wdGlvbnMueG1sTW9kZSkpe1xuXHRcdFx0XHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogXCJ0YWdcIiwgbmFtZTogbmFtZX0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodG9rZW5zLmxlbmd0aCAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgPT09IFwiZGVzY2VuZGFudFwiKXtcblx0XHRcdFx0XHR0b2tlbnMucG9wKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YWRkVG9rZW4oc3Vic2VsZWN0cywgdG9rZW5zKTtcblx0XHRcdFx0cmV0dXJuIHNlbGVjdG9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGFkZFRva2VuKHN1YnNlbGVjdHMsIHRva2Vucyk7XG5cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRUb2tlbihzdWJzZWxlY3RzLCB0b2tlbnMpe1xuXHRpZihzdWJzZWxlY3RzLmxlbmd0aCA+IDAgJiYgdG9rZW5zLmxlbmd0aCA9PT0gMCl7XG5cdFx0dGhyb3cgbmV3IFN5bnRheEVycm9yKFwiZW1wdHkgc3ViLXNlbGVjdG9yXCIpO1xuXHR9XG5cblx0c3Vic2VsZWN0cy5wdXNoKHRva2Vucyk7XG59XG4iLCJcbnZhciBOYXRpdmVDdXN0b21FdmVudCA9IGdsb2JhbC5DdXN0b21FdmVudDtcblxuZnVuY3Rpb24gdXNlTmF0aXZlICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgcCA9IG5ldyBOYXRpdmVDdXN0b21FdmVudCgnY2F0JywgeyBkZXRhaWw6IHsgZm9vOiAnYmFyJyB9IH0pO1xuICAgIHJldHVybiAgJ2NhdCcgPT09IHAudHlwZSAmJiAnYmFyJyA9PT0gcC5kZXRhaWwuZm9vO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENyb3NzLWJyb3dzZXIgYEN1c3RvbUV2ZW50YCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQuQ3VzdG9tRXZlbnRcbiAqXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB1c2VOYXRpdmUoKSA/IE5hdGl2ZUN1c3RvbUV2ZW50IDpcblxuLy8gSUUgPj0gOVxuJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID8gZnVuY3Rpb24gQ3VzdG9tRXZlbnQgKHR5cGUsIHBhcmFtcykge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICBpZiAocGFyYW1zKSB7XG4gICAgZS5pbml0Q3VzdG9tRXZlbnQodHlwZSwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgfSBlbHNlIHtcbiAgICBlLmluaXRDdXN0b21FdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UsIHZvaWQgMCk7XG4gIH1cbiAgcmV0dXJuIGU7XG59IDpcblxuLy8gSUUgPD0gOFxuZnVuY3Rpb24gQ3VzdG9tRXZlbnQgKHR5cGUsIHBhcmFtcykge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCk7XG4gIGUudHlwZSA9IHR5cGU7XG4gIGlmIChwYXJhbXMpIHtcbiAgICBlLmJ1YmJsZXMgPSBCb29sZWFuKHBhcmFtcy5idWJibGVzKTtcbiAgICBlLmNhbmNlbGFibGUgPSBCb29sZWFuKHBhcmFtcy5jYW5jZWxhYmxlKTtcbiAgICBlLmRldGFpbCA9IHBhcmFtcy5kZXRhaWw7XG4gIH0gZWxzZSB7XG4gICAgZS5idWJibGVzID0gZmFsc2U7XG4gICAgZS5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgZS5kZXRhaWwgPSB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG4iLCIvKlxuICBNb2R1bGUgZGVwZW5kZW5jaWVzXG4qL1xudmFyIEVsZW1lbnRUeXBlID0gcmVxdWlyZSgnZG9tZWxlbWVudHR5cGUnKTtcbnZhciBlbnRpdGllcyA9IHJlcXVpcmUoJ2VudGl0aWVzJyk7XG5cbi8qXG4gIEJvb2xlYW4gQXR0cmlidXRlc1xuKi9cbnZhciBib29sZWFuQXR0cmlidXRlcyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhbGxvd2Z1bGxzY3JlZW46IHRydWUsXG4gIGFzeW5jOiB0cnVlLFxuICBhdXRvZm9jdXM6IHRydWUsXG4gIGF1dG9wbGF5OiB0cnVlLFxuICBjaGVja2VkOiB0cnVlLFxuICBjb250cm9sczogdHJ1ZSxcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgZGVmZXI6IHRydWUsXG4gIGRpc2FibGVkOiB0cnVlLFxuICBoaWRkZW46IHRydWUsXG4gIGlzbWFwOiB0cnVlLFxuICBsb29wOiB0cnVlLFxuICBtdWx0aXBsZTogdHJ1ZSxcbiAgbXV0ZWQ6IHRydWUsXG4gIG9wZW46IHRydWUsXG4gIHJlYWRvbmx5OiB0cnVlLFxuICByZXF1aXJlZDogdHJ1ZSxcbiAgcmV2ZXJzZWQ6IHRydWUsXG4gIHNjb3BlZDogdHJ1ZSxcbiAgc2VhbWxlc3M6IHRydWUsXG4gIHNlbGVjdGVkOiB0cnVlLFxuICB0eXBlbXVzdG1hdGNoOiB0cnVlXG59O1xuXG52YXIgdW5lbmNvZGVkRWxlbWVudHMgPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgc3R5bGU6IHRydWUsXG4gIHNjcmlwdDogdHJ1ZSxcbiAgeG1wOiB0cnVlLFxuICBpZnJhbWU6IHRydWUsXG4gIG5vZW1iZWQ6IHRydWUsXG4gIG5vZnJhbWVzOiB0cnVlLFxuICBwbGFpbnRleHQ6IHRydWUsXG4gIG5vc2NyaXB0OiB0cnVlXG59O1xuXG4vKlxuICBGb3JtYXQgYXR0cmlidXRlc1xuKi9cbmZ1bmN0aW9uIGZvcm1hdEF0dHJzKGF0dHJpYnV0ZXMsIG9wdHMpIHtcbiAgaWYgKCFhdHRyaWJ1dGVzKSByZXR1cm47XG5cbiAgdmFyIG91dHB1dCA9ICcnLFxuICAgICAgdmFsdWU7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBhdHRyaWJ1dGVzXG4gIGZvciAodmFyIGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgdmFsdWUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgaWYgKG91dHB1dCkge1xuICAgICAgb3V0cHV0ICs9ICcgJztcbiAgICB9XG5cbiAgICBpZiAoIXZhbHVlICYmIGJvb2xlYW5BdHRyaWJ1dGVzW2tleV0pIHtcbiAgICAgIG91dHB1dCArPSBrZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dCArPSBrZXkgKyAnPVwiJyArIChvcHRzLmRlY29kZUVudGl0aWVzID8gZW50aXRpZXMuZW5jb2RlWE1MKHZhbHVlKSA6IHZhbHVlKSArICdcIic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLypcbiAgU2VsZi1lbmNsb3NpbmcgdGFncyAoc3RvbGVuIGZyb20gbm9kZS1odG1scGFyc2VyKVxuKi9cbnZhciBzaW5nbGVUYWcgPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYXJlYTogdHJ1ZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYmFzZWZvbnQ6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGNvbW1hbmQ6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBmcmFtZTogdHJ1ZSxcbiAgaHI6IHRydWUsXG4gIGltZzogdHJ1ZSxcbiAgaW5wdXQ6IHRydWUsXG4gIGlzaW5kZXg6IHRydWUsXG4gIGtleWdlbjogdHJ1ZSxcbiAgbGluazogdHJ1ZSxcbiAgbWV0YTogdHJ1ZSxcbiAgcGFyYW06IHRydWUsXG4gIHNvdXJjZTogdHJ1ZSxcbiAgdHJhY2s6IHRydWUsXG4gIHdicjogdHJ1ZSxcbn07XG5cblxudmFyIHJlbmRlciA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9tLCBvcHRzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShkb20pICYmICFkb20uY2hlZXJpbykgZG9tID0gW2RvbV07XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBvdXRwdXQgPSAnJztcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgZG9tLmxlbmd0aDsgaSsrKXtcbiAgICB2YXIgZWxlbSA9IGRvbVtpXTtcblxuICAgIGlmIChlbGVtLnR5cGUgPT09ICdyb290JylcbiAgICAgIG91dHB1dCArPSByZW5kZXIoZWxlbS5jaGlsZHJlbiwgb3B0cyk7XG4gICAgZWxzZSBpZiAoRWxlbWVudFR5cGUuaXNUYWcoZWxlbSkpXG4gICAgICBvdXRwdXQgKz0gcmVuZGVyVGFnKGVsZW0sIG9wdHMpO1xuICAgIGVsc2UgaWYgKGVsZW0udHlwZSA9PT0gRWxlbWVudFR5cGUuRGlyZWN0aXZlKVxuICAgICAgb3V0cHV0ICs9IHJlbmRlckRpcmVjdGl2ZShlbGVtKTtcbiAgICBlbHNlIGlmIChlbGVtLnR5cGUgPT09IEVsZW1lbnRUeXBlLkNvbW1lbnQpXG4gICAgICBvdXRwdXQgKz0gcmVuZGVyQ29tbWVudChlbGVtKTtcbiAgICBlbHNlIGlmIChlbGVtLnR5cGUgPT09IEVsZW1lbnRUeXBlLkNEQVRBKVxuICAgICAgb3V0cHV0ICs9IHJlbmRlckNkYXRhKGVsZW0pO1xuICAgIGVsc2VcbiAgICAgIG91dHB1dCArPSByZW5kZXJUZXh0KGVsZW0sIG9wdHMpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbmZ1bmN0aW9uIHJlbmRlclRhZyhlbGVtLCBvcHRzKSB7XG4gIC8vIEhhbmRsZSBTVkdcbiAgaWYgKGVsZW0ubmFtZSA9PT0gXCJzdmdcIikgb3B0cyA9IHtkZWNvZGVFbnRpdGllczogb3B0cy5kZWNvZGVFbnRpdGllcywgeG1sTW9kZTogdHJ1ZX07XG5cbiAgdmFyIHRhZyA9ICc8JyArIGVsZW0ubmFtZSxcbiAgICAgIGF0dHJpYnMgPSBmb3JtYXRBdHRycyhlbGVtLmF0dHJpYnMsIG9wdHMpO1xuXG4gIGlmIChhdHRyaWJzKSB7XG4gICAgdGFnICs9ICcgJyArIGF0dHJpYnM7XG4gIH1cblxuICBpZiAoXG4gICAgb3B0cy54bWxNb2RlXG4gICAgJiYgKCFlbGVtLmNoaWxkcmVuIHx8IGVsZW0uY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuICApIHtcbiAgICB0YWcgKz0gJy8+JztcbiAgfSBlbHNlIHtcbiAgICB0YWcgKz0gJz4nO1xuICAgIGlmIChlbGVtLmNoaWxkcmVuKSB7XG4gICAgICB0YWcgKz0gcmVuZGVyKGVsZW0uY2hpbGRyZW4sIG9wdHMpO1xuICAgIH1cblxuICAgIGlmICghc2luZ2xlVGFnW2VsZW0ubmFtZV0gfHwgb3B0cy54bWxNb2RlKSB7XG4gICAgICB0YWcgKz0gJzwvJyArIGVsZW0ubmFtZSArICc+JztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFnO1xufVxuXG5mdW5jdGlvbiByZW5kZXJEaXJlY3RpdmUoZWxlbSkge1xuICByZXR1cm4gJzwnICsgZWxlbS5kYXRhICsgJz4nO1xufVxuXG5mdW5jdGlvbiByZW5kZXJUZXh0KGVsZW0sIG9wdHMpIHtcbiAgdmFyIGRhdGEgPSBlbGVtLmRhdGEgfHwgJyc7XG5cbiAgLy8gaWYgZW50aXRpZXMgd2VyZW4ndCBkZWNvZGVkLCBubyBuZWVkIHRvIGVuY29kZSB0aGVtIGJhY2tcbiAgaWYgKG9wdHMuZGVjb2RlRW50aXRpZXMgJiYgIShlbGVtLnBhcmVudCAmJiBlbGVtLnBhcmVudC5uYW1lIGluIHVuZW5jb2RlZEVsZW1lbnRzKSkge1xuICAgIGRhdGEgPSBlbnRpdGllcy5lbmNvZGVYTUwoZGF0YSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2RhdGEoZWxlbSkge1xuICByZXR1cm4gJzwhW0NEQVRBWycgKyBlbGVtLmNoaWxkcmVuWzBdLmRhdGEgKyAnXV0+Jztcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ29tbWVudChlbGVtKSB7XG4gIHJldHVybiAnPCEtLScgKyBlbGVtLmRhdGEgKyAnLS0+Jztcbn1cbiIsIi8vVHlwZXMgb2YgZWxlbWVudHMgZm91bmQgaW4gdGhlIERPTVxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdFRleHQ6IFwidGV4dFwiLCAvL1RleHRcblx0RGlyZWN0aXZlOiBcImRpcmVjdGl2ZVwiLCAvLzw/IC4uLiA/PlxuXHRDb21tZW50OiBcImNvbW1lbnRcIiwgLy88IS0tIC4uLiAtLT5cblx0U2NyaXB0OiBcInNjcmlwdFwiLCAvLzxzY3JpcHQ+IHRhZ3Ncblx0U3R5bGU6IFwic3R5bGVcIiwgLy88c3R5bGU+IHRhZ3Ncblx0VGFnOiBcInRhZ1wiLCAvL0FueSB0YWdcblx0Q0RBVEE6IFwiY2RhdGFcIiwgLy88IVtDREFUQVsgLi4uIF1dPlxuXG5cdGlzVGFnOiBmdW5jdGlvbihlbGVtKXtcblx0XHRyZXR1cm4gZWxlbS50eXBlID09PSBcInRhZ1wiIHx8IGVsZW0udHlwZSA9PT0gXCJzY3JpcHRcIiB8fCBlbGVtLnR5cGUgPT09IFwic3R5bGVcIjtcblx0fVxufTsiLCIvL1R5cGVzIG9mIGVsZW1lbnRzIGZvdW5kIGluIHRoZSBET01cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRUZXh0OiBcInRleHRcIiwgLy9UZXh0XG5cdERpcmVjdGl2ZTogXCJkaXJlY3RpdmVcIiwgLy88PyAuLi4gPz5cblx0Q29tbWVudDogXCJjb21tZW50XCIsIC8vPCEtLSAuLi4gLS0+XG5cdFNjcmlwdDogXCJzY3JpcHRcIiwgLy88c2NyaXB0PiB0YWdzXG5cdFN0eWxlOiBcInN0eWxlXCIsIC8vPHN0eWxlPiB0YWdzXG5cdFRhZzogXCJ0YWdcIiwgLy9BbnkgdGFnXG5cdENEQVRBOiBcImNkYXRhXCIsIC8vPCFbQ0RBVEFbIC4uLiBdXT5cblx0RG9jdHlwZTogXCJkb2N0eXBlXCIsXG5cblx0aXNUYWc6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdHJldHVybiBlbGVtLnR5cGUgPT09IFwidGFnXCIgfHwgZWxlbS50eXBlID09PSBcInNjcmlwdFwiIHx8IGVsZW0udHlwZSA9PT0gXCJzdHlsZVwiO1xuXHR9XG59O1xuIiwidmFyIEVsZW1lbnRUeXBlID0gcmVxdWlyZShcImRvbWVsZW1lbnR0eXBlXCIpO1xuXG52YXIgcmVfd2hpdGVzcGFjZSA9IC9cXHMrL2c7XG52YXIgTm9kZVByb3RvdHlwZSA9IHJlcXVpcmUoXCIuL2xpYi9ub2RlXCIpO1xudmFyIEVsZW1lbnRQcm90b3R5cGUgPSByZXF1aXJlKFwiLi9saWIvZWxlbWVudFwiKTtcblxuZnVuY3Rpb24gRG9tSGFuZGxlcihjYWxsYmFjaywgb3B0aW9ucywgZWxlbWVudENCKXtcblx0aWYodHlwZW9mIGNhbGxiYWNrID09PSBcIm9iamVjdFwiKXtcblx0XHRlbGVtZW50Q0IgPSBvcHRpb25zO1xuXHRcdG9wdGlvbnMgPSBjYWxsYmFjaztcblx0XHRjYWxsYmFjayA9IG51bGw7XG5cdH0gZWxzZSBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKXtcblx0XHRlbGVtZW50Q0IgPSBvcHRpb25zO1xuXHRcdG9wdGlvbnMgPSBkZWZhdWx0T3B0cztcblx0fVxuXHR0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHR0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0T3B0cztcblx0dGhpcy5fZWxlbWVudENCID0gZWxlbWVudENCO1xuXHR0aGlzLmRvbSA9IFtdO1xuXHR0aGlzLl9kb25lID0gZmFsc2U7XG5cdHRoaXMuX3RhZ1N0YWNrID0gW107XG5cdHRoaXMuX3BhcnNlciA9IHRoaXMuX3BhcnNlciB8fCBudWxsO1xufVxuXG4vL2RlZmF1bHQgb3B0aW9uc1xudmFyIGRlZmF1bHRPcHRzID0ge1xuXHRub3JtYWxpemVXaGl0ZXNwYWNlOiBmYWxzZSwgLy9SZXBsYWNlIGFsbCB3aGl0ZXNwYWNlIHdpdGggc2luZ2xlIHNwYWNlc1xuXHR3aXRoU3RhcnRJbmRpY2VzOiBmYWxzZSwgLy9BZGQgc3RhcnRJbmRleCBwcm9wZXJ0aWVzIHRvIG5vZGVzXG59O1xuXG5Eb21IYW5kbGVyLnByb3RvdHlwZS5vbnBhcnNlcmluaXQgPSBmdW5jdGlvbihwYXJzZXIpe1xuXHR0aGlzLl9wYXJzZXIgPSBwYXJzZXI7XG59O1xuXG4vL1Jlc2V0cyB0aGUgaGFuZGxlciBiYWNrIHRvIHN0YXJ0aW5nIHN0YXRlXG5Eb21IYW5kbGVyLnByb3RvdHlwZS5vbnJlc2V0ID0gZnVuY3Rpb24oKXtcblx0RG9tSGFuZGxlci5jYWxsKHRoaXMsIHRoaXMuX2NhbGxiYWNrLCB0aGlzLl9vcHRpb25zLCB0aGlzLl9lbGVtZW50Q0IpO1xufTtcblxuLy9TaWduYWxzIHRoZSBoYW5kbGVyIHRoYXQgcGFyc2luZyBpcyBkb25lXG5Eb21IYW5kbGVyLnByb3RvdHlwZS5vbmVuZCA9IGZ1bmN0aW9uKCl7XG5cdGlmKHRoaXMuX2RvbmUpIHJldHVybjtcblx0dGhpcy5fZG9uZSA9IHRydWU7XG5cdHRoaXMuX3BhcnNlciA9IG51bGw7XG5cdHRoaXMuX2hhbmRsZUNhbGxiYWNrKG51bGwpO1xufTtcblxuRG9tSGFuZGxlci5wcm90b3R5cGUuX2hhbmRsZUNhbGxiYWNrID1cbkRvbUhhbmRsZXIucHJvdG90eXBlLm9uZXJyb3IgPSBmdW5jdGlvbihlcnJvcil7XG5cdGlmKHR5cGVvZiB0aGlzLl9jYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKXtcblx0XHR0aGlzLl9jYWxsYmFjayhlcnJvciwgdGhpcy5kb20pO1xuXHR9IGVsc2Uge1xuXHRcdGlmKGVycm9yKSB0aHJvdyBlcnJvcjtcblx0fVxufTtcblxuRG9tSGFuZGxlci5wcm90b3R5cGUub25jbG9zZXRhZyA9IGZ1bmN0aW9uKCl7XG5cdC8vaWYodGhpcy5fdGFnU3RhY2sucG9wKCkubmFtZSAhPT0gbmFtZSkgdGhpcy5faGFuZGxlQ2FsbGJhY2soRXJyb3IoXCJUYWduYW1lIGRpZG4ndCBtYXRjaCFcIikpO1xuXHR2YXIgZWxlbSA9IHRoaXMuX3RhZ1N0YWNrLnBvcCgpO1xuXHRpZih0aGlzLl9lbGVtZW50Q0IpIHRoaXMuX2VsZW1lbnRDQihlbGVtKTtcbn07XG5cbkRvbUhhbmRsZXIucHJvdG90eXBlLl9hZGREb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCl7XG5cdHZhciBwYXJlbnQgPSB0aGlzLl90YWdTdGFja1t0aGlzLl90YWdTdGFjay5sZW5ndGggLSAxXTtcblx0dmFyIHNpYmxpbmdzID0gcGFyZW50ID8gcGFyZW50LmNoaWxkcmVuIDogdGhpcy5kb207XG5cdHZhciBwcmV2aW91c1NpYmxpbmcgPSBzaWJsaW5nc1tzaWJsaW5ncy5sZW5ndGggLSAxXTtcblxuXHRlbGVtZW50Lm5leHQgPSBudWxsO1xuXG5cdGlmKHRoaXMuX29wdGlvbnMud2l0aFN0YXJ0SW5kaWNlcyl7XG5cdFx0ZWxlbWVudC5zdGFydEluZGV4ID0gdGhpcy5fcGFyc2VyLnN0YXJ0SW5kZXg7XG5cdH1cblxuXHRpZiAodGhpcy5fb3B0aW9ucy53aXRoRG9tTHZsMSkge1xuXHRcdGVsZW1lbnQuX19wcm90b19fID0gZWxlbWVudC50eXBlID09PSBcInRhZ1wiID8gRWxlbWVudFByb3RvdHlwZSA6IE5vZGVQcm90b3R5cGU7XG5cdH1cblxuXHRpZihwcmV2aW91c1NpYmxpbmcpe1xuXHRcdGVsZW1lbnQucHJldiA9IHByZXZpb3VzU2libGluZztcblx0XHRwcmV2aW91c1NpYmxpbmcubmV4dCA9IGVsZW1lbnQ7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbWVudC5wcmV2ID0gbnVsbDtcblx0fVxuXG5cdHNpYmxpbmdzLnB1c2goZWxlbWVudCk7XG5cdGVsZW1lbnQucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG59O1xuXG5Eb21IYW5kbGVyLnByb3RvdHlwZS5vbm9wZW50YWcgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJzKXtcblx0dmFyIGVsZW1lbnQgPSB7XG5cdFx0dHlwZTogbmFtZSA9PT0gXCJzY3JpcHRcIiA/IEVsZW1lbnRUeXBlLlNjcmlwdCA6IG5hbWUgPT09IFwic3R5bGVcIiA/IEVsZW1lbnRUeXBlLlN0eWxlIDogRWxlbWVudFR5cGUuVGFnLFxuXHRcdG5hbWU6IG5hbWUsXG5cdFx0YXR0cmliczogYXR0cmlicyxcblx0XHRjaGlsZHJlbjogW11cblx0fTtcblxuXHR0aGlzLl9hZGREb21FbGVtZW50KGVsZW1lbnQpO1xuXG5cdHRoaXMuX3RhZ1N0YWNrLnB1c2goZWxlbWVudCk7XG59O1xuXG5Eb21IYW5kbGVyLnByb3RvdHlwZS5vbnRleHQgPSBmdW5jdGlvbihkYXRhKXtcblx0Ly90aGUgaWdub3JlV2hpdGVzcGFjZSBpcyBvZmZpY2lhbGx5IGRyb3BwZWQsIGJ1dCBmb3Igbm93LFxuXHQvL2l0J3MgYW4gYWxpYXMgZm9yIG5vcm1hbGl6ZVdoaXRlc3BhY2Vcblx0dmFyIG5vcm1hbGl6ZSA9IHRoaXMuX29wdGlvbnMubm9ybWFsaXplV2hpdGVzcGFjZSB8fCB0aGlzLl9vcHRpb25zLmlnbm9yZVdoaXRlc3BhY2U7XG5cblx0dmFyIGxhc3RUYWc7XG5cblx0aWYoIXRoaXMuX3RhZ1N0YWNrLmxlbmd0aCAmJiB0aGlzLmRvbS5sZW5ndGggJiYgKGxhc3RUYWcgPSB0aGlzLmRvbVt0aGlzLmRvbS5sZW5ndGgtMV0pLnR5cGUgPT09IEVsZW1lbnRUeXBlLlRleHQpe1xuXHRcdGlmKG5vcm1hbGl6ZSl7XG5cdFx0XHRsYXN0VGFnLmRhdGEgPSAobGFzdFRhZy5kYXRhICsgZGF0YSkucmVwbGFjZShyZV93aGl0ZXNwYWNlLCBcIiBcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxhc3RUYWcuZGF0YSArPSBkYXRhO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRpZihcblx0XHRcdHRoaXMuX3RhZ1N0YWNrLmxlbmd0aCAmJlxuXHRcdFx0KGxhc3RUYWcgPSB0aGlzLl90YWdTdGFja1t0aGlzLl90YWdTdGFjay5sZW5ndGggLSAxXSkgJiZcblx0XHRcdChsYXN0VGFnID0gbGFzdFRhZy5jaGlsZHJlbltsYXN0VGFnLmNoaWxkcmVuLmxlbmd0aCAtIDFdKSAmJlxuXHRcdFx0bGFzdFRhZy50eXBlID09PSBFbGVtZW50VHlwZS5UZXh0XG5cdFx0KXtcblx0XHRcdGlmKG5vcm1hbGl6ZSl7XG5cdFx0XHRcdGxhc3RUYWcuZGF0YSA9IChsYXN0VGFnLmRhdGEgKyBkYXRhKS5yZXBsYWNlKHJlX3doaXRlc3BhY2UsIFwiIFwiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxhc3RUYWcuZGF0YSArPSBkYXRhO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZihub3JtYWxpemUpe1xuXHRcdFx0XHRkYXRhID0gZGF0YS5yZXBsYWNlKHJlX3doaXRlc3BhY2UsIFwiIFwiKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fYWRkRG9tRWxlbWVudCh7XG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdHR5cGU6IEVsZW1lbnRUeXBlLlRleHRcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufTtcblxuRG9tSGFuZGxlci5wcm90b3R5cGUub25jb21tZW50ID0gZnVuY3Rpb24oZGF0YSl7XG5cdHZhciBsYXN0VGFnID0gdGhpcy5fdGFnU3RhY2tbdGhpcy5fdGFnU3RhY2subGVuZ3RoIC0gMV07XG5cblx0aWYobGFzdFRhZyAmJiBsYXN0VGFnLnR5cGUgPT09IEVsZW1lbnRUeXBlLkNvbW1lbnQpe1xuXHRcdGxhc3RUYWcuZGF0YSArPSBkYXRhO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBlbGVtZW50ID0ge1xuXHRcdGRhdGE6IGRhdGEsXG5cdFx0dHlwZTogRWxlbWVudFR5cGUuQ29tbWVudFxuXHR9O1xuXG5cdHRoaXMuX2FkZERvbUVsZW1lbnQoZWxlbWVudCk7XG5cdHRoaXMuX3RhZ1N0YWNrLnB1c2goZWxlbWVudCk7XG59O1xuXG5Eb21IYW5kbGVyLnByb3RvdHlwZS5vbmNkYXRhc3RhcnQgPSBmdW5jdGlvbigpe1xuXHR2YXIgZWxlbWVudCA9IHtcblx0XHRjaGlsZHJlbjogW3tcblx0XHRcdGRhdGE6IFwiXCIsXG5cdFx0XHR0eXBlOiBFbGVtZW50VHlwZS5UZXh0XG5cdFx0fV0sXG5cdFx0dHlwZTogRWxlbWVudFR5cGUuQ0RBVEFcblx0fTtcblxuXHR0aGlzLl9hZGREb21FbGVtZW50KGVsZW1lbnQpO1xuXHR0aGlzLl90YWdTdGFjay5wdXNoKGVsZW1lbnQpO1xufTtcblxuRG9tSGFuZGxlci5wcm90b3R5cGUub25jb21tZW50ZW5kID0gRG9tSGFuZGxlci5wcm90b3R5cGUub25jZGF0YWVuZCA9IGZ1bmN0aW9uKCl7XG5cdHRoaXMuX3RhZ1N0YWNrLnBvcCgpO1xufTtcblxuRG9tSGFuZGxlci5wcm90b3R5cGUub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbihuYW1lLCBkYXRhKXtcblx0dGhpcy5fYWRkRG9tRWxlbWVudCh7XG5cdFx0bmFtZTogbmFtZSxcblx0XHRkYXRhOiBkYXRhLFxuXHRcdHR5cGU6IEVsZW1lbnRUeXBlLkRpcmVjdGl2ZVxuXHR9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRG9tSGFuZGxlcjtcbiIsIi8vIERPTS1MZXZlbC0xLWNvbXBsaWFudCBzdHJ1Y3R1cmVcbnZhciBOb2RlUHJvdG90eXBlID0gcmVxdWlyZSgnLi9ub2RlJyk7XG52YXIgRWxlbWVudFByb3RvdHlwZSA9IG1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZShOb2RlUHJvdG90eXBlKTtcblxudmFyIGRvbUx2bDEgPSB7XG5cdHRhZ05hbWU6IFwibmFtZVwiXG59O1xuXG5PYmplY3Qua2V5cyhkb21MdmwxKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHR2YXIgc2hvcnRoYW5kID0gZG9tTHZsMVtrZXldO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoRWxlbWVudFByb3RvdHlwZSwga2V5LCB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzW3Nob3J0aGFuZF0gfHwgbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHR0aGlzW3Nob3J0aGFuZF0gPSB2YWw7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0fSk7XG59KTtcbiIsIi8vIFRoaXMgb2JqZWN0IHdpbGwgYmUgdXNlZCBhcyB0aGUgcHJvdG90eXBlIGZvciBOb2RlcyB3aGVuIGNyZWF0aW5nIGFcbi8vIERPTS1MZXZlbC0xLWNvbXBsaWFudCBzdHJ1Y3R1cmUuXG52YXIgTm9kZVByb3RvdHlwZSA9IG1vZHVsZS5leHBvcnRzID0ge1xuXHRnZXQgZmlyc3RDaGlsZCgpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXHRcdHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlblswXSB8fCBudWxsO1xuXHR9LFxuXHRnZXQgbGFzdENoaWxkKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cdFx0cmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdIHx8IG51bGw7XG5cdH0sXG5cdGdldCBub2RlVHlwZSgpIHtcblx0XHRyZXR1cm4gbm9kZVR5cGVzW3RoaXMudHlwZV0gfHwgbm9kZVR5cGVzLmVsZW1lbnQ7XG5cdH1cbn07XG5cbnZhciBkb21MdmwxID0ge1xuXHR0YWdOYW1lOiBcIm5hbWVcIixcblx0Y2hpbGROb2RlczogXCJjaGlsZHJlblwiLFxuXHRwYXJlbnROb2RlOiBcInBhcmVudFwiLFxuXHRwcmV2aW91c1NpYmxpbmc6IFwicHJldlwiLFxuXHRuZXh0U2libGluZzogXCJuZXh0XCIsXG5cdG5vZGVWYWx1ZTogXCJkYXRhXCJcbn07XG5cbnZhciBub2RlVHlwZXMgPSB7XG5cdGVsZW1lbnQ6IDEsXG5cdHRleHQ6IDMsXG5cdGNkYXRhOiA0LFxuXHRjb21tZW50OiA4XG59O1xuXG5PYmplY3Qua2V5cyhkb21MdmwxKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHR2YXIgc2hvcnRoYW5kID0gZG9tTHZsMVtrZXldO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZVByb3RvdHlwZSwga2V5LCB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzW3Nob3J0aGFuZF0gfHwgbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHR0aGlzW3Nob3J0aGFuZF0gPSB2YWw7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0fSk7XG59KTtcbiIsInZhciBEb21VdGlscyA9IG1vZHVsZS5leHBvcnRzO1xuXG5bXG5cdHJlcXVpcmUoXCIuL2xpYi9zdHJpbmdpZnlcIiksXG5cdHJlcXVpcmUoXCIuL2xpYi90cmF2ZXJzYWxcIiksXG5cdHJlcXVpcmUoXCIuL2xpYi9tYW5pcHVsYXRpb25cIiksXG5cdHJlcXVpcmUoXCIuL2xpYi9xdWVyeWluZ1wiKSxcblx0cmVxdWlyZShcIi4vbGliL2xlZ2FjeVwiKSxcblx0cmVxdWlyZShcIi4vbGliL2hlbHBlcnNcIilcbl0uZm9yRWFjaChmdW5jdGlvbihleHQpe1xuXHRPYmplY3Qua2V5cyhleHQpLmZvckVhY2goZnVuY3Rpb24oa2V5KXtcblx0XHREb21VdGlsc1trZXldID0gZXh0W2tleV0uYmluZChEb21VdGlscyk7XG5cdH0pO1xufSk7XG4iLCIvLyByZW1vdmVTdWJzZXRzXG4vLyBHaXZlbiBhbiBhcnJheSBvZiBub2RlcywgcmVtb3ZlIGFueSBtZW1iZXIgdGhhdCBpcyBjb250YWluZWQgYnkgYW5vdGhlci5cbmV4cG9ydHMucmVtb3ZlU3Vic2V0cyA9IGZ1bmN0aW9uKG5vZGVzKSB7XG5cdHZhciBpZHggPSBub2Rlcy5sZW5ndGgsIG5vZGUsIGFuY2VzdG9yLCByZXBsYWNlO1xuXG5cdC8vIENoZWNrIGlmIGVhY2ggbm9kZSAob3Igb25lIG9mIGl0cyBhbmNlc3RvcnMpIGlzIGFscmVhZHkgY29udGFpbmVkIGluIHRoZVxuXHQvLyBhcnJheS5cblx0d2hpbGUgKC0taWR4ID4gLTEpIHtcblx0XHRub2RlID0gYW5jZXN0b3IgPSBub2Rlc1tpZHhdO1xuXG5cdFx0Ly8gVGVtcG9yYXJpbHkgcmVtb3ZlIHRoZSBub2RlIHVuZGVyIGNvbnNpZGVyYXRpb25cblx0XHRub2Rlc1tpZHhdID0gbnVsbDtcblx0XHRyZXBsYWNlID0gdHJ1ZTtcblxuXHRcdHdoaWxlIChhbmNlc3Rvcikge1xuXHRcdFx0aWYgKG5vZGVzLmluZGV4T2YoYW5jZXN0b3IpID4gLTEpIHtcblx0XHRcdFx0cmVwbGFjZSA9IGZhbHNlO1xuXHRcdFx0XHRub2Rlcy5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgbm9kZSBoYXMgYmVlbiBmb3VuZCB0byBiZSB1bmlxdWUsIHJlLWluc2VydCBpdC5cblx0XHRpZiAocmVwbGFjZSkge1xuXHRcdFx0bm9kZXNbaWR4XSA9IG5vZGU7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5vZGVzO1xufTtcblxuLy8gU291cmNlOiBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLW5vZGUtY29tcGFyZWRvY3VtZW50cG9zaXRpb25cbnZhciBQT1NJVElPTiA9IHtcblx0RElTQ09OTkVDVEVEOiAxLFxuXHRQUkVDRURJTkc6IDIsXG5cdEZPTExPV0lORzogNCxcblx0Q09OVEFJTlM6IDgsXG5cdENPTlRBSU5FRF9CWTogMTZcbn07XG5cbi8vIENvbXBhcmUgdGhlIHBvc2l0aW9uIG9mIG9uZSBub2RlIGFnYWluc3QgYW5vdGhlciBub2RlIGluIGFueSBvdGhlciBkb2N1bWVudC5cbi8vIFRoZSByZXR1cm4gdmFsdWUgaXMgYSBiaXRtYXNrIHdpdGggdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4vL1xuLy8gZG9jdW1lbnQgb3JkZXI6XG4vLyA+IFRoZXJlIGlzIGFuIG9yZGVyaW5nLCBkb2N1bWVudCBvcmRlciwgZGVmaW5lZCBvbiBhbGwgdGhlIG5vZGVzIGluIHRoZVxuLy8gPiBkb2N1bWVudCBjb3JyZXNwb25kaW5nIHRvIHRoZSBvcmRlciBpbiB3aGljaCB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZVxuLy8gPiBYTUwgcmVwcmVzZW50YXRpb24gb2YgZWFjaCBub2RlIG9jY3VycyBpbiB0aGUgWE1MIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuLy8gPiBkb2N1bWVudCBhZnRlciBleHBhbnNpb24gb2YgZ2VuZXJhbCBlbnRpdGllcy4gVGh1cywgdGhlIGRvY3VtZW50IGVsZW1lbnRcbi8vID4gbm9kZSB3aWxsIGJlIHRoZSBmaXJzdCBub2RlLiBFbGVtZW50IG5vZGVzIG9jY3VyIGJlZm9yZSB0aGVpciBjaGlsZHJlbi5cbi8vID4gVGh1cywgZG9jdW1lbnQgb3JkZXIgb3JkZXJzIGVsZW1lbnQgbm9kZXMgaW4gb3JkZXIgb2YgdGhlIG9jY3VycmVuY2Ugb2Zcbi8vID4gdGhlaXIgc3RhcnQtdGFnIGluIHRoZSBYTUwgKGFmdGVyIGV4cGFuc2lvbiBvZiBlbnRpdGllcykuIFRoZSBhdHRyaWJ1dGVcbi8vID4gbm9kZXMgb2YgYW4gZWxlbWVudCBvY2N1ciBhZnRlciB0aGUgZWxlbWVudCBhbmQgYmVmb3JlIGl0cyBjaGlsZHJlbi4gVGhlXG4vLyA+IHJlbGF0aXZlIG9yZGVyIG9mIGF0dHJpYnV0ZSBub2RlcyBpcyBpbXBsZW1lbnRhdGlvbi1kZXBlbmRlbnQuL1xuLy8gU291cmNlOlxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtQ29yZS9nbG9zc2FyeS5odG1sI2R0LWRvY3VtZW50LW9yZGVyXG4vL1xuLy8gQGFyZ3VtZW50IHtOb2RlfSBub2RhQSBUaGUgZmlyc3Qgbm9kZSB0byB1c2UgaW4gdGhlIGNvbXBhcmlzb25cbi8vIEBhcmd1bWVudCB7Tm9kZX0gbm9kZUIgVGhlIHNlY29uZCBub2RlIHRvIHVzZSBpbiB0aGUgY29tcGFyaXNvblxuLy9cbi8vIEByZXR1cm4ge051bWJlcn0gQSBiaXRtYXNrIGRlc2NyaWJpbmcgdGhlIGlucHV0IG5vZGVzJyByZWxhdGl2ZSBwb3NpdGlvbi5cbi8vICAgICAgICAgU2VlIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tbm9kZS1jb21wYXJlZG9jdW1lbnRwb3NpdGlvbiBmb3Jcbi8vICAgICAgICAgYSBkZXNjcmlwdGlvbiBvZiB0aGVzZSB2YWx1ZXMuXG52YXIgY29tcGFyZVBvcyA9IGV4cG9ydHMuY29tcGFyZURvY3VtZW50UG9zaXRpb24gPSBmdW5jdGlvbihub2RlQSwgbm9kZUIpIHtcblx0dmFyIGFQYXJlbnRzID0gW107XG5cdHZhciBiUGFyZW50cyA9IFtdO1xuXHR2YXIgY3VycmVudCwgc2hhcmVkUGFyZW50LCBzaWJsaW5ncywgYVNpYmxpbmcsIGJTaWJsaW5nLCBpZHg7XG5cblx0aWYgKG5vZGVBID09PSBub2RlQikge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Y3VycmVudCA9IG5vZGVBO1xuXHR3aGlsZSAoY3VycmVudCkge1xuXHRcdGFQYXJlbnRzLnVuc2hpZnQoY3VycmVudCk7XG5cdFx0Y3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuXHR9XG5cdGN1cnJlbnQgPSBub2RlQjtcblx0d2hpbGUgKGN1cnJlbnQpIHtcblx0XHRiUGFyZW50cy51bnNoaWZ0KGN1cnJlbnQpO1xuXHRcdGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcblx0fVxuXG5cdGlkeCA9IDA7XG5cdHdoaWxlIChhUGFyZW50c1tpZHhdID09PSBiUGFyZW50c1tpZHhdKSB7XG5cdFx0aWR4Kys7XG5cdH1cblxuXHRpZiAoaWR4ID09PSAwKSB7XG5cdFx0cmV0dXJuIFBPU0lUSU9OLkRJU0NPTk5FQ1RFRDtcblx0fVxuXG5cdHNoYXJlZFBhcmVudCA9IGFQYXJlbnRzW2lkeCAtIDFdO1xuXHRzaWJsaW5ncyA9IHNoYXJlZFBhcmVudC5jaGlsZHJlbjtcblx0YVNpYmxpbmcgPSBhUGFyZW50c1tpZHhdO1xuXHRiU2libGluZyA9IGJQYXJlbnRzW2lkeF07XG5cblx0aWYgKHNpYmxpbmdzLmluZGV4T2YoYVNpYmxpbmcpID4gc2libGluZ3MuaW5kZXhPZihiU2libGluZykpIHtcblx0XHRpZiAoc2hhcmVkUGFyZW50ID09PSBub2RlQikge1xuXHRcdFx0cmV0dXJuIFBPU0lUSU9OLkZPTExPV0lORyB8IFBPU0lUSU9OLkNPTlRBSU5FRF9CWTtcblx0XHR9XG5cdFx0cmV0dXJuIFBPU0lUSU9OLkZPTExPV0lORztcblx0fSBlbHNlIHtcblx0XHRpZiAoc2hhcmVkUGFyZW50ID09PSBub2RlQSkge1xuXHRcdFx0cmV0dXJuIFBPU0lUSU9OLlBSRUNFRElORyB8IFBPU0lUSU9OLkNPTlRBSU5TO1xuXHRcdH1cblx0XHRyZXR1cm4gUE9TSVRJT04uUFJFQ0VESU5HO1xuXHR9XG59O1xuXG4vLyBTb3J0IGFuIGFycmF5IG9mIG5vZGVzIGJhc2VkIG9uIHRoZWlyIHJlbGF0aXZlIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCBhbmRcbi8vIHJlbW92ZSBhbnkgZHVwbGljYXRlIG5vZGVzLiBJZiB0aGUgYXJyYXkgY29udGFpbnMgbm9kZXMgdGhhdCBkbyBub3QgYmVsb25nXG4vLyB0byB0aGUgc2FtZSBkb2N1bWVudCwgc29ydCBvcmRlciBpcyB1bnNwZWNpZmllZC5cbi8vXG4vLyBAYXJndW1lbnQge0FycmF5fSBub2RlcyBBcnJheSBvZiBET00gbm9kZXNcbi8vXG4vLyBAcmV0dXJucyB7QXJyYXl9IGNvbGxlY3Rpb24gb2YgdW5pcXVlIG5vZGVzLCBzb3J0ZWQgaW4gZG9jdW1lbnQgb3JkZXJcbmV4cG9ydHMudW5pcXVlU29ydCA9IGZ1bmN0aW9uKG5vZGVzKSB7XG5cdHZhciBpZHggPSBub2Rlcy5sZW5ndGgsIG5vZGUsIHBvc2l0aW9uO1xuXG5cdG5vZGVzID0gbm9kZXMuc2xpY2UoKTtcblxuXHR3aGlsZSAoLS1pZHggPiAtMSkge1xuXHRcdG5vZGUgPSBub2Rlc1tpZHhdO1xuXHRcdHBvc2l0aW9uID0gbm9kZXMuaW5kZXhPZihub2RlKTtcblx0XHRpZiAocG9zaXRpb24gPiAtMSAmJiBwb3NpdGlvbiA8IGlkeCkge1xuXHRcdFx0bm9kZXMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0fVxuXHR9XG5cdG5vZGVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdHZhciByZWxhdGl2ZSA9IGNvbXBhcmVQb3MoYSwgYik7XG5cdFx0aWYgKHJlbGF0aXZlICYgUE9TSVRJT04uUFJFQ0VESU5HKSB7XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fSBlbHNlIGlmIChyZWxhdGl2ZSAmIFBPU0lUSU9OLkZPTExPV0lORykge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9KTtcblxuXHRyZXR1cm4gbm9kZXM7XG59O1xuIiwidmFyIEVsZW1lbnRUeXBlID0gcmVxdWlyZShcImRvbWVsZW1lbnR0eXBlXCIpO1xudmFyIGlzVGFnID0gZXhwb3J0cy5pc1RhZyA9IEVsZW1lbnRUeXBlLmlzVGFnO1xuXG5leHBvcnRzLnRlc3RFbGVtZW50ID0gZnVuY3Rpb24ob3B0aW9ucywgZWxlbWVudCl7XG5cdGZvcih2YXIga2V5IGluIG9wdGlvbnMpe1xuXHRcdGlmKCFvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpO1xuXHRcdGVsc2UgaWYoa2V5ID09PSBcInRhZ19uYW1lXCIpe1xuXHRcdFx0aWYoIWlzVGFnKGVsZW1lbnQpIHx8ICFvcHRpb25zLnRhZ19uYW1lKGVsZW1lbnQubmFtZSkpe1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmKGtleSA9PT0gXCJ0YWdfdHlwZVwiKXtcblx0XHRcdGlmKCFvcHRpb25zLnRhZ190eXBlKGVsZW1lbnQudHlwZSkpIHJldHVybiBmYWxzZTtcblx0XHR9IGVsc2UgaWYoa2V5ID09PSBcInRhZ19jb250YWluc1wiKXtcblx0XHRcdGlmKGlzVGFnKGVsZW1lbnQpIHx8ICFvcHRpb25zLnRhZ19jb250YWlucyhlbGVtZW50LmRhdGEpKXtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZighZWxlbWVudC5hdHRyaWJzIHx8ICFvcHRpb25zW2tleV0oZWxlbWVudC5hdHRyaWJzW2tleV0pKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRydWU7XG59O1xuXG52YXIgQ2hlY2tzID0ge1xuXHR0YWdfbmFtZTogZnVuY3Rpb24obmFtZSl7XG5cdFx0aWYodHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIil7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oZWxlbSl7IHJldHVybiBpc1RhZyhlbGVtKSAmJiBuYW1lKGVsZW0ubmFtZSk7IH07XG5cdFx0fSBlbHNlIGlmKG5hbWUgPT09IFwiKlwiKXtcblx0XHRcdHJldHVybiBpc1RhZztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGVsZW0peyByZXR1cm4gaXNUYWcoZWxlbSkgJiYgZWxlbS5uYW1lID09PSBuYW1lOyB9O1xuXHRcdH1cblx0fSxcblx0dGFnX3R5cGU6IGZ1bmN0aW9uKHR5cGUpe1xuXHRcdGlmKHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIpe1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGVsZW0peyByZXR1cm4gdHlwZShlbGVtLnR5cGUpOyB9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oZWxlbSl7IHJldHVybiBlbGVtLnR5cGUgPT09IHR5cGU7IH07XG5cdFx0fVxuXHR9LFxuXHR0YWdfY29udGFpbnM6IGZ1bmN0aW9uKGRhdGEpe1xuXHRcdGlmKHR5cGVvZiBkYXRhID09PSBcImZ1bmN0aW9uXCIpe1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGVsZW0peyByZXR1cm4gIWlzVGFnKGVsZW0pICYmIGRhdGEoZWxlbS5kYXRhKTsgfTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGVsZW0peyByZXR1cm4gIWlzVGFnKGVsZW0pICYmIGVsZW0uZGF0YSA9PT0gZGF0YTsgfTtcblx0XHR9XG5cdH1cbn07XG5cbmZ1bmN0aW9uIGdldEF0dHJpYkNoZWNrKGF0dHJpYiwgdmFsdWUpe1xuXHRpZih0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIil7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGVsZW0peyByZXR1cm4gZWxlbS5hdHRyaWJzICYmIHZhbHVlKGVsZW0uYXR0cmlic1thdHRyaWJdKTsgfTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oZWxlbSl7IHJldHVybiBlbGVtLmF0dHJpYnMgJiYgZWxlbS5hdHRyaWJzW2F0dHJpYl0gPT09IHZhbHVlOyB9O1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVGdW5jcyhhLCBiKXtcblx0cmV0dXJuIGZ1bmN0aW9uKGVsZW0pe1xuXHRcdHJldHVybiBhKGVsZW0pIHx8IGIoZWxlbSk7XG5cdH07XG59XG5cbmV4cG9ydHMuZ2V0RWxlbWVudHMgPSBmdW5jdGlvbihvcHRpb25zLCBlbGVtZW50LCByZWN1cnNlLCBsaW1pdCl7XG5cdHZhciBmdW5jcyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpLm1hcChmdW5jdGlvbihrZXkpe1xuXHRcdHZhciB2YWx1ZSA9IG9wdGlvbnNba2V5XTtcblx0XHRyZXR1cm4ga2V5IGluIENoZWNrcyA/IENoZWNrc1trZXldKHZhbHVlKSA6IGdldEF0dHJpYkNoZWNrKGtleSwgdmFsdWUpO1xuXHR9KTtcblxuXHRyZXR1cm4gZnVuY3MubGVuZ3RoID09PSAwID8gW10gOiB0aGlzLmZpbHRlcihcblx0XHRmdW5jcy5yZWR1Y2UoY29tYmluZUZ1bmNzKSxcblx0XHRlbGVtZW50LCByZWN1cnNlLCBsaW1pdFxuXHQpO1xufTtcblxuZXhwb3J0cy5nZXRFbGVtZW50QnlJZCA9IGZ1bmN0aW9uKGlkLCBlbGVtZW50LCByZWN1cnNlKXtcblx0aWYoIUFycmF5LmlzQXJyYXkoZWxlbWVudCkpIGVsZW1lbnQgPSBbZWxlbWVudF07XG5cdHJldHVybiB0aGlzLmZpbmRPbmUoZ2V0QXR0cmliQ2hlY2soXCJpZFwiLCBpZCksIGVsZW1lbnQsIHJlY3Vyc2UgIT09IGZhbHNlKTtcbn07XG5cbmV4cG9ydHMuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBmdW5jdGlvbihuYW1lLCBlbGVtZW50LCByZWN1cnNlLCBsaW1pdCl7XG5cdHJldHVybiB0aGlzLmZpbHRlcihDaGVja3MudGFnX25hbWUobmFtZSksIGVsZW1lbnQsIHJlY3Vyc2UsIGxpbWl0KTtcbn07XG5cbmV4cG9ydHMuZ2V0RWxlbWVudHNCeVRhZ1R5cGUgPSBmdW5jdGlvbih0eXBlLCBlbGVtZW50LCByZWN1cnNlLCBsaW1pdCl7XG5cdHJldHVybiB0aGlzLmZpbHRlcihDaGVja3MudGFnX3R5cGUodHlwZSksIGVsZW1lbnQsIHJlY3Vyc2UsIGxpbWl0KTtcbn07XG4iLCJleHBvcnRzLnJlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtKXtcblx0aWYoZWxlbS5wcmV2KSBlbGVtLnByZXYubmV4dCA9IGVsZW0ubmV4dDtcblx0aWYoZWxlbS5uZXh0KSBlbGVtLm5leHQucHJldiA9IGVsZW0ucHJldjtcblxuXHRpZihlbGVtLnBhcmVudCl7XG5cdFx0dmFyIGNoaWxkcyA9IGVsZW0ucGFyZW50LmNoaWxkcmVuO1xuXHRcdGNoaWxkcy5zcGxpY2UoY2hpbGRzLmxhc3RJbmRleE9mKGVsZW0pLCAxKTtcblx0fVxufTtcblxuZXhwb3J0cy5yZXBsYWNlRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW0sIHJlcGxhY2VtZW50KXtcblx0dmFyIHByZXYgPSByZXBsYWNlbWVudC5wcmV2ID0gZWxlbS5wcmV2O1xuXHRpZihwcmV2KXtcblx0XHRwcmV2Lm5leHQgPSByZXBsYWNlbWVudDtcblx0fVxuXG5cdHZhciBuZXh0ID0gcmVwbGFjZW1lbnQubmV4dCA9IGVsZW0ubmV4dDtcblx0aWYobmV4dCl7XG5cdFx0bmV4dC5wcmV2ID0gcmVwbGFjZW1lbnQ7XG5cdH1cblxuXHR2YXIgcGFyZW50ID0gcmVwbGFjZW1lbnQucGFyZW50ID0gZWxlbS5wYXJlbnQ7XG5cdGlmKHBhcmVudCl7XG5cdFx0dmFyIGNoaWxkcyA9IHBhcmVudC5jaGlsZHJlbjtcblx0XHRjaGlsZHNbY2hpbGRzLmxhc3RJbmRleE9mKGVsZW0pXSA9IHJlcGxhY2VtZW50O1xuXHR9XG59O1xuXG5leHBvcnRzLmFwcGVuZENoaWxkID0gZnVuY3Rpb24oZWxlbSwgY2hpbGQpe1xuXHRjaGlsZC5wYXJlbnQgPSBlbGVtO1xuXG5cdGlmKGVsZW0uY2hpbGRyZW4ucHVzaChjaGlsZCkgIT09IDEpe1xuXHRcdHZhciBzaWJsaW5nID0gZWxlbS5jaGlsZHJlbltlbGVtLmNoaWxkcmVuLmxlbmd0aCAtIDJdO1xuXHRcdHNpYmxpbmcubmV4dCA9IGNoaWxkO1xuXHRcdGNoaWxkLnByZXYgPSBzaWJsaW5nO1xuXHRcdGNoaWxkLm5leHQgPSBudWxsO1xuXHR9XG59O1xuXG5leHBvcnRzLmFwcGVuZCA9IGZ1bmN0aW9uKGVsZW0sIG5leHQpe1xuXHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnQsXG5cdFx0Y3Vyck5leHQgPSBlbGVtLm5leHQ7XG5cblx0bmV4dC5uZXh0ID0gY3Vyck5leHQ7XG5cdG5leHQucHJldiA9IGVsZW07XG5cdGVsZW0ubmV4dCA9IG5leHQ7XG5cdG5leHQucGFyZW50ID0gcGFyZW50O1xuXG5cdGlmKGN1cnJOZXh0KXtcblx0XHRjdXJyTmV4dC5wcmV2ID0gbmV4dDtcblx0XHRpZihwYXJlbnQpe1xuXHRcdFx0dmFyIGNoaWxkcyA9IHBhcmVudC5jaGlsZHJlbjtcblx0XHRcdGNoaWxkcy5zcGxpY2UoY2hpbGRzLmxhc3RJbmRleE9mKGN1cnJOZXh0KSwgMCwgbmV4dCk7XG5cdFx0fVxuXHR9IGVsc2UgaWYocGFyZW50KXtcblx0XHRwYXJlbnQuY2hpbGRyZW4ucHVzaChuZXh0KTtcblx0fVxufTtcblxuZXhwb3J0cy5wcmVwZW5kID0gZnVuY3Rpb24oZWxlbSwgcHJldil7XG5cdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudDtcblx0aWYocGFyZW50KXtcblx0XHR2YXIgY2hpbGRzID0gcGFyZW50LmNoaWxkcmVuO1xuXHRcdGNoaWxkcy5zcGxpY2UoY2hpbGRzLmxhc3RJbmRleE9mKGVsZW0pLCAwLCBwcmV2KTtcblx0fVxuXG5cdGlmKGVsZW0ucHJldil7XG5cdFx0ZWxlbS5wcmV2Lm5leHQgPSBwcmV2O1xuXHR9XG5cdFxuXHRwcmV2LnBhcmVudCA9IHBhcmVudDtcblx0cHJldi5wcmV2ID0gZWxlbS5wcmV2O1xuXHRwcmV2Lm5leHQgPSBlbGVtO1xuXHRlbGVtLnByZXYgPSBwcmV2O1xufTtcblxuXG4iLCJ2YXIgaXNUYWcgPSByZXF1aXJlKFwiZG9tZWxlbWVudHR5cGVcIikuaXNUYWc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRmaWx0ZXI6IGZpbHRlcixcblx0ZmluZDogZmluZCxcblx0ZmluZE9uZUNoaWxkOiBmaW5kT25lQ2hpbGQsXG5cdGZpbmRPbmU6IGZpbmRPbmUsXG5cdGV4aXN0c09uZTogZXhpc3RzT25lLFxuXHRmaW5kQWxsOiBmaW5kQWxsXG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIodGVzdCwgZWxlbWVudCwgcmVjdXJzZSwgbGltaXQpe1xuXHRpZighQXJyYXkuaXNBcnJheShlbGVtZW50KSkgZWxlbWVudCA9IFtlbGVtZW50XTtcblxuXHRpZih0eXBlb2YgbGltaXQgIT09IFwibnVtYmVyXCIgfHwgIWlzRmluaXRlKGxpbWl0KSl7XG5cdFx0bGltaXQgPSBJbmZpbml0eTtcblx0fVxuXHRyZXR1cm4gZmluZCh0ZXN0LCBlbGVtZW50LCByZWN1cnNlICE9PSBmYWxzZSwgbGltaXQpO1xufVxuXG5mdW5jdGlvbiBmaW5kKHRlc3QsIGVsZW1zLCByZWN1cnNlLCBsaW1pdCl7XG5cdHZhciByZXN1bHQgPSBbXSwgY2hpbGRzO1xuXG5cdGZvcih2YXIgaSA9IDAsIGogPSBlbGVtcy5sZW5ndGg7IGkgPCBqOyBpKyspe1xuXHRcdGlmKHRlc3QoZWxlbXNbaV0pKXtcblx0XHRcdHJlc3VsdC5wdXNoKGVsZW1zW2ldKTtcblx0XHRcdGlmKC0tbGltaXQgPD0gMCkgYnJlYWs7XG5cdFx0fVxuXG5cdFx0Y2hpbGRzID0gZWxlbXNbaV0uY2hpbGRyZW47XG5cdFx0aWYocmVjdXJzZSAmJiBjaGlsZHMgJiYgY2hpbGRzLmxlbmd0aCA+IDApe1xuXHRcdFx0Y2hpbGRzID0gZmluZCh0ZXN0LCBjaGlsZHMsIHJlY3Vyc2UsIGxpbWl0KTtcblx0XHRcdHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoY2hpbGRzKTtcblx0XHRcdGxpbWl0IC09IGNoaWxkcy5sZW5ndGg7XG5cdFx0XHRpZihsaW1pdCA8PSAwKSBicmVhaztcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmaW5kT25lQ2hpbGQodGVzdCwgZWxlbXMpe1xuXHRmb3IodmFyIGkgPSAwLCBsID0gZWxlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKXtcblx0XHRpZih0ZXN0KGVsZW1zW2ldKSkgcmV0dXJuIGVsZW1zW2ldO1xuXHR9XG5cblx0cmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRPbmUodGVzdCwgZWxlbXMpe1xuXHR2YXIgZWxlbSA9IG51bGw7XG5cblx0Zm9yKHZhciBpID0gMCwgbCA9IGVsZW1zLmxlbmd0aDsgaSA8IGwgJiYgIWVsZW07IGkrKyl7XG5cdFx0aWYoIWlzVGFnKGVsZW1zW2ldKSl7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9IGVsc2UgaWYodGVzdChlbGVtc1tpXSkpe1xuXHRcdFx0ZWxlbSA9IGVsZW1zW2ldO1xuXHRcdH0gZWxzZSBpZihlbGVtc1tpXS5jaGlsZHJlbi5sZW5ndGggPiAwKXtcblx0XHRcdGVsZW0gPSBmaW5kT25lKHRlc3QsIGVsZW1zW2ldLmNoaWxkcmVuKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gZXhpc3RzT25lKHRlc3QsIGVsZW1zKXtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGVsZW1zLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0aWYoXG5cdFx0XHRpc1RhZyhlbGVtc1tpXSkgJiYgKFxuXHRcdFx0XHR0ZXN0KGVsZW1zW2ldKSB8fCAoXG5cdFx0XHRcdFx0ZWxlbXNbaV0uY2hpbGRyZW4ubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdGV4aXN0c09uZSh0ZXN0LCBlbGVtc1tpXS5jaGlsZHJlbilcblx0XHRcdFx0KVxuXHRcdFx0KVxuXHRcdCl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZpbmRBbGwodGVzdCwgZWxlbXMpe1xuXHR2YXIgcmVzdWx0ID0gW107XG5cdGZvcih2YXIgaSA9IDAsIGogPSBlbGVtcy5sZW5ndGg7IGkgPCBqOyBpKyspe1xuXHRcdGlmKCFpc1RhZyhlbGVtc1tpXSkpIGNvbnRpbnVlO1xuXHRcdGlmKHRlc3QoZWxlbXNbaV0pKSByZXN1bHQucHVzaChlbGVtc1tpXSk7XG5cblx0XHRpZihlbGVtc1tpXS5jaGlsZHJlbi5sZW5ndGggPiAwKXtcblx0XHRcdHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoZmluZEFsbCh0ZXN0LCBlbGVtc1tpXS5jaGlsZHJlbikpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuIiwidmFyIEVsZW1lbnRUeXBlID0gcmVxdWlyZShcImRvbWVsZW1lbnR0eXBlXCIpLFxuICAgIGdldE91dGVySFRNTCA9IHJlcXVpcmUoXCJkb20tc2VyaWFsaXplclwiKSxcbiAgICBpc1RhZyA9IEVsZW1lbnRUeXBlLmlzVGFnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Z2V0SW5uZXJIVE1MOiBnZXRJbm5lckhUTUwsXG5cdGdldE91dGVySFRNTDogZ2V0T3V0ZXJIVE1MLFxuXHRnZXRUZXh0OiBnZXRUZXh0XG59O1xuXG5mdW5jdGlvbiBnZXRJbm5lckhUTUwoZWxlbSwgb3B0cyl7XG5cdHJldHVybiBlbGVtLmNoaWxkcmVuID8gZWxlbS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oZWxlbSl7XG5cdFx0cmV0dXJuIGdldE91dGVySFRNTChlbGVtLCBvcHRzKTtcblx0fSkuam9pbihcIlwiKSA6IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGdldFRleHQoZWxlbSl7XG5cdGlmKEFycmF5LmlzQXJyYXkoZWxlbSkpIHJldHVybiBlbGVtLm1hcChnZXRUZXh0KS5qb2luKFwiXCIpO1xuXHRpZihpc1RhZyhlbGVtKSB8fCBlbGVtLnR5cGUgPT09IEVsZW1lbnRUeXBlLkNEQVRBKSByZXR1cm4gZ2V0VGV4dChlbGVtLmNoaWxkcmVuKTtcblx0aWYoZWxlbS50eXBlID09PSBFbGVtZW50VHlwZS5UZXh0KSByZXR1cm4gZWxlbS5kYXRhO1xuXHRyZXR1cm4gXCJcIjtcbn1cbiIsInZhciBnZXRDaGlsZHJlbiA9IGV4cG9ydHMuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbihlbGVtKXtcblx0cmV0dXJuIGVsZW0uY2hpbGRyZW47XG59O1xuXG52YXIgZ2V0UGFyZW50ID0gZXhwb3J0cy5nZXRQYXJlbnQgPSBmdW5jdGlvbihlbGVtKXtcblx0cmV0dXJuIGVsZW0ucGFyZW50O1xufTtcblxuZXhwb3J0cy5nZXRTaWJsaW5ncyA9IGZ1bmN0aW9uKGVsZW0pe1xuXHR2YXIgcGFyZW50ID0gZ2V0UGFyZW50KGVsZW0pO1xuXHRyZXR1cm4gcGFyZW50ID8gZ2V0Q2hpbGRyZW4ocGFyZW50KSA6IFtlbGVtXTtcbn07XG5cbmV4cG9ydHMuZ2V0QXR0cmlidXRlVmFsdWUgPSBmdW5jdGlvbihlbGVtLCBuYW1lKXtcblx0cmV0dXJuIGVsZW0uYXR0cmlicyAmJiBlbGVtLmF0dHJpYnNbbmFtZV07XG59O1xuXG5leHBvcnRzLmhhc0F0dHJpYiA9IGZ1bmN0aW9uKGVsZW0sIG5hbWUpe1xuXHRyZXR1cm4gISFlbGVtLmF0dHJpYnMgJiYgaGFzT3duUHJvcGVydHkuY2FsbChlbGVtLmF0dHJpYnMsIG5hbWUpO1xufTtcblxuZXhwb3J0cy5nZXROYW1lID0gZnVuY3Rpb24oZWxlbSl7XG5cdHJldHVybiBlbGVtLm5hbWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FjaGUgPSB7fTtcbnZhciBzdGFydCA9ICcoPzpefFxcXFxzKSc7XG52YXIgZW5kID0gJyg/OlxcXFxzfCQpJztcblxuZnVuY3Rpb24gbG9va3VwQ2xhc3MgKGNsYXNzTmFtZSkge1xuICB2YXIgY2FjaGVkID0gY2FjaGVbY2xhc3NOYW1lXTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIGNhY2hlZC5sYXN0SW5kZXggPSAwO1xuICB9IGVsc2Uge1xuICAgIGNhY2hlW2NsYXNzTmFtZV0gPSBjYWNoZWQgPSBuZXcgUmVnRXhwKHN0YXJ0ICsgY2xhc3NOYW1lICsgZW5kLCAnZycpO1xuICB9XG4gIHJldHVybiBjYWNoZWQ7XG59XG5cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xhc3NOYW1lKSB7XG4gIHZhciBjdXJyZW50ID0gZWwuY2xhc3NOYW1lO1xuICBpZiAoIWN1cnJlbnQubGVuZ3RoKSB7XG4gICAgZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICB9IGVsc2UgaWYgKCFsb29rdXBDbGFzcyhjbGFzc05hbWUpLnRlc3QoY3VycmVudCkpIHtcbiAgICBlbC5jbGFzc05hbWUgKz0gJyAnICsgY2xhc3NOYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJtQ2xhc3MgKGVsLCBjbGFzc05hbWUpIHtcbiAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UobG9va3VwQ2xhc3MoY2xhc3NOYW1lKSwgJyAnKS50cmltKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGQ6IGFkZENsYXNzLFxuICBybTogcm1DbGFzc1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVtaXR0ZXIgPSByZXF1aXJlKCdjb250cmEvZW1pdHRlcicpO1xudmFyIGNyb3NzdmVudCA9IHJlcXVpcmUoJ2Nyb3NzdmVudCcpO1xudmFyIGNsYXNzZXMgPSByZXF1aXJlKCcuL2NsYXNzZXMnKTtcbnZhciBkb2MgPSBkb2N1bWVudDtcbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG5mdW5jdGlvbiBkcmFndWxhIChpbml0aWFsQ29udGFpbmVycywgb3B0aW9ucykge1xuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGluaXRpYWxDb250YWluZXJzKSA9PT0gZmFsc2UpIHtcbiAgICBvcHRpb25zID0gaW5pdGlhbENvbnRhaW5lcnM7XG4gICAgaW5pdGlhbENvbnRhaW5lcnMgPSBbXTtcbiAgfVxuICB2YXIgX21pcnJvcjsgLy8gbWlycm9yIGltYWdlXG4gIHZhciBfc291cmNlOyAvLyBzb3VyY2UgY29udGFpbmVyXG4gIHZhciBfaXRlbTsgLy8gaXRlbSBiZWluZyBkcmFnZ2VkXG4gIHZhciBfb2Zmc2V0WDsgLy8gcmVmZXJlbmNlIHhcbiAgdmFyIF9vZmZzZXRZOyAvLyByZWZlcmVuY2UgeVxuICB2YXIgX21vdmVYOyAvLyByZWZlcmVuY2UgbW92ZSB4XG4gIHZhciBfbW92ZVk7IC8vIHJlZmVyZW5jZSBtb3ZlIHlcbiAgdmFyIF9pbml0aWFsU2libGluZzsgLy8gcmVmZXJlbmNlIHNpYmxpbmcgd2hlbiBncmFiYmVkXG4gIHZhciBfY3VycmVudFNpYmxpbmc7IC8vIHJlZmVyZW5jZSBzaWJsaW5nIG5vd1xuICB2YXIgX2NvcHk7IC8vIGl0ZW0gdXNlZCBmb3IgY29weWluZ1xuICB2YXIgX3JlbmRlclRpbWVyOyAvLyB0aW1lciBmb3Igc2V0VGltZW91dCByZW5kZXJNaXJyb3JJbWFnZVxuICB2YXIgX2xhc3REcm9wVGFyZ2V0ID0gbnVsbDsgLy8gbGFzdCBjb250YWluZXIgaXRlbSB3YXMgb3ZlclxuICB2YXIgX2dyYWJiZWQ7IC8vIGhvbGRzIG1vdXNlZG93biBjb250ZXh0IHVudGlsIGZpcnN0IG1vdXNlbW92ZVxuXG4gIHZhciBvID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKG8ubW92ZXMgPT09IHZvaWQgMCkgeyBvLm1vdmVzID0gYWx3YXlzOyB9XG4gIGlmIChvLmFjY2VwdHMgPT09IHZvaWQgMCkgeyBvLmFjY2VwdHMgPSBhbHdheXM7IH1cbiAgaWYgKG8uaW52YWxpZCA9PT0gdm9pZCAwKSB7IG8uaW52YWxpZCA9IGludmFsaWRUYXJnZXQ7IH1cbiAgaWYgKG8uY29udGFpbmVycyA9PT0gdm9pZCAwKSB7IG8uY29udGFpbmVycyA9IGluaXRpYWxDb250YWluZXJzIHx8IFtdOyB9XG4gIGlmIChvLmlzQ29udGFpbmVyID09PSB2b2lkIDApIHsgby5pc0NvbnRhaW5lciA9IG5ldmVyOyB9XG4gIGlmIChvLmNvcHkgPT09IHZvaWQgMCkgeyBvLmNvcHkgPSBmYWxzZTsgfVxuICBpZiAoby5jb3B5U29ydFNvdXJjZSA9PT0gdm9pZCAwKSB7IG8uY29weVNvcnRTb3VyY2UgPSBmYWxzZTsgfVxuICBpZiAoby5yZXZlcnRPblNwaWxsID09PSB2b2lkIDApIHsgby5yZXZlcnRPblNwaWxsID0gZmFsc2U7IH1cbiAgaWYgKG8ucmVtb3ZlT25TcGlsbCA9PT0gdm9pZCAwKSB7IG8ucmVtb3ZlT25TcGlsbCA9IGZhbHNlOyB9XG4gIGlmIChvLmRpcmVjdGlvbiA9PT0gdm9pZCAwKSB7IG8uZGlyZWN0aW9uID0gJ3ZlcnRpY2FsJzsgfVxuICBpZiAoby5pZ25vcmVJbnB1dFRleHRTZWxlY3Rpb24gPT09IHZvaWQgMCkgeyBvLmlnbm9yZUlucHV0VGV4dFNlbGVjdGlvbiA9IHRydWU7IH1cbiAgaWYgKG8ubWlycm9yQ29udGFpbmVyID09PSB2b2lkIDApIHsgby5taXJyb3JDb250YWluZXIgPSBkb2MuYm9keTsgfVxuXG4gIHZhciBkcmFrZSA9IGVtaXR0ZXIoe1xuICAgIGNvbnRhaW5lcnM6IG8uY29udGFpbmVycyxcbiAgICBzdGFydDogbWFudWFsU3RhcnQsXG4gICAgZW5kOiBlbmQsXG4gICAgY2FuY2VsOiBjYW5jZWwsXG4gICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgZGVzdHJveTogZGVzdHJveSxcbiAgICBjYW5Nb3ZlOiBjYW5Nb3ZlLFxuICAgIGRyYWdnaW5nOiBmYWxzZVxuICB9KTtcblxuICBpZiAoby5yZW1vdmVPblNwaWxsID09PSB0cnVlKSB7XG4gICAgZHJha2Uub24oJ292ZXInLCBzcGlsbE92ZXIpLm9uKCdvdXQnLCBzcGlsbE91dCk7XG4gIH1cblxuICBldmVudHMoKTtcblxuICByZXR1cm4gZHJha2U7XG5cbiAgZnVuY3Rpb24gaXNDb250YWluZXIgKGVsKSB7XG4gICAgcmV0dXJuIGRyYWtlLmNvbnRhaW5lcnMuaW5kZXhPZihlbCkgIT09IC0xIHx8IG8uaXNDb250YWluZXIoZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXZlbnRzIChyZW1vdmUpIHtcbiAgICB2YXIgb3AgPSByZW1vdmUgPyAncmVtb3ZlJyA6ICdhZGQnO1xuICAgIHRvdWNoeShkb2N1bWVudEVsZW1lbnQsIG9wLCAnbW91c2Vkb3duJywgZ3JhYik7XG4gICAgdG91Y2h5KGRvY3VtZW50RWxlbWVudCwgb3AsICdtb3VzZXVwJywgcmVsZWFzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBldmVudHVhbE1vdmVtZW50cyAocmVtb3ZlKSB7XG4gICAgdmFyIG9wID0gcmVtb3ZlID8gJ3JlbW92ZScgOiAnYWRkJztcbiAgICB0b3VjaHkoZG9jdW1lbnRFbGVtZW50LCBvcCwgJ21vdXNlbW92ZScsIHN0YXJ0QmVjYXVzZU1vdXNlTW92ZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW92ZW1lbnRzIChyZW1vdmUpIHtcbiAgICB2YXIgb3AgPSByZW1vdmUgPyAncmVtb3ZlJyA6ICdhZGQnO1xuICAgIGNyb3NzdmVudFtvcF0oZG9jdW1lbnRFbGVtZW50LCAnc2VsZWN0c3RhcnQnLCBwcmV2ZW50R3JhYmJlZCk7IC8vIElFOFxuICAgIGNyb3NzdmVudFtvcF0oZG9jdW1lbnRFbGVtZW50LCAnY2xpY2snLCBwcmV2ZW50R3JhYmJlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgICBldmVudHModHJ1ZSk7XG4gICAgcmVsZWFzZSh7fSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmV2ZW50R3JhYmJlZCAoZSkge1xuICAgIGlmIChfZ3JhYmJlZCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdyYWIgKGUpIHtcbiAgICBfbW92ZVggPSBlLmNsaWVudFg7XG4gICAgX21vdmVZID0gZS5jbGllbnRZO1xuXG4gICAgdmFyIGlnbm9yZSA9IHdoaWNoTW91c2VCdXR0b24oZSkgIT09IDEgfHwgZS5tZXRhS2V5IHx8IGUuY3RybEtleTtcbiAgICBpZiAoaWdub3JlKSB7XG4gICAgICByZXR1cm47IC8vIHdlIG9ubHkgY2FyZSBhYm91dCBob25lc3QtdG8tZ29kIGxlZnQgY2xpY2tzIGFuZCB0b3VjaCBldmVudHNcbiAgICB9XG4gICAgdmFyIGl0ZW0gPSBlLnRhcmdldDtcbiAgICB2YXIgY29udGV4dCA9IGNhblN0YXJ0KGl0ZW0pO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfZ3JhYmJlZCA9IGNvbnRleHQ7XG4gICAgZXZlbnR1YWxNb3ZlbWVudHMoKTtcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgaWYgKGlzSW5wdXQoaXRlbSkpIHsgLy8gc2VlIGFsc286IGh0dHBzOi8vZ2l0aHViLmNvbS9iZXZhY3F1YS9kcmFndWxhL2lzc3Vlcy8yMDhcbiAgICAgICAgaXRlbS5mb2N1cygpOyAvLyBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vYmV2YWNxdWEvZHJhZ3VsYS9pc3N1ZXMvMTc2XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIGZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXZhY3F1YS9kcmFndWxhL2lzc3Vlcy8xNTVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydEJlY2F1c2VNb3VzZU1vdmVkIChlKSB7XG4gICAgaWYgKCFfZ3JhYmJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAod2hpY2hNb3VzZUJ1dHRvbihlKSA9PT0gMCkge1xuICAgICAgcmVsZWFzZSh7fSk7XG4gICAgICByZXR1cm47IC8vIHdoZW4gdGV4dCBpcyBzZWxlY3RlZCBvbiBhbiBpbnB1dCBhbmQgdGhlbiBkcmFnZ2VkLCBtb3VzZXVwIGRvZXNuJ3QgZmlyZS4gdGhpcyBpcyBvdXIgb25seSBob3BlXG4gICAgfVxuICAgIC8vIHRydXRoeSBjaGVjayBmaXhlcyAjMjM5LCBlcXVhbGl0eSBmaXhlcyAjMjA3XG4gICAgaWYgKGUuY2xpZW50WCAhPT0gdm9pZCAwICYmIGUuY2xpZW50WCA9PT0gX21vdmVYICYmIGUuY2xpZW50WSAhPT0gdm9pZCAwICYmIGUuY2xpZW50WSA9PT0gX21vdmVZKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvLmlnbm9yZUlucHV0VGV4dFNlbGVjdGlvbikge1xuICAgICAgdmFyIGNsaWVudFggPSBnZXRDb29yZCgnY2xpZW50WCcsIGUpO1xuICAgICAgdmFyIGNsaWVudFkgPSBnZXRDb29yZCgnY2xpZW50WScsIGUpO1xuICAgICAgdmFyIGVsZW1lbnRCZWhpbmRDdXJzb3IgPSBkb2MuZWxlbWVudEZyb21Qb2ludChjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgIGlmIChpc0lucHV0KGVsZW1lbnRCZWhpbmRDdXJzb3IpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZ3JhYmJlZCA9IF9ncmFiYmVkOyAvLyBjYWxsIHRvIGVuZCgpIHVuc2V0cyBfZ3JhYmJlZFxuICAgIGV2ZW50dWFsTW92ZW1lbnRzKHRydWUpO1xuICAgIG1vdmVtZW50cygpO1xuICAgIGVuZCgpO1xuICAgIHN0YXJ0KGdyYWJiZWQpO1xuXG4gICAgdmFyIG9mZnNldCA9IGdldE9mZnNldChfaXRlbSk7XG4gICAgX29mZnNldFggPSBnZXRDb29yZCgncGFnZVgnLCBlKSAtIG9mZnNldC5sZWZ0O1xuICAgIF9vZmZzZXRZID0gZ2V0Q29vcmQoJ3BhZ2VZJywgZSkgLSBvZmZzZXQudG9wO1xuXG4gICAgY2xhc3Nlcy5hZGQoX2NvcHkgfHwgX2l0ZW0sICdndS10cmFuc2l0Jyk7XG4gICAgcmVuZGVyTWlycm9ySW1hZ2UoKTtcbiAgICBkcmFnKGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuU3RhcnQgKGl0ZW0pIHtcbiAgICBpZiAoZHJha2UuZHJhZ2dpbmcgJiYgX21pcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNDb250YWluZXIoaXRlbSkpIHtcbiAgICAgIHJldHVybjsgLy8gZG9uJ3QgZHJhZyBjb250YWluZXIgaXRzZWxmXG4gICAgfVxuICAgIHZhciBoYW5kbGUgPSBpdGVtO1xuICAgIHdoaWxlIChnZXRQYXJlbnQoaXRlbSkgJiYgaXNDb250YWluZXIoZ2V0UGFyZW50KGl0ZW0pKSA9PT0gZmFsc2UpIHtcbiAgICAgIGlmIChvLmludmFsaWQoaXRlbSwgaGFuZGxlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpdGVtID0gZ2V0UGFyZW50KGl0ZW0pOyAvLyBkcmFnIHRhcmdldCBzaG91bGQgYmUgYSB0b3AgZWxlbWVudFxuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHNvdXJjZSA9IGdldFBhcmVudChpdGVtKTtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoby5pbnZhbGlkKGl0ZW0sIGhhbmRsZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbW92YWJsZSA9IG8ubW92ZXMoaXRlbSwgc291cmNlLCBoYW5kbGUsIG5leHRFbChpdGVtKSk7XG4gICAgaWYgKCFtb3ZhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICBzb3VyY2U6IHNvdXJjZVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjYW5Nb3ZlIChpdGVtKSB7XG4gICAgcmV0dXJuICEhY2FuU3RhcnQoaXRlbSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYW51YWxTdGFydCAoaXRlbSkge1xuICAgIHZhciBjb250ZXh0ID0gY2FuU3RhcnQoaXRlbSk7XG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIHN0YXJ0KGNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0IChjb250ZXh0KSB7XG4gICAgaWYgKGlzQ29weShjb250ZXh0Lml0ZW0sIGNvbnRleHQuc291cmNlKSkge1xuICAgICAgX2NvcHkgPSBjb250ZXh0Lml0ZW0uY2xvbmVOb2RlKHRydWUpO1xuICAgICAgZHJha2UuZW1pdCgnY2xvbmVkJywgX2NvcHksIGNvbnRleHQuaXRlbSwgJ2NvcHknKTtcbiAgICB9XG5cbiAgICBfc291cmNlID0gY29udGV4dC5zb3VyY2U7XG4gICAgX2l0ZW0gPSBjb250ZXh0Lml0ZW07XG4gICAgX2luaXRpYWxTaWJsaW5nID0gX2N1cnJlbnRTaWJsaW5nID0gbmV4dEVsKGNvbnRleHQuaXRlbSk7XG5cbiAgICBkcmFrZS5kcmFnZ2luZyA9IHRydWU7XG4gICAgZHJha2UuZW1pdCgnZHJhZycsIF9pdGVtLCBfc291cmNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRUYXJnZXQgKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZCAoKSB7XG4gICAgaWYgKCFkcmFrZS5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaXRlbSA9IF9jb3B5IHx8IF9pdGVtO1xuICAgIGRyb3AoaXRlbSwgZ2V0UGFyZW50KGl0ZW0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuZ3JhYiAoKSB7XG4gICAgX2dyYWJiZWQgPSBmYWxzZTtcbiAgICBldmVudHVhbE1vdmVtZW50cyh0cnVlKTtcbiAgICBtb3ZlbWVudHModHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWxlYXNlIChlKSB7XG4gICAgdW5ncmFiKCk7XG5cbiAgICBpZiAoIWRyYWtlLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpdGVtID0gX2NvcHkgfHwgX2l0ZW07XG4gICAgdmFyIGNsaWVudFggPSBnZXRDb29yZCgnY2xpZW50WCcsIGUpO1xuICAgIHZhciBjbGllbnRZID0gZ2V0Q29vcmQoJ2NsaWVudFknLCBlKTtcbiAgICB2YXIgZWxlbWVudEJlaGluZEN1cnNvciA9IGdldEVsZW1lbnRCZWhpbmRQb2ludChfbWlycm9yLCBjbGllbnRYLCBjbGllbnRZKTtcbiAgICB2YXIgZHJvcFRhcmdldCA9IGZpbmREcm9wVGFyZ2V0KGVsZW1lbnRCZWhpbmRDdXJzb3IsIGNsaWVudFgsIGNsaWVudFkpO1xuICAgIGlmIChkcm9wVGFyZ2V0ICYmICgoX2NvcHkgJiYgby5jb3B5U29ydFNvdXJjZSkgfHwgKCFfY29weSB8fCBkcm9wVGFyZ2V0ICE9PSBfc291cmNlKSkpIHtcbiAgICAgIGRyb3AoaXRlbSwgZHJvcFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChvLnJlbW92ZU9uU3BpbGwpIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW5jZWwoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkcm9wIChpdGVtLCB0YXJnZXQpIHtcbiAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50KGl0ZW0pO1xuICAgIGlmIChfY29weSAmJiBvLmNvcHlTb3J0U291cmNlICYmIHRhcmdldCA9PT0gX3NvdXJjZSkge1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKF9pdGVtKTtcbiAgICB9XG4gICAgaWYgKGlzSW5pdGlhbFBsYWNlbWVudCh0YXJnZXQpKSB7XG4gICAgICBkcmFrZS5lbWl0KCdjYW5jZWwnLCBpdGVtLCBfc291cmNlLCBfc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZHJha2UuZW1pdCgnZHJvcCcsIGl0ZW0sIHRhcmdldCwgX3NvdXJjZSwgX2N1cnJlbnRTaWJsaW5nKTtcbiAgICB9XG4gICAgY2xlYW51cCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICBpZiAoIWRyYWtlLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpdGVtID0gX2NvcHkgfHwgX2l0ZW07XG4gICAgdmFyIHBhcmVudCA9IGdldFBhcmVudChpdGVtKTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoaXRlbSk7XG4gICAgfVxuICAgIGRyYWtlLmVtaXQoX2NvcHkgPyAnY2FuY2VsJyA6ICdyZW1vdmUnLCBpdGVtLCBwYXJlbnQsIF9zb3VyY2UpO1xuICAgIGNsZWFudXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCAocmV2ZXJ0KSB7XG4gICAgaWYgKCFkcmFrZS5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmV2ZXJ0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwID8gcmV2ZXJ0IDogby5yZXZlcnRPblNwaWxsO1xuICAgIHZhciBpdGVtID0gX2NvcHkgfHwgX2l0ZW07XG4gICAgdmFyIHBhcmVudCA9IGdldFBhcmVudChpdGVtKTtcbiAgICB2YXIgaW5pdGlhbCA9IGlzSW5pdGlhbFBsYWNlbWVudChwYXJlbnQpO1xuICAgIGlmIChpbml0aWFsID09PSBmYWxzZSAmJiByZXZlcnRzKSB7XG4gICAgICBpZiAoX2NvcHkpIHtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChfY29weSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9zb3VyY2UuaW5zZXJ0QmVmb3JlKGl0ZW0sIF9pbml0aWFsU2libGluZyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbml0aWFsIHx8IHJldmVydHMpIHtcbiAgICAgIGRyYWtlLmVtaXQoJ2NhbmNlbCcsIGl0ZW0sIF9zb3VyY2UsIF9zb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkcmFrZS5lbWl0KCdkcm9wJywgaXRlbSwgcGFyZW50LCBfc291cmNlLCBfY3VycmVudFNpYmxpbmcpO1xuICAgIH1cbiAgICBjbGVhbnVwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwICgpIHtcbiAgICB2YXIgaXRlbSA9IF9jb3B5IHx8IF9pdGVtO1xuICAgIHVuZ3JhYigpO1xuICAgIHJlbW92ZU1pcnJvckltYWdlKCk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGNsYXNzZXMucm0oaXRlbSwgJ2d1LXRyYW5zaXQnKTtcbiAgICB9XG4gICAgaWYgKF9yZW5kZXJUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KF9yZW5kZXJUaW1lcik7XG4gICAgfVxuICAgIGRyYWtlLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgaWYgKF9sYXN0RHJvcFRhcmdldCkge1xuICAgICAgZHJha2UuZW1pdCgnb3V0JywgaXRlbSwgX2xhc3REcm9wVGFyZ2V0LCBfc291cmNlKTtcbiAgICB9XG4gICAgZHJha2UuZW1pdCgnZHJhZ2VuZCcsIGl0ZW0pO1xuICAgIF9zb3VyY2UgPSBfaXRlbSA9IF9jb3B5ID0gX2luaXRpYWxTaWJsaW5nID0gX2N1cnJlbnRTaWJsaW5nID0gX3JlbmRlclRpbWVyID0gX2xhc3REcm9wVGFyZ2V0ID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW5pdGlhbFBsYWNlbWVudCAodGFyZ2V0LCBzKSB7XG4gICAgdmFyIHNpYmxpbmc7XG4gICAgaWYgKHMgIT09IHZvaWQgMCkge1xuICAgICAgc2libGluZyA9IHM7XG4gICAgfSBlbHNlIGlmIChfbWlycm9yKSB7XG4gICAgICBzaWJsaW5nID0gX2N1cnJlbnRTaWJsaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaWJsaW5nID0gbmV4dEVsKF9jb3B5IHx8IF9pdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldCA9PT0gX3NvdXJjZSAmJiBzaWJsaW5nID09PSBfaW5pdGlhbFNpYmxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kRHJvcFRhcmdldCAoZWxlbWVudEJlaGluZEN1cnNvciwgY2xpZW50WCwgY2xpZW50WSkge1xuICAgIHZhciB0YXJnZXQgPSBlbGVtZW50QmVoaW5kQ3Vyc29yO1xuICAgIHdoaWxlICh0YXJnZXQgJiYgIWFjY2VwdGVkKCkpIHtcbiAgICAgIHRhcmdldCA9IGdldFBhcmVudCh0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuXG4gICAgZnVuY3Rpb24gYWNjZXB0ZWQgKCkge1xuICAgICAgdmFyIGRyb3BwYWJsZSA9IGlzQ29udGFpbmVyKHRhcmdldCk7XG4gICAgICBpZiAoZHJvcHBhYmxlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbW1lZGlhdGUgPSBnZXRJbW1lZGlhdGVDaGlsZCh0YXJnZXQsIGVsZW1lbnRCZWhpbmRDdXJzb3IpO1xuICAgICAgdmFyIHJlZmVyZW5jZSA9IGdldFJlZmVyZW5jZSh0YXJnZXQsIGltbWVkaWF0ZSwgY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICB2YXIgaW5pdGlhbCA9IGlzSW5pdGlhbFBsYWNlbWVudCh0YXJnZXQsIHJlZmVyZW5jZSk7XG4gICAgICBpZiAoaW5pdGlhbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gc2hvdWxkIGFsd2F5cyBiZSBhYmxlIHRvIGRyb3AgaXQgcmlnaHQgYmFjayB3aGVyZSBpdCB3YXNcbiAgICAgIH1cbiAgICAgIHJldHVybiBvLmFjY2VwdHMoX2l0ZW0sIHRhcmdldCwgX3NvdXJjZSwgcmVmZXJlbmNlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkcmFnIChlKSB7XG4gICAgaWYgKCFfbWlycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIHZhciBjbGllbnRYID0gZ2V0Q29vcmQoJ2NsaWVudFgnLCBlKTtcbiAgICB2YXIgY2xpZW50WSA9IGdldENvb3JkKCdjbGllbnRZJywgZSk7XG4gICAgdmFyIHggPSBjbGllbnRYIC0gX29mZnNldFg7XG4gICAgdmFyIHkgPSBjbGllbnRZIC0gX29mZnNldFk7XG5cbiAgICBfbWlycm9yLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgICBfbWlycm9yLnN0eWxlLnRvcCA9IHkgKyAncHgnO1xuXG4gICAgdmFyIGl0ZW0gPSBfY29weSB8fCBfaXRlbTtcbiAgICB2YXIgZWxlbWVudEJlaGluZEN1cnNvciA9IGdldEVsZW1lbnRCZWhpbmRQb2ludChfbWlycm9yLCBjbGllbnRYLCBjbGllbnRZKTtcbiAgICB2YXIgZHJvcFRhcmdldCA9IGZpbmREcm9wVGFyZ2V0KGVsZW1lbnRCZWhpbmRDdXJzb3IsIGNsaWVudFgsIGNsaWVudFkpO1xuICAgIHZhciBjaGFuZ2VkID0gZHJvcFRhcmdldCAhPT0gbnVsbCAmJiBkcm9wVGFyZ2V0ICE9PSBfbGFzdERyb3BUYXJnZXQ7XG4gICAgaWYgKGNoYW5nZWQgfHwgZHJvcFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgb3V0KCk7XG4gICAgICBfbGFzdERyb3BUYXJnZXQgPSBkcm9wVGFyZ2V0O1xuICAgICAgb3ZlcigpO1xuICAgIH1cbiAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50KGl0ZW0pO1xuICAgIGlmIChkcm9wVGFyZ2V0ID09PSBfc291cmNlICYmIF9jb3B5ICYmICFvLmNvcHlTb3J0U291cmNlKSB7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChpdGVtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJlZmVyZW5jZTtcbiAgICB2YXIgaW1tZWRpYXRlID0gZ2V0SW1tZWRpYXRlQ2hpbGQoZHJvcFRhcmdldCwgZWxlbWVudEJlaGluZEN1cnNvcik7XG4gICAgaWYgKGltbWVkaWF0ZSAhPT0gbnVsbCkge1xuICAgICAgcmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlKGRyb3BUYXJnZXQsIGltbWVkaWF0ZSwgY2xpZW50WCwgY2xpZW50WSk7XG4gICAgfSBlbHNlIGlmIChvLnJldmVydE9uU3BpbGwgPT09IHRydWUgJiYgIV9jb3B5KSB7XG4gICAgICByZWZlcmVuY2UgPSBfaW5pdGlhbFNpYmxpbmc7XG4gICAgICBkcm9wVGFyZ2V0ID0gX3NvdXJjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKF9jb3B5ICYmIHBhcmVudCkge1xuICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoaXRlbSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChcbiAgICAgIChyZWZlcmVuY2UgPT09IG51bGwgJiYgY2hhbmdlZCkgfHxcbiAgICAgIHJlZmVyZW5jZSAhPT0gaXRlbSAmJlxuICAgICAgcmVmZXJlbmNlICE9PSBuZXh0RWwoaXRlbSlcbiAgICApIHtcbiAgICAgIF9jdXJyZW50U2libGluZyA9IHJlZmVyZW5jZTtcbiAgICAgIGRyb3BUYXJnZXQuaW5zZXJ0QmVmb3JlKGl0ZW0sIHJlZmVyZW5jZSk7XG4gICAgICBkcmFrZS5lbWl0KCdzaGFkb3cnLCBpdGVtLCBkcm9wVGFyZ2V0LCBfc291cmNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW92ZWQgKHR5cGUpIHsgZHJha2UuZW1pdCh0eXBlLCBpdGVtLCBfbGFzdERyb3BUYXJnZXQsIF9zb3VyY2UpOyB9XG4gICAgZnVuY3Rpb24gb3ZlciAoKSB7IGlmIChjaGFuZ2VkKSB7IG1vdmVkKCdvdmVyJyk7IH0gfVxuICAgIGZ1bmN0aW9uIG91dCAoKSB7IGlmIChfbGFzdERyb3BUYXJnZXQpIHsgbW92ZWQoJ291dCcpOyB9IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNwaWxsT3ZlciAoZWwpIHtcbiAgICBjbGFzc2VzLnJtKGVsLCAnZ3UtaGlkZScpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3BpbGxPdXQgKGVsKSB7XG4gICAgaWYgKGRyYWtlLmRyYWdnaW5nKSB7IGNsYXNzZXMuYWRkKGVsLCAnZ3UtaGlkZScpOyB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJNaXJyb3JJbWFnZSAoKSB7XG4gICAgaWYgKF9taXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJlY3QgPSBfaXRlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBfbWlycm9yID0gX2l0ZW0uY2xvbmVOb2RlKHRydWUpO1xuICAgIF9taXJyb3Iuc3R5bGUud2lkdGggPSBnZXRSZWN0V2lkdGgocmVjdCkgKyAncHgnO1xuICAgIF9taXJyb3Iuc3R5bGUuaGVpZ2h0ID0gZ2V0UmVjdEhlaWdodChyZWN0KSArICdweCc7XG4gICAgY2xhc3Nlcy5ybShfbWlycm9yLCAnZ3UtdHJhbnNpdCcpO1xuICAgIGNsYXNzZXMuYWRkKF9taXJyb3IsICdndS1taXJyb3InKTtcbiAgICBvLm1pcnJvckNvbnRhaW5lci5hcHBlbmRDaGlsZChfbWlycm9yKTtcbiAgICB0b3VjaHkoZG9jdW1lbnRFbGVtZW50LCAnYWRkJywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgIGNsYXNzZXMuYWRkKG8ubWlycm9yQ29udGFpbmVyLCAnZ3UtdW5zZWxlY3RhYmxlJyk7XG4gICAgZHJha2UuZW1pdCgnY2xvbmVkJywgX21pcnJvciwgX2l0ZW0sICdtaXJyb3InKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU1pcnJvckltYWdlICgpIHtcbiAgICBpZiAoX21pcnJvcikge1xuICAgICAgY2xhc3Nlcy5ybShvLm1pcnJvckNvbnRhaW5lciwgJ2d1LXVuc2VsZWN0YWJsZScpO1xuICAgICAgdG91Y2h5KGRvY3VtZW50RWxlbWVudCwgJ3JlbW92ZScsICdtb3VzZW1vdmUnLCBkcmFnKTtcbiAgICAgIGdldFBhcmVudChfbWlycm9yKS5yZW1vdmVDaGlsZChfbWlycm9yKTtcbiAgICAgIF9taXJyb3IgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEltbWVkaWF0ZUNoaWxkIChkcm9wVGFyZ2V0LCB0YXJnZXQpIHtcbiAgICB2YXIgaW1tZWRpYXRlID0gdGFyZ2V0O1xuICAgIHdoaWxlIChpbW1lZGlhdGUgIT09IGRyb3BUYXJnZXQgJiYgZ2V0UGFyZW50KGltbWVkaWF0ZSkgIT09IGRyb3BUYXJnZXQpIHtcbiAgICAgIGltbWVkaWF0ZSA9IGdldFBhcmVudChpbW1lZGlhdGUpO1xuICAgIH1cbiAgICBpZiAoaW1tZWRpYXRlID09PSBkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaW1tZWRpYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmVmZXJlbmNlIChkcm9wVGFyZ2V0LCB0YXJnZXQsIHgsIHkpIHtcbiAgICB2YXIgaG9yaXpvbnRhbCA9IG8uZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgdmFyIHJlZmVyZW5jZSA9IHRhcmdldCAhPT0gZHJvcFRhcmdldCA/IGluc2lkZSgpIDogb3V0c2lkZSgpO1xuICAgIHJldHVybiByZWZlcmVuY2U7XG5cbiAgICBmdW5jdGlvbiBvdXRzaWRlICgpIHsgLy8gc2xvd2VyLCBidXQgYWJsZSB0byBmaWd1cmUgb3V0IGFueSBwb3NpdGlvblxuICAgICAgdmFyIGxlbiA9IGRyb3BUYXJnZXQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgZWw7XG4gICAgICB2YXIgcmVjdDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbCA9IGRyb3BUYXJnZXQuY2hpbGRyZW5baV07XG4gICAgICAgIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGhvcml6b250YWwgJiYgKHJlY3QubGVmdCArIHJlY3Qud2lkdGggLyAyKSA+IHgpIHsgcmV0dXJuIGVsOyB9XG4gICAgICAgIGlmICghaG9yaXpvbnRhbCAmJiAocmVjdC50b3AgKyByZWN0LmhlaWdodCAvIDIpID4geSkgeyByZXR1cm4gZWw7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc2lkZSAoKSB7IC8vIGZhc3RlciwgYnV0IG9ubHkgYXZhaWxhYmxlIGlmIGRyb3BwZWQgaW5zaWRlIGEgY2hpbGQgZWxlbWVudFxuICAgICAgdmFyIHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSh4ID4gcmVjdC5sZWZ0ICsgZ2V0UmVjdFdpZHRoKHJlY3QpIC8gMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzb2x2ZSh5ID4gcmVjdC50b3AgKyBnZXRSZWN0SGVpZ2h0KHJlY3QpIC8gMik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZSAoYWZ0ZXIpIHtcbiAgICAgIHJldHVybiBhZnRlciA/IG5leHRFbCh0YXJnZXQpIDogdGFyZ2V0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ29weSAoaXRlbSwgY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvLmNvcHkgPT09ICdib29sZWFuJyA/IG8uY29weSA6IG8uY29weShpdGVtLCBjb250YWluZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvdWNoeSAoZWwsIG9wLCB0eXBlLCBmbikge1xuICB2YXIgdG91Y2ggPSB7XG4gICAgbW91c2V1cDogJ3RvdWNoZW5kJyxcbiAgICBtb3VzZWRvd246ICd0b3VjaHN0YXJ0JyxcbiAgICBtb3VzZW1vdmU6ICd0b3VjaG1vdmUnXG4gIH07XG4gIHZhciBwb2ludGVycyA9IHtcbiAgICBtb3VzZXVwOiAncG9pbnRlcnVwJyxcbiAgICBtb3VzZWRvd246ICdwb2ludGVyZG93bicsXG4gICAgbW91c2Vtb3ZlOiAncG9pbnRlcm1vdmUnXG4gIH07XG4gIHZhciBtaWNyb3NvZnQgPSB7XG4gICAgbW91c2V1cDogJ01TUG9pbnRlclVwJyxcbiAgICBtb3VzZWRvd246ICdNU1BvaW50ZXJEb3duJyxcbiAgICBtb3VzZW1vdmU6ICdNU1BvaW50ZXJNb3ZlJ1xuICB9O1xuICBpZiAoZ2xvYmFsLm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCkge1xuICAgIGNyb3NzdmVudFtvcF0oZWwsIHBvaW50ZXJzW3R5cGVdLCBmbik7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XG4gICAgY3Jvc3N2ZW50W29wXShlbCwgbWljcm9zb2Z0W3R5cGVdLCBmbik7XG4gIH0gZWxzZSB7XG4gICAgY3Jvc3N2ZW50W29wXShlbCwgdG91Y2hbdHlwZV0sIGZuKTtcbiAgICBjcm9zc3ZlbnRbb3BdKGVsLCB0eXBlLCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2hpY2hNb3VzZUJ1dHRvbiAoZSkge1xuICBpZiAoZS50b3VjaGVzICE9PSB2b2lkIDApIHsgcmV0dXJuIGUudG91Y2hlcy5sZW5ndGg7IH1cbiAgaWYgKGUud2hpY2ggIT09IHZvaWQgMCAmJiBlLndoaWNoICE9PSAwKSB7IHJldHVybiBlLndoaWNoOyB9IC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYmV2YWNxdWEvZHJhZ3VsYS9pc3N1ZXMvMjYxXG4gIGlmIChlLmJ1dHRvbnMgIT09IHZvaWQgMCkgeyByZXR1cm4gZS5idXR0b25zOyB9XG4gIHZhciBidXR0b24gPSBlLmJ1dHRvbjtcbiAgaWYgKGJ1dHRvbiAhPT0gdm9pZCAwKSB7IC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iLzk5ZThmZjFiYWE3YWUzNDFlOTRiYjg5YzNlODQ1NzBjN2MzYWQ5ZWEvc3JjL2V2ZW50LmpzI0w1NzMtTDU3NVxuICAgIHJldHVybiBidXR0b24gJiAxID8gMSA6IGJ1dHRvbiAmIDIgPyAzIDogKGJ1dHRvbiAmIDQgPyAyIDogMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0IChlbCkge1xuICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IHJlY3QubGVmdCArIGdldFNjcm9sbCgnc2Nyb2xsTGVmdCcsICdwYWdlWE9mZnNldCcpLFxuICAgIHRvcDogcmVjdC50b3AgKyBnZXRTY3JvbGwoJ3Njcm9sbFRvcCcsICdwYWdlWU9mZnNldCcpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbCAoc2Nyb2xsUHJvcCwgb2Zmc2V0UHJvcCkge1xuICBpZiAodHlwZW9mIGdsb2JhbFtvZmZzZXRQcm9wXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZ2xvYmFsW29mZnNldFByb3BdO1xuICB9XG4gIGlmIChkb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50RWxlbWVudFtzY3JvbGxQcm9wXTtcbiAgfVxuICByZXR1cm4gZG9jLmJvZHlbc2Nyb2xsUHJvcF07XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRCZWhpbmRQb2ludCAocG9pbnQsIHgsIHkpIHtcbiAgdmFyIHAgPSBwb2ludCB8fCB7fTtcbiAgdmFyIHN0YXRlID0gcC5jbGFzc05hbWU7XG4gIHZhciBlbDtcbiAgcC5jbGFzc05hbWUgKz0gJyBndS1oaWRlJztcbiAgZWwgPSBkb2MuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgcC5jbGFzc05hbWUgPSBzdGF0ZTtcbiAgcmV0dXJuIGVsO1xufVxuXG5mdW5jdGlvbiBuZXZlciAoKSB7IHJldHVybiBmYWxzZTsgfVxuZnVuY3Rpb24gYWx3YXlzICgpIHsgcmV0dXJuIHRydWU7IH1cbmZ1bmN0aW9uIGdldFJlY3RXaWR0aCAocmVjdCkgeyByZXR1cm4gcmVjdC53aWR0aCB8fCAocmVjdC5yaWdodCAtIHJlY3QubGVmdCk7IH1cbmZ1bmN0aW9uIGdldFJlY3RIZWlnaHQgKHJlY3QpIHsgcmV0dXJuIHJlY3QuaGVpZ2h0IHx8IChyZWN0LmJvdHRvbSAtIHJlY3QudG9wKTsgfVxuZnVuY3Rpb24gZ2V0UGFyZW50IChlbCkgeyByZXR1cm4gZWwucGFyZW50Tm9kZSA9PT0gZG9jID8gbnVsbCA6IGVsLnBhcmVudE5vZGU7IH1cbmZ1bmN0aW9uIGlzSW5wdXQgKGVsKSB7IHJldHVybiBlbC50YWdOYW1lID09PSAnSU5QVVQnIHx8IGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgfHwgZWwudGFnTmFtZSA9PT0gJ1NFTEVDVCcgfHwgaXNFZGl0YWJsZShlbCk7IH1cbmZ1bmN0aW9uIGlzRWRpdGFibGUgKGVsKSB7XG4gIGlmICghZWwpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIG5vIHBhcmVudHMgd2VyZSBlZGl0YWJsZVxuICBpZiAoZWwuY29udGVudEVkaXRhYmxlID09PSAnZmFsc2UnKSB7IHJldHVybiBmYWxzZTsgfSAvLyBzdG9wIHRoZSBsb29rdXBcbiAgaWYgKGVsLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7IHJldHVybiB0cnVlOyB9IC8vIGZvdW5kIGEgY29udGVudEVkaXRhYmxlIGVsZW1lbnQgaW4gdGhlIGNoYWluXG4gIHJldHVybiBpc0VkaXRhYmxlKGdldFBhcmVudChlbCkpOyAvLyBjb250ZW50RWRpdGFibGUgaXMgc2V0IHRvICdpbmhlcml0J1xufVxuXG5mdW5jdGlvbiBuZXh0RWwgKGVsKSB7XG4gIHJldHVybiBlbC5uZXh0RWxlbWVudFNpYmxpbmcgfHwgbWFudWFsbHkoKTtcbiAgZnVuY3Rpb24gbWFudWFsbHkgKCkge1xuICAgIHZhciBzaWJsaW5nID0gZWw7XG4gICAgZG8ge1xuICAgICAgc2libGluZyA9IHNpYmxpbmcubmV4dFNpYmxpbmc7XG4gICAgfSB3aGlsZSAoc2libGluZyAmJiBzaWJsaW5nLm5vZGVUeXBlICE9PSAxKTtcbiAgICByZXR1cm4gc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFdmVudEhvc3QgKGUpIHtcbiAgLy8gb24gdG91Y2hlbmQgZXZlbnQsIHdlIGhhdmUgdG8gdXNlIGBlLmNoYW5nZWRUb3VjaGVzYFxuICAvLyBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MTkyNTYzL3RvdWNoZW5kLWV2ZW50LXByb3BlcnRpZXNcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXZhY3F1YS9kcmFndWxhL2lzc3Vlcy8zNFxuICBpZiAoZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZS50YXJnZXRUb3VjaGVzWzBdO1xuICB9XG4gIGlmIChlLmNoYW5nZWRUb3VjaGVzICYmIGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIGdldENvb3JkIChjb29yZCwgZSkge1xuICB2YXIgaG9zdCA9IGdldEV2ZW50SG9zdChlKTtcbiAgdmFyIG1pc3NNYXAgPSB7XG4gICAgcGFnZVg6ICdjbGllbnRYJywgLy8gSUU4XG4gICAgcGFnZVk6ICdjbGllbnRZJyAvLyBJRThcbiAgfTtcbiAgaWYgKGNvb3JkIGluIG1pc3NNYXAgJiYgIShjb29yZCBpbiBob3N0KSAmJiBtaXNzTWFwW2Nvb3JkXSBpbiBob3N0KSB7XG4gICAgY29vcmQgPSBtaXNzTWFwW2Nvb3JkXTtcbiAgfVxuICByZXR1cm4gaG9zdFtjb29yZF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhZ3VsYTtcbiIsInZhciBlbmNvZGUgPSByZXF1aXJlKFwiLi9saWIvZW5jb2RlLmpzXCIpLFxuICAgIGRlY29kZSA9IHJlcXVpcmUoXCIuL2xpYi9kZWNvZGUuanNcIik7XG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24oZGF0YSwgbGV2ZWwpe1xuXHRyZXR1cm4gKCFsZXZlbCB8fCBsZXZlbCA8PSAwID8gZGVjb2RlLlhNTCA6IGRlY29kZS5IVE1MKShkYXRhKTtcbn07XG5cbmV4cG9ydHMuZGVjb2RlU3RyaWN0ID0gZnVuY3Rpb24oZGF0YSwgbGV2ZWwpe1xuXHRyZXR1cm4gKCFsZXZlbCB8fCBsZXZlbCA8PSAwID8gZGVjb2RlLlhNTCA6IGRlY29kZS5IVE1MU3RyaWN0KShkYXRhKTtcbn07XG5cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oZGF0YSwgbGV2ZWwpe1xuXHRyZXR1cm4gKCFsZXZlbCB8fCBsZXZlbCA8PSAwID8gZW5jb2RlLlhNTCA6IGVuY29kZS5IVE1MKShkYXRhKTtcbn07XG5cbmV4cG9ydHMuZW5jb2RlWE1MID0gZW5jb2RlLlhNTDtcblxuZXhwb3J0cy5lbmNvZGVIVE1MNCA9XG5leHBvcnRzLmVuY29kZUhUTUw1ID1cbmV4cG9ydHMuZW5jb2RlSFRNTCAgPSBlbmNvZGUuSFRNTDtcblxuZXhwb3J0cy5kZWNvZGVYTUwgPVxuZXhwb3J0cy5kZWNvZGVYTUxTdHJpY3QgPSBkZWNvZGUuWE1MO1xuXG5leHBvcnRzLmRlY29kZUhUTUw0ID1cbmV4cG9ydHMuZGVjb2RlSFRNTDUgPVxuZXhwb3J0cy5kZWNvZGVIVE1MID0gZGVjb2RlLkhUTUw7XG5cbmV4cG9ydHMuZGVjb2RlSFRNTDRTdHJpY3QgPVxuZXhwb3J0cy5kZWNvZGVIVE1MNVN0cmljdCA9XG5leHBvcnRzLmRlY29kZUhUTUxTdHJpY3QgPSBkZWNvZGUuSFRNTFN0cmljdDtcblxuZXhwb3J0cy5lc2NhcGUgPSBlbmNvZGUuZXNjYXBlO1xuIiwidmFyIGVudGl0eU1hcCA9IHJlcXVpcmUoXCIuLi9tYXBzL2VudGl0aWVzLmpzb25cIiksXG4gICAgbGVnYWN5TWFwID0gcmVxdWlyZShcIi4uL21hcHMvbGVnYWN5Lmpzb25cIiksXG4gICAgeG1sTWFwICAgID0gcmVxdWlyZShcIi4uL21hcHMveG1sLmpzb25cIiksXG4gICAgZGVjb2RlQ29kZVBvaW50ID0gcmVxdWlyZShcIi4vZGVjb2RlX2NvZGVwb2ludC5qc1wiKTtcblxudmFyIGRlY29kZVhNTFN0cmljdCAgPSBnZXRTdHJpY3REZWNvZGVyKHhtbE1hcCksXG4gICAgZGVjb2RlSFRNTFN0cmljdCA9IGdldFN0cmljdERlY29kZXIoZW50aXR5TWFwKTtcblxuZnVuY3Rpb24gZ2V0U3RyaWN0RGVjb2RlcihtYXApe1xuXHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1hcCkuam9pbihcInxcIiksXG5cdCAgICByZXBsYWNlID0gZ2V0UmVwbGFjZXIobWFwKTtcblxuXHRrZXlzICs9IFwifCNbeFhdW1xcXFxkYS1mQS1GXSt8I1xcXFxkK1wiO1xuXG5cdHZhciByZSA9IG5ldyBSZWdFeHAoXCImKD86XCIgKyBrZXlzICsgXCIpO1wiLCBcImdcIik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHN0cil7XG5cdFx0cmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UocmUsIHJlcGxhY2UpO1xuXHR9O1xufVxuXG52YXIgZGVjb2RlSFRNTCA9IChmdW5jdGlvbigpe1xuXHR2YXIgbGVnYWN5ID0gT2JqZWN0LmtleXMobGVnYWN5TWFwKVxuXHRcdC5zb3J0KHNvcnRlcik7XG5cblx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhlbnRpdHlNYXApXG5cdFx0LnNvcnQoc29ydGVyKTtcblxuXHRmb3IodmFyIGkgPSAwLCBqID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspe1xuXHRcdGlmKGxlZ2FjeVtqXSA9PT0ga2V5c1tpXSl7XG5cdFx0XHRrZXlzW2ldICs9IFwiOz9cIjtcblx0XHRcdGorKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0a2V5c1tpXSArPSBcIjtcIjtcblx0XHR9XG5cdH1cblxuXHR2YXIgcmUgPSBuZXcgUmVnRXhwKFwiJig/OlwiICsga2V5cy5qb2luKFwifFwiKSArIFwifCNbeFhdW1xcXFxkYS1mQS1GXSs7P3wjXFxcXGQrOz8pXCIsIFwiZ1wiKSxcblx0ICAgIHJlcGxhY2UgPSBnZXRSZXBsYWNlcihlbnRpdHlNYXApO1xuXG5cdGZ1bmN0aW9uIHJlcGxhY2VyKHN0cil7XG5cdFx0aWYoc3RyLnN1YnN0cigtMSkgIT09IFwiO1wiKSBzdHIgKz0gXCI7XCI7XG5cdFx0cmV0dXJuIHJlcGxhY2Uoc3RyKTtcblx0fVxuXG5cdC8vVE9ETyBjb25zaWRlciBjcmVhdGluZyBhIG1lcmdlZCBtYXBcblx0cmV0dXJuIGZ1bmN0aW9uKHN0cil7XG5cdFx0cmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UocmUsIHJlcGxhY2VyKTtcblx0fTtcbn0oKSk7XG5cbmZ1bmN0aW9uIHNvcnRlcihhLCBiKXtcblx0cmV0dXJuIGEgPCBiID8gMSA6IC0xO1xufVxuXG5mdW5jdGlvbiBnZXRSZXBsYWNlcihtYXApe1xuXHRyZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShzdHIpe1xuXHRcdGlmKHN0ci5jaGFyQXQoMSkgPT09IFwiI1wiKXtcblx0XHRcdGlmKHN0ci5jaGFyQXQoMikgPT09IFwiWFwiIHx8IHN0ci5jaGFyQXQoMikgPT09IFwieFwiKXtcblx0XHRcdFx0cmV0dXJuIGRlY29kZUNvZGVQb2ludChwYXJzZUludChzdHIuc3Vic3RyKDMpLCAxNikpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRlY29kZUNvZGVQb2ludChwYXJzZUludChzdHIuc3Vic3RyKDIpLCAxMCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWFwW3N0ci5zbGljZSgxLCAtMSldO1xuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0WE1MOiBkZWNvZGVYTUxTdHJpY3QsXG5cdEhUTUw6IGRlY29kZUhUTUwsXG5cdEhUTUxTdHJpY3Q6IGRlY29kZUhUTUxTdHJpY3Rcbn07IiwidmFyIGRlY29kZU1hcCA9IHJlcXVpcmUoXCIuLi9tYXBzL2RlY29kZS5qc29uXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZUNvZGVQb2ludDtcblxuLy8gbW9kaWZpZWQgdmVyc2lvbiBvZiBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9oZS9ibG9iL21hc3Rlci9zcmMvaGUuanMjTDk0LUwxMTlcbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludChjb2RlUG9pbnQpe1xuXG5cdGlmKChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHx8IGNvZGVQb2ludCA+IDB4MTBGRkZGKXtcblx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdH1cblxuXHRpZihjb2RlUG9pbnQgaW4gZGVjb2RlTWFwKXtcblx0XHRjb2RlUG9pbnQgPSBkZWNvZGVNYXBbY29kZVBvaW50XTtcblx0fVxuXG5cdHZhciBvdXRwdXQgPSBcIlwiO1xuXG5cdGlmKGNvZGVQb2ludCA+IDB4RkZGRil7XG5cdFx0Y29kZVBvaW50IC09IDB4MTAwMDA7XG5cdFx0b3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRjtcblx0fVxuXG5cdG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdHJldHVybiBvdXRwdXQ7XG59XG4iLCJ2YXIgaW52ZXJzZVhNTCA9IGdldEludmVyc2VPYmoocmVxdWlyZShcIi4uL21hcHMveG1sLmpzb25cIikpLFxuICAgIHhtbFJlcGxhY2VyID0gZ2V0SW52ZXJzZVJlcGxhY2VyKGludmVyc2VYTUwpO1xuXG5leHBvcnRzLlhNTCA9IGdldEludmVyc2UoaW52ZXJzZVhNTCwgeG1sUmVwbGFjZXIpO1xuXG52YXIgaW52ZXJzZUhUTUwgPSBnZXRJbnZlcnNlT2JqKHJlcXVpcmUoXCIuLi9tYXBzL2VudGl0aWVzLmpzb25cIikpLFxuICAgIGh0bWxSZXBsYWNlciA9IGdldEludmVyc2VSZXBsYWNlcihpbnZlcnNlSFRNTCk7XG5cbmV4cG9ydHMuSFRNTCA9IGdldEludmVyc2UoaW52ZXJzZUhUTUwsIGh0bWxSZXBsYWNlcik7XG5cbmZ1bmN0aW9uIGdldEludmVyc2VPYmoob2JqKXtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG9iaikuc29ydCgpLnJlZHVjZShmdW5jdGlvbihpbnZlcnNlLCBuYW1lKXtcblx0XHRpbnZlcnNlW29ialtuYW1lXV0gPSBcIiZcIiArIG5hbWUgKyBcIjtcIjtcblx0XHRyZXR1cm4gaW52ZXJzZTtcblx0fSwge30pO1xufVxuXG5mdW5jdGlvbiBnZXRJbnZlcnNlUmVwbGFjZXIoaW52ZXJzZSl7XG5cdHZhciBzaW5nbGUgPSBbXSxcblx0ICAgIG11bHRpcGxlID0gW107XG5cblx0T2JqZWN0LmtleXMoaW52ZXJzZSkuZm9yRWFjaChmdW5jdGlvbihrKXtcblx0XHRpZihrLmxlbmd0aCA9PT0gMSl7XG5cdFx0XHRzaW5nbGUucHVzaChcIlxcXFxcIiArIGspO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtdWx0aXBsZS5wdXNoKGspO1xuXHRcdH1cblx0fSk7XG5cblx0Ly9UT0RPIGFkZCByYW5nZXNcblx0bXVsdGlwbGUudW5zaGlmdChcIltcIiArIHNpbmdsZS5qb2luKFwiXCIpICsgXCJdXCIpO1xuXG5cdHJldHVybiBuZXcgUmVnRXhwKG11bHRpcGxlLmpvaW4oXCJ8XCIpLCBcImdcIik7XG59XG5cbnZhciByZV9ub25BU0NJSSA9IC9bXlxcMC1cXHg3Rl0vZyxcbiAgICByZV9hc3RyYWxTeW1ib2xzID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZztcblxuZnVuY3Rpb24gc2luZ2xlQ2hhclJlcGxhY2VyKGMpe1xuXHRyZXR1cm4gXCImI3hcIiArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiO1wiO1xufVxuXG5mdW5jdGlvbiBhc3RyYWxSZXBsYWNlcihjKXtcblx0Ly8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcblx0dmFyIGhpZ2ggPSBjLmNoYXJDb2RlQXQoMCk7XG5cdHZhciBsb3cgID0gYy5jaGFyQ29kZUF0KDEpO1xuXHR2YXIgY29kZVBvaW50ID0gKGhpZ2ggLSAweEQ4MDApICogMHg0MDAgKyBsb3cgLSAweERDMDAgKyAweDEwMDAwO1xuXHRyZXR1cm4gXCImI3hcIiArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiO1wiO1xufVxuXG5mdW5jdGlvbiBnZXRJbnZlcnNlKGludmVyc2UsIHJlKXtcblx0ZnVuY3Rpb24gZnVuYyhuYW1lKXtcblx0XHRyZXR1cm4gaW52ZXJzZVtuYW1lXTtcblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbihkYXRhKXtcblx0XHRyZXR1cm4gZGF0YVxuXHRcdFx0XHQucmVwbGFjZShyZSwgZnVuYylcblx0XHRcdFx0LnJlcGxhY2UocmVfYXN0cmFsU3ltYm9scywgYXN0cmFsUmVwbGFjZXIpXG5cdFx0XHRcdC5yZXBsYWNlKHJlX25vbkFTQ0lJLCBzaW5nbGVDaGFyUmVwbGFjZXIpO1xuXHR9O1xufVxuXG52YXIgcmVfeG1sQ2hhcnMgPSBnZXRJbnZlcnNlUmVwbGFjZXIoaW52ZXJzZVhNTCk7XG5cbmZ1bmN0aW9uIGVzY2FwZVhNTChkYXRhKXtcblx0cmV0dXJuIGRhdGFcblx0XHRcdC5yZXBsYWNlKHJlX3htbENoYXJzLCBzaW5nbGVDaGFyUmVwbGFjZXIpXG5cdFx0XHQucmVwbGFjZShyZV9hc3RyYWxTeW1ib2xzLCBhc3RyYWxSZXBsYWNlcilcblx0XHRcdC5yZXBsYWNlKHJlX25vbkFTQ0lJLCBzaW5nbGVDaGFyUmVwbGFjZXIpO1xufVxuXG5leHBvcnRzLmVzY2FwZSA9IGVzY2FwZVhNTDtcbiIsIm1vZHVsZS5leHBvcnRzPXtcIjBcIjo2NTUzMyxcIjEyOFwiOjgzNjQsXCIxMzBcIjo4MjE4LFwiMTMxXCI6NDAyLFwiMTMyXCI6ODIyMixcIjEzM1wiOjgyMzAsXCIxMzRcIjo4MjI0LFwiMTM1XCI6ODIyNSxcIjEzNlwiOjcxMCxcIjEzN1wiOjgyNDAsXCIxMzhcIjozNTIsXCIxMzlcIjo4MjQ5LFwiMTQwXCI6MzM4LFwiMTQyXCI6MzgxLFwiMTQ1XCI6ODIxNixcIjE0NlwiOjgyMTcsXCIxNDdcIjo4MjIwLFwiMTQ4XCI6ODIyMSxcIjE0OVwiOjgyMjYsXCIxNTBcIjo4MjExLFwiMTUxXCI6ODIxMixcIjE1MlwiOjczMixcIjE1M1wiOjg0ODIsXCIxNTRcIjozNTMsXCIxNTVcIjo4MjUwLFwiMTU2XCI6MzM5LFwiMTU4XCI6MzgyLFwiMTU5XCI6Mzc2fSIsIm1vZHVsZS5leHBvcnRzPXtcIkFhY3V0ZVwiOlwiXFx1MDBDMVwiLFwiYWFjdXRlXCI6XCJcXHUwMEUxXCIsXCJBYnJldmVcIjpcIlxcdTAxMDJcIixcImFicmV2ZVwiOlwiXFx1MDEwM1wiLFwiYWNcIjpcIlxcdTIyM0VcIixcImFjZFwiOlwiXFx1MjIzRlwiLFwiYWNFXCI6XCJcXHUyMjNFXFx1MDMzM1wiLFwiQWNpcmNcIjpcIlxcdTAwQzJcIixcImFjaXJjXCI6XCJcXHUwMEUyXCIsXCJhY3V0ZVwiOlwiXFx1MDBCNFwiLFwiQWN5XCI6XCJcXHUwNDEwXCIsXCJhY3lcIjpcIlxcdTA0MzBcIixcIkFFbGlnXCI6XCJcXHUwMEM2XCIsXCJhZWxpZ1wiOlwiXFx1MDBFNlwiLFwiYWZcIjpcIlxcdTIwNjFcIixcIkFmclwiOlwiXFx1RDgzNVxcdUREMDRcIixcImFmclwiOlwiXFx1RDgzNVxcdUREMUVcIixcIkFncmF2ZVwiOlwiXFx1MDBDMFwiLFwiYWdyYXZlXCI6XCJcXHUwMEUwXCIsXCJhbGVmc3ltXCI6XCJcXHUyMTM1XCIsXCJhbGVwaFwiOlwiXFx1MjEzNVwiLFwiQWxwaGFcIjpcIlxcdTAzOTFcIixcImFscGhhXCI6XCJcXHUwM0IxXCIsXCJBbWFjclwiOlwiXFx1MDEwMFwiLFwiYW1hY3JcIjpcIlxcdTAxMDFcIixcImFtYWxnXCI6XCJcXHUyQTNGXCIsXCJhbXBcIjpcIiZcIixcIkFNUFwiOlwiJlwiLFwiYW5kYW5kXCI6XCJcXHUyQTU1XCIsXCJBbmRcIjpcIlxcdTJBNTNcIixcImFuZFwiOlwiXFx1MjIyN1wiLFwiYW5kZFwiOlwiXFx1MkE1Q1wiLFwiYW5kc2xvcGVcIjpcIlxcdTJBNThcIixcImFuZHZcIjpcIlxcdTJBNUFcIixcImFuZ1wiOlwiXFx1MjIyMFwiLFwiYW5nZVwiOlwiXFx1MjlBNFwiLFwiYW5nbGVcIjpcIlxcdTIyMjBcIixcImFuZ21zZGFhXCI6XCJcXHUyOUE4XCIsXCJhbmdtc2RhYlwiOlwiXFx1MjlBOVwiLFwiYW5nbXNkYWNcIjpcIlxcdTI5QUFcIixcImFuZ21zZGFkXCI6XCJcXHUyOUFCXCIsXCJhbmdtc2RhZVwiOlwiXFx1MjlBQ1wiLFwiYW5nbXNkYWZcIjpcIlxcdTI5QURcIixcImFuZ21zZGFnXCI6XCJcXHUyOUFFXCIsXCJhbmdtc2RhaFwiOlwiXFx1MjlBRlwiLFwiYW5nbXNkXCI6XCJcXHUyMjIxXCIsXCJhbmdydFwiOlwiXFx1MjIxRlwiLFwiYW5ncnR2YlwiOlwiXFx1MjJCRVwiLFwiYW5ncnR2YmRcIjpcIlxcdTI5OURcIixcImFuZ3NwaFwiOlwiXFx1MjIyMlwiLFwiYW5nc3RcIjpcIlxcdTAwQzVcIixcImFuZ3phcnJcIjpcIlxcdTIzN0NcIixcIkFvZ29uXCI6XCJcXHUwMTA0XCIsXCJhb2dvblwiOlwiXFx1MDEwNVwiLFwiQW9wZlwiOlwiXFx1RDgzNVxcdUREMzhcIixcImFvcGZcIjpcIlxcdUQ4MzVcXHVERDUyXCIsXCJhcGFjaXJcIjpcIlxcdTJBNkZcIixcImFwXCI6XCJcXHUyMjQ4XCIsXCJhcEVcIjpcIlxcdTJBNzBcIixcImFwZVwiOlwiXFx1MjI0QVwiLFwiYXBpZFwiOlwiXFx1MjI0QlwiLFwiYXBvc1wiOlwiJ1wiLFwiQXBwbHlGdW5jdGlvblwiOlwiXFx1MjA2MVwiLFwiYXBwcm94XCI6XCJcXHUyMjQ4XCIsXCJhcHByb3hlcVwiOlwiXFx1MjI0QVwiLFwiQXJpbmdcIjpcIlxcdTAwQzVcIixcImFyaW5nXCI6XCJcXHUwMEU1XCIsXCJBc2NyXCI6XCJcXHVEODM1XFx1REM5Q1wiLFwiYXNjclwiOlwiXFx1RDgzNVxcdURDQjZcIixcIkFzc2lnblwiOlwiXFx1MjI1NFwiLFwiYXN0XCI6XCIqXCIsXCJhc3ltcFwiOlwiXFx1MjI0OFwiLFwiYXN5bXBlcVwiOlwiXFx1MjI0RFwiLFwiQXRpbGRlXCI6XCJcXHUwMEMzXCIsXCJhdGlsZGVcIjpcIlxcdTAwRTNcIixcIkF1bWxcIjpcIlxcdTAwQzRcIixcImF1bWxcIjpcIlxcdTAwRTRcIixcImF3Y29uaW50XCI6XCJcXHUyMjMzXCIsXCJhd2ludFwiOlwiXFx1MkExMVwiLFwiYmFja2NvbmdcIjpcIlxcdTIyNENcIixcImJhY2tlcHNpbG9uXCI6XCJcXHUwM0Y2XCIsXCJiYWNrcHJpbWVcIjpcIlxcdTIwMzVcIixcImJhY2tzaW1cIjpcIlxcdTIyM0RcIixcImJhY2tzaW1lcVwiOlwiXFx1MjJDRFwiLFwiQmFja3NsYXNoXCI6XCJcXHUyMjE2XCIsXCJCYXJ2XCI6XCJcXHUyQUU3XCIsXCJiYXJ2ZWVcIjpcIlxcdTIyQkRcIixcImJhcndlZFwiOlwiXFx1MjMwNVwiLFwiQmFyd2VkXCI6XCJcXHUyMzA2XCIsXCJiYXJ3ZWRnZVwiOlwiXFx1MjMwNVwiLFwiYmJya1wiOlwiXFx1MjNCNVwiLFwiYmJya3RicmtcIjpcIlxcdTIzQjZcIixcImJjb25nXCI6XCJcXHUyMjRDXCIsXCJCY3lcIjpcIlxcdTA0MTFcIixcImJjeVwiOlwiXFx1MDQzMVwiLFwiYmRxdW9cIjpcIlxcdTIwMUVcIixcImJlY2F1c1wiOlwiXFx1MjIzNVwiLFwiYmVjYXVzZVwiOlwiXFx1MjIzNVwiLFwiQmVjYXVzZVwiOlwiXFx1MjIzNVwiLFwiYmVtcHR5dlwiOlwiXFx1MjlCMFwiLFwiYmVwc2lcIjpcIlxcdTAzRjZcIixcImJlcm5vdVwiOlwiXFx1MjEyQ1wiLFwiQmVybm91bGxpc1wiOlwiXFx1MjEyQ1wiLFwiQmV0YVwiOlwiXFx1MDM5MlwiLFwiYmV0YVwiOlwiXFx1MDNCMlwiLFwiYmV0aFwiOlwiXFx1MjEzNlwiLFwiYmV0d2VlblwiOlwiXFx1MjI2Q1wiLFwiQmZyXCI6XCJcXHVEODM1XFx1REQwNVwiLFwiYmZyXCI6XCJcXHVEODM1XFx1REQxRlwiLFwiYmlnY2FwXCI6XCJcXHUyMkMyXCIsXCJiaWdjaXJjXCI6XCJcXHUyNUVGXCIsXCJiaWdjdXBcIjpcIlxcdTIyQzNcIixcImJpZ29kb3RcIjpcIlxcdTJBMDBcIixcImJpZ29wbHVzXCI6XCJcXHUyQTAxXCIsXCJiaWdvdGltZXNcIjpcIlxcdTJBMDJcIixcImJpZ3NxY3VwXCI6XCJcXHUyQTA2XCIsXCJiaWdzdGFyXCI6XCJcXHUyNjA1XCIsXCJiaWd0cmlhbmdsZWRvd25cIjpcIlxcdTI1QkRcIixcImJpZ3RyaWFuZ2xldXBcIjpcIlxcdTI1QjNcIixcImJpZ3VwbHVzXCI6XCJcXHUyQTA0XCIsXCJiaWd2ZWVcIjpcIlxcdTIyQzFcIixcImJpZ3dlZGdlXCI6XCJcXHUyMkMwXCIsXCJia2Fyb3dcIjpcIlxcdTI5MERcIixcImJsYWNrbG96ZW5nZVwiOlwiXFx1MjlFQlwiLFwiYmxhY2tzcXVhcmVcIjpcIlxcdTI1QUFcIixcImJsYWNrdHJpYW5nbGVcIjpcIlxcdTI1QjRcIixcImJsYWNrdHJpYW5nbGVkb3duXCI6XCJcXHUyNUJFXCIsXCJibGFja3RyaWFuZ2xlbGVmdFwiOlwiXFx1MjVDMlwiLFwiYmxhY2t0cmlhbmdsZXJpZ2h0XCI6XCJcXHUyNUI4XCIsXCJibGFua1wiOlwiXFx1MjQyM1wiLFwiYmxrMTJcIjpcIlxcdTI1OTJcIixcImJsazE0XCI6XCJcXHUyNTkxXCIsXCJibGszNFwiOlwiXFx1MjU5M1wiLFwiYmxvY2tcIjpcIlxcdTI1ODhcIixcImJuZVwiOlwiPVxcdTIwRTVcIixcImJuZXF1aXZcIjpcIlxcdTIyNjFcXHUyMEU1XCIsXCJiTm90XCI6XCJcXHUyQUVEXCIsXCJibm90XCI6XCJcXHUyMzEwXCIsXCJCb3BmXCI6XCJcXHVEODM1XFx1REQzOVwiLFwiYm9wZlwiOlwiXFx1RDgzNVxcdURENTNcIixcImJvdFwiOlwiXFx1MjJBNVwiLFwiYm90dG9tXCI6XCJcXHUyMkE1XCIsXCJib3d0aWVcIjpcIlxcdTIyQzhcIixcImJveGJveFwiOlwiXFx1MjlDOVwiLFwiYm94ZGxcIjpcIlxcdTI1MTBcIixcImJveGRMXCI6XCJcXHUyNTU1XCIsXCJib3hEbFwiOlwiXFx1MjU1NlwiLFwiYm94RExcIjpcIlxcdTI1NTdcIixcImJveGRyXCI6XCJcXHUyNTBDXCIsXCJib3hkUlwiOlwiXFx1MjU1MlwiLFwiYm94RHJcIjpcIlxcdTI1NTNcIixcImJveERSXCI6XCJcXHUyNTU0XCIsXCJib3hoXCI6XCJcXHUyNTAwXCIsXCJib3hIXCI6XCJcXHUyNTUwXCIsXCJib3hoZFwiOlwiXFx1MjUyQ1wiLFwiYm94SGRcIjpcIlxcdTI1NjRcIixcImJveGhEXCI6XCJcXHUyNTY1XCIsXCJib3hIRFwiOlwiXFx1MjU2NlwiLFwiYm94aHVcIjpcIlxcdTI1MzRcIixcImJveEh1XCI6XCJcXHUyNTY3XCIsXCJib3hoVVwiOlwiXFx1MjU2OFwiLFwiYm94SFVcIjpcIlxcdTI1NjlcIixcImJveG1pbnVzXCI6XCJcXHUyMjlGXCIsXCJib3hwbHVzXCI6XCJcXHUyMjlFXCIsXCJib3h0aW1lc1wiOlwiXFx1MjJBMFwiLFwiYm94dWxcIjpcIlxcdTI1MThcIixcImJveHVMXCI6XCJcXHUyNTVCXCIsXCJib3hVbFwiOlwiXFx1MjU1Q1wiLFwiYm94VUxcIjpcIlxcdTI1NURcIixcImJveHVyXCI6XCJcXHUyNTE0XCIsXCJib3h1UlwiOlwiXFx1MjU1OFwiLFwiYm94VXJcIjpcIlxcdTI1NTlcIixcImJveFVSXCI6XCJcXHUyNTVBXCIsXCJib3h2XCI6XCJcXHUyNTAyXCIsXCJib3hWXCI6XCJcXHUyNTUxXCIsXCJib3h2aFwiOlwiXFx1MjUzQ1wiLFwiYm94dkhcIjpcIlxcdTI1NkFcIixcImJveFZoXCI6XCJcXHUyNTZCXCIsXCJib3hWSFwiOlwiXFx1MjU2Q1wiLFwiYm94dmxcIjpcIlxcdTI1MjRcIixcImJveHZMXCI6XCJcXHUyNTYxXCIsXCJib3hWbFwiOlwiXFx1MjU2MlwiLFwiYm94VkxcIjpcIlxcdTI1NjNcIixcImJveHZyXCI6XCJcXHUyNTFDXCIsXCJib3h2UlwiOlwiXFx1MjU1RVwiLFwiYm94VnJcIjpcIlxcdTI1NUZcIixcImJveFZSXCI6XCJcXHUyNTYwXCIsXCJicHJpbWVcIjpcIlxcdTIwMzVcIixcImJyZXZlXCI6XCJcXHUwMkQ4XCIsXCJCcmV2ZVwiOlwiXFx1MDJEOFwiLFwiYnJ2YmFyXCI6XCJcXHUwMEE2XCIsXCJic2NyXCI6XCJcXHVEODM1XFx1RENCN1wiLFwiQnNjclwiOlwiXFx1MjEyQ1wiLFwiYnNlbWlcIjpcIlxcdTIwNEZcIixcImJzaW1cIjpcIlxcdTIyM0RcIixcImJzaW1lXCI6XCJcXHUyMkNEXCIsXCJic29sYlwiOlwiXFx1MjlDNVwiLFwiYnNvbFwiOlwiXFxcXFwiLFwiYnNvbGhzdWJcIjpcIlxcdTI3QzhcIixcImJ1bGxcIjpcIlxcdTIwMjJcIixcImJ1bGxldFwiOlwiXFx1MjAyMlwiLFwiYnVtcFwiOlwiXFx1MjI0RVwiLFwiYnVtcEVcIjpcIlxcdTJBQUVcIixcImJ1bXBlXCI6XCJcXHUyMjRGXCIsXCJCdW1wZXFcIjpcIlxcdTIyNEVcIixcImJ1bXBlcVwiOlwiXFx1MjI0RlwiLFwiQ2FjdXRlXCI6XCJcXHUwMTA2XCIsXCJjYWN1dGVcIjpcIlxcdTAxMDdcIixcImNhcGFuZFwiOlwiXFx1MkE0NFwiLFwiY2FwYnJjdXBcIjpcIlxcdTJBNDlcIixcImNhcGNhcFwiOlwiXFx1MkE0QlwiLFwiY2FwXCI6XCJcXHUyMjI5XCIsXCJDYXBcIjpcIlxcdTIyRDJcIixcImNhcGN1cFwiOlwiXFx1MkE0N1wiLFwiY2FwZG90XCI6XCJcXHUyQTQwXCIsXCJDYXBpdGFsRGlmZmVyZW50aWFsRFwiOlwiXFx1MjE0NVwiLFwiY2Fwc1wiOlwiXFx1MjIyOVxcdUZFMDBcIixcImNhcmV0XCI6XCJcXHUyMDQxXCIsXCJjYXJvblwiOlwiXFx1MDJDN1wiLFwiQ2F5bGV5c1wiOlwiXFx1MjEyRFwiLFwiY2NhcHNcIjpcIlxcdTJBNERcIixcIkNjYXJvblwiOlwiXFx1MDEwQ1wiLFwiY2Nhcm9uXCI6XCJcXHUwMTBEXCIsXCJDY2VkaWxcIjpcIlxcdTAwQzdcIixcImNjZWRpbFwiOlwiXFx1MDBFN1wiLFwiQ2NpcmNcIjpcIlxcdTAxMDhcIixcImNjaXJjXCI6XCJcXHUwMTA5XCIsXCJDY29uaW50XCI6XCJcXHUyMjMwXCIsXCJjY3Vwc1wiOlwiXFx1MkE0Q1wiLFwiY2N1cHNzbVwiOlwiXFx1MkE1MFwiLFwiQ2RvdFwiOlwiXFx1MDEwQVwiLFwiY2RvdFwiOlwiXFx1MDEwQlwiLFwiY2VkaWxcIjpcIlxcdTAwQjhcIixcIkNlZGlsbGFcIjpcIlxcdTAwQjhcIixcImNlbXB0eXZcIjpcIlxcdTI5QjJcIixcImNlbnRcIjpcIlxcdTAwQTJcIixcImNlbnRlcmRvdFwiOlwiXFx1MDBCN1wiLFwiQ2VudGVyRG90XCI6XCJcXHUwMEI3XCIsXCJjZnJcIjpcIlxcdUQ4MzVcXHVERDIwXCIsXCJDZnJcIjpcIlxcdTIxMkRcIixcIkNIY3lcIjpcIlxcdTA0MjdcIixcImNoY3lcIjpcIlxcdTA0NDdcIixcImNoZWNrXCI6XCJcXHUyNzEzXCIsXCJjaGVja21hcmtcIjpcIlxcdTI3MTNcIixcIkNoaVwiOlwiXFx1MDNBN1wiLFwiY2hpXCI6XCJcXHUwM0M3XCIsXCJjaXJjXCI6XCJcXHUwMkM2XCIsXCJjaXJjZXFcIjpcIlxcdTIyNTdcIixcImNpcmNsZWFycm93bGVmdFwiOlwiXFx1MjFCQVwiLFwiY2lyY2xlYXJyb3dyaWdodFwiOlwiXFx1MjFCQlwiLFwiY2lyY2xlZGFzdFwiOlwiXFx1MjI5QlwiLFwiY2lyY2xlZGNpcmNcIjpcIlxcdTIyOUFcIixcImNpcmNsZWRkYXNoXCI6XCJcXHUyMjlEXCIsXCJDaXJjbGVEb3RcIjpcIlxcdTIyOTlcIixcImNpcmNsZWRSXCI6XCJcXHUwMEFFXCIsXCJjaXJjbGVkU1wiOlwiXFx1MjRDOFwiLFwiQ2lyY2xlTWludXNcIjpcIlxcdTIyOTZcIixcIkNpcmNsZVBsdXNcIjpcIlxcdTIyOTVcIixcIkNpcmNsZVRpbWVzXCI6XCJcXHUyMjk3XCIsXCJjaXJcIjpcIlxcdTI1Q0JcIixcImNpckVcIjpcIlxcdTI5QzNcIixcImNpcmVcIjpcIlxcdTIyNTdcIixcImNpcmZuaW50XCI6XCJcXHUyQTEwXCIsXCJjaXJtaWRcIjpcIlxcdTJBRUZcIixcImNpcnNjaXJcIjpcIlxcdTI5QzJcIixcIkNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbFwiOlwiXFx1MjIzMlwiLFwiQ2xvc2VDdXJseURvdWJsZVF1b3RlXCI6XCJcXHUyMDFEXCIsXCJDbG9zZUN1cmx5UXVvdGVcIjpcIlxcdTIwMTlcIixcImNsdWJzXCI6XCJcXHUyNjYzXCIsXCJjbHVic3VpdFwiOlwiXFx1MjY2M1wiLFwiY29sb25cIjpcIjpcIixcIkNvbG9uXCI6XCJcXHUyMjM3XCIsXCJDb2xvbmVcIjpcIlxcdTJBNzRcIixcImNvbG9uZVwiOlwiXFx1MjI1NFwiLFwiY29sb25lcVwiOlwiXFx1MjI1NFwiLFwiY29tbWFcIjpcIixcIixcImNvbW1hdFwiOlwiQFwiLFwiY29tcFwiOlwiXFx1MjIwMVwiLFwiY29tcGZuXCI6XCJcXHUyMjE4XCIsXCJjb21wbGVtZW50XCI6XCJcXHUyMjAxXCIsXCJjb21wbGV4ZXNcIjpcIlxcdTIxMDJcIixcImNvbmdcIjpcIlxcdTIyNDVcIixcImNvbmdkb3RcIjpcIlxcdTJBNkRcIixcIkNvbmdydWVudFwiOlwiXFx1MjI2MVwiLFwiY29uaW50XCI6XCJcXHUyMjJFXCIsXCJDb25pbnRcIjpcIlxcdTIyMkZcIixcIkNvbnRvdXJJbnRlZ3JhbFwiOlwiXFx1MjIyRVwiLFwiY29wZlwiOlwiXFx1RDgzNVxcdURENTRcIixcIkNvcGZcIjpcIlxcdTIxMDJcIixcImNvcHJvZFwiOlwiXFx1MjIxMFwiLFwiQ29wcm9kdWN0XCI6XCJcXHUyMjEwXCIsXCJjb3B5XCI6XCJcXHUwMEE5XCIsXCJDT1BZXCI6XCJcXHUwMEE5XCIsXCJjb3B5c3JcIjpcIlxcdTIxMTdcIixcIkNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWxcIjpcIlxcdTIyMzNcIixcImNyYXJyXCI6XCJcXHUyMUI1XCIsXCJjcm9zc1wiOlwiXFx1MjcxN1wiLFwiQ3Jvc3NcIjpcIlxcdTJBMkZcIixcIkNzY3JcIjpcIlxcdUQ4MzVcXHVEQzlFXCIsXCJjc2NyXCI6XCJcXHVEODM1XFx1RENCOFwiLFwiY3N1YlwiOlwiXFx1MkFDRlwiLFwiY3N1YmVcIjpcIlxcdTJBRDFcIixcImNzdXBcIjpcIlxcdTJBRDBcIixcImNzdXBlXCI6XCJcXHUyQUQyXCIsXCJjdGRvdFwiOlwiXFx1MjJFRlwiLFwiY3VkYXJybFwiOlwiXFx1MjkzOFwiLFwiY3VkYXJyclwiOlwiXFx1MjkzNVwiLFwiY3VlcHJcIjpcIlxcdTIyREVcIixcImN1ZXNjXCI6XCJcXHUyMkRGXCIsXCJjdWxhcnJcIjpcIlxcdTIxQjZcIixcImN1bGFycnBcIjpcIlxcdTI5M0RcIixcImN1cGJyY2FwXCI6XCJcXHUyQTQ4XCIsXCJjdXBjYXBcIjpcIlxcdTJBNDZcIixcIkN1cENhcFwiOlwiXFx1MjI0RFwiLFwiY3VwXCI6XCJcXHUyMjJBXCIsXCJDdXBcIjpcIlxcdTIyRDNcIixcImN1cGN1cFwiOlwiXFx1MkE0QVwiLFwiY3VwZG90XCI6XCJcXHUyMjhEXCIsXCJjdXBvclwiOlwiXFx1MkE0NVwiLFwiY3Vwc1wiOlwiXFx1MjIyQVxcdUZFMDBcIixcImN1cmFyclwiOlwiXFx1MjFCN1wiLFwiY3VyYXJybVwiOlwiXFx1MjkzQ1wiLFwiY3VybHllcXByZWNcIjpcIlxcdTIyREVcIixcImN1cmx5ZXFzdWNjXCI6XCJcXHUyMkRGXCIsXCJjdXJseXZlZVwiOlwiXFx1MjJDRVwiLFwiY3VybHl3ZWRnZVwiOlwiXFx1MjJDRlwiLFwiY3VycmVuXCI6XCJcXHUwMEE0XCIsXCJjdXJ2ZWFycm93bGVmdFwiOlwiXFx1MjFCNlwiLFwiY3VydmVhcnJvd3JpZ2h0XCI6XCJcXHUyMUI3XCIsXCJjdXZlZVwiOlwiXFx1MjJDRVwiLFwiY3V3ZWRcIjpcIlxcdTIyQ0ZcIixcImN3Y29uaW50XCI6XCJcXHUyMjMyXCIsXCJjd2ludFwiOlwiXFx1MjIzMVwiLFwiY3lsY3R5XCI6XCJcXHUyMzJEXCIsXCJkYWdnZXJcIjpcIlxcdTIwMjBcIixcIkRhZ2dlclwiOlwiXFx1MjAyMVwiLFwiZGFsZXRoXCI6XCJcXHUyMTM4XCIsXCJkYXJyXCI6XCJcXHUyMTkzXCIsXCJEYXJyXCI6XCJcXHUyMUExXCIsXCJkQXJyXCI6XCJcXHUyMUQzXCIsXCJkYXNoXCI6XCJcXHUyMDEwXCIsXCJEYXNodlwiOlwiXFx1MkFFNFwiLFwiZGFzaHZcIjpcIlxcdTIyQTNcIixcImRia2Fyb3dcIjpcIlxcdTI5MEZcIixcImRibGFjXCI6XCJcXHUwMkREXCIsXCJEY2Fyb25cIjpcIlxcdTAxMEVcIixcImRjYXJvblwiOlwiXFx1MDEwRlwiLFwiRGN5XCI6XCJcXHUwNDE0XCIsXCJkY3lcIjpcIlxcdTA0MzRcIixcImRkYWdnZXJcIjpcIlxcdTIwMjFcIixcImRkYXJyXCI6XCJcXHUyMUNBXCIsXCJERFwiOlwiXFx1MjE0NVwiLFwiZGRcIjpcIlxcdTIxNDZcIixcIkREb3RyYWhkXCI6XCJcXHUyOTExXCIsXCJkZG90c2VxXCI6XCJcXHUyQTc3XCIsXCJkZWdcIjpcIlxcdTAwQjBcIixcIkRlbFwiOlwiXFx1MjIwN1wiLFwiRGVsdGFcIjpcIlxcdTAzOTRcIixcImRlbHRhXCI6XCJcXHUwM0I0XCIsXCJkZW1wdHl2XCI6XCJcXHUyOUIxXCIsXCJkZmlzaHRcIjpcIlxcdTI5N0ZcIixcIkRmclwiOlwiXFx1RDgzNVxcdUREMDdcIixcImRmclwiOlwiXFx1RDgzNVxcdUREMjFcIixcImRIYXJcIjpcIlxcdTI5NjVcIixcImRoYXJsXCI6XCJcXHUyMUMzXCIsXCJkaGFyclwiOlwiXFx1MjFDMlwiLFwiRGlhY3JpdGljYWxBY3V0ZVwiOlwiXFx1MDBCNFwiLFwiRGlhY3JpdGljYWxEb3RcIjpcIlxcdTAyRDlcIixcIkRpYWNyaXRpY2FsRG91YmxlQWN1dGVcIjpcIlxcdTAyRERcIixcIkRpYWNyaXRpY2FsR3JhdmVcIjpcImBcIixcIkRpYWNyaXRpY2FsVGlsZGVcIjpcIlxcdTAyRENcIixcImRpYW1cIjpcIlxcdTIyQzRcIixcImRpYW1vbmRcIjpcIlxcdTIyQzRcIixcIkRpYW1vbmRcIjpcIlxcdTIyQzRcIixcImRpYW1vbmRzdWl0XCI6XCJcXHUyNjY2XCIsXCJkaWFtc1wiOlwiXFx1MjY2NlwiLFwiZGllXCI6XCJcXHUwMEE4XCIsXCJEaWZmZXJlbnRpYWxEXCI6XCJcXHUyMTQ2XCIsXCJkaWdhbW1hXCI6XCJcXHUwM0REXCIsXCJkaXNpblwiOlwiXFx1MjJGMlwiLFwiZGl2XCI6XCJcXHUwMEY3XCIsXCJkaXZpZGVcIjpcIlxcdTAwRjdcIixcImRpdmlkZW9udGltZXNcIjpcIlxcdTIyQzdcIixcImRpdm9ueFwiOlwiXFx1MjJDN1wiLFwiREpjeVwiOlwiXFx1MDQwMlwiLFwiZGpjeVwiOlwiXFx1MDQ1MlwiLFwiZGxjb3JuXCI6XCJcXHUyMzFFXCIsXCJkbGNyb3BcIjpcIlxcdTIzMERcIixcImRvbGxhclwiOlwiJFwiLFwiRG9wZlwiOlwiXFx1RDgzNVxcdUREM0JcIixcImRvcGZcIjpcIlxcdUQ4MzVcXHVERDU1XCIsXCJEb3RcIjpcIlxcdTAwQThcIixcImRvdFwiOlwiXFx1MDJEOVwiLFwiRG90RG90XCI6XCJcXHUyMERDXCIsXCJkb3RlcVwiOlwiXFx1MjI1MFwiLFwiZG90ZXFkb3RcIjpcIlxcdTIyNTFcIixcIkRvdEVxdWFsXCI6XCJcXHUyMjUwXCIsXCJkb3RtaW51c1wiOlwiXFx1MjIzOFwiLFwiZG90cGx1c1wiOlwiXFx1MjIxNFwiLFwiZG90c3F1YXJlXCI6XCJcXHUyMkExXCIsXCJkb3VibGViYXJ3ZWRnZVwiOlwiXFx1MjMwNlwiLFwiRG91YmxlQ29udG91ckludGVncmFsXCI6XCJcXHUyMjJGXCIsXCJEb3VibGVEb3RcIjpcIlxcdTAwQThcIixcIkRvdWJsZURvd25BcnJvd1wiOlwiXFx1MjFEM1wiLFwiRG91YmxlTGVmdEFycm93XCI6XCJcXHUyMUQwXCIsXCJEb3VibGVMZWZ0UmlnaHRBcnJvd1wiOlwiXFx1MjFENFwiLFwiRG91YmxlTGVmdFRlZVwiOlwiXFx1MkFFNFwiLFwiRG91YmxlTG9uZ0xlZnRBcnJvd1wiOlwiXFx1MjdGOFwiLFwiRG91YmxlTG9uZ0xlZnRSaWdodEFycm93XCI6XCJcXHUyN0ZBXCIsXCJEb3VibGVMb25nUmlnaHRBcnJvd1wiOlwiXFx1MjdGOVwiLFwiRG91YmxlUmlnaHRBcnJvd1wiOlwiXFx1MjFEMlwiLFwiRG91YmxlUmlnaHRUZWVcIjpcIlxcdTIyQThcIixcIkRvdWJsZVVwQXJyb3dcIjpcIlxcdTIxRDFcIixcIkRvdWJsZVVwRG93bkFycm93XCI6XCJcXHUyMUQ1XCIsXCJEb3VibGVWZXJ0aWNhbEJhclwiOlwiXFx1MjIyNVwiLFwiRG93bkFycm93QmFyXCI6XCJcXHUyOTEzXCIsXCJkb3duYXJyb3dcIjpcIlxcdTIxOTNcIixcIkRvd25BcnJvd1wiOlwiXFx1MjE5M1wiLFwiRG93bmFycm93XCI6XCJcXHUyMUQzXCIsXCJEb3duQXJyb3dVcEFycm93XCI6XCJcXHUyMUY1XCIsXCJEb3duQnJldmVcIjpcIlxcdTAzMTFcIixcImRvd25kb3duYXJyb3dzXCI6XCJcXHUyMUNBXCIsXCJkb3duaGFycG9vbmxlZnRcIjpcIlxcdTIxQzNcIixcImRvd25oYXJwb29ucmlnaHRcIjpcIlxcdTIxQzJcIixcIkRvd25MZWZ0UmlnaHRWZWN0b3JcIjpcIlxcdTI5NTBcIixcIkRvd25MZWZ0VGVlVmVjdG9yXCI6XCJcXHUyOTVFXCIsXCJEb3duTGVmdFZlY3RvckJhclwiOlwiXFx1Mjk1NlwiLFwiRG93bkxlZnRWZWN0b3JcIjpcIlxcdTIxQkRcIixcIkRvd25SaWdodFRlZVZlY3RvclwiOlwiXFx1Mjk1RlwiLFwiRG93blJpZ2h0VmVjdG9yQmFyXCI6XCJcXHUyOTU3XCIsXCJEb3duUmlnaHRWZWN0b3JcIjpcIlxcdTIxQzFcIixcIkRvd25UZWVBcnJvd1wiOlwiXFx1MjFBN1wiLFwiRG93blRlZVwiOlwiXFx1MjJBNFwiLFwiZHJia2Fyb3dcIjpcIlxcdTI5MTBcIixcImRyY29yblwiOlwiXFx1MjMxRlwiLFwiZHJjcm9wXCI6XCJcXHUyMzBDXCIsXCJEc2NyXCI6XCJcXHVEODM1XFx1REM5RlwiLFwiZHNjclwiOlwiXFx1RDgzNVxcdURDQjlcIixcIkRTY3lcIjpcIlxcdTA0MDVcIixcImRzY3lcIjpcIlxcdTA0NTVcIixcImRzb2xcIjpcIlxcdTI5RjZcIixcIkRzdHJva1wiOlwiXFx1MDExMFwiLFwiZHN0cm9rXCI6XCJcXHUwMTExXCIsXCJkdGRvdFwiOlwiXFx1MjJGMVwiLFwiZHRyaVwiOlwiXFx1MjVCRlwiLFwiZHRyaWZcIjpcIlxcdTI1QkVcIixcImR1YXJyXCI6XCJcXHUyMUY1XCIsXCJkdWhhclwiOlwiXFx1Mjk2RlwiLFwiZHdhbmdsZVwiOlwiXFx1MjlBNlwiLFwiRFpjeVwiOlwiXFx1MDQwRlwiLFwiZHpjeVwiOlwiXFx1MDQ1RlwiLFwiZHppZ3JhcnJcIjpcIlxcdTI3RkZcIixcIkVhY3V0ZVwiOlwiXFx1MDBDOVwiLFwiZWFjdXRlXCI6XCJcXHUwMEU5XCIsXCJlYXN0ZXJcIjpcIlxcdTJBNkVcIixcIkVjYXJvblwiOlwiXFx1MDExQVwiLFwiZWNhcm9uXCI6XCJcXHUwMTFCXCIsXCJFY2lyY1wiOlwiXFx1MDBDQVwiLFwiZWNpcmNcIjpcIlxcdTAwRUFcIixcImVjaXJcIjpcIlxcdTIyNTZcIixcImVjb2xvblwiOlwiXFx1MjI1NVwiLFwiRWN5XCI6XCJcXHUwNDJEXCIsXCJlY3lcIjpcIlxcdTA0NERcIixcImVERG90XCI6XCJcXHUyQTc3XCIsXCJFZG90XCI6XCJcXHUwMTE2XCIsXCJlZG90XCI6XCJcXHUwMTE3XCIsXCJlRG90XCI6XCJcXHUyMjUxXCIsXCJlZVwiOlwiXFx1MjE0N1wiLFwiZWZEb3RcIjpcIlxcdTIyNTJcIixcIkVmclwiOlwiXFx1RDgzNVxcdUREMDhcIixcImVmclwiOlwiXFx1RDgzNVxcdUREMjJcIixcImVnXCI6XCJcXHUyQTlBXCIsXCJFZ3JhdmVcIjpcIlxcdTAwQzhcIixcImVncmF2ZVwiOlwiXFx1MDBFOFwiLFwiZWdzXCI6XCJcXHUyQTk2XCIsXCJlZ3Nkb3RcIjpcIlxcdTJBOThcIixcImVsXCI6XCJcXHUyQTk5XCIsXCJFbGVtZW50XCI6XCJcXHUyMjA4XCIsXCJlbGludGVyc1wiOlwiXFx1MjNFN1wiLFwiZWxsXCI6XCJcXHUyMTEzXCIsXCJlbHNcIjpcIlxcdTJBOTVcIixcImVsc2RvdFwiOlwiXFx1MkE5N1wiLFwiRW1hY3JcIjpcIlxcdTAxMTJcIixcImVtYWNyXCI6XCJcXHUwMTEzXCIsXCJlbXB0eVwiOlwiXFx1MjIwNVwiLFwiZW1wdHlzZXRcIjpcIlxcdTIyMDVcIixcIkVtcHR5U21hbGxTcXVhcmVcIjpcIlxcdTI1RkJcIixcImVtcHR5dlwiOlwiXFx1MjIwNVwiLFwiRW1wdHlWZXJ5U21hbGxTcXVhcmVcIjpcIlxcdTI1QUJcIixcImVtc3AxM1wiOlwiXFx1MjAwNFwiLFwiZW1zcDE0XCI6XCJcXHUyMDA1XCIsXCJlbXNwXCI6XCJcXHUyMDAzXCIsXCJFTkdcIjpcIlxcdTAxNEFcIixcImVuZ1wiOlwiXFx1MDE0QlwiLFwiZW5zcFwiOlwiXFx1MjAwMlwiLFwiRW9nb25cIjpcIlxcdTAxMThcIixcImVvZ29uXCI6XCJcXHUwMTE5XCIsXCJFb3BmXCI6XCJcXHVEODM1XFx1REQzQ1wiLFwiZW9wZlwiOlwiXFx1RDgzNVxcdURENTZcIixcImVwYXJcIjpcIlxcdTIyRDVcIixcImVwYXJzbFwiOlwiXFx1MjlFM1wiLFwiZXBsdXNcIjpcIlxcdTJBNzFcIixcImVwc2lcIjpcIlxcdTAzQjVcIixcIkVwc2lsb25cIjpcIlxcdTAzOTVcIixcImVwc2lsb25cIjpcIlxcdTAzQjVcIixcImVwc2l2XCI6XCJcXHUwM0Y1XCIsXCJlcWNpcmNcIjpcIlxcdTIyNTZcIixcImVxY29sb25cIjpcIlxcdTIyNTVcIixcImVxc2ltXCI6XCJcXHUyMjQyXCIsXCJlcXNsYW50Z3RyXCI6XCJcXHUyQTk2XCIsXCJlcXNsYW50bGVzc1wiOlwiXFx1MkE5NVwiLFwiRXF1YWxcIjpcIlxcdTJBNzVcIixcImVxdWFsc1wiOlwiPVwiLFwiRXF1YWxUaWxkZVwiOlwiXFx1MjI0MlwiLFwiZXF1ZXN0XCI6XCJcXHUyMjVGXCIsXCJFcXVpbGlicml1bVwiOlwiXFx1MjFDQ1wiLFwiZXF1aXZcIjpcIlxcdTIyNjFcIixcImVxdWl2RERcIjpcIlxcdTJBNzhcIixcImVxdnBhcnNsXCI6XCJcXHUyOUU1XCIsXCJlcmFyclwiOlwiXFx1Mjk3MVwiLFwiZXJEb3RcIjpcIlxcdTIyNTNcIixcImVzY3JcIjpcIlxcdTIxMkZcIixcIkVzY3JcIjpcIlxcdTIxMzBcIixcImVzZG90XCI6XCJcXHUyMjUwXCIsXCJFc2ltXCI6XCJcXHUyQTczXCIsXCJlc2ltXCI6XCJcXHUyMjQyXCIsXCJFdGFcIjpcIlxcdTAzOTdcIixcImV0YVwiOlwiXFx1MDNCN1wiLFwiRVRIXCI6XCJcXHUwMEQwXCIsXCJldGhcIjpcIlxcdTAwRjBcIixcIkV1bWxcIjpcIlxcdTAwQ0JcIixcImV1bWxcIjpcIlxcdTAwRUJcIixcImV1cm9cIjpcIlxcdTIwQUNcIixcImV4Y2xcIjpcIiFcIixcImV4aXN0XCI6XCJcXHUyMjAzXCIsXCJFeGlzdHNcIjpcIlxcdTIyMDNcIixcImV4cGVjdGF0aW9uXCI6XCJcXHUyMTMwXCIsXCJleHBvbmVudGlhbGVcIjpcIlxcdTIxNDdcIixcIkV4cG9uZW50aWFsRVwiOlwiXFx1MjE0N1wiLFwiZmFsbGluZ2RvdHNlcVwiOlwiXFx1MjI1MlwiLFwiRmN5XCI6XCJcXHUwNDI0XCIsXCJmY3lcIjpcIlxcdTA0NDRcIixcImZlbWFsZVwiOlwiXFx1MjY0MFwiLFwiZmZpbGlnXCI6XCJcXHVGQjAzXCIsXCJmZmxpZ1wiOlwiXFx1RkIwMFwiLFwiZmZsbGlnXCI6XCJcXHVGQjA0XCIsXCJGZnJcIjpcIlxcdUQ4MzVcXHVERDA5XCIsXCJmZnJcIjpcIlxcdUQ4MzVcXHVERDIzXCIsXCJmaWxpZ1wiOlwiXFx1RkIwMVwiLFwiRmlsbGVkU21hbGxTcXVhcmVcIjpcIlxcdTI1RkNcIixcIkZpbGxlZFZlcnlTbWFsbFNxdWFyZVwiOlwiXFx1MjVBQVwiLFwiZmpsaWdcIjpcImZqXCIsXCJmbGF0XCI6XCJcXHUyNjZEXCIsXCJmbGxpZ1wiOlwiXFx1RkIwMlwiLFwiZmx0bnNcIjpcIlxcdTI1QjFcIixcImZub2ZcIjpcIlxcdTAxOTJcIixcIkZvcGZcIjpcIlxcdUQ4MzVcXHVERDNEXCIsXCJmb3BmXCI6XCJcXHVEODM1XFx1REQ1N1wiLFwiZm9yYWxsXCI6XCJcXHUyMjAwXCIsXCJGb3JBbGxcIjpcIlxcdTIyMDBcIixcImZvcmtcIjpcIlxcdTIyRDRcIixcImZvcmt2XCI6XCJcXHUyQUQ5XCIsXCJGb3VyaWVydHJmXCI6XCJcXHUyMTMxXCIsXCJmcGFydGludFwiOlwiXFx1MkEwRFwiLFwiZnJhYzEyXCI6XCJcXHUwMEJEXCIsXCJmcmFjMTNcIjpcIlxcdTIxNTNcIixcImZyYWMxNFwiOlwiXFx1MDBCQ1wiLFwiZnJhYzE1XCI6XCJcXHUyMTU1XCIsXCJmcmFjMTZcIjpcIlxcdTIxNTlcIixcImZyYWMxOFwiOlwiXFx1MjE1QlwiLFwiZnJhYzIzXCI6XCJcXHUyMTU0XCIsXCJmcmFjMjVcIjpcIlxcdTIxNTZcIixcImZyYWMzNFwiOlwiXFx1MDBCRVwiLFwiZnJhYzM1XCI6XCJcXHUyMTU3XCIsXCJmcmFjMzhcIjpcIlxcdTIxNUNcIixcImZyYWM0NVwiOlwiXFx1MjE1OFwiLFwiZnJhYzU2XCI6XCJcXHUyMTVBXCIsXCJmcmFjNThcIjpcIlxcdTIxNURcIixcImZyYWM3OFwiOlwiXFx1MjE1RVwiLFwiZnJhc2xcIjpcIlxcdTIwNDRcIixcImZyb3duXCI6XCJcXHUyMzIyXCIsXCJmc2NyXCI6XCJcXHVEODM1XFx1RENCQlwiLFwiRnNjclwiOlwiXFx1MjEzMVwiLFwiZ2FjdXRlXCI6XCJcXHUwMUY1XCIsXCJHYW1tYVwiOlwiXFx1MDM5M1wiLFwiZ2FtbWFcIjpcIlxcdTAzQjNcIixcIkdhbW1hZFwiOlwiXFx1MDNEQ1wiLFwiZ2FtbWFkXCI6XCJcXHUwM0REXCIsXCJnYXBcIjpcIlxcdTJBODZcIixcIkdicmV2ZVwiOlwiXFx1MDExRVwiLFwiZ2JyZXZlXCI6XCJcXHUwMTFGXCIsXCJHY2VkaWxcIjpcIlxcdTAxMjJcIixcIkdjaXJjXCI6XCJcXHUwMTFDXCIsXCJnY2lyY1wiOlwiXFx1MDExRFwiLFwiR2N5XCI6XCJcXHUwNDEzXCIsXCJnY3lcIjpcIlxcdTA0MzNcIixcIkdkb3RcIjpcIlxcdTAxMjBcIixcImdkb3RcIjpcIlxcdTAxMjFcIixcImdlXCI6XCJcXHUyMjY1XCIsXCJnRVwiOlwiXFx1MjI2N1wiLFwiZ0VsXCI6XCJcXHUyQThDXCIsXCJnZWxcIjpcIlxcdTIyREJcIixcImdlcVwiOlwiXFx1MjI2NVwiLFwiZ2VxcVwiOlwiXFx1MjI2N1wiLFwiZ2Vxc2xhbnRcIjpcIlxcdTJBN0VcIixcImdlc2NjXCI6XCJcXHUyQUE5XCIsXCJnZXNcIjpcIlxcdTJBN0VcIixcImdlc2RvdFwiOlwiXFx1MkE4MFwiLFwiZ2VzZG90b1wiOlwiXFx1MkE4MlwiLFwiZ2VzZG90b2xcIjpcIlxcdTJBODRcIixcImdlc2xcIjpcIlxcdTIyREJcXHVGRTAwXCIsXCJnZXNsZXNcIjpcIlxcdTJBOTRcIixcIkdmclwiOlwiXFx1RDgzNVxcdUREMEFcIixcImdmclwiOlwiXFx1RDgzNVxcdUREMjRcIixcImdnXCI6XCJcXHUyMjZCXCIsXCJHZ1wiOlwiXFx1MjJEOVwiLFwiZ2dnXCI6XCJcXHUyMkQ5XCIsXCJnaW1lbFwiOlwiXFx1MjEzN1wiLFwiR0pjeVwiOlwiXFx1MDQwM1wiLFwiZ2pjeVwiOlwiXFx1MDQ1M1wiLFwiZ2xhXCI6XCJcXHUyQUE1XCIsXCJnbFwiOlwiXFx1MjI3N1wiLFwiZ2xFXCI6XCJcXHUyQTkyXCIsXCJnbGpcIjpcIlxcdTJBQTRcIixcImduYXBcIjpcIlxcdTJBOEFcIixcImduYXBwcm94XCI6XCJcXHUyQThBXCIsXCJnbmVcIjpcIlxcdTJBODhcIixcImduRVwiOlwiXFx1MjI2OVwiLFwiZ25lcVwiOlwiXFx1MkE4OFwiLFwiZ25lcXFcIjpcIlxcdTIyNjlcIixcImduc2ltXCI6XCJcXHUyMkU3XCIsXCJHb3BmXCI6XCJcXHVEODM1XFx1REQzRVwiLFwiZ29wZlwiOlwiXFx1RDgzNVxcdURENThcIixcImdyYXZlXCI6XCJgXCIsXCJHcmVhdGVyRXF1YWxcIjpcIlxcdTIyNjVcIixcIkdyZWF0ZXJFcXVhbExlc3NcIjpcIlxcdTIyREJcIixcIkdyZWF0ZXJGdWxsRXF1YWxcIjpcIlxcdTIyNjdcIixcIkdyZWF0ZXJHcmVhdGVyXCI6XCJcXHUyQUEyXCIsXCJHcmVhdGVyTGVzc1wiOlwiXFx1MjI3N1wiLFwiR3JlYXRlclNsYW50RXF1YWxcIjpcIlxcdTJBN0VcIixcIkdyZWF0ZXJUaWxkZVwiOlwiXFx1MjI3M1wiLFwiR3NjclwiOlwiXFx1RDgzNVxcdURDQTJcIixcImdzY3JcIjpcIlxcdTIxMEFcIixcImdzaW1cIjpcIlxcdTIyNzNcIixcImdzaW1lXCI6XCJcXHUyQThFXCIsXCJnc2ltbFwiOlwiXFx1MkE5MFwiLFwiZ3RjY1wiOlwiXFx1MkFBN1wiLFwiZ3RjaXJcIjpcIlxcdTJBN0FcIixcImd0XCI6XCI+XCIsXCJHVFwiOlwiPlwiLFwiR3RcIjpcIlxcdTIyNkJcIixcImd0ZG90XCI6XCJcXHUyMkQ3XCIsXCJndGxQYXJcIjpcIlxcdTI5OTVcIixcImd0cXVlc3RcIjpcIlxcdTJBN0NcIixcImd0cmFwcHJveFwiOlwiXFx1MkE4NlwiLFwiZ3RyYXJyXCI6XCJcXHUyOTc4XCIsXCJndHJkb3RcIjpcIlxcdTIyRDdcIixcImd0cmVxbGVzc1wiOlwiXFx1MjJEQlwiLFwiZ3RyZXFxbGVzc1wiOlwiXFx1MkE4Q1wiLFwiZ3RybGVzc1wiOlwiXFx1MjI3N1wiLFwiZ3Ryc2ltXCI6XCJcXHUyMjczXCIsXCJndmVydG5lcXFcIjpcIlxcdTIyNjlcXHVGRTAwXCIsXCJndm5FXCI6XCJcXHUyMjY5XFx1RkUwMFwiLFwiSGFjZWtcIjpcIlxcdTAyQzdcIixcImhhaXJzcFwiOlwiXFx1MjAwQVwiLFwiaGFsZlwiOlwiXFx1MDBCRFwiLFwiaGFtaWx0XCI6XCJcXHUyMTBCXCIsXCJIQVJEY3lcIjpcIlxcdTA0MkFcIixcImhhcmRjeVwiOlwiXFx1MDQ0QVwiLFwiaGFycmNpclwiOlwiXFx1Mjk0OFwiLFwiaGFyclwiOlwiXFx1MjE5NFwiLFwiaEFyclwiOlwiXFx1MjFENFwiLFwiaGFycndcIjpcIlxcdTIxQURcIixcIkhhdFwiOlwiXlwiLFwiaGJhclwiOlwiXFx1MjEwRlwiLFwiSGNpcmNcIjpcIlxcdTAxMjRcIixcImhjaXJjXCI6XCJcXHUwMTI1XCIsXCJoZWFydHNcIjpcIlxcdTI2NjVcIixcImhlYXJ0c3VpdFwiOlwiXFx1MjY2NVwiLFwiaGVsbGlwXCI6XCJcXHUyMDI2XCIsXCJoZXJjb25cIjpcIlxcdTIyQjlcIixcImhmclwiOlwiXFx1RDgzNVxcdUREMjVcIixcIkhmclwiOlwiXFx1MjEwQ1wiLFwiSGlsYmVydFNwYWNlXCI6XCJcXHUyMTBCXCIsXCJoa3NlYXJvd1wiOlwiXFx1MjkyNVwiLFwiaGtzd2Fyb3dcIjpcIlxcdTI5MjZcIixcImhvYXJyXCI6XCJcXHUyMUZGXCIsXCJob210aHRcIjpcIlxcdTIyM0JcIixcImhvb2tsZWZ0YXJyb3dcIjpcIlxcdTIxQTlcIixcImhvb2tyaWdodGFycm93XCI6XCJcXHUyMUFBXCIsXCJob3BmXCI6XCJcXHVEODM1XFx1REQ1OVwiLFwiSG9wZlwiOlwiXFx1MjEwRFwiLFwiaG9yYmFyXCI6XCJcXHUyMDE1XCIsXCJIb3Jpem9udGFsTGluZVwiOlwiXFx1MjUwMFwiLFwiaHNjclwiOlwiXFx1RDgzNVxcdURDQkRcIixcIkhzY3JcIjpcIlxcdTIxMEJcIixcImhzbGFzaFwiOlwiXFx1MjEwRlwiLFwiSHN0cm9rXCI6XCJcXHUwMTI2XCIsXCJoc3Ryb2tcIjpcIlxcdTAxMjdcIixcIkh1bXBEb3duSHVtcFwiOlwiXFx1MjI0RVwiLFwiSHVtcEVxdWFsXCI6XCJcXHUyMjRGXCIsXCJoeWJ1bGxcIjpcIlxcdTIwNDNcIixcImh5cGhlblwiOlwiXFx1MjAxMFwiLFwiSWFjdXRlXCI6XCJcXHUwMENEXCIsXCJpYWN1dGVcIjpcIlxcdTAwRURcIixcImljXCI6XCJcXHUyMDYzXCIsXCJJY2lyY1wiOlwiXFx1MDBDRVwiLFwiaWNpcmNcIjpcIlxcdTAwRUVcIixcIkljeVwiOlwiXFx1MDQxOFwiLFwiaWN5XCI6XCJcXHUwNDM4XCIsXCJJZG90XCI6XCJcXHUwMTMwXCIsXCJJRWN5XCI6XCJcXHUwNDE1XCIsXCJpZWN5XCI6XCJcXHUwNDM1XCIsXCJpZXhjbFwiOlwiXFx1MDBBMVwiLFwiaWZmXCI6XCJcXHUyMUQ0XCIsXCJpZnJcIjpcIlxcdUQ4MzVcXHVERDI2XCIsXCJJZnJcIjpcIlxcdTIxMTFcIixcIklncmF2ZVwiOlwiXFx1MDBDQ1wiLFwiaWdyYXZlXCI6XCJcXHUwMEVDXCIsXCJpaVwiOlwiXFx1MjE0OFwiLFwiaWlpaW50XCI6XCJcXHUyQTBDXCIsXCJpaWludFwiOlwiXFx1MjIyRFwiLFwiaWluZmluXCI6XCJcXHUyOURDXCIsXCJpaW90YVwiOlwiXFx1MjEyOVwiLFwiSUpsaWdcIjpcIlxcdTAxMzJcIixcImlqbGlnXCI6XCJcXHUwMTMzXCIsXCJJbWFjclwiOlwiXFx1MDEyQVwiLFwiaW1hY3JcIjpcIlxcdTAxMkJcIixcImltYWdlXCI6XCJcXHUyMTExXCIsXCJJbWFnaW5hcnlJXCI6XCJcXHUyMTQ4XCIsXCJpbWFnbGluZVwiOlwiXFx1MjExMFwiLFwiaW1hZ3BhcnRcIjpcIlxcdTIxMTFcIixcImltYXRoXCI6XCJcXHUwMTMxXCIsXCJJbVwiOlwiXFx1MjExMVwiLFwiaW1vZlwiOlwiXFx1MjJCN1wiLFwiaW1wZWRcIjpcIlxcdTAxQjVcIixcIkltcGxpZXNcIjpcIlxcdTIxRDJcIixcImluY2FyZVwiOlwiXFx1MjEwNVwiLFwiaW5cIjpcIlxcdTIyMDhcIixcImluZmluXCI6XCJcXHUyMjFFXCIsXCJpbmZpbnRpZVwiOlwiXFx1MjlERFwiLFwiaW5vZG90XCI6XCJcXHUwMTMxXCIsXCJpbnRjYWxcIjpcIlxcdTIyQkFcIixcImludFwiOlwiXFx1MjIyQlwiLFwiSW50XCI6XCJcXHUyMjJDXCIsXCJpbnRlZ2Vyc1wiOlwiXFx1MjEyNFwiLFwiSW50ZWdyYWxcIjpcIlxcdTIyMkJcIixcImludGVyY2FsXCI6XCJcXHUyMkJBXCIsXCJJbnRlcnNlY3Rpb25cIjpcIlxcdTIyQzJcIixcImludGxhcmhrXCI6XCJcXHUyQTE3XCIsXCJpbnRwcm9kXCI6XCJcXHUyQTNDXCIsXCJJbnZpc2libGVDb21tYVwiOlwiXFx1MjA2M1wiLFwiSW52aXNpYmxlVGltZXNcIjpcIlxcdTIwNjJcIixcIklPY3lcIjpcIlxcdTA0MDFcIixcImlvY3lcIjpcIlxcdTA0NTFcIixcIklvZ29uXCI6XCJcXHUwMTJFXCIsXCJpb2dvblwiOlwiXFx1MDEyRlwiLFwiSW9wZlwiOlwiXFx1RDgzNVxcdURENDBcIixcImlvcGZcIjpcIlxcdUQ4MzVcXHVERDVBXCIsXCJJb3RhXCI6XCJcXHUwMzk5XCIsXCJpb3RhXCI6XCJcXHUwM0I5XCIsXCJpcHJvZFwiOlwiXFx1MkEzQ1wiLFwiaXF1ZXN0XCI6XCJcXHUwMEJGXCIsXCJpc2NyXCI6XCJcXHVEODM1XFx1RENCRVwiLFwiSXNjclwiOlwiXFx1MjExMFwiLFwiaXNpblwiOlwiXFx1MjIwOFwiLFwiaXNpbmRvdFwiOlwiXFx1MjJGNVwiLFwiaXNpbkVcIjpcIlxcdTIyRjlcIixcImlzaW5zXCI6XCJcXHUyMkY0XCIsXCJpc2luc3ZcIjpcIlxcdTIyRjNcIixcImlzaW52XCI6XCJcXHUyMjA4XCIsXCJpdFwiOlwiXFx1MjA2MlwiLFwiSXRpbGRlXCI6XCJcXHUwMTI4XCIsXCJpdGlsZGVcIjpcIlxcdTAxMjlcIixcIkl1a2N5XCI6XCJcXHUwNDA2XCIsXCJpdWtjeVwiOlwiXFx1MDQ1NlwiLFwiSXVtbFwiOlwiXFx1MDBDRlwiLFwiaXVtbFwiOlwiXFx1MDBFRlwiLFwiSmNpcmNcIjpcIlxcdTAxMzRcIixcImpjaXJjXCI6XCJcXHUwMTM1XCIsXCJKY3lcIjpcIlxcdTA0MTlcIixcImpjeVwiOlwiXFx1MDQzOVwiLFwiSmZyXCI6XCJcXHVEODM1XFx1REQwRFwiLFwiamZyXCI6XCJcXHVEODM1XFx1REQyN1wiLFwiam1hdGhcIjpcIlxcdTAyMzdcIixcIkpvcGZcIjpcIlxcdUQ4MzVcXHVERDQxXCIsXCJqb3BmXCI6XCJcXHVEODM1XFx1REQ1QlwiLFwiSnNjclwiOlwiXFx1RDgzNVxcdURDQTVcIixcImpzY3JcIjpcIlxcdUQ4MzVcXHVEQ0JGXCIsXCJKc2VyY3lcIjpcIlxcdTA0MDhcIixcImpzZXJjeVwiOlwiXFx1MDQ1OFwiLFwiSnVrY3lcIjpcIlxcdTA0MDRcIixcImp1a2N5XCI6XCJcXHUwNDU0XCIsXCJLYXBwYVwiOlwiXFx1MDM5QVwiLFwia2FwcGFcIjpcIlxcdTAzQkFcIixcImthcHBhdlwiOlwiXFx1MDNGMFwiLFwiS2NlZGlsXCI6XCJcXHUwMTM2XCIsXCJrY2VkaWxcIjpcIlxcdTAxMzdcIixcIktjeVwiOlwiXFx1MDQxQVwiLFwia2N5XCI6XCJcXHUwNDNBXCIsXCJLZnJcIjpcIlxcdUQ4MzVcXHVERDBFXCIsXCJrZnJcIjpcIlxcdUQ4MzVcXHVERDI4XCIsXCJrZ3JlZW5cIjpcIlxcdTAxMzhcIixcIktIY3lcIjpcIlxcdTA0MjVcIixcImtoY3lcIjpcIlxcdTA0NDVcIixcIktKY3lcIjpcIlxcdTA0MENcIixcImtqY3lcIjpcIlxcdTA0NUNcIixcIktvcGZcIjpcIlxcdUQ4MzVcXHVERDQyXCIsXCJrb3BmXCI6XCJcXHVEODM1XFx1REQ1Q1wiLFwiS3NjclwiOlwiXFx1RDgzNVxcdURDQTZcIixcImtzY3JcIjpcIlxcdUQ4MzVcXHVEQ0MwXCIsXCJsQWFyclwiOlwiXFx1MjFEQVwiLFwiTGFjdXRlXCI6XCJcXHUwMTM5XCIsXCJsYWN1dGVcIjpcIlxcdTAxM0FcIixcImxhZW1wdHl2XCI6XCJcXHUyOUI0XCIsXCJsYWdyYW5cIjpcIlxcdTIxMTJcIixcIkxhbWJkYVwiOlwiXFx1MDM5QlwiLFwibGFtYmRhXCI6XCJcXHUwM0JCXCIsXCJsYW5nXCI6XCJcXHUyN0U4XCIsXCJMYW5nXCI6XCJcXHUyN0VBXCIsXCJsYW5nZFwiOlwiXFx1Mjk5MVwiLFwibGFuZ2xlXCI6XCJcXHUyN0U4XCIsXCJsYXBcIjpcIlxcdTJBODVcIixcIkxhcGxhY2V0cmZcIjpcIlxcdTIxMTJcIixcImxhcXVvXCI6XCJcXHUwMEFCXCIsXCJsYXJyYlwiOlwiXFx1MjFFNFwiLFwibGFycmJmc1wiOlwiXFx1MjkxRlwiLFwibGFyclwiOlwiXFx1MjE5MFwiLFwiTGFyclwiOlwiXFx1MjE5RVwiLFwibEFyclwiOlwiXFx1MjFEMFwiLFwibGFycmZzXCI6XCJcXHUyOTFEXCIsXCJsYXJyaGtcIjpcIlxcdTIxQTlcIixcImxhcnJscFwiOlwiXFx1MjFBQlwiLFwibGFycnBsXCI6XCJcXHUyOTM5XCIsXCJsYXJyc2ltXCI6XCJcXHUyOTczXCIsXCJsYXJydGxcIjpcIlxcdTIxQTJcIixcImxhdGFpbFwiOlwiXFx1MjkxOVwiLFwibEF0YWlsXCI6XCJcXHUyOTFCXCIsXCJsYXRcIjpcIlxcdTJBQUJcIixcImxhdGVcIjpcIlxcdTJBQURcIixcImxhdGVzXCI6XCJcXHUyQUFEXFx1RkUwMFwiLFwibGJhcnJcIjpcIlxcdTI5MENcIixcImxCYXJyXCI6XCJcXHUyOTBFXCIsXCJsYmJya1wiOlwiXFx1Mjc3MlwiLFwibGJyYWNlXCI6XCJ7XCIsXCJsYnJhY2tcIjpcIltcIixcImxicmtlXCI6XCJcXHUyOThCXCIsXCJsYnJrc2xkXCI6XCJcXHUyOThGXCIsXCJsYnJrc2x1XCI6XCJcXHUyOThEXCIsXCJMY2Fyb25cIjpcIlxcdTAxM0RcIixcImxjYXJvblwiOlwiXFx1MDEzRVwiLFwiTGNlZGlsXCI6XCJcXHUwMTNCXCIsXCJsY2VkaWxcIjpcIlxcdTAxM0NcIixcImxjZWlsXCI6XCJcXHUyMzA4XCIsXCJsY3ViXCI6XCJ7XCIsXCJMY3lcIjpcIlxcdTA0MUJcIixcImxjeVwiOlwiXFx1MDQzQlwiLFwibGRjYVwiOlwiXFx1MjkzNlwiLFwibGRxdW9cIjpcIlxcdTIwMUNcIixcImxkcXVvclwiOlwiXFx1MjAxRVwiLFwibGRyZGhhclwiOlwiXFx1Mjk2N1wiLFwibGRydXNoYXJcIjpcIlxcdTI5NEJcIixcImxkc2hcIjpcIlxcdTIxQjJcIixcImxlXCI6XCJcXHUyMjY0XCIsXCJsRVwiOlwiXFx1MjI2NlwiLFwiTGVmdEFuZ2xlQnJhY2tldFwiOlwiXFx1MjdFOFwiLFwiTGVmdEFycm93QmFyXCI6XCJcXHUyMUU0XCIsXCJsZWZ0YXJyb3dcIjpcIlxcdTIxOTBcIixcIkxlZnRBcnJvd1wiOlwiXFx1MjE5MFwiLFwiTGVmdGFycm93XCI6XCJcXHUyMUQwXCIsXCJMZWZ0QXJyb3dSaWdodEFycm93XCI6XCJcXHUyMUM2XCIsXCJsZWZ0YXJyb3d0YWlsXCI6XCJcXHUyMUEyXCIsXCJMZWZ0Q2VpbGluZ1wiOlwiXFx1MjMwOFwiLFwiTGVmdERvdWJsZUJyYWNrZXRcIjpcIlxcdTI3RTZcIixcIkxlZnREb3duVGVlVmVjdG9yXCI6XCJcXHUyOTYxXCIsXCJMZWZ0RG93blZlY3RvckJhclwiOlwiXFx1Mjk1OVwiLFwiTGVmdERvd25WZWN0b3JcIjpcIlxcdTIxQzNcIixcIkxlZnRGbG9vclwiOlwiXFx1MjMwQVwiLFwibGVmdGhhcnBvb25kb3duXCI6XCJcXHUyMUJEXCIsXCJsZWZ0aGFycG9vbnVwXCI6XCJcXHUyMUJDXCIsXCJsZWZ0bGVmdGFycm93c1wiOlwiXFx1MjFDN1wiLFwibGVmdHJpZ2h0YXJyb3dcIjpcIlxcdTIxOTRcIixcIkxlZnRSaWdodEFycm93XCI6XCJcXHUyMTk0XCIsXCJMZWZ0cmlnaHRhcnJvd1wiOlwiXFx1MjFENFwiLFwibGVmdHJpZ2h0YXJyb3dzXCI6XCJcXHUyMUM2XCIsXCJsZWZ0cmlnaHRoYXJwb29uc1wiOlwiXFx1MjFDQlwiLFwibGVmdHJpZ2h0c3F1aWdhcnJvd1wiOlwiXFx1MjFBRFwiLFwiTGVmdFJpZ2h0VmVjdG9yXCI6XCJcXHUyOTRFXCIsXCJMZWZ0VGVlQXJyb3dcIjpcIlxcdTIxQTRcIixcIkxlZnRUZWVcIjpcIlxcdTIyQTNcIixcIkxlZnRUZWVWZWN0b3JcIjpcIlxcdTI5NUFcIixcImxlZnR0aHJlZXRpbWVzXCI6XCJcXHUyMkNCXCIsXCJMZWZ0VHJpYW5nbGVCYXJcIjpcIlxcdTI5Q0ZcIixcIkxlZnRUcmlhbmdsZVwiOlwiXFx1MjJCMlwiLFwiTGVmdFRyaWFuZ2xlRXF1YWxcIjpcIlxcdTIyQjRcIixcIkxlZnRVcERvd25WZWN0b3JcIjpcIlxcdTI5NTFcIixcIkxlZnRVcFRlZVZlY3RvclwiOlwiXFx1Mjk2MFwiLFwiTGVmdFVwVmVjdG9yQmFyXCI6XCJcXHUyOTU4XCIsXCJMZWZ0VXBWZWN0b3JcIjpcIlxcdTIxQkZcIixcIkxlZnRWZWN0b3JCYXJcIjpcIlxcdTI5NTJcIixcIkxlZnRWZWN0b3JcIjpcIlxcdTIxQkNcIixcImxFZ1wiOlwiXFx1MkE4QlwiLFwibGVnXCI6XCJcXHUyMkRBXCIsXCJsZXFcIjpcIlxcdTIyNjRcIixcImxlcXFcIjpcIlxcdTIyNjZcIixcImxlcXNsYW50XCI6XCJcXHUyQTdEXCIsXCJsZXNjY1wiOlwiXFx1MkFBOFwiLFwibGVzXCI6XCJcXHUyQTdEXCIsXCJsZXNkb3RcIjpcIlxcdTJBN0ZcIixcImxlc2RvdG9cIjpcIlxcdTJBODFcIixcImxlc2RvdG9yXCI6XCJcXHUyQTgzXCIsXCJsZXNnXCI6XCJcXHUyMkRBXFx1RkUwMFwiLFwibGVzZ2VzXCI6XCJcXHUyQTkzXCIsXCJsZXNzYXBwcm94XCI6XCJcXHUyQTg1XCIsXCJsZXNzZG90XCI6XCJcXHUyMkQ2XCIsXCJsZXNzZXFndHJcIjpcIlxcdTIyREFcIixcImxlc3NlcXFndHJcIjpcIlxcdTJBOEJcIixcIkxlc3NFcXVhbEdyZWF0ZXJcIjpcIlxcdTIyREFcIixcIkxlc3NGdWxsRXF1YWxcIjpcIlxcdTIyNjZcIixcIkxlc3NHcmVhdGVyXCI6XCJcXHUyMjc2XCIsXCJsZXNzZ3RyXCI6XCJcXHUyMjc2XCIsXCJMZXNzTGVzc1wiOlwiXFx1MkFBMVwiLFwibGVzc3NpbVwiOlwiXFx1MjI3MlwiLFwiTGVzc1NsYW50RXF1YWxcIjpcIlxcdTJBN0RcIixcIkxlc3NUaWxkZVwiOlwiXFx1MjI3MlwiLFwibGZpc2h0XCI6XCJcXHUyOTdDXCIsXCJsZmxvb3JcIjpcIlxcdTIzMEFcIixcIkxmclwiOlwiXFx1RDgzNVxcdUREMEZcIixcImxmclwiOlwiXFx1RDgzNVxcdUREMjlcIixcImxnXCI6XCJcXHUyMjc2XCIsXCJsZ0VcIjpcIlxcdTJBOTFcIixcImxIYXJcIjpcIlxcdTI5NjJcIixcImxoYXJkXCI6XCJcXHUyMUJEXCIsXCJsaGFydVwiOlwiXFx1MjFCQ1wiLFwibGhhcnVsXCI6XCJcXHUyOTZBXCIsXCJsaGJsa1wiOlwiXFx1MjU4NFwiLFwiTEpjeVwiOlwiXFx1MDQwOVwiLFwibGpjeVwiOlwiXFx1MDQ1OVwiLFwibGxhcnJcIjpcIlxcdTIxQzdcIixcImxsXCI6XCJcXHUyMjZBXCIsXCJMbFwiOlwiXFx1MjJEOFwiLFwibGxjb3JuZXJcIjpcIlxcdTIzMUVcIixcIkxsZWZ0YXJyb3dcIjpcIlxcdTIxREFcIixcImxsaGFyZFwiOlwiXFx1Mjk2QlwiLFwibGx0cmlcIjpcIlxcdTI1RkFcIixcIkxtaWRvdFwiOlwiXFx1MDEzRlwiLFwibG1pZG90XCI6XCJcXHUwMTQwXCIsXCJsbW91c3RhY2hlXCI6XCJcXHUyM0IwXCIsXCJsbW91c3RcIjpcIlxcdTIzQjBcIixcImxuYXBcIjpcIlxcdTJBODlcIixcImxuYXBwcm94XCI6XCJcXHUyQTg5XCIsXCJsbmVcIjpcIlxcdTJBODdcIixcImxuRVwiOlwiXFx1MjI2OFwiLFwibG5lcVwiOlwiXFx1MkE4N1wiLFwibG5lcXFcIjpcIlxcdTIyNjhcIixcImxuc2ltXCI6XCJcXHUyMkU2XCIsXCJsb2FuZ1wiOlwiXFx1MjdFQ1wiLFwibG9hcnJcIjpcIlxcdTIxRkRcIixcImxvYnJrXCI6XCJcXHUyN0U2XCIsXCJsb25nbGVmdGFycm93XCI6XCJcXHUyN0Y1XCIsXCJMb25nTGVmdEFycm93XCI6XCJcXHUyN0Y1XCIsXCJMb25nbGVmdGFycm93XCI6XCJcXHUyN0Y4XCIsXCJsb25nbGVmdHJpZ2h0YXJyb3dcIjpcIlxcdTI3RjdcIixcIkxvbmdMZWZ0UmlnaHRBcnJvd1wiOlwiXFx1MjdGN1wiLFwiTG9uZ2xlZnRyaWdodGFycm93XCI6XCJcXHUyN0ZBXCIsXCJsb25nbWFwc3RvXCI6XCJcXHUyN0ZDXCIsXCJsb25ncmlnaHRhcnJvd1wiOlwiXFx1MjdGNlwiLFwiTG9uZ1JpZ2h0QXJyb3dcIjpcIlxcdTI3RjZcIixcIkxvbmdyaWdodGFycm93XCI6XCJcXHUyN0Y5XCIsXCJsb29wYXJyb3dsZWZ0XCI6XCJcXHUyMUFCXCIsXCJsb29wYXJyb3dyaWdodFwiOlwiXFx1MjFBQ1wiLFwibG9wYXJcIjpcIlxcdTI5ODVcIixcIkxvcGZcIjpcIlxcdUQ4MzVcXHVERDQzXCIsXCJsb3BmXCI6XCJcXHVEODM1XFx1REQ1RFwiLFwibG9wbHVzXCI6XCJcXHUyQTJEXCIsXCJsb3RpbWVzXCI6XCJcXHUyQTM0XCIsXCJsb3dhc3RcIjpcIlxcdTIyMTdcIixcImxvd2JhclwiOlwiX1wiLFwiTG93ZXJMZWZ0QXJyb3dcIjpcIlxcdTIxOTlcIixcIkxvd2VyUmlnaHRBcnJvd1wiOlwiXFx1MjE5OFwiLFwibG96XCI6XCJcXHUyNUNBXCIsXCJsb3plbmdlXCI6XCJcXHUyNUNBXCIsXCJsb3pmXCI6XCJcXHUyOUVCXCIsXCJscGFyXCI6XCIoXCIsXCJscGFybHRcIjpcIlxcdTI5OTNcIixcImxyYXJyXCI6XCJcXHUyMUM2XCIsXCJscmNvcm5lclwiOlwiXFx1MjMxRlwiLFwibHJoYXJcIjpcIlxcdTIxQ0JcIixcImxyaGFyZFwiOlwiXFx1Mjk2RFwiLFwibHJtXCI6XCJcXHUyMDBFXCIsXCJscnRyaVwiOlwiXFx1MjJCRlwiLFwibHNhcXVvXCI6XCJcXHUyMDM5XCIsXCJsc2NyXCI6XCJcXHVEODM1XFx1RENDMVwiLFwiTHNjclwiOlwiXFx1MjExMlwiLFwibHNoXCI6XCJcXHUyMUIwXCIsXCJMc2hcIjpcIlxcdTIxQjBcIixcImxzaW1cIjpcIlxcdTIyNzJcIixcImxzaW1lXCI6XCJcXHUyQThEXCIsXCJsc2ltZ1wiOlwiXFx1MkE4RlwiLFwibHNxYlwiOlwiW1wiLFwibHNxdW9cIjpcIlxcdTIwMThcIixcImxzcXVvclwiOlwiXFx1MjAxQVwiLFwiTHN0cm9rXCI6XCJcXHUwMTQxXCIsXCJsc3Ryb2tcIjpcIlxcdTAxNDJcIixcImx0Y2NcIjpcIlxcdTJBQTZcIixcImx0Y2lyXCI6XCJcXHUyQTc5XCIsXCJsdFwiOlwiPFwiLFwiTFRcIjpcIjxcIixcIkx0XCI6XCJcXHUyMjZBXCIsXCJsdGRvdFwiOlwiXFx1MjJENlwiLFwibHRocmVlXCI6XCJcXHUyMkNCXCIsXCJsdGltZXNcIjpcIlxcdTIyQzlcIixcImx0bGFyclwiOlwiXFx1Mjk3NlwiLFwibHRxdWVzdFwiOlwiXFx1MkE3QlwiLFwibHRyaVwiOlwiXFx1MjVDM1wiLFwibHRyaWVcIjpcIlxcdTIyQjRcIixcImx0cmlmXCI6XCJcXHUyNUMyXCIsXCJsdHJQYXJcIjpcIlxcdTI5OTZcIixcImx1cmRzaGFyXCI6XCJcXHUyOTRBXCIsXCJsdXJ1aGFyXCI6XCJcXHUyOTY2XCIsXCJsdmVydG5lcXFcIjpcIlxcdTIyNjhcXHVGRTAwXCIsXCJsdm5FXCI6XCJcXHUyMjY4XFx1RkUwMFwiLFwibWFjclwiOlwiXFx1MDBBRlwiLFwibWFsZVwiOlwiXFx1MjY0MlwiLFwibWFsdFwiOlwiXFx1MjcyMFwiLFwibWFsdGVzZVwiOlwiXFx1MjcyMFwiLFwiTWFwXCI6XCJcXHUyOTA1XCIsXCJtYXBcIjpcIlxcdTIxQTZcIixcIm1hcHN0b1wiOlwiXFx1MjFBNlwiLFwibWFwc3RvZG93blwiOlwiXFx1MjFBN1wiLFwibWFwc3RvbGVmdFwiOlwiXFx1MjFBNFwiLFwibWFwc3RvdXBcIjpcIlxcdTIxQTVcIixcIm1hcmtlclwiOlwiXFx1MjVBRVwiLFwibWNvbW1hXCI6XCJcXHUyQTI5XCIsXCJNY3lcIjpcIlxcdTA0MUNcIixcIm1jeVwiOlwiXFx1MDQzQ1wiLFwibWRhc2hcIjpcIlxcdTIwMTRcIixcIm1ERG90XCI6XCJcXHUyMjNBXCIsXCJtZWFzdXJlZGFuZ2xlXCI6XCJcXHUyMjIxXCIsXCJNZWRpdW1TcGFjZVwiOlwiXFx1MjA1RlwiLFwiTWVsbGludHJmXCI6XCJcXHUyMTMzXCIsXCJNZnJcIjpcIlxcdUQ4MzVcXHVERDEwXCIsXCJtZnJcIjpcIlxcdUQ4MzVcXHVERDJBXCIsXCJtaG9cIjpcIlxcdTIxMjdcIixcIm1pY3JvXCI6XCJcXHUwMEI1XCIsXCJtaWRhc3RcIjpcIipcIixcIm1pZGNpclwiOlwiXFx1MkFGMFwiLFwibWlkXCI6XCJcXHUyMjIzXCIsXCJtaWRkb3RcIjpcIlxcdTAwQjdcIixcIm1pbnVzYlwiOlwiXFx1MjI5RlwiLFwibWludXNcIjpcIlxcdTIyMTJcIixcIm1pbnVzZFwiOlwiXFx1MjIzOFwiLFwibWludXNkdVwiOlwiXFx1MkEyQVwiLFwiTWludXNQbHVzXCI6XCJcXHUyMjEzXCIsXCJtbGNwXCI6XCJcXHUyQURCXCIsXCJtbGRyXCI6XCJcXHUyMDI2XCIsXCJtbnBsdXNcIjpcIlxcdTIyMTNcIixcIm1vZGVsc1wiOlwiXFx1MjJBN1wiLFwiTW9wZlwiOlwiXFx1RDgzNVxcdURENDRcIixcIm1vcGZcIjpcIlxcdUQ4MzVcXHVERDVFXCIsXCJtcFwiOlwiXFx1MjIxM1wiLFwibXNjclwiOlwiXFx1RDgzNVxcdURDQzJcIixcIk1zY3JcIjpcIlxcdTIxMzNcIixcIm1zdHBvc1wiOlwiXFx1MjIzRVwiLFwiTXVcIjpcIlxcdTAzOUNcIixcIm11XCI6XCJcXHUwM0JDXCIsXCJtdWx0aW1hcFwiOlwiXFx1MjJCOFwiLFwibXVtYXBcIjpcIlxcdTIyQjhcIixcIm5hYmxhXCI6XCJcXHUyMjA3XCIsXCJOYWN1dGVcIjpcIlxcdTAxNDNcIixcIm5hY3V0ZVwiOlwiXFx1MDE0NFwiLFwibmFuZ1wiOlwiXFx1MjIyMFxcdTIwRDJcIixcIm5hcFwiOlwiXFx1MjI0OVwiLFwibmFwRVwiOlwiXFx1MkE3MFxcdTAzMzhcIixcIm5hcGlkXCI6XCJcXHUyMjRCXFx1MDMzOFwiLFwibmFwb3NcIjpcIlxcdTAxNDlcIixcIm5hcHByb3hcIjpcIlxcdTIyNDlcIixcIm5hdHVyYWxcIjpcIlxcdTI2NkVcIixcIm5hdHVyYWxzXCI6XCJcXHUyMTE1XCIsXCJuYXR1clwiOlwiXFx1MjY2RVwiLFwibmJzcFwiOlwiXFx1MDBBMFwiLFwibmJ1bXBcIjpcIlxcdTIyNEVcXHUwMzM4XCIsXCJuYnVtcGVcIjpcIlxcdTIyNEZcXHUwMzM4XCIsXCJuY2FwXCI6XCJcXHUyQTQzXCIsXCJOY2Fyb25cIjpcIlxcdTAxNDdcIixcIm5jYXJvblwiOlwiXFx1MDE0OFwiLFwiTmNlZGlsXCI6XCJcXHUwMTQ1XCIsXCJuY2VkaWxcIjpcIlxcdTAxNDZcIixcIm5jb25nXCI6XCJcXHUyMjQ3XCIsXCJuY29uZ2RvdFwiOlwiXFx1MkE2RFxcdTAzMzhcIixcIm5jdXBcIjpcIlxcdTJBNDJcIixcIk5jeVwiOlwiXFx1MDQxRFwiLFwibmN5XCI6XCJcXHUwNDNEXCIsXCJuZGFzaFwiOlwiXFx1MjAxM1wiLFwibmVhcmhrXCI6XCJcXHUyOTI0XCIsXCJuZWFyclwiOlwiXFx1MjE5N1wiLFwibmVBcnJcIjpcIlxcdTIxRDdcIixcIm5lYXJyb3dcIjpcIlxcdTIxOTdcIixcIm5lXCI6XCJcXHUyMjYwXCIsXCJuZWRvdFwiOlwiXFx1MjI1MFxcdTAzMzhcIixcIk5lZ2F0aXZlTWVkaXVtU3BhY2VcIjpcIlxcdTIwMEJcIixcIk5lZ2F0aXZlVGhpY2tTcGFjZVwiOlwiXFx1MjAwQlwiLFwiTmVnYXRpdmVUaGluU3BhY2VcIjpcIlxcdTIwMEJcIixcIk5lZ2F0aXZlVmVyeVRoaW5TcGFjZVwiOlwiXFx1MjAwQlwiLFwibmVxdWl2XCI6XCJcXHUyMjYyXCIsXCJuZXNlYXJcIjpcIlxcdTI5MjhcIixcIm5lc2ltXCI6XCJcXHUyMjQyXFx1MDMzOFwiLFwiTmVzdGVkR3JlYXRlckdyZWF0ZXJcIjpcIlxcdTIyNkJcIixcIk5lc3RlZExlc3NMZXNzXCI6XCJcXHUyMjZBXCIsXCJOZXdMaW5lXCI6XCJcXG5cIixcIm5leGlzdFwiOlwiXFx1MjIwNFwiLFwibmV4aXN0c1wiOlwiXFx1MjIwNFwiLFwiTmZyXCI6XCJcXHVEODM1XFx1REQxMVwiLFwibmZyXCI6XCJcXHVEODM1XFx1REQyQlwiLFwibmdFXCI6XCJcXHUyMjY3XFx1MDMzOFwiLFwibmdlXCI6XCJcXHUyMjcxXCIsXCJuZ2VxXCI6XCJcXHUyMjcxXCIsXCJuZ2VxcVwiOlwiXFx1MjI2N1xcdTAzMzhcIixcIm5nZXFzbGFudFwiOlwiXFx1MkE3RVxcdTAzMzhcIixcIm5nZXNcIjpcIlxcdTJBN0VcXHUwMzM4XCIsXCJuR2dcIjpcIlxcdTIyRDlcXHUwMzM4XCIsXCJuZ3NpbVwiOlwiXFx1MjI3NVwiLFwibkd0XCI6XCJcXHUyMjZCXFx1MjBEMlwiLFwibmd0XCI6XCJcXHUyMjZGXCIsXCJuZ3RyXCI6XCJcXHUyMjZGXCIsXCJuR3R2XCI6XCJcXHUyMjZCXFx1MDMzOFwiLFwibmhhcnJcIjpcIlxcdTIxQUVcIixcIm5oQXJyXCI6XCJcXHUyMUNFXCIsXCJuaHBhclwiOlwiXFx1MkFGMlwiLFwibmlcIjpcIlxcdTIyMEJcIixcIm5pc1wiOlwiXFx1MjJGQ1wiLFwibmlzZFwiOlwiXFx1MjJGQVwiLFwibml2XCI6XCJcXHUyMjBCXCIsXCJOSmN5XCI6XCJcXHUwNDBBXCIsXCJuamN5XCI6XCJcXHUwNDVBXCIsXCJubGFyclwiOlwiXFx1MjE5QVwiLFwibmxBcnJcIjpcIlxcdTIxQ0RcIixcIm5sZHJcIjpcIlxcdTIwMjVcIixcIm5sRVwiOlwiXFx1MjI2NlxcdTAzMzhcIixcIm5sZVwiOlwiXFx1MjI3MFwiLFwibmxlZnRhcnJvd1wiOlwiXFx1MjE5QVwiLFwibkxlZnRhcnJvd1wiOlwiXFx1MjFDRFwiLFwibmxlZnRyaWdodGFycm93XCI6XCJcXHUyMUFFXCIsXCJuTGVmdHJpZ2h0YXJyb3dcIjpcIlxcdTIxQ0VcIixcIm5sZXFcIjpcIlxcdTIyNzBcIixcIm5sZXFxXCI6XCJcXHUyMjY2XFx1MDMzOFwiLFwibmxlcXNsYW50XCI6XCJcXHUyQTdEXFx1MDMzOFwiLFwibmxlc1wiOlwiXFx1MkE3RFxcdTAzMzhcIixcIm5sZXNzXCI6XCJcXHUyMjZFXCIsXCJuTGxcIjpcIlxcdTIyRDhcXHUwMzM4XCIsXCJubHNpbVwiOlwiXFx1MjI3NFwiLFwibkx0XCI6XCJcXHUyMjZBXFx1MjBEMlwiLFwibmx0XCI6XCJcXHUyMjZFXCIsXCJubHRyaVwiOlwiXFx1MjJFQVwiLFwibmx0cmllXCI6XCJcXHUyMkVDXCIsXCJuTHR2XCI6XCJcXHUyMjZBXFx1MDMzOFwiLFwibm1pZFwiOlwiXFx1MjIyNFwiLFwiTm9CcmVha1wiOlwiXFx1MjA2MFwiLFwiTm9uQnJlYWtpbmdTcGFjZVwiOlwiXFx1MDBBMFwiLFwibm9wZlwiOlwiXFx1RDgzNVxcdURENUZcIixcIk5vcGZcIjpcIlxcdTIxMTVcIixcIk5vdFwiOlwiXFx1MkFFQ1wiLFwibm90XCI6XCJcXHUwMEFDXCIsXCJOb3RDb25ncnVlbnRcIjpcIlxcdTIyNjJcIixcIk5vdEN1cENhcFwiOlwiXFx1MjI2RFwiLFwiTm90RG91YmxlVmVydGljYWxCYXJcIjpcIlxcdTIyMjZcIixcIk5vdEVsZW1lbnRcIjpcIlxcdTIyMDlcIixcIk5vdEVxdWFsXCI6XCJcXHUyMjYwXCIsXCJOb3RFcXVhbFRpbGRlXCI6XCJcXHUyMjQyXFx1MDMzOFwiLFwiTm90RXhpc3RzXCI6XCJcXHUyMjA0XCIsXCJOb3RHcmVhdGVyXCI6XCJcXHUyMjZGXCIsXCJOb3RHcmVhdGVyRXF1YWxcIjpcIlxcdTIyNzFcIixcIk5vdEdyZWF0ZXJGdWxsRXF1YWxcIjpcIlxcdTIyNjdcXHUwMzM4XCIsXCJOb3RHcmVhdGVyR3JlYXRlclwiOlwiXFx1MjI2QlxcdTAzMzhcIixcIk5vdEdyZWF0ZXJMZXNzXCI6XCJcXHUyMjc5XCIsXCJOb3RHcmVhdGVyU2xhbnRFcXVhbFwiOlwiXFx1MkE3RVxcdTAzMzhcIixcIk5vdEdyZWF0ZXJUaWxkZVwiOlwiXFx1MjI3NVwiLFwiTm90SHVtcERvd25IdW1wXCI6XCJcXHUyMjRFXFx1MDMzOFwiLFwiTm90SHVtcEVxdWFsXCI6XCJcXHUyMjRGXFx1MDMzOFwiLFwibm90aW5cIjpcIlxcdTIyMDlcIixcIm5vdGluZG90XCI6XCJcXHUyMkY1XFx1MDMzOFwiLFwibm90aW5FXCI6XCJcXHUyMkY5XFx1MDMzOFwiLFwibm90aW52YVwiOlwiXFx1MjIwOVwiLFwibm90aW52YlwiOlwiXFx1MjJGN1wiLFwibm90aW52Y1wiOlwiXFx1MjJGNlwiLFwiTm90TGVmdFRyaWFuZ2xlQmFyXCI6XCJcXHUyOUNGXFx1MDMzOFwiLFwiTm90TGVmdFRyaWFuZ2xlXCI6XCJcXHUyMkVBXCIsXCJOb3RMZWZ0VHJpYW5nbGVFcXVhbFwiOlwiXFx1MjJFQ1wiLFwiTm90TGVzc1wiOlwiXFx1MjI2RVwiLFwiTm90TGVzc0VxdWFsXCI6XCJcXHUyMjcwXCIsXCJOb3RMZXNzR3JlYXRlclwiOlwiXFx1MjI3OFwiLFwiTm90TGVzc0xlc3NcIjpcIlxcdTIyNkFcXHUwMzM4XCIsXCJOb3RMZXNzU2xhbnRFcXVhbFwiOlwiXFx1MkE3RFxcdTAzMzhcIixcIk5vdExlc3NUaWxkZVwiOlwiXFx1MjI3NFwiLFwiTm90TmVzdGVkR3JlYXRlckdyZWF0ZXJcIjpcIlxcdTJBQTJcXHUwMzM4XCIsXCJOb3ROZXN0ZWRMZXNzTGVzc1wiOlwiXFx1MkFBMVxcdTAzMzhcIixcIm5vdG5pXCI6XCJcXHUyMjBDXCIsXCJub3RuaXZhXCI6XCJcXHUyMjBDXCIsXCJub3RuaXZiXCI6XCJcXHUyMkZFXCIsXCJub3RuaXZjXCI6XCJcXHUyMkZEXCIsXCJOb3RQcmVjZWRlc1wiOlwiXFx1MjI4MFwiLFwiTm90UHJlY2VkZXNFcXVhbFwiOlwiXFx1MkFBRlxcdTAzMzhcIixcIk5vdFByZWNlZGVzU2xhbnRFcXVhbFwiOlwiXFx1MjJFMFwiLFwiTm90UmV2ZXJzZUVsZW1lbnRcIjpcIlxcdTIyMENcIixcIk5vdFJpZ2h0VHJpYW5nbGVCYXJcIjpcIlxcdTI5RDBcXHUwMzM4XCIsXCJOb3RSaWdodFRyaWFuZ2xlXCI6XCJcXHUyMkVCXCIsXCJOb3RSaWdodFRyaWFuZ2xlRXF1YWxcIjpcIlxcdTIyRURcIixcIk5vdFNxdWFyZVN1YnNldFwiOlwiXFx1MjI4RlxcdTAzMzhcIixcIk5vdFNxdWFyZVN1YnNldEVxdWFsXCI6XCJcXHUyMkUyXCIsXCJOb3RTcXVhcmVTdXBlcnNldFwiOlwiXFx1MjI5MFxcdTAzMzhcIixcIk5vdFNxdWFyZVN1cGVyc2V0RXF1YWxcIjpcIlxcdTIyRTNcIixcIk5vdFN1YnNldFwiOlwiXFx1MjI4MlxcdTIwRDJcIixcIk5vdFN1YnNldEVxdWFsXCI6XCJcXHUyMjg4XCIsXCJOb3RTdWNjZWVkc1wiOlwiXFx1MjI4MVwiLFwiTm90U3VjY2VlZHNFcXVhbFwiOlwiXFx1MkFCMFxcdTAzMzhcIixcIk5vdFN1Y2NlZWRzU2xhbnRFcXVhbFwiOlwiXFx1MjJFMVwiLFwiTm90U3VjY2VlZHNUaWxkZVwiOlwiXFx1MjI3RlxcdTAzMzhcIixcIk5vdFN1cGVyc2V0XCI6XCJcXHUyMjgzXFx1MjBEMlwiLFwiTm90U3VwZXJzZXRFcXVhbFwiOlwiXFx1MjI4OVwiLFwiTm90VGlsZGVcIjpcIlxcdTIyNDFcIixcIk5vdFRpbGRlRXF1YWxcIjpcIlxcdTIyNDRcIixcIk5vdFRpbGRlRnVsbEVxdWFsXCI6XCJcXHUyMjQ3XCIsXCJOb3RUaWxkZVRpbGRlXCI6XCJcXHUyMjQ5XCIsXCJOb3RWZXJ0aWNhbEJhclwiOlwiXFx1MjIyNFwiLFwibnBhcmFsbGVsXCI6XCJcXHUyMjI2XCIsXCJucGFyXCI6XCJcXHUyMjI2XCIsXCJucGFyc2xcIjpcIlxcdTJBRkRcXHUyMEU1XCIsXCJucGFydFwiOlwiXFx1MjIwMlxcdTAzMzhcIixcIm5wb2xpbnRcIjpcIlxcdTJBMTRcIixcIm5wclwiOlwiXFx1MjI4MFwiLFwibnByY3VlXCI6XCJcXHUyMkUwXCIsXCJucHJlY1wiOlwiXFx1MjI4MFwiLFwibnByZWNlcVwiOlwiXFx1MkFBRlxcdTAzMzhcIixcIm5wcmVcIjpcIlxcdTJBQUZcXHUwMzM4XCIsXCJucmFycmNcIjpcIlxcdTI5MzNcXHUwMzM4XCIsXCJucmFyclwiOlwiXFx1MjE5QlwiLFwibnJBcnJcIjpcIlxcdTIxQ0ZcIixcIm5yYXJyd1wiOlwiXFx1MjE5RFxcdTAzMzhcIixcIm5yaWdodGFycm93XCI6XCJcXHUyMTlCXCIsXCJuUmlnaHRhcnJvd1wiOlwiXFx1MjFDRlwiLFwibnJ0cmlcIjpcIlxcdTIyRUJcIixcIm5ydHJpZVwiOlwiXFx1MjJFRFwiLFwibnNjXCI6XCJcXHUyMjgxXCIsXCJuc2NjdWVcIjpcIlxcdTIyRTFcIixcIm5zY2VcIjpcIlxcdTJBQjBcXHUwMzM4XCIsXCJOc2NyXCI6XCJcXHVEODM1XFx1RENBOVwiLFwibnNjclwiOlwiXFx1RDgzNVxcdURDQzNcIixcIm5zaG9ydG1pZFwiOlwiXFx1MjIyNFwiLFwibnNob3J0cGFyYWxsZWxcIjpcIlxcdTIyMjZcIixcIm5zaW1cIjpcIlxcdTIyNDFcIixcIm5zaW1lXCI6XCJcXHUyMjQ0XCIsXCJuc2ltZXFcIjpcIlxcdTIyNDRcIixcIm5zbWlkXCI6XCJcXHUyMjI0XCIsXCJuc3BhclwiOlwiXFx1MjIyNlwiLFwibnNxc3ViZVwiOlwiXFx1MjJFMlwiLFwibnNxc3VwZVwiOlwiXFx1MjJFM1wiLFwibnN1YlwiOlwiXFx1MjI4NFwiLFwibnN1YkVcIjpcIlxcdTJBQzVcXHUwMzM4XCIsXCJuc3ViZVwiOlwiXFx1MjI4OFwiLFwibnN1YnNldFwiOlwiXFx1MjI4MlxcdTIwRDJcIixcIm5zdWJzZXRlcVwiOlwiXFx1MjI4OFwiLFwibnN1YnNldGVxcVwiOlwiXFx1MkFDNVxcdTAzMzhcIixcIm5zdWNjXCI6XCJcXHUyMjgxXCIsXCJuc3VjY2VxXCI6XCJcXHUyQUIwXFx1MDMzOFwiLFwibnN1cFwiOlwiXFx1MjI4NVwiLFwibnN1cEVcIjpcIlxcdTJBQzZcXHUwMzM4XCIsXCJuc3VwZVwiOlwiXFx1MjI4OVwiLFwibnN1cHNldFwiOlwiXFx1MjI4M1xcdTIwRDJcIixcIm5zdXBzZXRlcVwiOlwiXFx1MjI4OVwiLFwibnN1cHNldGVxcVwiOlwiXFx1MkFDNlxcdTAzMzhcIixcIm50Z2xcIjpcIlxcdTIyNzlcIixcIk50aWxkZVwiOlwiXFx1MDBEMVwiLFwibnRpbGRlXCI6XCJcXHUwMEYxXCIsXCJudGxnXCI6XCJcXHUyMjc4XCIsXCJudHJpYW5nbGVsZWZ0XCI6XCJcXHUyMkVBXCIsXCJudHJpYW5nbGVsZWZ0ZXFcIjpcIlxcdTIyRUNcIixcIm50cmlhbmdsZXJpZ2h0XCI6XCJcXHUyMkVCXCIsXCJudHJpYW5nbGVyaWdodGVxXCI6XCJcXHUyMkVEXCIsXCJOdVwiOlwiXFx1MDM5RFwiLFwibnVcIjpcIlxcdTAzQkRcIixcIm51bVwiOlwiI1wiLFwibnVtZXJvXCI6XCJcXHUyMTE2XCIsXCJudW1zcFwiOlwiXFx1MjAwN1wiLFwibnZhcFwiOlwiXFx1MjI0RFxcdTIwRDJcIixcIm52ZGFzaFwiOlwiXFx1MjJBQ1wiLFwibnZEYXNoXCI6XCJcXHUyMkFEXCIsXCJuVmRhc2hcIjpcIlxcdTIyQUVcIixcIm5WRGFzaFwiOlwiXFx1MjJBRlwiLFwibnZnZVwiOlwiXFx1MjI2NVxcdTIwRDJcIixcIm52Z3RcIjpcIj5cXHUyMEQyXCIsXCJudkhhcnJcIjpcIlxcdTI5MDRcIixcIm52aW5maW5cIjpcIlxcdTI5REVcIixcIm52bEFyclwiOlwiXFx1MjkwMlwiLFwibnZsZVwiOlwiXFx1MjI2NFxcdTIwRDJcIixcIm52bHRcIjpcIjxcXHUyMEQyXCIsXCJudmx0cmllXCI6XCJcXHUyMkI0XFx1MjBEMlwiLFwibnZyQXJyXCI6XCJcXHUyOTAzXCIsXCJudnJ0cmllXCI6XCJcXHUyMkI1XFx1MjBEMlwiLFwibnZzaW1cIjpcIlxcdTIyM0NcXHUyMEQyXCIsXCJud2FyaGtcIjpcIlxcdTI5MjNcIixcIm53YXJyXCI6XCJcXHUyMTk2XCIsXCJud0FyclwiOlwiXFx1MjFENlwiLFwibndhcnJvd1wiOlwiXFx1MjE5NlwiLFwibnduZWFyXCI6XCJcXHUyOTI3XCIsXCJPYWN1dGVcIjpcIlxcdTAwRDNcIixcIm9hY3V0ZVwiOlwiXFx1MDBGM1wiLFwib2FzdFwiOlwiXFx1MjI5QlwiLFwiT2NpcmNcIjpcIlxcdTAwRDRcIixcIm9jaXJjXCI6XCJcXHUwMEY0XCIsXCJvY2lyXCI6XCJcXHUyMjlBXCIsXCJPY3lcIjpcIlxcdTA0MUVcIixcIm9jeVwiOlwiXFx1MDQzRVwiLFwib2Rhc2hcIjpcIlxcdTIyOURcIixcIk9kYmxhY1wiOlwiXFx1MDE1MFwiLFwib2RibGFjXCI6XCJcXHUwMTUxXCIsXCJvZGl2XCI6XCJcXHUyQTM4XCIsXCJvZG90XCI6XCJcXHUyMjk5XCIsXCJvZHNvbGRcIjpcIlxcdTI5QkNcIixcIk9FbGlnXCI6XCJcXHUwMTUyXCIsXCJvZWxpZ1wiOlwiXFx1MDE1M1wiLFwib2ZjaXJcIjpcIlxcdTI5QkZcIixcIk9mclwiOlwiXFx1RDgzNVxcdUREMTJcIixcIm9mclwiOlwiXFx1RDgzNVxcdUREMkNcIixcIm9nb25cIjpcIlxcdTAyREJcIixcIk9ncmF2ZVwiOlwiXFx1MDBEMlwiLFwib2dyYXZlXCI6XCJcXHUwMEYyXCIsXCJvZ3RcIjpcIlxcdTI5QzFcIixcIm9oYmFyXCI6XCJcXHUyOUI1XCIsXCJvaG1cIjpcIlxcdTAzQTlcIixcIm9pbnRcIjpcIlxcdTIyMkVcIixcIm9sYXJyXCI6XCJcXHUyMUJBXCIsXCJvbGNpclwiOlwiXFx1MjlCRVwiLFwib2xjcm9zc1wiOlwiXFx1MjlCQlwiLFwib2xpbmVcIjpcIlxcdTIwM0VcIixcIm9sdFwiOlwiXFx1MjlDMFwiLFwiT21hY3JcIjpcIlxcdTAxNENcIixcIm9tYWNyXCI6XCJcXHUwMTREXCIsXCJPbWVnYVwiOlwiXFx1MDNBOVwiLFwib21lZ2FcIjpcIlxcdTAzQzlcIixcIk9taWNyb25cIjpcIlxcdTAzOUZcIixcIm9taWNyb25cIjpcIlxcdTAzQkZcIixcIm9taWRcIjpcIlxcdTI5QjZcIixcIm9taW51c1wiOlwiXFx1MjI5NlwiLFwiT29wZlwiOlwiXFx1RDgzNVxcdURENDZcIixcIm9vcGZcIjpcIlxcdUQ4MzVcXHVERDYwXCIsXCJvcGFyXCI6XCJcXHUyOUI3XCIsXCJPcGVuQ3VybHlEb3VibGVRdW90ZVwiOlwiXFx1MjAxQ1wiLFwiT3BlbkN1cmx5UXVvdGVcIjpcIlxcdTIwMThcIixcIm9wZXJwXCI6XCJcXHUyOUI5XCIsXCJvcGx1c1wiOlwiXFx1MjI5NVwiLFwib3JhcnJcIjpcIlxcdTIxQkJcIixcIk9yXCI6XCJcXHUyQTU0XCIsXCJvclwiOlwiXFx1MjIyOFwiLFwib3JkXCI6XCJcXHUyQTVEXCIsXCJvcmRlclwiOlwiXFx1MjEzNFwiLFwib3JkZXJvZlwiOlwiXFx1MjEzNFwiLFwib3JkZlwiOlwiXFx1MDBBQVwiLFwib3JkbVwiOlwiXFx1MDBCQVwiLFwib3JpZ29mXCI6XCJcXHUyMkI2XCIsXCJvcm9yXCI6XCJcXHUyQTU2XCIsXCJvcnNsb3BlXCI6XCJcXHUyQTU3XCIsXCJvcnZcIjpcIlxcdTJBNUJcIixcIm9TXCI6XCJcXHUyNEM4XCIsXCJPc2NyXCI6XCJcXHVEODM1XFx1RENBQVwiLFwib3NjclwiOlwiXFx1MjEzNFwiLFwiT3NsYXNoXCI6XCJcXHUwMEQ4XCIsXCJvc2xhc2hcIjpcIlxcdTAwRjhcIixcIm9zb2xcIjpcIlxcdTIyOThcIixcIk90aWxkZVwiOlwiXFx1MDBENVwiLFwib3RpbGRlXCI6XCJcXHUwMEY1XCIsXCJvdGltZXNhc1wiOlwiXFx1MkEzNlwiLFwiT3RpbWVzXCI6XCJcXHUyQTM3XCIsXCJvdGltZXNcIjpcIlxcdTIyOTdcIixcIk91bWxcIjpcIlxcdTAwRDZcIixcIm91bWxcIjpcIlxcdTAwRjZcIixcIm92YmFyXCI6XCJcXHUyMzNEXCIsXCJPdmVyQmFyXCI6XCJcXHUyMDNFXCIsXCJPdmVyQnJhY2VcIjpcIlxcdTIzREVcIixcIk92ZXJCcmFja2V0XCI6XCJcXHUyM0I0XCIsXCJPdmVyUGFyZW50aGVzaXNcIjpcIlxcdTIzRENcIixcInBhcmFcIjpcIlxcdTAwQjZcIixcInBhcmFsbGVsXCI6XCJcXHUyMjI1XCIsXCJwYXJcIjpcIlxcdTIyMjVcIixcInBhcnNpbVwiOlwiXFx1MkFGM1wiLFwicGFyc2xcIjpcIlxcdTJBRkRcIixcInBhcnRcIjpcIlxcdTIyMDJcIixcIlBhcnRpYWxEXCI6XCJcXHUyMjAyXCIsXCJQY3lcIjpcIlxcdTA0MUZcIixcInBjeVwiOlwiXFx1MDQzRlwiLFwicGVyY250XCI6XCIlXCIsXCJwZXJpb2RcIjpcIi5cIixcInBlcm1pbFwiOlwiXFx1MjAzMFwiLFwicGVycFwiOlwiXFx1MjJBNVwiLFwicGVydGVua1wiOlwiXFx1MjAzMVwiLFwiUGZyXCI6XCJcXHVEODM1XFx1REQxM1wiLFwicGZyXCI6XCJcXHVEODM1XFx1REQyRFwiLFwiUGhpXCI6XCJcXHUwM0E2XCIsXCJwaGlcIjpcIlxcdTAzQzZcIixcInBoaXZcIjpcIlxcdTAzRDVcIixcInBobW1hdFwiOlwiXFx1MjEzM1wiLFwicGhvbmVcIjpcIlxcdTI2MEVcIixcIlBpXCI6XCJcXHUwM0EwXCIsXCJwaVwiOlwiXFx1MDNDMFwiLFwicGl0Y2hmb3JrXCI6XCJcXHUyMkQ0XCIsXCJwaXZcIjpcIlxcdTAzRDZcIixcInBsYW5ja1wiOlwiXFx1MjEwRlwiLFwicGxhbmNraFwiOlwiXFx1MjEwRVwiLFwicGxhbmt2XCI6XCJcXHUyMTBGXCIsXCJwbHVzYWNpclwiOlwiXFx1MkEyM1wiLFwicGx1c2JcIjpcIlxcdTIyOUVcIixcInBsdXNjaXJcIjpcIlxcdTJBMjJcIixcInBsdXNcIjpcIitcIixcInBsdXNkb1wiOlwiXFx1MjIxNFwiLFwicGx1c2R1XCI6XCJcXHUyQTI1XCIsXCJwbHVzZVwiOlwiXFx1MkE3MlwiLFwiUGx1c01pbnVzXCI6XCJcXHUwMEIxXCIsXCJwbHVzbW5cIjpcIlxcdTAwQjFcIixcInBsdXNzaW1cIjpcIlxcdTJBMjZcIixcInBsdXN0d29cIjpcIlxcdTJBMjdcIixcInBtXCI6XCJcXHUwMEIxXCIsXCJQb2luY2FyZXBsYW5lXCI6XCJcXHUyMTBDXCIsXCJwb2ludGludFwiOlwiXFx1MkExNVwiLFwicG9wZlwiOlwiXFx1RDgzNVxcdURENjFcIixcIlBvcGZcIjpcIlxcdTIxMTlcIixcInBvdW5kXCI6XCJcXHUwMEEzXCIsXCJwcmFwXCI6XCJcXHUyQUI3XCIsXCJQclwiOlwiXFx1MkFCQlwiLFwicHJcIjpcIlxcdTIyN0FcIixcInByY3VlXCI6XCJcXHUyMjdDXCIsXCJwcmVjYXBwcm94XCI6XCJcXHUyQUI3XCIsXCJwcmVjXCI6XCJcXHUyMjdBXCIsXCJwcmVjY3VybHllcVwiOlwiXFx1MjI3Q1wiLFwiUHJlY2VkZXNcIjpcIlxcdTIyN0FcIixcIlByZWNlZGVzRXF1YWxcIjpcIlxcdTJBQUZcIixcIlByZWNlZGVzU2xhbnRFcXVhbFwiOlwiXFx1MjI3Q1wiLFwiUHJlY2VkZXNUaWxkZVwiOlwiXFx1MjI3RVwiLFwicHJlY2VxXCI6XCJcXHUyQUFGXCIsXCJwcmVjbmFwcHJveFwiOlwiXFx1MkFCOVwiLFwicHJlY25lcXFcIjpcIlxcdTJBQjVcIixcInByZWNuc2ltXCI6XCJcXHUyMkU4XCIsXCJwcmVcIjpcIlxcdTJBQUZcIixcInByRVwiOlwiXFx1MkFCM1wiLFwicHJlY3NpbVwiOlwiXFx1MjI3RVwiLFwicHJpbWVcIjpcIlxcdTIwMzJcIixcIlByaW1lXCI6XCJcXHUyMDMzXCIsXCJwcmltZXNcIjpcIlxcdTIxMTlcIixcInBybmFwXCI6XCJcXHUyQUI5XCIsXCJwcm5FXCI6XCJcXHUyQUI1XCIsXCJwcm5zaW1cIjpcIlxcdTIyRThcIixcInByb2RcIjpcIlxcdTIyMEZcIixcIlByb2R1Y3RcIjpcIlxcdTIyMEZcIixcInByb2ZhbGFyXCI6XCJcXHUyMzJFXCIsXCJwcm9mbGluZVwiOlwiXFx1MjMxMlwiLFwicHJvZnN1cmZcIjpcIlxcdTIzMTNcIixcInByb3BcIjpcIlxcdTIyMURcIixcIlByb3BvcnRpb25hbFwiOlwiXFx1MjIxRFwiLFwiUHJvcG9ydGlvblwiOlwiXFx1MjIzN1wiLFwicHJvcHRvXCI6XCJcXHUyMjFEXCIsXCJwcnNpbVwiOlwiXFx1MjI3RVwiLFwicHJ1cmVsXCI6XCJcXHUyMkIwXCIsXCJQc2NyXCI6XCJcXHVEODM1XFx1RENBQlwiLFwicHNjclwiOlwiXFx1RDgzNVxcdURDQzVcIixcIlBzaVwiOlwiXFx1MDNBOFwiLFwicHNpXCI6XCJcXHUwM0M4XCIsXCJwdW5jc3BcIjpcIlxcdTIwMDhcIixcIlFmclwiOlwiXFx1RDgzNVxcdUREMTRcIixcInFmclwiOlwiXFx1RDgzNVxcdUREMkVcIixcInFpbnRcIjpcIlxcdTJBMENcIixcInFvcGZcIjpcIlxcdUQ4MzVcXHVERDYyXCIsXCJRb3BmXCI6XCJcXHUyMTFBXCIsXCJxcHJpbWVcIjpcIlxcdTIwNTdcIixcIlFzY3JcIjpcIlxcdUQ4MzVcXHVEQ0FDXCIsXCJxc2NyXCI6XCJcXHVEODM1XFx1RENDNlwiLFwicXVhdGVybmlvbnNcIjpcIlxcdTIxMERcIixcInF1YXRpbnRcIjpcIlxcdTJBMTZcIixcInF1ZXN0XCI6XCI/XCIsXCJxdWVzdGVxXCI6XCJcXHUyMjVGXCIsXCJxdW90XCI6XCJcXFwiXCIsXCJRVU9UXCI6XCJcXFwiXCIsXCJyQWFyclwiOlwiXFx1MjFEQlwiLFwicmFjZVwiOlwiXFx1MjIzRFxcdTAzMzFcIixcIlJhY3V0ZVwiOlwiXFx1MDE1NFwiLFwicmFjdXRlXCI6XCJcXHUwMTU1XCIsXCJyYWRpY1wiOlwiXFx1MjIxQVwiLFwicmFlbXB0eXZcIjpcIlxcdTI5QjNcIixcInJhbmdcIjpcIlxcdTI3RTlcIixcIlJhbmdcIjpcIlxcdTI3RUJcIixcInJhbmdkXCI6XCJcXHUyOTkyXCIsXCJyYW5nZVwiOlwiXFx1MjlBNVwiLFwicmFuZ2xlXCI6XCJcXHUyN0U5XCIsXCJyYXF1b1wiOlwiXFx1MDBCQlwiLFwicmFycmFwXCI6XCJcXHUyOTc1XCIsXCJyYXJyYlwiOlwiXFx1MjFFNVwiLFwicmFycmJmc1wiOlwiXFx1MjkyMFwiLFwicmFycmNcIjpcIlxcdTI5MzNcIixcInJhcnJcIjpcIlxcdTIxOTJcIixcIlJhcnJcIjpcIlxcdTIxQTBcIixcInJBcnJcIjpcIlxcdTIxRDJcIixcInJhcnJmc1wiOlwiXFx1MjkxRVwiLFwicmFycmhrXCI6XCJcXHUyMUFBXCIsXCJyYXJybHBcIjpcIlxcdTIxQUNcIixcInJhcnJwbFwiOlwiXFx1Mjk0NVwiLFwicmFycnNpbVwiOlwiXFx1Mjk3NFwiLFwiUmFycnRsXCI6XCJcXHUyOTE2XCIsXCJyYXJydGxcIjpcIlxcdTIxQTNcIixcInJhcnJ3XCI6XCJcXHUyMTlEXCIsXCJyYXRhaWxcIjpcIlxcdTI5MUFcIixcInJBdGFpbFwiOlwiXFx1MjkxQ1wiLFwicmF0aW9cIjpcIlxcdTIyMzZcIixcInJhdGlvbmFsc1wiOlwiXFx1MjExQVwiLFwicmJhcnJcIjpcIlxcdTI5MERcIixcInJCYXJyXCI6XCJcXHUyOTBGXCIsXCJSQmFyclwiOlwiXFx1MjkxMFwiLFwicmJicmtcIjpcIlxcdTI3NzNcIixcInJicmFjZVwiOlwifVwiLFwicmJyYWNrXCI6XCJdXCIsXCJyYnJrZVwiOlwiXFx1Mjk4Q1wiLFwicmJya3NsZFwiOlwiXFx1Mjk4RVwiLFwicmJya3NsdVwiOlwiXFx1Mjk5MFwiLFwiUmNhcm9uXCI6XCJcXHUwMTU4XCIsXCJyY2Fyb25cIjpcIlxcdTAxNTlcIixcIlJjZWRpbFwiOlwiXFx1MDE1NlwiLFwicmNlZGlsXCI6XCJcXHUwMTU3XCIsXCJyY2VpbFwiOlwiXFx1MjMwOVwiLFwicmN1YlwiOlwifVwiLFwiUmN5XCI6XCJcXHUwNDIwXCIsXCJyY3lcIjpcIlxcdTA0NDBcIixcInJkY2FcIjpcIlxcdTI5MzdcIixcInJkbGRoYXJcIjpcIlxcdTI5NjlcIixcInJkcXVvXCI6XCJcXHUyMDFEXCIsXCJyZHF1b3JcIjpcIlxcdTIwMURcIixcInJkc2hcIjpcIlxcdTIxQjNcIixcInJlYWxcIjpcIlxcdTIxMUNcIixcInJlYWxpbmVcIjpcIlxcdTIxMUJcIixcInJlYWxwYXJ0XCI6XCJcXHUyMTFDXCIsXCJyZWFsc1wiOlwiXFx1MjExRFwiLFwiUmVcIjpcIlxcdTIxMUNcIixcInJlY3RcIjpcIlxcdTI1QURcIixcInJlZ1wiOlwiXFx1MDBBRVwiLFwiUkVHXCI6XCJcXHUwMEFFXCIsXCJSZXZlcnNlRWxlbWVudFwiOlwiXFx1MjIwQlwiLFwiUmV2ZXJzZUVxdWlsaWJyaXVtXCI6XCJcXHUyMUNCXCIsXCJSZXZlcnNlVXBFcXVpbGlicml1bVwiOlwiXFx1Mjk2RlwiLFwicmZpc2h0XCI6XCJcXHUyOTdEXCIsXCJyZmxvb3JcIjpcIlxcdTIzMEJcIixcInJmclwiOlwiXFx1RDgzNVxcdUREMkZcIixcIlJmclwiOlwiXFx1MjExQ1wiLFwickhhclwiOlwiXFx1Mjk2NFwiLFwicmhhcmRcIjpcIlxcdTIxQzFcIixcInJoYXJ1XCI6XCJcXHUyMUMwXCIsXCJyaGFydWxcIjpcIlxcdTI5NkNcIixcIlJob1wiOlwiXFx1MDNBMVwiLFwicmhvXCI6XCJcXHUwM0MxXCIsXCJyaG92XCI6XCJcXHUwM0YxXCIsXCJSaWdodEFuZ2xlQnJhY2tldFwiOlwiXFx1MjdFOVwiLFwiUmlnaHRBcnJvd0JhclwiOlwiXFx1MjFFNVwiLFwicmlnaHRhcnJvd1wiOlwiXFx1MjE5MlwiLFwiUmlnaHRBcnJvd1wiOlwiXFx1MjE5MlwiLFwiUmlnaHRhcnJvd1wiOlwiXFx1MjFEMlwiLFwiUmlnaHRBcnJvd0xlZnRBcnJvd1wiOlwiXFx1MjFDNFwiLFwicmlnaHRhcnJvd3RhaWxcIjpcIlxcdTIxQTNcIixcIlJpZ2h0Q2VpbGluZ1wiOlwiXFx1MjMwOVwiLFwiUmlnaHREb3VibGVCcmFja2V0XCI6XCJcXHUyN0U3XCIsXCJSaWdodERvd25UZWVWZWN0b3JcIjpcIlxcdTI5NURcIixcIlJpZ2h0RG93blZlY3RvckJhclwiOlwiXFx1Mjk1NVwiLFwiUmlnaHREb3duVmVjdG9yXCI6XCJcXHUyMUMyXCIsXCJSaWdodEZsb29yXCI6XCJcXHUyMzBCXCIsXCJyaWdodGhhcnBvb25kb3duXCI6XCJcXHUyMUMxXCIsXCJyaWdodGhhcnBvb251cFwiOlwiXFx1MjFDMFwiLFwicmlnaHRsZWZ0YXJyb3dzXCI6XCJcXHUyMUM0XCIsXCJyaWdodGxlZnRoYXJwb29uc1wiOlwiXFx1MjFDQ1wiLFwicmlnaHRyaWdodGFycm93c1wiOlwiXFx1MjFDOVwiLFwicmlnaHRzcXVpZ2Fycm93XCI6XCJcXHUyMTlEXCIsXCJSaWdodFRlZUFycm93XCI6XCJcXHUyMUE2XCIsXCJSaWdodFRlZVwiOlwiXFx1MjJBMlwiLFwiUmlnaHRUZWVWZWN0b3JcIjpcIlxcdTI5NUJcIixcInJpZ2h0dGhyZWV0aW1lc1wiOlwiXFx1MjJDQ1wiLFwiUmlnaHRUcmlhbmdsZUJhclwiOlwiXFx1MjlEMFwiLFwiUmlnaHRUcmlhbmdsZVwiOlwiXFx1MjJCM1wiLFwiUmlnaHRUcmlhbmdsZUVxdWFsXCI6XCJcXHUyMkI1XCIsXCJSaWdodFVwRG93blZlY3RvclwiOlwiXFx1Mjk0RlwiLFwiUmlnaHRVcFRlZVZlY3RvclwiOlwiXFx1Mjk1Q1wiLFwiUmlnaHRVcFZlY3RvckJhclwiOlwiXFx1Mjk1NFwiLFwiUmlnaHRVcFZlY3RvclwiOlwiXFx1MjFCRVwiLFwiUmlnaHRWZWN0b3JCYXJcIjpcIlxcdTI5NTNcIixcIlJpZ2h0VmVjdG9yXCI6XCJcXHUyMUMwXCIsXCJyaW5nXCI6XCJcXHUwMkRBXCIsXCJyaXNpbmdkb3RzZXFcIjpcIlxcdTIyNTNcIixcInJsYXJyXCI6XCJcXHUyMUM0XCIsXCJybGhhclwiOlwiXFx1MjFDQ1wiLFwicmxtXCI6XCJcXHUyMDBGXCIsXCJybW91c3RhY2hlXCI6XCJcXHUyM0IxXCIsXCJybW91c3RcIjpcIlxcdTIzQjFcIixcInJubWlkXCI6XCJcXHUyQUVFXCIsXCJyb2FuZ1wiOlwiXFx1MjdFRFwiLFwicm9hcnJcIjpcIlxcdTIxRkVcIixcInJvYnJrXCI6XCJcXHUyN0U3XCIsXCJyb3BhclwiOlwiXFx1Mjk4NlwiLFwicm9wZlwiOlwiXFx1RDgzNVxcdURENjNcIixcIlJvcGZcIjpcIlxcdTIxMURcIixcInJvcGx1c1wiOlwiXFx1MkEyRVwiLFwicm90aW1lc1wiOlwiXFx1MkEzNVwiLFwiUm91bmRJbXBsaWVzXCI6XCJcXHUyOTcwXCIsXCJycGFyXCI6XCIpXCIsXCJycGFyZ3RcIjpcIlxcdTI5OTRcIixcInJwcG9saW50XCI6XCJcXHUyQTEyXCIsXCJycmFyclwiOlwiXFx1MjFDOVwiLFwiUnJpZ2h0YXJyb3dcIjpcIlxcdTIxREJcIixcInJzYXF1b1wiOlwiXFx1MjAzQVwiLFwicnNjclwiOlwiXFx1RDgzNVxcdURDQzdcIixcIlJzY3JcIjpcIlxcdTIxMUJcIixcInJzaFwiOlwiXFx1MjFCMVwiLFwiUnNoXCI6XCJcXHUyMUIxXCIsXCJyc3FiXCI6XCJdXCIsXCJyc3F1b1wiOlwiXFx1MjAxOVwiLFwicnNxdW9yXCI6XCJcXHUyMDE5XCIsXCJydGhyZWVcIjpcIlxcdTIyQ0NcIixcInJ0aW1lc1wiOlwiXFx1MjJDQVwiLFwicnRyaVwiOlwiXFx1MjVCOVwiLFwicnRyaWVcIjpcIlxcdTIyQjVcIixcInJ0cmlmXCI6XCJcXHUyNUI4XCIsXCJydHJpbHRyaVwiOlwiXFx1MjlDRVwiLFwiUnVsZURlbGF5ZWRcIjpcIlxcdTI5RjRcIixcInJ1bHVoYXJcIjpcIlxcdTI5NjhcIixcInJ4XCI6XCJcXHUyMTFFXCIsXCJTYWN1dGVcIjpcIlxcdTAxNUFcIixcInNhY3V0ZVwiOlwiXFx1MDE1QlwiLFwic2JxdW9cIjpcIlxcdTIwMUFcIixcInNjYXBcIjpcIlxcdTJBQjhcIixcIlNjYXJvblwiOlwiXFx1MDE2MFwiLFwic2Nhcm9uXCI6XCJcXHUwMTYxXCIsXCJTY1wiOlwiXFx1MkFCQ1wiLFwic2NcIjpcIlxcdTIyN0JcIixcInNjY3VlXCI6XCJcXHUyMjdEXCIsXCJzY2VcIjpcIlxcdTJBQjBcIixcInNjRVwiOlwiXFx1MkFCNFwiLFwiU2NlZGlsXCI6XCJcXHUwMTVFXCIsXCJzY2VkaWxcIjpcIlxcdTAxNUZcIixcIlNjaXJjXCI6XCJcXHUwMTVDXCIsXCJzY2lyY1wiOlwiXFx1MDE1RFwiLFwic2NuYXBcIjpcIlxcdTJBQkFcIixcInNjbkVcIjpcIlxcdTJBQjZcIixcInNjbnNpbVwiOlwiXFx1MjJFOVwiLFwic2Nwb2xpbnRcIjpcIlxcdTJBMTNcIixcInNjc2ltXCI6XCJcXHUyMjdGXCIsXCJTY3lcIjpcIlxcdTA0MjFcIixcInNjeVwiOlwiXFx1MDQ0MVwiLFwic2RvdGJcIjpcIlxcdTIyQTFcIixcInNkb3RcIjpcIlxcdTIyQzVcIixcInNkb3RlXCI6XCJcXHUyQTY2XCIsXCJzZWFyaGtcIjpcIlxcdTI5MjVcIixcInNlYXJyXCI6XCJcXHUyMTk4XCIsXCJzZUFyclwiOlwiXFx1MjFEOFwiLFwic2VhcnJvd1wiOlwiXFx1MjE5OFwiLFwic2VjdFwiOlwiXFx1MDBBN1wiLFwic2VtaVwiOlwiO1wiLFwic2Vzd2FyXCI6XCJcXHUyOTI5XCIsXCJzZXRtaW51c1wiOlwiXFx1MjIxNlwiLFwic2V0bW5cIjpcIlxcdTIyMTZcIixcInNleHRcIjpcIlxcdTI3MzZcIixcIlNmclwiOlwiXFx1RDgzNVxcdUREMTZcIixcInNmclwiOlwiXFx1RDgzNVxcdUREMzBcIixcInNmcm93blwiOlwiXFx1MjMyMlwiLFwic2hhcnBcIjpcIlxcdTI2NkZcIixcIlNIQ0hjeVwiOlwiXFx1MDQyOVwiLFwic2hjaGN5XCI6XCJcXHUwNDQ5XCIsXCJTSGN5XCI6XCJcXHUwNDI4XCIsXCJzaGN5XCI6XCJcXHUwNDQ4XCIsXCJTaG9ydERvd25BcnJvd1wiOlwiXFx1MjE5M1wiLFwiU2hvcnRMZWZ0QXJyb3dcIjpcIlxcdTIxOTBcIixcInNob3J0bWlkXCI6XCJcXHUyMjIzXCIsXCJzaG9ydHBhcmFsbGVsXCI6XCJcXHUyMjI1XCIsXCJTaG9ydFJpZ2h0QXJyb3dcIjpcIlxcdTIxOTJcIixcIlNob3J0VXBBcnJvd1wiOlwiXFx1MjE5MVwiLFwic2h5XCI6XCJcXHUwMEFEXCIsXCJTaWdtYVwiOlwiXFx1MDNBM1wiLFwic2lnbWFcIjpcIlxcdTAzQzNcIixcInNpZ21hZlwiOlwiXFx1MDNDMlwiLFwic2lnbWF2XCI6XCJcXHUwM0MyXCIsXCJzaW1cIjpcIlxcdTIyM0NcIixcInNpbWRvdFwiOlwiXFx1MkE2QVwiLFwic2ltZVwiOlwiXFx1MjI0M1wiLFwic2ltZXFcIjpcIlxcdTIyNDNcIixcInNpbWdcIjpcIlxcdTJBOUVcIixcInNpbWdFXCI6XCJcXHUyQUEwXCIsXCJzaW1sXCI6XCJcXHUyQTlEXCIsXCJzaW1sRVwiOlwiXFx1MkE5RlwiLFwic2ltbmVcIjpcIlxcdTIyNDZcIixcInNpbXBsdXNcIjpcIlxcdTJBMjRcIixcInNpbXJhcnJcIjpcIlxcdTI5NzJcIixcInNsYXJyXCI6XCJcXHUyMTkwXCIsXCJTbWFsbENpcmNsZVwiOlwiXFx1MjIxOFwiLFwic21hbGxzZXRtaW51c1wiOlwiXFx1MjIxNlwiLFwic21hc2hwXCI6XCJcXHUyQTMzXCIsXCJzbWVwYXJzbFwiOlwiXFx1MjlFNFwiLFwic21pZFwiOlwiXFx1MjIyM1wiLFwic21pbGVcIjpcIlxcdTIzMjNcIixcInNtdFwiOlwiXFx1MkFBQVwiLFwic210ZVwiOlwiXFx1MkFBQ1wiLFwic210ZXNcIjpcIlxcdTJBQUNcXHVGRTAwXCIsXCJTT0ZUY3lcIjpcIlxcdTA0MkNcIixcInNvZnRjeVwiOlwiXFx1MDQ0Q1wiLFwic29sYmFyXCI6XCJcXHUyMzNGXCIsXCJzb2xiXCI6XCJcXHUyOUM0XCIsXCJzb2xcIjpcIi9cIixcIlNvcGZcIjpcIlxcdUQ4MzVcXHVERDRBXCIsXCJzb3BmXCI6XCJcXHVEODM1XFx1REQ2NFwiLFwic3BhZGVzXCI6XCJcXHUyNjYwXCIsXCJzcGFkZXN1aXRcIjpcIlxcdTI2NjBcIixcInNwYXJcIjpcIlxcdTIyMjVcIixcInNxY2FwXCI6XCJcXHUyMjkzXCIsXCJzcWNhcHNcIjpcIlxcdTIyOTNcXHVGRTAwXCIsXCJzcWN1cFwiOlwiXFx1MjI5NFwiLFwic3FjdXBzXCI6XCJcXHUyMjk0XFx1RkUwMFwiLFwiU3FydFwiOlwiXFx1MjIxQVwiLFwic3FzdWJcIjpcIlxcdTIyOEZcIixcInNxc3ViZVwiOlwiXFx1MjI5MVwiLFwic3FzdWJzZXRcIjpcIlxcdTIyOEZcIixcInNxc3Vic2V0ZXFcIjpcIlxcdTIyOTFcIixcInNxc3VwXCI6XCJcXHUyMjkwXCIsXCJzcXN1cGVcIjpcIlxcdTIyOTJcIixcInNxc3Vwc2V0XCI6XCJcXHUyMjkwXCIsXCJzcXN1cHNldGVxXCI6XCJcXHUyMjkyXCIsXCJzcXVhcmVcIjpcIlxcdTI1QTFcIixcIlNxdWFyZVwiOlwiXFx1MjVBMVwiLFwiU3F1YXJlSW50ZXJzZWN0aW9uXCI6XCJcXHUyMjkzXCIsXCJTcXVhcmVTdWJzZXRcIjpcIlxcdTIyOEZcIixcIlNxdWFyZVN1YnNldEVxdWFsXCI6XCJcXHUyMjkxXCIsXCJTcXVhcmVTdXBlcnNldFwiOlwiXFx1MjI5MFwiLFwiU3F1YXJlU3VwZXJzZXRFcXVhbFwiOlwiXFx1MjI5MlwiLFwiU3F1YXJlVW5pb25cIjpcIlxcdTIyOTRcIixcInNxdWFyZlwiOlwiXFx1MjVBQVwiLFwic3F1XCI6XCJcXHUyNUExXCIsXCJzcXVmXCI6XCJcXHUyNUFBXCIsXCJzcmFyclwiOlwiXFx1MjE5MlwiLFwiU3NjclwiOlwiXFx1RDgzNVxcdURDQUVcIixcInNzY3JcIjpcIlxcdUQ4MzVcXHVEQ0M4XCIsXCJzc2V0bW5cIjpcIlxcdTIyMTZcIixcInNzbWlsZVwiOlwiXFx1MjMyM1wiLFwic3N0YXJmXCI6XCJcXHUyMkM2XCIsXCJTdGFyXCI6XCJcXHUyMkM2XCIsXCJzdGFyXCI6XCJcXHUyNjA2XCIsXCJzdGFyZlwiOlwiXFx1MjYwNVwiLFwic3RyYWlnaHRlcHNpbG9uXCI6XCJcXHUwM0Y1XCIsXCJzdHJhaWdodHBoaVwiOlwiXFx1MDNENVwiLFwic3RybnNcIjpcIlxcdTAwQUZcIixcInN1YlwiOlwiXFx1MjI4MlwiLFwiU3ViXCI6XCJcXHUyMkQwXCIsXCJzdWJkb3RcIjpcIlxcdTJBQkRcIixcInN1YkVcIjpcIlxcdTJBQzVcIixcInN1YmVcIjpcIlxcdTIyODZcIixcInN1YmVkb3RcIjpcIlxcdTJBQzNcIixcInN1Ym11bHRcIjpcIlxcdTJBQzFcIixcInN1Ym5FXCI6XCJcXHUyQUNCXCIsXCJzdWJuZVwiOlwiXFx1MjI4QVwiLFwic3VicGx1c1wiOlwiXFx1MkFCRlwiLFwic3VicmFyclwiOlwiXFx1Mjk3OVwiLFwic3Vic2V0XCI6XCJcXHUyMjgyXCIsXCJTdWJzZXRcIjpcIlxcdTIyRDBcIixcInN1YnNldGVxXCI6XCJcXHUyMjg2XCIsXCJzdWJzZXRlcXFcIjpcIlxcdTJBQzVcIixcIlN1YnNldEVxdWFsXCI6XCJcXHUyMjg2XCIsXCJzdWJzZXRuZXFcIjpcIlxcdTIyOEFcIixcInN1YnNldG5lcXFcIjpcIlxcdTJBQ0JcIixcInN1YnNpbVwiOlwiXFx1MkFDN1wiLFwic3Vic3ViXCI6XCJcXHUyQUQ1XCIsXCJzdWJzdXBcIjpcIlxcdTJBRDNcIixcInN1Y2NhcHByb3hcIjpcIlxcdTJBQjhcIixcInN1Y2NcIjpcIlxcdTIyN0JcIixcInN1Y2NjdXJseWVxXCI6XCJcXHUyMjdEXCIsXCJTdWNjZWVkc1wiOlwiXFx1MjI3QlwiLFwiU3VjY2VlZHNFcXVhbFwiOlwiXFx1MkFCMFwiLFwiU3VjY2VlZHNTbGFudEVxdWFsXCI6XCJcXHUyMjdEXCIsXCJTdWNjZWVkc1RpbGRlXCI6XCJcXHUyMjdGXCIsXCJzdWNjZXFcIjpcIlxcdTJBQjBcIixcInN1Y2NuYXBwcm94XCI6XCJcXHUyQUJBXCIsXCJzdWNjbmVxcVwiOlwiXFx1MkFCNlwiLFwic3VjY25zaW1cIjpcIlxcdTIyRTlcIixcInN1Y2NzaW1cIjpcIlxcdTIyN0ZcIixcIlN1Y2hUaGF0XCI6XCJcXHUyMjBCXCIsXCJzdW1cIjpcIlxcdTIyMTFcIixcIlN1bVwiOlwiXFx1MjIxMVwiLFwic3VuZ1wiOlwiXFx1MjY2QVwiLFwic3VwMVwiOlwiXFx1MDBCOVwiLFwic3VwMlwiOlwiXFx1MDBCMlwiLFwic3VwM1wiOlwiXFx1MDBCM1wiLFwic3VwXCI6XCJcXHUyMjgzXCIsXCJTdXBcIjpcIlxcdTIyRDFcIixcInN1cGRvdFwiOlwiXFx1MkFCRVwiLFwic3VwZHN1YlwiOlwiXFx1MkFEOFwiLFwic3VwRVwiOlwiXFx1MkFDNlwiLFwic3VwZVwiOlwiXFx1MjI4N1wiLFwic3VwZWRvdFwiOlwiXFx1MkFDNFwiLFwiU3VwZXJzZXRcIjpcIlxcdTIyODNcIixcIlN1cGVyc2V0RXF1YWxcIjpcIlxcdTIyODdcIixcInN1cGhzb2xcIjpcIlxcdTI3QzlcIixcInN1cGhzdWJcIjpcIlxcdTJBRDdcIixcInN1cGxhcnJcIjpcIlxcdTI5N0JcIixcInN1cG11bHRcIjpcIlxcdTJBQzJcIixcInN1cG5FXCI6XCJcXHUyQUNDXCIsXCJzdXBuZVwiOlwiXFx1MjI4QlwiLFwic3VwcGx1c1wiOlwiXFx1MkFDMFwiLFwic3Vwc2V0XCI6XCJcXHUyMjgzXCIsXCJTdXBzZXRcIjpcIlxcdTIyRDFcIixcInN1cHNldGVxXCI6XCJcXHUyMjg3XCIsXCJzdXBzZXRlcXFcIjpcIlxcdTJBQzZcIixcInN1cHNldG5lcVwiOlwiXFx1MjI4QlwiLFwic3Vwc2V0bmVxcVwiOlwiXFx1MkFDQ1wiLFwic3Vwc2ltXCI6XCJcXHUyQUM4XCIsXCJzdXBzdWJcIjpcIlxcdTJBRDRcIixcInN1cHN1cFwiOlwiXFx1MkFENlwiLFwic3dhcmhrXCI6XCJcXHUyOTI2XCIsXCJzd2FyclwiOlwiXFx1MjE5OVwiLFwic3dBcnJcIjpcIlxcdTIxRDlcIixcInN3YXJyb3dcIjpcIlxcdTIxOTlcIixcInN3bndhclwiOlwiXFx1MjkyQVwiLFwic3psaWdcIjpcIlxcdTAwREZcIixcIlRhYlwiOlwiXFx0XCIsXCJ0YXJnZXRcIjpcIlxcdTIzMTZcIixcIlRhdVwiOlwiXFx1MDNBNFwiLFwidGF1XCI6XCJcXHUwM0M0XCIsXCJ0YnJrXCI6XCJcXHUyM0I0XCIsXCJUY2Fyb25cIjpcIlxcdTAxNjRcIixcInRjYXJvblwiOlwiXFx1MDE2NVwiLFwiVGNlZGlsXCI6XCJcXHUwMTYyXCIsXCJ0Y2VkaWxcIjpcIlxcdTAxNjNcIixcIlRjeVwiOlwiXFx1MDQyMlwiLFwidGN5XCI6XCJcXHUwNDQyXCIsXCJ0ZG90XCI6XCJcXHUyMERCXCIsXCJ0ZWxyZWNcIjpcIlxcdTIzMTVcIixcIlRmclwiOlwiXFx1RDgzNVxcdUREMTdcIixcInRmclwiOlwiXFx1RDgzNVxcdUREMzFcIixcInRoZXJlNFwiOlwiXFx1MjIzNFwiLFwidGhlcmVmb3JlXCI6XCJcXHUyMjM0XCIsXCJUaGVyZWZvcmVcIjpcIlxcdTIyMzRcIixcIlRoZXRhXCI6XCJcXHUwMzk4XCIsXCJ0aGV0YVwiOlwiXFx1MDNCOFwiLFwidGhldGFzeW1cIjpcIlxcdTAzRDFcIixcInRoZXRhdlwiOlwiXFx1MDNEMVwiLFwidGhpY2thcHByb3hcIjpcIlxcdTIyNDhcIixcInRoaWNrc2ltXCI6XCJcXHUyMjNDXCIsXCJUaGlja1NwYWNlXCI6XCJcXHUyMDVGXFx1MjAwQVwiLFwiVGhpblNwYWNlXCI6XCJcXHUyMDA5XCIsXCJ0aGluc3BcIjpcIlxcdTIwMDlcIixcInRoa2FwXCI6XCJcXHUyMjQ4XCIsXCJ0aGtzaW1cIjpcIlxcdTIyM0NcIixcIlRIT1JOXCI6XCJcXHUwMERFXCIsXCJ0aG9yblwiOlwiXFx1MDBGRVwiLFwidGlsZGVcIjpcIlxcdTAyRENcIixcIlRpbGRlXCI6XCJcXHUyMjNDXCIsXCJUaWxkZUVxdWFsXCI6XCJcXHUyMjQzXCIsXCJUaWxkZUZ1bGxFcXVhbFwiOlwiXFx1MjI0NVwiLFwiVGlsZGVUaWxkZVwiOlwiXFx1MjI0OFwiLFwidGltZXNiYXJcIjpcIlxcdTJBMzFcIixcInRpbWVzYlwiOlwiXFx1MjJBMFwiLFwidGltZXNcIjpcIlxcdTAwRDdcIixcInRpbWVzZFwiOlwiXFx1MkEzMFwiLFwidGludFwiOlwiXFx1MjIyRFwiLFwidG9lYVwiOlwiXFx1MjkyOFwiLFwidG9wYm90XCI6XCJcXHUyMzM2XCIsXCJ0b3BjaXJcIjpcIlxcdTJBRjFcIixcInRvcFwiOlwiXFx1MjJBNFwiLFwiVG9wZlwiOlwiXFx1RDgzNVxcdURENEJcIixcInRvcGZcIjpcIlxcdUQ4MzVcXHVERDY1XCIsXCJ0b3Bmb3JrXCI6XCJcXHUyQURBXCIsXCJ0b3NhXCI6XCJcXHUyOTI5XCIsXCJ0cHJpbWVcIjpcIlxcdTIwMzRcIixcInRyYWRlXCI6XCJcXHUyMTIyXCIsXCJUUkFERVwiOlwiXFx1MjEyMlwiLFwidHJpYW5nbGVcIjpcIlxcdTI1QjVcIixcInRyaWFuZ2xlZG93blwiOlwiXFx1MjVCRlwiLFwidHJpYW5nbGVsZWZ0XCI6XCJcXHUyNUMzXCIsXCJ0cmlhbmdsZWxlZnRlcVwiOlwiXFx1MjJCNFwiLFwidHJpYW5nbGVxXCI6XCJcXHUyMjVDXCIsXCJ0cmlhbmdsZXJpZ2h0XCI6XCJcXHUyNUI5XCIsXCJ0cmlhbmdsZXJpZ2h0ZXFcIjpcIlxcdTIyQjVcIixcInRyaWRvdFwiOlwiXFx1MjVFQ1wiLFwidHJpZVwiOlwiXFx1MjI1Q1wiLFwidHJpbWludXNcIjpcIlxcdTJBM0FcIixcIlRyaXBsZURvdFwiOlwiXFx1MjBEQlwiLFwidHJpcGx1c1wiOlwiXFx1MkEzOVwiLFwidHJpc2JcIjpcIlxcdTI5Q0RcIixcInRyaXRpbWVcIjpcIlxcdTJBM0JcIixcInRycGV6aXVtXCI6XCJcXHUyM0UyXCIsXCJUc2NyXCI6XCJcXHVEODM1XFx1RENBRlwiLFwidHNjclwiOlwiXFx1RDgzNVxcdURDQzlcIixcIlRTY3lcIjpcIlxcdTA0MjZcIixcInRzY3lcIjpcIlxcdTA0NDZcIixcIlRTSGN5XCI6XCJcXHUwNDBCXCIsXCJ0c2hjeVwiOlwiXFx1MDQ1QlwiLFwiVHN0cm9rXCI6XCJcXHUwMTY2XCIsXCJ0c3Ryb2tcIjpcIlxcdTAxNjdcIixcInR3aXh0XCI6XCJcXHUyMjZDXCIsXCJ0d29oZWFkbGVmdGFycm93XCI6XCJcXHUyMTlFXCIsXCJ0d29oZWFkcmlnaHRhcnJvd1wiOlwiXFx1MjFBMFwiLFwiVWFjdXRlXCI6XCJcXHUwMERBXCIsXCJ1YWN1dGVcIjpcIlxcdTAwRkFcIixcInVhcnJcIjpcIlxcdTIxOTFcIixcIlVhcnJcIjpcIlxcdTIxOUZcIixcInVBcnJcIjpcIlxcdTIxRDFcIixcIlVhcnJvY2lyXCI6XCJcXHUyOTQ5XCIsXCJVYnJjeVwiOlwiXFx1MDQwRVwiLFwidWJyY3lcIjpcIlxcdTA0NUVcIixcIlVicmV2ZVwiOlwiXFx1MDE2Q1wiLFwidWJyZXZlXCI6XCJcXHUwMTZEXCIsXCJVY2lyY1wiOlwiXFx1MDBEQlwiLFwidWNpcmNcIjpcIlxcdTAwRkJcIixcIlVjeVwiOlwiXFx1MDQyM1wiLFwidWN5XCI6XCJcXHUwNDQzXCIsXCJ1ZGFyclwiOlwiXFx1MjFDNVwiLFwiVWRibGFjXCI6XCJcXHUwMTcwXCIsXCJ1ZGJsYWNcIjpcIlxcdTAxNzFcIixcInVkaGFyXCI6XCJcXHUyOTZFXCIsXCJ1ZmlzaHRcIjpcIlxcdTI5N0VcIixcIlVmclwiOlwiXFx1RDgzNVxcdUREMThcIixcInVmclwiOlwiXFx1RDgzNVxcdUREMzJcIixcIlVncmF2ZVwiOlwiXFx1MDBEOVwiLFwidWdyYXZlXCI6XCJcXHUwMEY5XCIsXCJ1SGFyXCI6XCJcXHUyOTYzXCIsXCJ1aGFybFwiOlwiXFx1MjFCRlwiLFwidWhhcnJcIjpcIlxcdTIxQkVcIixcInVoYmxrXCI6XCJcXHUyNTgwXCIsXCJ1bGNvcm5cIjpcIlxcdTIzMUNcIixcInVsY29ybmVyXCI6XCJcXHUyMzFDXCIsXCJ1bGNyb3BcIjpcIlxcdTIzMEZcIixcInVsdHJpXCI6XCJcXHUyNUY4XCIsXCJVbWFjclwiOlwiXFx1MDE2QVwiLFwidW1hY3JcIjpcIlxcdTAxNkJcIixcInVtbFwiOlwiXFx1MDBBOFwiLFwiVW5kZXJCYXJcIjpcIl9cIixcIlVuZGVyQnJhY2VcIjpcIlxcdTIzREZcIixcIlVuZGVyQnJhY2tldFwiOlwiXFx1MjNCNVwiLFwiVW5kZXJQYXJlbnRoZXNpc1wiOlwiXFx1MjNERFwiLFwiVW5pb25cIjpcIlxcdTIyQzNcIixcIlVuaW9uUGx1c1wiOlwiXFx1MjI4RVwiLFwiVW9nb25cIjpcIlxcdTAxNzJcIixcInVvZ29uXCI6XCJcXHUwMTczXCIsXCJVb3BmXCI6XCJcXHVEODM1XFx1REQ0Q1wiLFwidW9wZlwiOlwiXFx1RDgzNVxcdURENjZcIixcIlVwQXJyb3dCYXJcIjpcIlxcdTI5MTJcIixcInVwYXJyb3dcIjpcIlxcdTIxOTFcIixcIlVwQXJyb3dcIjpcIlxcdTIxOTFcIixcIlVwYXJyb3dcIjpcIlxcdTIxRDFcIixcIlVwQXJyb3dEb3duQXJyb3dcIjpcIlxcdTIxQzVcIixcInVwZG93bmFycm93XCI6XCJcXHUyMTk1XCIsXCJVcERvd25BcnJvd1wiOlwiXFx1MjE5NVwiLFwiVXBkb3duYXJyb3dcIjpcIlxcdTIxRDVcIixcIlVwRXF1aWxpYnJpdW1cIjpcIlxcdTI5NkVcIixcInVwaGFycG9vbmxlZnRcIjpcIlxcdTIxQkZcIixcInVwaGFycG9vbnJpZ2h0XCI6XCJcXHUyMUJFXCIsXCJ1cGx1c1wiOlwiXFx1MjI4RVwiLFwiVXBwZXJMZWZ0QXJyb3dcIjpcIlxcdTIxOTZcIixcIlVwcGVyUmlnaHRBcnJvd1wiOlwiXFx1MjE5N1wiLFwidXBzaVwiOlwiXFx1MDNDNVwiLFwiVXBzaVwiOlwiXFx1MDNEMlwiLFwidXBzaWhcIjpcIlxcdTAzRDJcIixcIlVwc2lsb25cIjpcIlxcdTAzQTVcIixcInVwc2lsb25cIjpcIlxcdTAzQzVcIixcIlVwVGVlQXJyb3dcIjpcIlxcdTIxQTVcIixcIlVwVGVlXCI6XCJcXHUyMkE1XCIsXCJ1cHVwYXJyb3dzXCI6XCJcXHUyMUM4XCIsXCJ1cmNvcm5cIjpcIlxcdTIzMURcIixcInVyY29ybmVyXCI6XCJcXHUyMzFEXCIsXCJ1cmNyb3BcIjpcIlxcdTIzMEVcIixcIlVyaW5nXCI6XCJcXHUwMTZFXCIsXCJ1cmluZ1wiOlwiXFx1MDE2RlwiLFwidXJ0cmlcIjpcIlxcdTI1RjlcIixcIlVzY3JcIjpcIlxcdUQ4MzVcXHVEQ0IwXCIsXCJ1c2NyXCI6XCJcXHVEODM1XFx1RENDQVwiLFwidXRkb3RcIjpcIlxcdTIyRjBcIixcIlV0aWxkZVwiOlwiXFx1MDE2OFwiLFwidXRpbGRlXCI6XCJcXHUwMTY5XCIsXCJ1dHJpXCI6XCJcXHUyNUI1XCIsXCJ1dHJpZlwiOlwiXFx1MjVCNFwiLFwidXVhcnJcIjpcIlxcdTIxQzhcIixcIlV1bWxcIjpcIlxcdTAwRENcIixcInV1bWxcIjpcIlxcdTAwRkNcIixcInV3YW5nbGVcIjpcIlxcdTI5QTdcIixcInZhbmdydFwiOlwiXFx1Mjk5Q1wiLFwidmFyZXBzaWxvblwiOlwiXFx1MDNGNVwiLFwidmFya2FwcGFcIjpcIlxcdTAzRjBcIixcInZhcm5vdGhpbmdcIjpcIlxcdTIyMDVcIixcInZhcnBoaVwiOlwiXFx1MDNENVwiLFwidmFycGlcIjpcIlxcdTAzRDZcIixcInZhcnByb3B0b1wiOlwiXFx1MjIxRFwiLFwidmFyclwiOlwiXFx1MjE5NVwiLFwidkFyclwiOlwiXFx1MjFENVwiLFwidmFycmhvXCI6XCJcXHUwM0YxXCIsXCJ2YXJzaWdtYVwiOlwiXFx1MDNDMlwiLFwidmFyc3Vic2V0bmVxXCI6XCJcXHUyMjhBXFx1RkUwMFwiLFwidmFyc3Vic2V0bmVxcVwiOlwiXFx1MkFDQlxcdUZFMDBcIixcInZhcnN1cHNldG5lcVwiOlwiXFx1MjI4QlxcdUZFMDBcIixcInZhcnN1cHNldG5lcXFcIjpcIlxcdTJBQ0NcXHVGRTAwXCIsXCJ2YXJ0aGV0YVwiOlwiXFx1MDNEMVwiLFwidmFydHJpYW5nbGVsZWZ0XCI6XCJcXHUyMkIyXCIsXCJ2YXJ0cmlhbmdsZXJpZ2h0XCI6XCJcXHUyMkIzXCIsXCJ2QmFyXCI6XCJcXHUyQUU4XCIsXCJWYmFyXCI6XCJcXHUyQUVCXCIsXCJ2QmFydlwiOlwiXFx1MkFFOVwiLFwiVmN5XCI6XCJcXHUwNDEyXCIsXCJ2Y3lcIjpcIlxcdTA0MzJcIixcInZkYXNoXCI6XCJcXHUyMkEyXCIsXCJ2RGFzaFwiOlwiXFx1MjJBOFwiLFwiVmRhc2hcIjpcIlxcdTIyQTlcIixcIlZEYXNoXCI6XCJcXHUyMkFCXCIsXCJWZGFzaGxcIjpcIlxcdTJBRTZcIixcInZlZWJhclwiOlwiXFx1MjJCQlwiLFwidmVlXCI6XCJcXHUyMjI4XCIsXCJWZWVcIjpcIlxcdTIyQzFcIixcInZlZWVxXCI6XCJcXHUyMjVBXCIsXCJ2ZWxsaXBcIjpcIlxcdTIyRUVcIixcInZlcmJhclwiOlwifFwiLFwiVmVyYmFyXCI6XCJcXHUyMDE2XCIsXCJ2ZXJ0XCI6XCJ8XCIsXCJWZXJ0XCI6XCJcXHUyMDE2XCIsXCJWZXJ0aWNhbEJhclwiOlwiXFx1MjIyM1wiLFwiVmVydGljYWxMaW5lXCI6XCJ8XCIsXCJWZXJ0aWNhbFNlcGFyYXRvclwiOlwiXFx1Mjc1OFwiLFwiVmVydGljYWxUaWxkZVwiOlwiXFx1MjI0MFwiLFwiVmVyeVRoaW5TcGFjZVwiOlwiXFx1MjAwQVwiLFwiVmZyXCI6XCJcXHVEODM1XFx1REQxOVwiLFwidmZyXCI6XCJcXHVEODM1XFx1REQzM1wiLFwidmx0cmlcIjpcIlxcdTIyQjJcIixcInZuc3ViXCI6XCJcXHUyMjgyXFx1MjBEMlwiLFwidm5zdXBcIjpcIlxcdTIyODNcXHUyMEQyXCIsXCJWb3BmXCI6XCJcXHVEODM1XFx1REQ0RFwiLFwidm9wZlwiOlwiXFx1RDgzNVxcdURENjdcIixcInZwcm9wXCI6XCJcXHUyMjFEXCIsXCJ2cnRyaVwiOlwiXFx1MjJCM1wiLFwiVnNjclwiOlwiXFx1RDgzNVxcdURDQjFcIixcInZzY3JcIjpcIlxcdUQ4MzVcXHVEQ0NCXCIsXCJ2c3VibkVcIjpcIlxcdTJBQ0JcXHVGRTAwXCIsXCJ2c3VibmVcIjpcIlxcdTIyOEFcXHVGRTAwXCIsXCJ2c3VwbkVcIjpcIlxcdTJBQ0NcXHVGRTAwXCIsXCJ2c3VwbmVcIjpcIlxcdTIyOEJcXHVGRTAwXCIsXCJWdmRhc2hcIjpcIlxcdTIyQUFcIixcInZ6aWd6YWdcIjpcIlxcdTI5OUFcIixcIldjaXJjXCI6XCJcXHUwMTc0XCIsXCJ3Y2lyY1wiOlwiXFx1MDE3NVwiLFwid2VkYmFyXCI6XCJcXHUyQTVGXCIsXCJ3ZWRnZVwiOlwiXFx1MjIyN1wiLFwiV2VkZ2VcIjpcIlxcdTIyQzBcIixcIndlZGdlcVwiOlwiXFx1MjI1OVwiLFwid2VpZXJwXCI6XCJcXHUyMTE4XCIsXCJXZnJcIjpcIlxcdUQ4MzVcXHVERDFBXCIsXCJ3ZnJcIjpcIlxcdUQ4MzVcXHVERDM0XCIsXCJXb3BmXCI6XCJcXHVEODM1XFx1REQ0RVwiLFwid29wZlwiOlwiXFx1RDgzNVxcdURENjhcIixcIndwXCI6XCJcXHUyMTE4XCIsXCJ3clwiOlwiXFx1MjI0MFwiLFwid3JlYXRoXCI6XCJcXHUyMjQwXCIsXCJXc2NyXCI6XCJcXHVEODM1XFx1RENCMlwiLFwid3NjclwiOlwiXFx1RDgzNVxcdURDQ0NcIixcInhjYXBcIjpcIlxcdTIyQzJcIixcInhjaXJjXCI6XCJcXHUyNUVGXCIsXCJ4Y3VwXCI6XCJcXHUyMkMzXCIsXCJ4ZHRyaVwiOlwiXFx1MjVCRFwiLFwiWGZyXCI6XCJcXHVEODM1XFx1REQxQlwiLFwieGZyXCI6XCJcXHVEODM1XFx1REQzNVwiLFwieGhhcnJcIjpcIlxcdTI3RjdcIixcInhoQXJyXCI6XCJcXHUyN0ZBXCIsXCJYaVwiOlwiXFx1MDM5RVwiLFwieGlcIjpcIlxcdTAzQkVcIixcInhsYXJyXCI6XCJcXHUyN0Y1XCIsXCJ4bEFyclwiOlwiXFx1MjdGOFwiLFwieG1hcFwiOlwiXFx1MjdGQ1wiLFwieG5pc1wiOlwiXFx1MjJGQlwiLFwieG9kb3RcIjpcIlxcdTJBMDBcIixcIlhvcGZcIjpcIlxcdUQ4MzVcXHVERDRGXCIsXCJ4b3BmXCI6XCJcXHVEODM1XFx1REQ2OVwiLFwieG9wbHVzXCI6XCJcXHUyQTAxXCIsXCJ4b3RpbWVcIjpcIlxcdTJBMDJcIixcInhyYXJyXCI6XCJcXHUyN0Y2XCIsXCJ4ckFyclwiOlwiXFx1MjdGOVwiLFwiWHNjclwiOlwiXFx1RDgzNVxcdURDQjNcIixcInhzY3JcIjpcIlxcdUQ4MzVcXHVEQ0NEXCIsXCJ4c3FjdXBcIjpcIlxcdTJBMDZcIixcInh1cGx1c1wiOlwiXFx1MkEwNFwiLFwieHV0cmlcIjpcIlxcdTI1QjNcIixcInh2ZWVcIjpcIlxcdTIyQzFcIixcInh3ZWRnZVwiOlwiXFx1MjJDMFwiLFwiWWFjdXRlXCI6XCJcXHUwMEREXCIsXCJ5YWN1dGVcIjpcIlxcdTAwRkRcIixcIllBY3lcIjpcIlxcdTA0MkZcIixcInlhY3lcIjpcIlxcdTA0NEZcIixcIlljaXJjXCI6XCJcXHUwMTc2XCIsXCJ5Y2lyY1wiOlwiXFx1MDE3N1wiLFwiWWN5XCI6XCJcXHUwNDJCXCIsXCJ5Y3lcIjpcIlxcdTA0NEJcIixcInllblwiOlwiXFx1MDBBNVwiLFwiWWZyXCI6XCJcXHVEODM1XFx1REQxQ1wiLFwieWZyXCI6XCJcXHVEODM1XFx1REQzNlwiLFwiWUljeVwiOlwiXFx1MDQwN1wiLFwieWljeVwiOlwiXFx1MDQ1N1wiLFwiWW9wZlwiOlwiXFx1RDgzNVxcdURENTBcIixcInlvcGZcIjpcIlxcdUQ4MzVcXHVERDZBXCIsXCJZc2NyXCI6XCJcXHVEODM1XFx1RENCNFwiLFwieXNjclwiOlwiXFx1RDgzNVxcdURDQ0VcIixcIllVY3lcIjpcIlxcdTA0MkVcIixcInl1Y3lcIjpcIlxcdTA0NEVcIixcInl1bWxcIjpcIlxcdTAwRkZcIixcIll1bWxcIjpcIlxcdTAxNzhcIixcIlphY3V0ZVwiOlwiXFx1MDE3OVwiLFwiemFjdXRlXCI6XCJcXHUwMTdBXCIsXCJaY2Fyb25cIjpcIlxcdTAxN0RcIixcInpjYXJvblwiOlwiXFx1MDE3RVwiLFwiWmN5XCI6XCJcXHUwNDE3XCIsXCJ6Y3lcIjpcIlxcdTA0MzdcIixcIlpkb3RcIjpcIlxcdTAxN0JcIixcInpkb3RcIjpcIlxcdTAxN0NcIixcInplZXRyZlwiOlwiXFx1MjEyOFwiLFwiWmVyb1dpZHRoU3BhY2VcIjpcIlxcdTIwMEJcIixcIlpldGFcIjpcIlxcdTAzOTZcIixcInpldGFcIjpcIlxcdTAzQjZcIixcInpmclwiOlwiXFx1RDgzNVxcdUREMzdcIixcIlpmclwiOlwiXFx1MjEyOFwiLFwiWkhjeVwiOlwiXFx1MDQxNlwiLFwiemhjeVwiOlwiXFx1MDQzNlwiLFwiemlncmFyclwiOlwiXFx1MjFERFwiLFwiem9wZlwiOlwiXFx1RDgzNVxcdURENkJcIixcIlpvcGZcIjpcIlxcdTIxMjRcIixcIlpzY3JcIjpcIlxcdUQ4MzVcXHVEQ0I1XCIsXCJ6c2NyXCI6XCJcXHVEODM1XFx1RENDRlwiLFwiendqXCI6XCJcXHUyMDBEXCIsXCJ6d25qXCI6XCJcXHUyMDBDXCJ9IiwibW9kdWxlLmV4cG9ydHM9e1wiQWFjdXRlXCI6XCJcXHUwMEMxXCIsXCJhYWN1dGVcIjpcIlxcdTAwRTFcIixcIkFjaXJjXCI6XCJcXHUwMEMyXCIsXCJhY2lyY1wiOlwiXFx1MDBFMlwiLFwiYWN1dGVcIjpcIlxcdTAwQjRcIixcIkFFbGlnXCI6XCJcXHUwMEM2XCIsXCJhZWxpZ1wiOlwiXFx1MDBFNlwiLFwiQWdyYXZlXCI6XCJcXHUwMEMwXCIsXCJhZ3JhdmVcIjpcIlxcdTAwRTBcIixcImFtcFwiOlwiJlwiLFwiQU1QXCI6XCImXCIsXCJBcmluZ1wiOlwiXFx1MDBDNVwiLFwiYXJpbmdcIjpcIlxcdTAwRTVcIixcIkF0aWxkZVwiOlwiXFx1MDBDM1wiLFwiYXRpbGRlXCI6XCJcXHUwMEUzXCIsXCJBdW1sXCI6XCJcXHUwMEM0XCIsXCJhdW1sXCI6XCJcXHUwMEU0XCIsXCJicnZiYXJcIjpcIlxcdTAwQTZcIixcIkNjZWRpbFwiOlwiXFx1MDBDN1wiLFwiY2NlZGlsXCI6XCJcXHUwMEU3XCIsXCJjZWRpbFwiOlwiXFx1MDBCOFwiLFwiY2VudFwiOlwiXFx1MDBBMlwiLFwiY29weVwiOlwiXFx1MDBBOVwiLFwiQ09QWVwiOlwiXFx1MDBBOVwiLFwiY3VycmVuXCI6XCJcXHUwMEE0XCIsXCJkZWdcIjpcIlxcdTAwQjBcIixcImRpdmlkZVwiOlwiXFx1MDBGN1wiLFwiRWFjdXRlXCI6XCJcXHUwMEM5XCIsXCJlYWN1dGVcIjpcIlxcdTAwRTlcIixcIkVjaXJjXCI6XCJcXHUwMENBXCIsXCJlY2lyY1wiOlwiXFx1MDBFQVwiLFwiRWdyYXZlXCI6XCJcXHUwMEM4XCIsXCJlZ3JhdmVcIjpcIlxcdTAwRThcIixcIkVUSFwiOlwiXFx1MDBEMFwiLFwiZXRoXCI6XCJcXHUwMEYwXCIsXCJFdW1sXCI6XCJcXHUwMENCXCIsXCJldW1sXCI6XCJcXHUwMEVCXCIsXCJmcmFjMTJcIjpcIlxcdTAwQkRcIixcImZyYWMxNFwiOlwiXFx1MDBCQ1wiLFwiZnJhYzM0XCI6XCJcXHUwMEJFXCIsXCJndFwiOlwiPlwiLFwiR1RcIjpcIj5cIixcIklhY3V0ZVwiOlwiXFx1MDBDRFwiLFwiaWFjdXRlXCI6XCJcXHUwMEVEXCIsXCJJY2lyY1wiOlwiXFx1MDBDRVwiLFwiaWNpcmNcIjpcIlxcdTAwRUVcIixcImlleGNsXCI6XCJcXHUwMEExXCIsXCJJZ3JhdmVcIjpcIlxcdTAwQ0NcIixcImlncmF2ZVwiOlwiXFx1MDBFQ1wiLFwiaXF1ZXN0XCI6XCJcXHUwMEJGXCIsXCJJdW1sXCI6XCJcXHUwMENGXCIsXCJpdW1sXCI6XCJcXHUwMEVGXCIsXCJsYXF1b1wiOlwiXFx1MDBBQlwiLFwibHRcIjpcIjxcIixcIkxUXCI6XCI8XCIsXCJtYWNyXCI6XCJcXHUwMEFGXCIsXCJtaWNyb1wiOlwiXFx1MDBCNVwiLFwibWlkZG90XCI6XCJcXHUwMEI3XCIsXCJuYnNwXCI6XCJcXHUwMEEwXCIsXCJub3RcIjpcIlxcdTAwQUNcIixcIk50aWxkZVwiOlwiXFx1MDBEMVwiLFwibnRpbGRlXCI6XCJcXHUwMEYxXCIsXCJPYWN1dGVcIjpcIlxcdTAwRDNcIixcIm9hY3V0ZVwiOlwiXFx1MDBGM1wiLFwiT2NpcmNcIjpcIlxcdTAwRDRcIixcIm9jaXJjXCI6XCJcXHUwMEY0XCIsXCJPZ3JhdmVcIjpcIlxcdTAwRDJcIixcIm9ncmF2ZVwiOlwiXFx1MDBGMlwiLFwib3JkZlwiOlwiXFx1MDBBQVwiLFwib3JkbVwiOlwiXFx1MDBCQVwiLFwiT3NsYXNoXCI6XCJcXHUwMEQ4XCIsXCJvc2xhc2hcIjpcIlxcdTAwRjhcIixcIk90aWxkZVwiOlwiXFx1MDBENVwiLFwib3RpbGRlXCI6XCJcXHUwMEY1XCIsXCJPdW1sXCI6XCJcXHUwMEQ2XCIsXCJvdW1sXCI6XCJcXHUwMEY2XCIsXCJwYXJhXCI6XCJcXHUwMEI2XCIsXCJwbHVzbW5cIjpcIlxcdTAwQjFcIixcInBvdW5kXCI6XCJcXHUwMEEzXCIsXCJxdW90XCI6XCJcXFwiXCIsXCJRVU9UXCI6XCJcXFwiXCIsXCJyYXF1b1wiOlwiXFx1MDBCQlwiLFwicmVnXCI6XCJcXHUwMEFFXCIsXCJSRUdcIjpcIlxcdTAwQUVcIixcInNlY3RcIjpcIlxcdTAwQTdcIixcInNoeVwiOlwiXFx1MDBBRFwiLFwic3VwMVwiOlwiXFx1MDBCOVwiLFwic3VwMlwiOlwiXFx1MDBCMlwiLFwic3VwM1wiOlwiXFx1MDBCM1wiLFwic3psaWdcIjpcIlxcdTAwREZcIixcIlRIT1JOXCI6XCJcXHUwMERFXCIsXCJ0aG9yblwiOlwiXFx1MDBGRVwiLFwidGltZXNcIjpcIlxcdTAwRDdcIixcIlVhY3V0ZVwiOlwiXFx1MDBEQVwiLFwidWFjdXRlXCI6XCJcXHUwMEZBXCIsXCJVY2lyY1wiOlwiXFx1MDBEQlwiLFwidWNpcmNcIjpcIlxcdTAwRkJcIixcIlVncmF2ZVwiOlwiXFx1MDBEOVwiLFwidWdyYXZlXCI6XCJcXHUwMEY5XCIsXCJ1bWxcIjpcIlxcdTAwQThcIixcIlV1bWxcIjpcIlxcdTAwRENcIixcInV1bWxcIjpcIlxcdTAwRkNcIixcIllhY3V0ZVwiOlwiXFx1MDBERFwiLFwieWFjdXRlXCI6XCJcXHUwMEZEXCIsXCJ5ZW5cIjpcIlxcdTAwQTVcIixcInl1bWxcIjpcIlxcdTAwRkZcIn0iLCJtb2R1bGUuZXhwb3J0cz17XCJhbXBcIjpcIiZcIixcImFwb3NcIjpcIidcIixcImd0XCI6XCI+XCIsXCJsdFwiOlwiPFwiLFwicXVvdFwiOlwiXFxcIlwifVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcImh0bWxcIjoge1xuICAgIFwiY29udGVudFwiOiBbIFwiPGhlYWQ+XCIsIFwiPGJvZHk+XCIgXSxcbiAgICBcInNpbmd1bGFyXCI6IHRydWVcbiAgfSxcbiAgXCJoZWFkXCI6IHtcbiAgICBcImNvbnRlbnRcIjogWyBcIm1ldGFkYXRhIGNvbnRlbnRcIiBdLFxuICAgIFwicGFyZW50XCI6IFsgXCI8aHRtbD5cIiBdLFxuICAgIFwic2luZ3VsYXJcIjogdHJ1ZVxuICB9LFxuICBcImJvZHlcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwic2VjdGlvbmluZyByb290XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcImZsb3cgY29udGVudFwiIF0sXG4gICAgXCJwYXJlbnRcIjogWyBcIjxodG1sPlwiIF0sXG4gICAgXCJzaW5ndWxhclwiOiB0cnVlXG4gIH0sXG5cbiAgXCJ0aXRsZVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJtZXRhZGF0YSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInRleHRcIiBdLFxuICAgIFwicGFyZW50XCI6IFsgXCI8aGVhZD5cIiBdLFxuICAgIFwic2luZ3VsYXJcIjogdHJ1ZVxuICB9LFxuICBcImJhc2VcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwibWV0YWRhdGEgY29udGVudFwiIF0sXG4gICAgXCJwYXJlbnRcIjogWyBcIjxoZWFkPlwiIF0sXG4gICAgXCJzaW5ndWxhclwiOiB0cnVlXG4gIH0sXG4gIFwibGlua1wiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJtZXRhZGF0YSBjb250ZW50XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPGhlYWQ+XCIgXVxuICB9LFxuICBcIm1ldGFcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwibWV0YWRhdGEgY29udGVudFwiIF0sXG4gICAgXCJwYXJlbnRcIjogWyBcIjxoZWFkPlwiIF1cbiAgfSxcbiAgXCJzdHlsZVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJtZXRhZGF0YSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInRleHRcIiBdLFxuICAgIFwicGFyZW50XCI6IFsgXCI8aGVhZD5cIiBdXG4gIH0sXG5cbiAgXCJhZGRyZXNzXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwiZmxvdyBjb250ZW50XCIgXSxcbiAgICBcImRpc2FsbG93XCI6IFsgXCI8YWRkcmVzcz5cIiwgXCJoZWFkaW5nIGNvbnRlbnRcIiwgXCJzZWN0aW9uaW5nIGNvbnRlbnRcIiwgXCI8aGVhZGVyPlwiLCBcIjxmb290ZXI+XCIgXVxuICB9LFxuICBcImFydGljbGVcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwic2VjdGlvbmluZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJmbG93IGNvbnRlbnRcIiBdLFxuICAgIFwiZGlzYWxsb3dcIjogWyBcIjxtYWluPlwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiBdXG4gIH0sXG4gIFwiYXNpZGVcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwic2VjdGlvbmluZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJmbG93IGNvbnRlbnRcIiBdLFxuICAgIFwiZGlzYWxsb3dcIjogWyBcIjxtYWluPlwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiBdXG4gIH0sXG4gIFwiZm9vdGVyXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwiZmxvdyBjb250ZW50XCIgXSxcbiAgICBcImRpc2FsbG93XCI6IFsgXCI8Zm9vdGVyPlwiLCBcIjxoZWFkZXI+XCIsIFwiPG1haW4+XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcbiAgXCJoZWFkZXJcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJmbG93IGNvbnRlbnRcIiBdLFxuICAgIFwiZGlzYWxsb3dcIjogWyBcIjxmb290ZXI+XCIsIFwiPGhlYWRlcj5cIiwgXCI8bWFpbj5cIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuICBcImgxXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcImhlYWRpbmcgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiIF1cbiAgfSxcbiAgXCJoMlwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJoZWFkaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwiaDNcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwiaGVhZGluZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcImg0XCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcImhlYWRpbmcgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiIF1cbiAgfSxcbiAgXCJoNVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJoZWFkaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwiaDZcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwiaGVhZGluZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcIm5hdlwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJzZWN0aW9uaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcImZsb3cgY29udGVudFwiIF0sXG4gICAgXCJkaXNhbGxvd1wiOiBbIFwiPG1haW4+XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcblxuICBcImJsb2NrcXVvdGVcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwic2VjdGlvbmluZyByb290XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJmbG93IGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwiZGRcIjoge1xuICAgIFwiY29udGVudFwiOiBbIFwiZmxvdyBjb250ZW50XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPGRsPlwiIF0sXG4gICAgXCJwcmV2aW91c1wiOiBbIFwiPGR0PlwiLCBcIjxkZD5cIiBdXG4gIH0sXG4gIFwiZGl2XCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwiZmxvdyBjb250ZW50XCIgXVxuICB9LFxuICBcImRsXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCI8ZHQ+XCIsIFwiPGRkPlwiIF1cbiAgfSxcbiAgXCJkdFwiOiB7XG4gICAgXCJjb250ZW50XCI6IFsgXCJmbG93IGNvbnRlbnRcIiBdLFxuICAgIFwicGFyZW50XCI6IFsgXCI8ZGw+XCIgXSxcbiAgICBcImRpc2FsbG93XCI6IFsgXCI8Zm9vdGVyPlwiLCBcIjxoZWFkZXI+XCIsIFwic2VjdGlvbmluZyBjb250ZW50XCIsIFwiaGVhZGluZyBjb250ZW50XCIgXSxcbiAgICBcIm5leHRcIjogWyBcIjxkdD5cIiwgXCI8ZGQ+XCIgXVxuICB9LFxuICBcImZpZ2NhcHRpb25cIjoge1xuICAgIFwiY29udGVudFwiOiBbIFwiZmxvdyBjb250ZW50XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPGZpZ3VyZT5cIiBdLFxuICAgIFwicG9zaXRpb25cIjogWyBcImZpcnN0XCIsIFwibGFzdFwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiBdXG4gIH0sXG4gIFwiZmlndXJlXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInNlY3Rpb25pbmcgcm9vdFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwiPGZpZ2NhcHRpb24+XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcbiAgXCJoclwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwibGlcIjoge1xuICAgIFwiY29udGVudFwiOiBbIFwiZmxvdyBjb250ZW50XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPHVsPlwiLCBcIjxvbD5cIiwgXCI8bWVudT5cIiBdXG4gIH0sXG4gIFwibWFpblwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcImZsb3cgY29udGVudFwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiBdXG4gIH0sXG4gIFwib2xcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcIjxsaT5cIiBdLFxuICAgIFwic3RhdGVzXCI6IHtcbiAgICAgIFwiOm5vdCg6ZW1wdHkpXCI6IHtcbiAgICAgICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJwYWxwYWJsZSBjb250ZW50XCIgXVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJwXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiIF1cbiAgfSxcbiAgXCJwcmVcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcInNlY3Rpb25cIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwic2VjdGlvbmluZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJmbG93IGNvbnRlbnRcIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuICBcInVsXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCI8bGk+XCIgXSxcbiAgICBcInN0YXRlc1wiOiB7XG4gICAgICBcIjpub3QoOmVtcHR5KVwiOiB7XG4gICAgICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwicGFscGFibGUgY29udGVudFwiIF1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgXCJhXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwiZGlzYWxsb3dcIjogWyBcImludGVyYWN0aXZlIGNvbnRlbnRcIiBdLFxuICAgIFwic3RhdGVzXCI6IHtcbiAgICAgIFwiW2hyZWZdXCIgOiB7XG4gICAgICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiaW50ZXJhY3RpdmUgY29udGVudFwiIF1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwiYWJiclwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcImJcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiIF1cbiAgfSxcbiAgXCJiZGlcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiBdXG4gIH0sXG4gIFwiYmRvXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuICBcImJyXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwiY2l0ZVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcImNvZGVcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiIF1cbiAgfSxcbiAgXCJkYXRhXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuICBcImRmblwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXSxcbiAgICBcImRpc2FsbG93XCI6IFsgXCI8ZGZuPlwiIF1cbiAgfSxcbiAgXCJlbVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcImlcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiIF1cbiAgfSxcbiAgXCJrYmRcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiIF1cbiAgfSxcbiAgXCJtYXJrXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuICBcInFcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiIF1cbiAgfSxcbiAgXCJycFwiOiB7XG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPHJ1Ynk+XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcbiAgXCJydFwiOiB7XG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPHJ1Ynk+XCIsIFwiPHJ0Yz5cIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuICBcInJ0Y1wiOiB7XG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIsIFwiPHJ0PlwiIF0sXG4gICAgXCJwYXJlbnRcIjogWyBcIjxydWJ5PlwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiBdXG4gIH0sXG4gIFwicnVieVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCI8cnA+XCIsIFwiPHJ0PlwiLCBcIjxydGM+XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcbiAgXCJzXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwic2FtcFwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcInNtYWxsXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwic3BhblwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcInN0cm9uZ1wiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcInN1YlwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcInN1cFwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcInRpbWVcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiBdXG4gIH0sXG4gIFwidVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcInZhclwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcIndiclwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcblxuICBcImFyZWFcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiIF0sXG4gICAgXCJhbmNlc3RvclwiOiBbIFwiPG1hcD5cIiBdXG4gIH0sXG4gIFwiYXVkaW9cIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcImVtYmVkZGVkIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwidHJhbnNwYXJlbnRcIiwgXCI8dHJhY2s+XCIgXSxcbiAgICBcImRpc2FsbG93XCI6IFsgXCI8YXVkaW8+XCIsIFwiPHZpZGVvPlwiIF0sXG4gICAgXCJzdGF0ZXNcIjoge1xuICAgICAgXCJbY29udHJvbHNdXCI6IHtcbiAgICAgICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJpbnRlcmFjdGl2ZSBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF1cbiAgICAgIH0sXG4gICAgICBcIjpub3QoW3NyY10pXCI6IHtcbiAgICAgICAgXCJjb250ZW50XCI6IFsgXCI8c291cmNlPlwiIF1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuICBcIm1hcFwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJ0cmFuc3BhcmVudFwiLCBcIjxhcmVhPlwiIF1cbiAgfSxcbiAgXCJ0cmFja1wiOiB7XG4gICAgXCJwYXJlbnRcIjogWyBcIjxhdWRpbz5cIiwgXCI8dmlkZW8+XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcbiAgXCJ2aWRlb1wiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwiZW1iZWRkZWQgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJ0cmFuc3BhcmVudFwiLCBcIjx0cmFjaz5cIiBdLFxuICAgIFwiZGlzYWxsb3dcIjogWyBcIjxhdWRpbz5cIiwgXCI8dmlkZW8+XCIgXSxcbiAgICBcInN0YXRlc1wiOiB7XG4gICAgICBcIltjb250cm9sc11cIjoge1xuICAgICAgICBcImNhdGVnb3JpZXNcIjogWyBcImludGVyYWN0aXZlIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXVxuICAgICAgfSxcbiAgICAgIFwiOm5vdChbc3JjXSlcIjoge1xuICAgICAgICBcImNvbnRlbnRcIjogWyBcIjxzb3VyY2U+XCIgXVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiBdXG4gIH0sXG5cbiAgXCJlbWJlZFwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwiZW1iZWRkZWQgY29udGVudFwiLCBcImludGVyYWN0aXZlIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcbiAgXCJpZnJhbWVcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcImVtYmVkZGVkIGNvbnRlbnRcIiwgXCJpbnRlcmFjdGl2ZSBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXSxcbiAgICBcImRpc2FsbG93XCI6IFsgXCI8c2NyaXB0PlwiIF1cbiAgfSxcbiAgXCJpbWdcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcImVtYmVkZGVkIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcInN0YXRlc1wiOiB7XG4gICAgICBcIlt1c2VtYXBdXCI6IHtcbiAgICAgICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJpbnRlcmFjdGl2ZSBjb250ZW50XCIgXVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJvYmplY3RcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcImVtYmVkZGVkIGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIsIFwiZm9ybS1hc3NvY2lhdGVkIGNvbnRlbnRcIiwgXCJsaXN0ZWRcIiwgXCJzdWJtaXR0YWJsZVwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJ0cmFuc3BhcmVudFwiLCBcIjxwYXJhbT5cIiBdLFxuICAgIFwic3RhdGVzXCI6IHtcbiAgICAgIFwiW3VzZW1hcF1cIjoge1xuICAgICAgICBcImNhdGVnb3JpZXNcIjogWyBcImludGVyYWN0aXZlIGNvbnRlbnRcIiBdXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcInBhcmFtXCI6IHtcbiAgICBcInBhcmVudFwiOiBbIFwiPG9iamVjdD5cIiBdXG4gIH0sXG4gIFwic291cmNlXCI6IHtcbiAgICBcInBhcmVudFwiOiBbIFwiPHBpY3R1cmU+XCIsIFwiPGF1ZGlvPlwiLCBcIjx2aWRlbz5cIiBdLFxuICAgIFwicG9zaXRpb25cIjogWyBcImZpcnN0XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcblxuICBcImNhbnZhc1wiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwiZW1iZWRkZWQgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwidHJhbnNwYXJlbnRcIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuICBcIm5vc2NyaXB0XCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJtZXRhZGF0YSBjb250ZW50XCIgXSxcbiAgICBcImRpc2FsbG93XCI6IFsgXCI8bm9zY3JpcHQ+XCIgXSxcbiAgICBcInN0YXRlc1wiOiB7XG4gICAgICBcImhlYWQgPiBub3NjcmlwdFwiOiB7XG4gICAgICAgIFwiY29udGVudFwiOiBbIFwiPGxpbms+XCIsIFwiPHN0eWxlPlwiLCBcIjxtZXRhPlwiIF1cbiAgICAgIH0sXG4gICAgICBcIjpub3QoIGhlYWQgPiBub3NjcmlwdCApXCI6IHtcbiAgICAgICAgXCJjb250ZW50XCI6IFsgXCJ0cmFuc3BhcmVudFwiIF1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwic2NyaXB0XCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJtZXRhZGF0YSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcInRleHRcIiBdXG4gIH0sXG4gIFwidGVtcGxhdGVcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwibWV0YWRhdGEgY29udGVudFwiLCBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwibWV0YWRhdGEgY29udGVudFwiLCBcImZsb3cgY29udGVudFwiIF0sXG4gICAgXCJwYXJlbnRcIjogWyBcImJvZHlcIiwgXCJoZWFkXCIsIFwiY29sZ3JvdXBcIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIgXVxuICB9LFxuXG4gIFwiZGVsXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwidHJhbnNwYXJlbnRcIiBdXG4gIH0sXG4gIFwiaW5zXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwidHJhbnNwYXJlbnRcIiBdXG4gIH0sXG5cbiAgXCJjYXB0aW9uXCI6IHtcbiAgICBcImNvbnRlbnRcIjogWyBcImZsb3cgY29udGVudFwiIF0sXG4gICAgXCJwYXJlbnRcIjogWyBcIjx0YWJsZT5cIiBdLFxuICAgIFwicG9zaXRpb25cIjogWyBcImZpcnN0XCIgXVxuICB9LFxuICBcImNvbFwiOiB7XG4gICAgXCJwYXJlbnRcIjogWyBcIjxjb2xncm91cD5cIiBdXG4gIH0sXG4gIFwiY29sZ3JvdXBcIjoge1xuICAgIFwicGFyZW50XCI6IFsgXCI8dGFibGU+XCIgXSxcbiAgICBcInN0YXRlc1wiOiB7XG4gICAgICBcIjpub3QoW3NwYW5dKVwiOiB7XG4gICAgICAgIFwiY29udGVudFwiOiBbIFwiPGNvbD5cIiBdXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcInRhYmxlXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCI8Y2FwdGlvbj5cIiwgXCI8Y29sZ3JvdXA+XCIsIFwiPHRoZWFkPlwiLCBcIjx0Ym9keT5cIiwgXCI8dGZvb3Q+XCIsIFwiPHRyPlwiIF1cbiAgfSxcbiAgXCJ0Ym9keVwiOiB7XG4gICAgXCJjb250ZW50XCI6IFsgXCI8dHI+XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPHRhYmxlPlwiIF1cbiAgfSxcbiAgXCJ0ZFwiOiB7XG4gICAgXCJjb250ZW50XCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPHRyPlwiIF1cbiAgfSxcbiAgXCJ0Zm9vdFwiOiB7XG4gICAgXCJjb250ZW50XCI6IFsgXCI8dHI+XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPHRhYmxlPlwiIF1cbiAgfSxcbiAgXCJ0aFwiOiB7XG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPHRyPlwiIF1cbiAgfSxcbiAgXCJ0aGVhZFwiOiB7XG4gICAgXCJjb250ZW50XCI6IFsgXCI8dHI+XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPHRhYmxlPlwiIF1cbiAgfSxcbiAgXCJ0clwiOiB7XG4gICAgXCJjb250ZW50XCI6IFsgXCI8dGg+XCIsIFwiPHRkPlwiIF0sXG4gICAgXCJwYXJlbnRcIjogWyBcIjx0YWJsZT5cIiwgXCI8dGhlYWQ+XCIsIFwiPHRib2R5PlwiLCBcIjx0Zm9vdD5cIiBdXG4gIH0sXG5cbiAgXCJidXR0b25cIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcImludGVyYWN0aXZlIGNvbnRlbnRcIiwgXCJmb3JtLWFzc29jaWF0ZWQgY29udGVudFwiLCBcImxpc3RlZFwiLCBcImxhYmVsYWJsZVwiLCBcInN1Ym1pdHRhYmxlXCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXVxuICB9LFxuICBcImRhdGFsaXN0XCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiLCBcIjxvcHRpb24+XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcbiAgXCJmaWVsZHNldFwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJzZWN0aW9uaW5nIHJvb3RcIiwgXCJmb3JtLWFzc29jaWF0ZWQgY29udGVudFwiLCBcImxpc3RlZFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwiPGxlZ2VuZD5cIiwgXCJmbG93IGNvbnRlbnRcIiBdXG4gIH0sXG4gIFwiZm9ybVwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICBcImNvbnRlbnRcIjogWyBcImZsb3cgY29udGVudFwiIF0sXG4gICAgXCJkaXNhbGxvd1wiOiBbIFwiPGZvcm0+XCIgXVxuICB9LFxuICBcImlucHV0XCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJmb3JtLWFzc29jaWF0ZWQgY29udGVudFwiLCBcImxpc3RlZFwiLCBcInN1Ym1pdHRhYmxlXCIsIFwicmVzZXR0YWJsZVwiIF0sXG4gICAgXCJzdGF0ZXNcIjoge1xuICAgICAgXCI6bm90KFt0eXBlPWhpZGRlbl0pXCI6IHtcbiAgICAgICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJsYWJlbGFibGVcIiwgXCJwYWxwYWJsZSBjb250ZW50XCIgXVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJsYWJlbFwiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJwaHJhc2luZyBjb250ZW50XCIsIFwiaW50ZXJhY3RpdmUgY29udGVudFwiLCBcImZvcm0tYXNzb2NpYXRlZCBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXSxcbiAgICBcImRpc2FsbG93XCI6IFsgXCI8bGFiZWw+XCIgXVxuICB9LFxuICBcImxlZ2VuZFwiOiB7XG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPGZpZWxkc2V0PlwiIF0sXG4gICAgXCJwb3NpdGlvblwiOiBbIFwiZmlyc3RcIiBdXG4gIH0sXG4gIFwibWV0ZXJcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcImZvcm0tYXNzb2NpYXRlZCBjb250ZW50XCIsIFwibGFiZWxhYmxlXCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXSxcbiAgICBcImRpc2FsbG93XCI6IFsgXCI8bWV0ZXI+XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcbiAgXCJvcHRncm91cFwiOiB7XG4gICAgXCJjb250ZW50XCI6IFsgXCI8b3B0aW9uPlwiIF0sXG4gICAgXCJwYXJlbnRcIjogWyBcIjxzZWxlY3Q+XCIgXVxuICB9LFxuICBcIm9wdGlvblwiOiB7XG4gICAgXCJjb250ZW50XCI6IFsgXCJ0ZXh0XCIgXSxcbiAgICBcInBhcmVudFwiOiBbIFwiPHNlbGVjdD5cIiwgXCI8b3B0Z3JvdXA+XCIsIFwiPGRhdGFsaXN0PlwiIF1cbiAgfSxcbiAgXCJvdXRwdXRcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcImZvcm0tYXNzb2NpYXRlZCBjb250ZW50XCIsIFwibGlzdGVkXCIsIFwibGFiZWxhYmxlXCIsIFwicmVzZXR0YWJsZVwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwicGhyYXNpbmcgY29udGVudFwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiBdXG4gIH0sXG4gIFwicHJvZ3Jlc3NcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcImZvcm0tYXNzb2NpYXRlZCBjb250ZW50XCIsIFwibGFiZWxhYmxlXCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJwaHJhc2luZyBjb250ZW50XCIgXSxcbiAgICBcImRpc2FsbG93XCI6IFsgXCI8cHJvZ3Jlc3M+XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiIF1cbiAgfSxcbiAgXCJzZWxlY3RcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcImludGVyYWN0aXZlIGNvbnRlbnRcIiwgXCJmb3JtLWFzc29jaWF0ZWQgY29udGVudFwiLCBcImxpc3RlZFwiLCBcImxhYmVsYWJsZVwiLCBcInN1Ym1pdHRhYmxlXCIsIFwicmVzZXR0YWJsZVwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCI8b3B0Z3JvdXA+XCIsIFwiPG9wdGlvbj5cIiBdXG4gIH0sXG4gIFwidGV4dGFyZWFcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcImludGVyYWN0aXZlIGNvbnRlbnRcIiwgXCJmb3JtLWFzc29jaWF0ZWQgY29udGVudFwiLCBcImxpc3RlZFwiLCBcImxhYmVsYWJsZVwiLCBcInN1Ym1pdHRhYmxlXCIsIFwicmVzZXR0YWJsZVwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCJ0ZXh0XCIgXVxuICB9LFxuXG4gIFwiZGV0YWlsc1wiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJzZWN0aW9uaW5nIHJvb3RcIiwgXCJpbnRlcmFjdGl2ZSBjb250ZW50XCIsIFwicGFscGFibGUgY29udGVudFwiIF0sXG4gICAgXCJjb250ZW50XCI6IFsgXCI8c3VtbWFyeT5cIiwgXCJmbG93IGNvbnRlbnRcIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIsIFwiNVwiIF0sXG4gICAgXCJleHBlcmltZW50YWxcIjogdHJ1ZVxuICB9LFxuICBcImRpYWxvZ1wiOiB7XG4gICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCJzZWN0aW9uaW5nIHJvb3RcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwiZmxvdyBjb250ZW50XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiLCBcIjVcIiBdLFxuICAgIFwiZXhwZXJpbWVudGFsXCI6IHRydWVcbiAgfSxcbiAgIFwiaGdyb3VwXCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiLCBcImhlYWRpbmcgY29udGVudFwiLCBcInBhbHBhYmxlIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwiPGgxPlwiLCBcIjxoMj5cIiwgXCI8aDM+XCIsIFwiPGg0PlwiLCBcIjxoNT5cIiwgXCI8aDY+XCIgXSxcbiAgICBcIm5vc3BlY1wiOiBbIFwiNC4wMVwiLCBcIjVcIiBdLFxuICAgIFwiZXhwZXJpbWVudGFsXCI6IHRydWVcbiAgfSxcbiAgXCJtZW51XCI6IHtcbiAgICBcImNhdGVnb3JpZXNcIjogWyBcImZsb3cgY29udGVudFwiIF0sXG4gICAgXCJzdGF0ZXNcIjoge1xuICAgICAgXCJbdHlwZT1saXN0XSwgOm5vdChbdHlwZV0pXCI6IHtcbiAgICAgICAgXCJjYXRlZ29yaWVzXCI6IFsgXCJwYWxwYWJsZSBjb250ZW50XCIgXSxcbiAgICAgICAgXCJjb250ZW50XCI6IFsgXCJmbG93IGNvbnRlbnRcIiwgXCI8bGk+XCIsIFwiPHNjcmlwdD5cIiwgXCI8dGVtcGxhdGU+XCIgXVxuICAgICAgfSxcbiAgICAgIFwiW3R5cGU9bWVudV1cIjoge1xuICAgICAgICBcImNvbnRlbnRcIjogWyBcIjxzY3JpcHQ+XCIsIFwiPHRlbXBsYXRlPlwiLCBcIjxtZW51PlwiLCBcIjxtZW51aXRlbT5cIiwgXCI8aHI+XCIgXVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiwgXCI1XCIgXSxcbiAgICBcImV4cGVyaW1lbnRhbFwiOiB0cnVlXG4gIH0sXG4gIFwibWVudWl0ZW1cIjoge1xuICAgIFwicGFyZW50XCI6IFsgXCI8bWVudT5cIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIsIFwiNVwiIF0sXG4gICAgXCJleHBlcmltZW50YWxcIjogdHJ1ZVxuICB9LFxuICBcInBpY3R1cmVcIjoge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBbIFwiZmxvdyBjb250ZW50XCIsIFwicGhyYXNpbmcgY29udGVudFwiLCBcImVtYmVkZGVkIGNvbnRlbnRcIiBdLFxuICAgIFwiY29udGVudFwiOiBbIFwiPHNvdXJjZT5cIiwgXCI8aW1nPlwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiwgXCI1XCIsIFwiNS4xXCIgXSxcbiAgICBcImV4cGVyaW1lbnRhbFwiOiB0cnVlXG4gIH0sXG4gIFwic2hhZG93XCI6IHtcbiAgICBcImNvbnRlbnRcIjogWyBcImZsb3cgY29udGVudFwiIF0sXG4gICAgXCJub3NwZWNcIjogWyBcIjQuMDFcIiwgXCI1XCIsIFwiNS4xXCIsIFwiTFNcIiBdLFxuICAgIFwiZXhwZXJpbWVudGFsXCI6IHRydWVcbiAgfSxcbiAgXCJzdW1tYXJ5XCI6IHtcbiAgICBcImNvbnRlbnRcIjogWyBcInBocmFzaW5nIGNvbnRlbnRcIiwgXCJoZWFkaW5nIGNvbnRlbnRcIiBdLFxuICAgIFwicGFyZW50XCI6IFsgXCI8ZGV0YWlscz5cIiBdLFxuICAgIFwibm9zcGVjXCI6IFsgXCI0LjAxXCIsIFwiNVwiIF0sXG4gICAgXCJleHBlcmltZW50YWxcIjogdHJ1ZVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZWxlbWVudERhdGEgPSByZXF1aXJlKCcuLi9kYXRhL2VsZW1lbnRzLmpzb24nKTtcclxudmFyIHNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYS9oaW5mby5zY2hlbWEuanNvbicpO1xyXG5cclxuLy8gZW5zdXJlIGEgZnJlc2ggY29weSwgaW4gY2FzZSB0aGUgY29uc3VtZXIgbW9kaWZpZXMgaXRcclxudmFyIGhpbmZvID0gZnVuY3Rpb24gaGluZm8oKSB7XHJcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZWxlbWVudERhdGEpKTtcclxufTtcclxuXHJcbmhpbmZvLnNjaGVtYSA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzY2hlbWEpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaGluZm87IiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICAgIFwidGl0bGVcIjogXCJodG1sIGVsZW1lbnQgbWV0YSBkYXRhXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcInNjaGVtYSBmb3IgaHRtbCBlbGVtZW50IG1ldGEgZGF0YVwiLFxuICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgIFwicGF0dGVyblByb3BlcnRpZXNcIjoge1xuICAgICAgICBcIl5bYS16XVthLXpcXFxcZF0qJFwiOiB7XG4gICAgICAgICAgICBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL2VsZW1lbnREZWZcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlLFxuICAgIFwiZGVmaW5pdGlvbnNcIjoge1xuICAgICAgICBcImVsZW1lbnREZWZcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICAgICAgICAgIFwiY2F0ZWdvcmllc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvY2F0ZWdvcnlBcnJheURlZlwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImNvbnRlbnRcIjoge1xuICAgICAgICAgICAgICAgICAgICBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5RGVmXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwicGFyZW50XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheURlZlwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImRpc2FsbG93XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheURlZlwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFuY2VzdG9yXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheURlZlwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9wb3NpdGlvbkFycmF5RGVmXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwicHJldmlvdXNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3RhZ0FycmF5RGVmXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwibmV4dFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvdGFnQXJyYXlEZWZcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzdGF0ZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0YXRlRGVmXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwibm9zcGVjXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub3NwZWNEZWZcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzaW5ndWxhclwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJleHBlcmltZW50YWxcIjoge1xuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcInN0cmluZ0FycmF5RGVmXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidW5pcXVlSXRlbXNcIjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBcInRhZ0FycmF5RGVmXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcInBhdHRlcm5cIjogXCJePFthLXpdW2EtejAtOV0qPiRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidW5pcXVlSXRlbXNcIjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBcImNhdGVnb3J5QXJyYXlEZWZcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwiZW1iZWRkZWQgY29udGVudFwiLFxuICAgICAgICAgICAgICAgICAgICBcImZsb3cgY29udGVudFwiLFxuICAgICAgICAgICAgICAgICAgICBcImZvcm0tYXNzb2NpYXRlZCBjb250ZW50XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGVhZGluZyBjb250ZW50XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW50ZXJhY3RpdmUgY29udGVudFwiLFxuICAgICAgICAgICAgICAgICAgICBcImxhYmVsYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpc3RlZFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm1ldGFkYXRhIGNvbnRlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwYWxwYWJsZSBjb250ZW50XCIsXG4gICAgICAgICAgICAgICAgICAgIFwicGhyYXNpbmcgY29udGVudFwiLFxuICAgICAgICAgICAgICAgICAgICBcInJlc2V0dGFibGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzZWN0aW9uaW5nIGNvbnRlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzZWN0aW9uaW5nIHJvb3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzdWJtaXR0YWJsZVwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidW5pcXVlSXRlbXNcIjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBcInBvc2l0aW9uQXJyYXlEZWZcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwiZmlyc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJsYXN0XCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIFwic3RhdGVEZWZcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICAgICAgICBcIl5bXFxcXHdcXFxcZCA6PSw8PlxcXFwoXFxcXClcXFxcW1xcXFxdXSskXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImNhdGVnb3JpZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc3RyaW5nQXJyYXlEZWZcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29udGVudFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheURlZlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcIm5vc3BlY0RlZlwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICAgICAgXCJtaW5JdGVtc1wiOiAxLFxuICAgICAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCI0LjAxXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiNVwiLFxuICAgICAgICAgICAgICAgICAgICBcIjUuMVwiLFxuICAgICAgICAgICAgICAgICAgICBcIkxTXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXG4gICAgICAgIH1cbiAgICB9XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGluZm8gPSByZXF1aXJlKCdoaW5mbycpO1xuXG52YXIgbm9kZURlZnMgPSB7XG4gICcjZG9jdW1lbnQnOiB7XG4gICAgJ2NvbnRlbnQnOiBbJyNkb2N1bWVudFR5cGUnLCAnPGh0bWw+J11cbiAgfSxcbiAgJyNkb2N1bWVudFR5cGUnOiB7XG4gICAgJ3BhcmVudCc6IFsnI2RvY3VtZW50J11cbiAgfSxcbiAgJyN0ZXh0Jzoge1xuICAgICdjYXRlZ29yaWVzJzogWydmbG93IGNvbnRlbnQnLCAncGhyYXNpbmcgY29udGVudCcsICdwYWxwYWJsZSBjb250ZW50J11cbiAgfSxcbiAgJyNjb21tZW50Jzoge1xuICAgICdjYXRlZ29yaWVzJzogWydmbG93IGNvbnRlbnQnXVxuICB9LFxuICAnI2RvY3VtZW50RnJhZ21lbnQnOiB7XG4gICAgJ2NvbnRlbnQnOiBbJ2Zsb3cgY29udGVudCddXG4gIH1cbn07XG5cbnZhciBlbnN1cmVBcnJheSA9IGZ1bmN0aW9uIGVuc3VyZUFycmF5KG9iaiwgbmFtZSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkob2JqW25hbWVdKSkgb2JqW25hbWVdID0gW107XG59O1xuXG52YXIgZW5zdXJlUHJvcGVydGllcyA9IGZ1bmN0aW9uIGVuc3VyZVByb3BlcnRpZXMoZGVmKSB7XG4gIGVuc3VyZUFycmF5KGRlZiwgJ2NhdGVnb3JpZXMnKTtcbiAgZW5zdXJlQXJyYXkoZGVmLCAnY29udGVudCcpO1xuICBlbnN1cmVBcnJheShkZWYsICdwYXJlbnQnKTtcbn07XG5cbnZhciBkZWZhdWx0RGVmcyA9IE9iamVjdC5hc3NpZ24oaGluZm8oKSwgbm9kZURlZnMpO1xuXG52YXIgSHRtbCA9IGZ1bmN0aW9uIEh0bWwoKSB7XG4gIHZhciBkZWZzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBkZWZhdWx0RGVmcztcblxuICBkZWZzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkZWZzKSk7XG5cbiAgdmFyIF90YWdOYW1lcyA9IE9iamVjdC5rZXlzKGRlZnMpO1xuXG4gIHZhciBoYXNDYXRlZ29yeSA9IGZ1bmN0aW9uIGhhc0NhdGVnb3J5KHRhZ05hbWUsIGNhdGVnb3J5TmFtZSkge1xuICAgIHJldHVybiBkZWZzW3RhZ05hbWVdLmNhdGVnb3JpZXMuaW5jbHVkZXMoY2F0ZWdvcnlOYW1lKTtcbiAgfTtcblxuICB2YXIgcHJlZGljYXRlcyA9IHtcbiAgICBlbXB0eTogZnVuY3Rpb24gZW1wdHkodGFnTmFtZSkge1xuICAgICAgcmV0dXJuIGRlZnNbdGFnTmFtZV0uY29udGVudC5sZW5ndGggPT09IDA7XG4gICAgfSxcbiAgICBtZXRhZGF0YTogZnVuY3Rpb24gbWV0YWRhdGEodGFnTmFtZSkge1xuICAgICAgcmV0dXJuIGhhc0NhdGVnb3J5KHRhZ05hbWUsICdtZXRhZGF0YSBjb250ZW50Jyk7XG4gICAgfSxcbiAgICBpbmxpbmU6IGZ1bmN0aW9uIGlubGluZSh0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gaGFzQ2F0ZWdvcnkodGFnTmFtZSwgJ3BocmFzaW5nIGNvbnRlbnQnKTtcbiAgICB9LFxuICAgIGVtYmVkZGVkOiBmdW5jdGlvbiBlbWJlZGRlZCh0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gaGFzQ2F0ZWdvcnkodGFnTmFtZSwgJ2VtYmVkZGVkIGNvbnRlbnQnKTtcbiAgICB9LFxuICAgIGJsb2NrOiBmdW5jdGlvbiBibG9jayh0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gaGFzQ2F0ZWdvcnkodGFnTmFtZSwgJ2Zsb3cgY29udGVudCcpICYmICFwcmVkaWNhdGVzLmlubGluZSh0YWdOYW1lKTtcbiAgICB9LFxuICAgIGNvbnRhaW5lcjogZnVuY3Rpb24gY29udGFpbmVyKHRhZ05hbWUpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlcy5lbXB0eSh0YWdOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGRvZXNBY2NlcHQgPSBmdW5jdGlvbiBkb2VzQWNjZXB0KHRhZ05hbWUsIGNoaWxkVGFnTmFtZSkge1xuICAgIGlmIChwcmVkaWNhdGVzLmVtcHR5KHRhZ05hbWUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgZGVmID0gZGVmc1t0YWdOYW1lXTtcbiAgICB2YXIgY2hpbGREZWYgPSBkZWZzW2NoaWxkVGFnTmFtZV07XG5cbiAgICBpZiAoY2hpbGREZWYucGFyZW50LmluY2x1ZGVzKCc8JyArIHRhZ05hbWUgKyAnPicpKSByZXR1cm4gdHJ1ZTtcblxuICAgIGlmIChkZWYuY29udGVudC5pbmNsdWRlcygnPCcgKyBjaGlsZFRhZ05hbWUgKyAnPicpIHx8IGRlZi5jb250ZW50LmluY2x1ZGVzKCcjJyArIGNoaWxkVGFnTmFtZSkpIHJldHVybiB0cnVlO1xuXG4gICAgcmV0dXJuIGNoaWxkRGVmLmNhdGVnb3JpZXMuc29tZShmdW5jdGlvbiAoY2F0ZWdvcnkpIHtcbiAgICAgIHJldHVybiBkZWYuY29udGVudC5pbmNsdWRlcyhjYXRlZ29yeSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHByZWRpY2F0ZU5hbWVzID0gT2JqZWN0LmtleXMocHJlZGljYXRlcyk7XG5cbiAgdmFyIG1hcHMgPSB7XG4gICAgYWNjZXB0czoge31cbiAgfTtcblxuICBwcmVkaWNhdGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIG1hcHNbbmFtZV0gPSB7fTtcbiAgfSk7XG5cbiAgdmFyIGFsbENhdGVnb3JpZXMgPSBbXTtcblxuICBfdGFnTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgIHZhciBkZWYgPSBkZWZzW3RhZ05hbWVdO1xuXG4gICAgZW5zdXJlUHJvcGVydGllcyhkZWYpO1xuXG4gICAgYWxsQ2F0ZWdvcmllcyA9IGFsbENhdGVnb3JpZXMuY29uY2F0KGRlZi5jYXRlZ29yaWVzKTtcblxuICAgIHByZWRpY2F0ZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHByZWRpY2F0ZU5hbWUpIHtcbiAgICAgIHJldHVybiBtYXBzW3ByZWRpY2F0ZU5hbWVdW3RhZ05hbWVdID0gcHJlZGljYXRlc1twcmVkaWNhdGVOYW1lXSh0YWdOYW1lKTtcbiAgICB9KTtcblxuICAgIG1hcHMuYWNjZXB0c1t0YWdOYW1lXSA9IHt9O1xuXG4gICAgX3RhZ05hbWVzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkVGFnTmFtZSkge1xuICAgICAgZW5zdXJlUHJvcGVydGllcyhkZWZzW2NoaWxkVGFnTmFtZV0pO1xuXG4gICAgICBtYXBzLmFjY2VwdHNbdGFnTmFtZV1bY2hpbGRUYWdOYW1lXSA9IGRvZXNBY2NlcHQodGFnTmFtZSwgY2hpbGRUYWdOYW1lKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgdmFyIF9jYXRlZ29yeU5hbWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KGFsbENhdGVnb3JpZXMpKS5zb3J0KCk7XG5cbiAgdmFyIGFwaSA9IHtcbiAgICB0YWdOYW1lczogZnVuY3Rpb24gdGFnTmFtZXMoKSB7XG4gICAgICByZXR1cm4gX3RhZ05hbWVzO1xuICAgIH0sXG4gICAgY2F0ZWdvcnlOYW1lczogZnVuY3Rpb24gY2F0ZWdvcnlOYW1lcygpIHtcbiAgICAgIHJldHVybiBfY2F0ZWdvcnlOYW1lcztcbiAgICB9LFxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkodGFnTmFtZSkge1xuICAgICAgcmV0dXJuIG1hcHMuZW1wdHlbdGFnTmFtZV07XG4gICAgfSxcbiAgICBpc01ldGFkYXRhOiBmdW5jdGlvbiBpc01ldGFkYXRhKHRhZ05hbWUpIHtcbiAgICAgIHJldHVybiBtYXBzLm1ldGFkYXRhW3RhZ05hbWVdO1xuICAgIH0sXG4gICAgaXNJbmxpbmU6IGZ1bmN0aW9uIGlzSW5saW5lKHRhZ05hbWUpIHtcbiAgICAgIHJldHVybiBtYXBzLmlubGluZVt0YWdOYW1lXTtcbiAgICB9LFxuICAgIGlzRW1iZWRkZWQ6IGZ1bmN0aW9uIGlzRW1iZWRkZWQodGFnTmFtZSkge1xuICAgICAgcmV0dXJuIG1hcHMuZW1iZWRkZWRbdGFnTmFtZV07XG4gICAgfSxcbiAgICBpc0Jsb2NrOiBmdW5jdGlvbiBpc0Jsb2NrKHRhZ05hbWUpIHtcbiAgICAgIHJldHVybiBtYXBzLmJsb2NrW3RhZ05hbWVdO1xuICAgIH0sXG4gICAgaXNDb250YWluZXI6IGZ1bmN0aW9uIGlzQ29udGFpbmVyKHRhZ05hbWUpIHtcbiAgICAgIHJldHVybiBtYXBzLmNvbnRhaW5lclt0YWdOYW1lXTtcbiAgICB9LFxuICAgIGFjY2VwdHM6IGZ1bmN0aW9uIGFjY2VwdHModGFnTmFtZSwgY2hpbGRUYWdOYW1lKSB7XG4gICAgICByZXR1cm4gbWFwcy5hY2NlcHRzW3RhZ05hbWVdW2NoaWxkVGFnTmFtZV07XG4gICAgfSxcbiAgICBkZWY6IGZ1bmN0aW9uIGRlZih0YWdOYW1lKSB7XG4gICAgICBpZiAoZGVmc1t0YWdOYW1lXSkgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGVmc1t0YWdOYW1lXSkpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gYXBpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sOyIsIm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGluZ0hhbmRsZXI7XG5cbmZ1bmN0aW9uIENvbGxlY3RpbmdIYW5kbGVyKGNicyl7XG5cdHRoaXMuX2NicyA9IGNicyB8fCB7fTtcblx0dGhpcy5ldmVudHMgPSBbXTtcbn1cblxudmFyIEVWRU5UUyA9IHJlcXVpcmUoXCIuL1wiKS5FVkVOVFM7XG5PYmplY3Qua2V5cyhFVkVOVFMpLmZvckVhY2goZnVuY3Rpb24obmFtZSl7XG5cdGlmKEVWRU5UU1tuYW1lXSA9PT0gMCl7XG5cdFx0bmFtZSA9IFwib25cIiArIG5hbWU7XG5cdFx0Q29sbGVjdGluZ0hhbmRsZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuZXZlbnRzLnB1c2goW25hbWVdKTtcblx0XHRcdGlmKHRoaXMuX2Nic1tuYW1lXSkgdGhpcy5fY2JzW25hbWVdKCk7XG5cdFx0fTtcblx0fSBlbHNlIGlmKEVWRU5UU1tuYW1lXSA9PT0gMSl7XG5cdFx0bmFtZSA9IFwib25cIiArIG5hbWU7XG5cdFx0Q29sbGVjdGluZ0hhbmRsZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oYSl7XG5cdFx0XHR0aGlzLmV2ZW50cy5wdXNoKFtuYW1lLCBhXSk7XG5cdFx0XHRpZih0aGlzLl9jYnNbbmFtZV0pIHRoaXMuX2Nic1tuYW1lXShhKTtcblx0XHR9O1xuXHR9IGVsc2UgaWYoRVZFTlRTW25hbWVdID09PSAyKXtcblx0XHRuYW1lID0gXCJvblwiICsgbmFtZTtcblx0XHRDb2xsZWN0aW5nSGFuZGxlci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbihhLCBiKXtcblx0XHRcdHRoaXMuZXZlbnRzLnB1c2goW25hbWUsIGEsIGJdKTtcblx0XHRcdGlmKHRoaXMuX2Nic1tuYW1lXSkgdGhpcy5fY2JzW25hbWVdKGEsIGIpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzXCIpO1xuXHR9XG59KTtcblxuQ29sbGVjdGluZ0hhbmRsZXIucHJvdG90eXBlLm9ucmVzZXQgPSBmdW5jdGlvbigpe1xuXHR0aGlzLmV2ZW50cyA9IFtdO1xuXHRpZih0aGlzLl9jYnMub25yZXNldCkgdGhpcy5fY2JzLm9ucmVzZXQoKTtcbn07XG5cbkNvbGxlY3RpbmdIYW5kbGVyLnByb3RvdHlwZS5yZXN0YXJ0ID0gZnVuY3Rpb24oKXtcblx0aWYodGhpcy5fY2JzLm9ucmVzZXQpIHRoaXMuX2Nicy5vbnJlc2V0KCk7XG5cblx0Zm9yKHZhciBpID0gMCwgbGVuID0gdGhpcy5ldmVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuXHRcdGlmKHRoaXMuX2Nic1t0aGlzLmV2ZW50c1tpXVswXV0pe1xuXG5cdFx0XHR2YXIgbnVtID0gdGhpcy5ldmVudHNbaV0ubGVuZ3RoO1xuXG5cdFx0XHRpZihudW0gPT09IDEpe1xuXHRcdFx0XHR0aGlzLl9jYnNbdGhpcy5ldmVudHNbaV1bMF1dKCk7XG5cdFx0XHR9IGVsc2UgaWYobnVtID09PSAyKXtcblx0XHRcdFx0dGhpcy5fY2JzW3RoaXMuZXZlbnRzW2ldWzBdXSh0aGlzLmV2ZW50c1tpXVsxXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9jYnNbdGhpcy5ldmVudHNbaV1bMF1dKHRoaXMuZXZlbnRzW2ldWzFdLCB0aGlzLmV2ZW50c1tpXVsyXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuIiwidmFyIGluZGV4ID0gcmVxdWlyZShcIi4vaW5kZXguanNcIiksXG4gICAgRG9tSGFuZGxlciA9IGluZGV4LkRvbUhhbmRsZXIsXG4gICAgRG9tVXRpbHMgPSBpbmRleC5Eb21VdGlscztcblxuLy9UT0RPOiBtYWtlIHRoaXMgYSBzdHJlYW1hYmxlIGhhbmRsZXJcbmZ1bmN0aW9uIEZlZWRIYW5kbGVyKGNhbGxiYWNrLCBvcHRpb25zKXtcblx0dGhpcy5pbml0KGNhbGxiYWNrLCBvcHRpb25zKTtcbn1cblxucmVxdWlyZShcImluaGVyaXRzXCIpKEZlZWRIYW5kbGVyLCBEb21IYW5kbGVyKTtcblxuRmVlZEhhbmRsZXIucHJvdG90eXBlLmluaXQgPSBEb21IYW5kbGVyO1xuXG5mdW5jdGlvbiBnZXRFbGVtZW50cyh3aGF0LCB3aGVyZSl7XG5cdHJldHVybiBEb21VdGlscy5nZXRFbGVtZW50c0J5VGFnTmFtZSh3aGF0LCB3aGVyZSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBnZXRPbmVFbGVtZW50KHdoYXQsIHdoZXJlKXtcblx0cmV0dXJuIERvbVV0aWxzLmdldEVsZW1lbnRzQnlUYWdOYW1lKHdoYXQsIHdoZXJlLCB0cnVlLCAxKVswXTtcbn1cbmZ1bmN0aW9uIGZldGNoKHdoYXQsIHdoZXJlLCByZWN1cnNlKXtcblx0cmV0dXJuIERvbVV0aWxzLmdldFRleHQoXG5cdFx0RG9tVXRpbHMuZ2V0RWxlbWVudHNCeVRhZ05hbWUod2hhdCwgd2hlcmUsIHJlY3Vyc2UsIDEpXG5cdCkudHJpbSgpO1xufVxuXG5mdW5jdGlvbiBhZGRDb25kaXRpb25hbGx5KG9iaiwgcHJvcCwgd2hhdCwgd2hlcmUsIHJlY3Vyc2Upe1xuXHR2YXIgdG1wID0gZmV0Y2god2hhdCwgd2hlcmUsIHJlY3Vyc2UpO1xuXHRpZih0bXApIG9ialtwcm9wXSA9IHRtcDtcbn1cblxudmFyIGlzVmFsaWRGZWVkID0gZnVuY3Rpb24odmFsdWUpe1xuXHRyZXR1cm4gdmFsdWUgPT09IFwicnNzXCIgfHwgdmFsdWUgPT09IFwiZmVlZFwiIHx8IHZhbHVlID09PSBcInJkZjpSREZcIjtcbn07XG5cbkZlZWRIYW5kbGVyLnByb3RvdHlwZS5vbmVuZCA9IGZ1bmN0aW9uKCl7XG5cdHZhciBmZWVkID0ge30sXG5cdCAgICBmZWVkUm9vdCA9IGdldE9uZUVsZW1lbnQoaXNWYWxpZEZlZWQsIHRoaXMuZG9tKSxcblx0ICAgIHRtcCwgY2hpbGRzO1xuXG5cdGlmKGZlZWRSb290KXtcblx0XHRpZihmZWVkUm9vdC5uYW1lID09PSBcImZlZWRcIil7XG5cdFx0XHRjaGlsZHMgPSBmZWVkUm9vdC5jaGlsZHJlbjtcblxuXHRcdFx0ZmVlZC50eXBlID0gXCJhdG9tXCI7XG5cdFx0XHRhZGRDb25kaXRpb25hbGx5KGZlZWQsIFwiaWRcIiwgXCJpZFwiLCBjaGlsZHMpO1xuXHRcdFx0YWRkQ29uZGl0aW9uYWxseShmZWVkLCBcInRpdGxlXCIsIFwidGl0bGVcIiwgY2hpbGRzKTtcblx0XHRcdGlmKCh0bXAgPSBnZXRPbmVFbGVtZW50KFwibGlua1wiLCBjaGlsZHMpKSAmJiAodG1wID0gdG1wLmF0dHJpYnMpICYmICh0bXAgPSB0bXAuaHJlZikpIGZlZWQubGluayA9IHRtcDtcblx0XHRcdGFkZENvbmRpdGlvbmFsbHkoZmVlZCwgXCJkZXNjcmlwdGlvblwiLCBcInN1YnRpdGxlXCIsIGNoaWxkcyk7XG5cdFx0XHRpZigodG1wID0gZmV0Y2goXCJ1cGRhdGVkXCIsIGNoaWxkcykpKSBmZWVkLnVwZGF0ZWQgPSBuZXcgRGF0ZSh0bXApO1xuXHRcdFx0YWRkQ29uZGl0aW9uYWxseShmZWVkLCBcImF1dGhvclwiLCBcImVtYWlsXCIsIGNoaWxkcywgdHJ1ZSk7XG5cblx0XHRcdGZlZWQuaXRlbXMgPSBnZXRFbGVtZW50cyhcImVudHJ5XCIsIGNoaWxkcykubWFwKGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdFx0XHR2YXIgZW50cnkgPSB7fSwgdG1wO1xuXG5cdFx0XHRcdGl0ZW0gPSBpdGVtLmNoaWxkcmVuO1xuXG5cdFx0XHRcdGFkZENvbmRpdGlvbmFsbHkoZW50cnksIFwiaWRcIiwgXCJpZFwiLCBpdGVtKTtcblx0XHRcdFx0YWRkQ29uZGl0aW9uYWxseShlbnRyeSwgXCJ0aXRsZVwiLCBcInRpdGxlXCIsIGl0ZW0pO1xuXHRcdFx0XHRpZigodG1wID0gZ2V0T25lRWxlbWVudChcImxpbmtcIiwgaXRlbSkpICYmICh0bXAgPSB0bXAuYXR0cmlicykgJiYgKHRtcCA9IHRtcC5ocmVmKSkgZW50cnkubGluayA9IHRtcDtcblx0XHRcdFx0aWYoKHRtcCA9IGZldGNoKFwic3VtbWFyeVwiLCBpdGVtKSB8fCBmZXRjaChcImNvbnRlbnRcIiwgaXRlbSkpKSBlbnRyeS5kZXNjcmlwdGlvbiA9IHRtcDtcblx0XHRcdFx0aWYoKHRtcCA9IGZldGNoKFwidXBkYXRlZFwiLCBpdGVtKSkpIGVudHJ5LnB1YkRhdGUgPSBuZXcgRGF0ZSh0bXApO1xuXHRcdFx0XHRyZXR1cm4gZW50cnk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2hpbGRzID0gZ2V0T25lRWxlbWVudChcImNoYW5uZWxcIiwgZmVlZFJvb3QuY2hpbGRyZW4pLmNoaWxkcmVuO1xuXG5cdFx0XHRmZWVkLnR5cGUgPSBmZWVkUm9vdC5uYW1lLnN1YnN0cigwLCAzKTtcblx0XHRcdGZlZWQuaWQgPSBcIlwiO1xuXHRcdFx0YWRkQ29uZGl0aW9uYWxseShmZWVkLCBcInRpdGxlXCIsIFwidGl0bGVcIiwgY2hpbGRzKTtcblx0XHRcdGFkZENvbmRpdGlvbmFsbHkoZmVlZCwgXCJsaW5rXCIsIFwibGlua1wiLCBjaGlsZHMpO1xuXHRcdFx0YWRkQ29uZGl0aW9uYWxseShmZWVkLCBcImRlc2NyaXB0aW9uXCIsIFwiZGVzY3JpcHRpb25cIiwgY2hpbGRzKTtcblx0XHRcdGlmKCh0bXAgPSBmZXRjaChcImxhc3RCdWlsZERhdGVcIiwgY2hpbGRzKSkpIGZlZWQudXBkYXRlZCA9IG5ldyBEYXRlKHRtcCk7XG5cdFx0XHRhZGRDb25kaXRpb25hbGx5KGZlZWQsIFwiYXV0aG9yXCIsIFwibWFuYWdpbmdFZGl0b3JcIiwgY2hpbGRzLCB0cnVlKTtcblxuXHRcdFx0ZmVlZC5pdGVtcyA9IGdldEVsZW1lbnRzKFwiaXRlbVwiLCBmZWVkUm9vdC5jaGlsZHJlbikubWFwKGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdFx0XHR2YXIgZW50cnkgPSB7fSwgdG1wO1xuXG5cdFx0XHRcdGl0ZW0gPSBpdGVtLmNoaWxkcmVuO1xuXG5cdFx0XHRcdGFkZENvbmRpdGlvbmFsbHkoZW50cnksIFwiaWRcIiwgXCJndWlkXCIsIGl0ZW0pO1xuXHRcdFx0XHRhZGRDb25kaXRpb25hbGx5KGVudHJ5LCBcInRpdGxlXCIsIFwidGl0bGVcIiwgaXRlbSk7XG5cdFx0XHRcdGFkZENvbmRpdGlvbmFsbHkoZW50cnksIFwibGlua1wiLCBcImxpbmtcIiwgaXRlbSk7XG5cdFx0XHRcdGFkZENvbmRpdGlvbmFsbHkoZW50cnksIFwiZGVzY3JpcHRpb25cIiwgXCJkZXNjcmlwdGlvblwiLCBpdGVtKTtcblx0XHRcdFx0aWYoKHRtcCA9IGZldGNoKFwicHViRGF0ZVwiLCBpdGVtKSkpIGVudHJ5LnB1YkRhdGUgPSBuZXcgRGF0ZSh0bXApO1xuXHRcdFx0XHRyZXR1cm4gZW50cnk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblx0dGhpcy5kb20gPSBmZWVkO1xuXHREb21IYW5kbGVyLnByb3RvdHlwZS5faGFuZGxlQ2FsbGJhY2suY2FsbChcblx0XHR0aGlzLCBmZWVkUm9vdCA/IG51bGwgOiBFcnJvcihcImNvdWxkbid0IGZpbmQgcm9vdCBvZiBmZWVkXCIpXG5cdCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZlZWRIYW5kbGVyO1xuIiwidmFyIFRva2VuaXplciA9IHJlcXVpcmUoXCIuL1Rva2VuaXplci5qc1wiKTtcblxuLypcblx0T3B0aW9uczpcblxuXHR4bWxNb2RlOiBEaXNhYmxlcyB0aGUgc3BlY2lhbCBiZWhhdmlvciBmb3Igc2NyaXB0L3N0eWxlIHRhZ3MgKGZhbHNlIGJ5IGRlZmF1bHQpXG5cdGxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzOiBjYWxsIC50b0xvd2VyQ2FzZSBmb3IgZWFjaCBhdHRyaWJ1dGUgbmFtZSAodHJ1ZSBpZiB4bWxNb2RlIGlzIGBmYWxzZWApXG5cdGxvd2VyQ2FzZVRhZ3M6IGNhbGwgLnRvTG93ZXJDYXNlIGZvciBlYWNoIHRhZyBuYW1lICh0cnVlIGlmIHhtbE1vZGUgaXMgYGZhbHNlYClcbiovXG5cbi8qXG5cdENhbGxiYWNrczpcblxuXHRvbmNkYXRhZW5kLFxuXHRvbmNkYXRhc3RhcnQsXG5cdG9uY2xvc2V0YWcsXG5cdG9uY29tbWVudCxcblx0b25jb21tZW50ZW5kLFxuXHRvbmVycm9yLFxuXHRvbm9wZW50YWcsXG5cdG9ucHJvY2Vzc2luZ2luc3RydWN0aW9uLFxuXHRvbnJlc2V0LFxuXHRvbnRleHRcbiovXG5cbnZhciBmb3JtVGFncyA9IHtcblx0aW5wdXQ6IHRydWUsXG5cdG9wdGlvbjogdHJ1ZSxcblx0b3B0Z3JvdXA6IHRydWUsXG5cdHNlbGVjdDogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRkYXRhbGlzdDogdHJ1ZSxcblx0dGV4dGFyZWE6IHRydWVcbn07XG5cbnZhciBvcGVuSW1wbGllc0Nsb3NlID0ge1xuXHR0ciAgICAgIDogeyB0cjp0cnVlLCB0aDp0cnVlLCB0ZDp0cnVlIH0sXG5cdHRoICAgICAgOiB7IHRoOnRydWUgfSxcblx0dGQgICAgICA6IHsgdGhlYWQ6dHJ1ZSwgdGg6dHJ1ZSwgdGQ6dHJ1ZSB9LFxuXHRib2R5ICAgIDogeyBoZWFkOnRydWUsIGxpbms6dHJ1ZSwgc2NyaXB0OnRydWUgfSxcblx0bGkgICAgICA6IHsgbGk6dHJ1ZSB9LFxuXHRwICAgICAgIDogeyBwOnRydWUgfSxcblx0aDEgICAgICA6IHsgcDp0cnVlIH0sXG5cdGgyICAgICAgOiB7IHA6dHJ1ZSB9LFxuXHRoMyAgICAgIDogeyBwOnRydWUgfSxcblx0aDQgICAgICA6IHsgcDp0cnVlIH0sXG5cdGg1ICAgICAgOiB7IHA6dHJ1ZSB9LFxuXHRoNiAgICAgIDogeyBwOnRydWUgfSxcblx0c2VsZWN0ICA6IGZvcm1UYWdzLFxuXHRpbnB1dCAgIDogZm9ybVRhZ3MsXG5cdG91dHB1dCAgOiBmb3JtVGFncyxcblx0YnV0dG9uICA6IGZvcm1UYWdzLFxuXHRkYXRhbGlzdDogZm9ybVRhZ3MsXG5cdHRleHRhcmVhOiBmb3JtVGFncyxcblx0b3B0aW9uICA6IHsgb3B0aW9uOnRydWUgfSxcblx0b3B0Z3JvdXA6IHsgb3B0Z3JvdXA6dHJ1ZSB9XG59O1xuXG52YXIgdm9pZEVsZW1lbnRzID0ge1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGFyZWE6IHRydWUsXG5cdGJhc2U6IHRydWUsXG5cdGJhc2Vmb250OiB0cnVlLFxuXHRicjogdHJ1ZSxcblx0Y29sOiB0cnVlLFxuXHRjb21tYW5kOiB0cnVlLFxuXHRlbWJlZDogdHJ1ZSxcblx0ZnJhbWU6IHRydWUsXG5cdGhyOiB0cnVlLFxuXHRpbWc6IHRydWUsXG5cdGlucHV0OiB0cnVlLFxuXHRpc2luZGV4OiB0cnVlLFxuXHRrZXlnZW46IHRydWUsXG5cdGxpbms6IHRydWUsXG5cdG1ldGE6IHRydWUsXG5cdHBhcmFtOiB0cnVlLFxuXHRzb3VyY2U6IHRydWUsXG5cdHRyYWNrOiB0cnVlLFxuXHR3YnI6IHRydWUsXG5cblx0Ly9jb21tb24gc2VsZiBjbG9zaW5nIHN2ZyBlbGVtZW50c1xuXHRwYXRoOiB0cnVlLFxuXHRjaXJjbGU6IHRydWUsXG5cdGVsbGlwc2U6IHRydWUsXG5cdGxpbmU6IHRydWUsXG5cdHJlY3Q6IHRydWUsXG5cdHVzZTogdHJ1ZSxcblx0c3RvcDogdHJ1ZSxcblx0cG9seWxpbmU6IHRydWUsXG5cdHBvbHlnb246IHRydWVcbn07XG5cbnZhciByZV9uYW1lRW5kID0gL1xcc3xcXC8vO1xuXG5mdW5jdGlvbiBQYXJzZXIoY2JzLCBvcHRpb25zKXtcblx0dGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdHRoaXMuX2NicyA9IGNicyB8fCB7fTtcblxuXHR0aGlzLl90YWduYW1lID0gXCJcIjtcblx0dGhpcy5fYXR0cmlibmFtZSA9IFwiXCI7XG5cdHRoaXMuX2F0dHJpYnZhbHVlID0gXCJcIjtcblx0dGhpcy5fYXR0cmlicyA9IG51bGw7XG5cdHRoaXMuX3N0YWNrID0gW107XG5cblx0dGhpcy5zdGFydEluZGV4ID0gMDtcblx0dGhpcy5lbmRJbmRleCA9IG51bGw7XG5cblx0dGhpcy5fbG93ZXJDYXNlVGFnTmFtZXMgPSBcImxvd2VyQ2FzZVRhZ3NcIiBpbiB0aGlzLl9vcHRpb25zID9cblx0XHRcdFx0XHRcdFx0XHRcdCEhdGhpcy5fb3B0aW9ucy5sb3dlckNhc2VUYWdzIDpcblx0XHRcdFx0XHRcdFx0XHRcdCF0aGlzLl9vcHRpb25zLnhtbE1vZGU7XG5cdHRoaXMuX2xvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzID0gXCJsb3dlckNhc2VBdHRyaWJ1dGVOYW1lc1wiIGluIHRoaXMuX29wdGlvbnMgP1xuXHRcdFx0XHRcdFx0XHRcdFx0ISF0aGlzLl9vcHRpb25zLmxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzIDpcblx0XHRcdFx0XHRcdFx0XHRcdCF0aGlzLl9vcHRpb25zLnhtbE1vZGU7XG5cblx0aWYodGhpcy5fb3B0aW9ucy5Ub2tlbml6ZXIpIHtcblx0XHRUb2tlbml6ZXIgPSB0aGlzLl9vcHRpb25zLlRva2VuaXplcjtcblx0fVxuXHR0aGlzLl90b2tlbml6ZXIgPSBuZXcgVG9rZW5pemVyKHRoaXMuX29wdGlvbnMsIHRoaXMpO1xuXG5cdGlmKHRoaXMuX2Nicy5vbnBhcnNlcmluaXQpIHRoaXMuX2Nicy5vbnBhcnNlcmluaXQodGhpcyk7XG59XG5cbnJlcXVpcmUoXCJpbmhlcml0c1wiKShQYXJzZXIsIHJlcXVpcmUoXCJldmVudHNcIikuRXZlbnRFbWl0dGVyKTtcblxuUGFyc2VyLnByb3RvdHlwZS5fdXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbihpbml0aWFsT2Zmc2V0KXtcblx0aWYodGhpcy5lbmRJbmRleCA9PT0gbnVsbCl7XG5cdFx0aWYodGhpcy5fdG9rZW5pemVyLl9zZWN0aW9uU3RhcnQgPD0gaW5pdGlhbE9mZnNldCl7XG5cdFx0XHR0aGlzLnN0YXJ0SW5kZXggPSAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnN0YXJ0SW5kZXggPSB0aGlzLl90b2tlbml6ZXIuX3NlY3Rpb25TdGFydCAtIGluaXRpYWxPZmZzZXQ7XG5cdFx0fVxuXHR9XG5cdGVsc2UgdGhpcy5zdGFydEluZGV4ID0gdGhpcy5lbmRJbmRleCArIDE7XG5cdHRoaXMuZW5kSW5kZXggPSB0aGlzLl90b2tlbml6ZXIuZ2V0QWJzb2x1dGVJbmRleCgpO1xufTtcblxuLy9Ub2tlbml6ZXIgZXZlbnQgaGFuZGxlcnNcblBhcnNlci5wcm90b3R5cGUub250ZXh0ID0gZnVuY3Rpb24oZGF0YSl7XG5cdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKDEpO1xuXHR0aGlzLmVuZEluZGV4LS07XG5cblx0aWYodGhpcy5fY2JzLm9udGV4dCkgdGhpcy5fY2JzLm9udGV4dChkYXRhKTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUub25vcGVudGFnbmFtZSA9IGZ1bmN0aW9uKG5hbWUpe1xuXHRpZih0aGlzLl9sb3dlckNhc2VUYWdOYW1lcyl7XG5cdFx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fVxuXG5cdHRoaXMuX3RhZ25hbWUgPSBuYW1lO1xuXG5cdGlmKCF0aGlzLl9vcHRpb25zLnhtbE1vZGUgJiYgbmFtZSBpbiBvcGVuSW1wbGllc0Nsb3NlKSB7XG5cdFx0Zm9yKFxuXHRcdFx0dmFyIGVsO1xuXHRcdFx0KGVsID0gdGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoIC0gMV0pIGluIG9wZW5JbXBsaWVzQ2xvc2VbbmFtZV07XG5cdFx0XHR0aGlzLm9uY2xvc2V0YWcoZWwpXG5cdFx0KTtcblx0fVxuXG5cdGlmKHRoaXMuX29wdGlvbnMueG1sTW9kZSB8fCAhKG5hbWUgaW4gdm9pZEVsZW1lbnRzKSl7XG5cdFx0dGhpcy5fc3RhY2sucHVzaChuYW1lKTtcblx0fVxuXG5cdGlmKHRoaXMuX2Nicy5vbm9wZW50YWduYW1lKSB0aGlzLl9jYnMub25vcGVudGFnbmFtZShuYW1lKTtcblx0aWYodGhpcy5fY2JzLm9ub3BlbnRhZykgdGhpcy5fYXR0cmlicyA9IHt9O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5vbm9wZW50YWdlbmQgPSBmdW5jdGlvbigpe1xuXHR0aGlzLl91cGRhdGVQb3NpdGlvbigxKTtcblxuXHRpZih0aGlzLl9hdHRyaWJzKXtcblx0XHRpZih0aGlzLl9jYnMub25vcGVudGFnKSB0aGlzLl9jYnMub25vcGVudGFnKHRoaXMuX3RhZ25hbWUsIHRoaXMuX2F0dHJpYnMpO1xuXHRcdHRoaXMuX2F0dHJpYnMgPSBudWxsO1xuXHR9XG5cblx0aWYoIXRoaXMuX29wdGlvbnMueG1sTW9kZSAmJiB0aGlzLl9jYnMub25jbG9zZXRhZyAmJiB0aGlzLl90YWduYW1lIGluIHZvaWRFbGVtZW50cyl7XG5cdFx0dGhpcy5fY2JzLm9uY2xvc2V0YWcodGhpcy5fdGFnbmFtZSk7XG5cdH1cblxuXHR0aGlzLl90YWduYW1lID0gXCJcIjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUub25jbG9zZXRhZyA9IGZ1bmN0aW9uKG5hbWUpe1xuXHR0aGlzLl91cGRhdGVQb3NpdGlvbigxKTtcblxuXHRpZih0aGlzLl9sb3dlckNhc2VUYWdOYW1lcyl7XG5cdFx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fVxuXG5cdGlmKHRoaXMuX3N0YWNrLmxlbmd0aCAmJiAoIShuYW1lIGluIHZvaWRFbGVtZW50cykgfHwgdGhpcy5fb3B0aW9ucy54bWxNb2RlKSl7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX3N0YWNrLmxhc3RJbmRleE9mKG5hbWUpO1xuXHRcdGlmKHBvcyAhPT0gLTEpe1xuXHRcdFx0aWYodGhpcy5fY2JzLm9uY2xvc2V0YWcpe1xuXHRcdFx0XHRwb3MgPSB0aGlzLl9zdGFjay5sZW5ndGggLSBwb3M7XG5cdFx0XHRcdHdoaWxlKHBvcy0tKSB0aGlzLl9jYnMub25jbG9zZXRhZyh0aGlzLl9zdGFjay5wb3AoKSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHRoaXMuX3N0YWNrLmxlbmd0aCA9IHBvcztcblx0XHR9IGVsc2UgaWYobmFtZSA9PT0gXCJwXCIgJiYgIXRoaXMuX29wdGlvbnMueG1sTW9kZSl7XG5cdFx0XHR0aGlzLm9ub3BlbnRhZ25hbWUobmFtZSk7XG5cdFx0XHR0aGlzLl9jbG9zZUN1cnJlbnRUYWcoKTtcblx0XHR9XG5cdH0gZWxzZSBpZighdGhpcy5fb3B0aW9ucy54bWxNb2RlICYmIChuYW1lID09PSBcImJyXCIgfHwgbmFtZSA9PT0gXCJwXCIpKXtcblx0XHR0aGlzLm9ub3BlbnRhZ25hbWUobmFtZSk7XG5cdFx0dGhpcy5fY2xvc2VDdXJyZW50VGFnKCk7XG5cdH1cbn07XG5cblBhcnNlci5wcm90b3R5cGUub25zZWxmY2xvc2luZ3RhZyA9IGZ1bmN0aW9uKCl7XG5cdGlmKHRoaXMuX29wdGlvbnMueG1sTW9kZSB8fCB0aGlzLl9vcHRpb25zLnJlY29nbml6ZVNlbGZDbG9zaW5nKXtcblx0XHR0aGlzLl9jbG9zZUN1cnJlbnRUYWcoKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLm9ub3BlbnRhZ2VuZCgpO1xuXHR9XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLl9jbG9zZUN1cnJlbnRUYWcgPSBmdW5jdGlvbigpe1xuXHR2YXIgbmFtZSA9IHRoaXMuX3RhZ25hbWU7XG5cblx0dGhpcy5vbm9wZW50YWdlbmQoKTtcblxuXHQvL3NlbGYtY2xvc2luZyB0YWdzIHdpbGwgYmUgb24gdGhlIHRvcCBvZiB0aGUgc3RhY2tcblx0Ly8oY2hlYXBlciBjaGVjayB0aGFuIGluIG9uY2xvc2V0YWcpXG5cdGlmKHRoaXMuX3N0YWNrW3RoaXMuX3N0YWNrLmxlbmd0aCAtIDFdID09PSBuYW1lKXtcblx0XHRpZih0aGlzLl9jYnMub25jbG9zZXRhZyl7XG5cdFx0XHR0aGlzLl9jYnMub25jbG9zZXRhZyhuYW1lKTtcblx0XHR9XG5cdFx0dGhpcy5fc3RhY2sucG9wKCk7XG5cdH1cbn07XG5cblBhcnNlci5wcm90b3R5cGUub25hdHRyaWJuYW1lID0gZnVuY3Rpb24obmFtZSl7XG5cdGlmKHRoaXMuX2xvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzKXtcblx0XHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9XG5cdHRoaXMuX2F0dHJpYm5hbWUgPSBuYW1lO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5vbmF0dHJpYmRhdGEgPSBmdW5jdGlvbih2YWx1ZSl7XG5cdHRoaXMuX2F0dHJpYnZhbHVlICs9IHZhbHVlO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5vbmF0dHJpYmVuZCA9IGZ1bmN0aW9uKCl7XG5cdGlmKHRoaXMuX2Nicy5vbmF0dHJpYnV0ZSkgdGhpcy5fY2JzLm9uYXR0cmlidXRlKHRoaXMuX2F0dHJpYm5hbWUsIHRoaXMuX2F0dHJpYnZhbHVlKTtcblx0aWYoXG5cdFx0dGhpcy5fYXR0cmlicyAmJlxuXHRcdCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fYXR0cmlicywgdGhpcy5fYXR0cmlibmFtZSlcblx0KXtcblx0XHR0aGlzLl9hdHRyaWJzW3RoaXMuX2F0dHJpYm5hbWVdID0gdGhpcy5fYXR0cmlidmFsdWU7XG5cdH1cblx0dGhpcy5fYXR0cmlibmFtZSA9IFwiXCI7XG5cdHRoaXMuX2F0dHJpYnZhbHVlID0gXCJcIjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuX2dldEluc3RydWN0aW9uTmFtZSA9IGZ1bmN0aW9uKHZhbHVlKXtcblx0dmFyIGlkeCA9IHZhbHVlLnNlYXJjaChyZV9uYW1lRW5kKSxcblx0ICAgIG5hbWUgPSBpZHggPCAwID8gdmFsdWUgOiB2YWx1ZS5zdWJzdHIoMCwgaWR4KTtcblxuXHRpZih0aGlzLl9sb3dlckNhc2VUYWdOYW1lcyl7XG5cdFx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fVxuXG5cdHJldHVybiBuYW1lO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5vbmRlY2xhcmF0aW9uID0gZnVuY3Rpb24odmFsdWUpe1xuXHRpZih0aGlzLl9jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24pe1xuXHRcdHZhciBuYW1lID0gdGhpcy5fZ2V0SW5zdHJ1Y3Rpb25OYW1lKHZhbHVlKTtcblx0XHR0aGlzLl9jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24oXCIhXCIgKyBuYW1lLCBcIiFcIiArIHZhbHVlKTtcblx0fVxufTtcblxuUGFyc2VyLnByb3RvdHlwZS5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKXtcblx0aWYodGhpcy5fY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKXtcblx0XHR2YXIgbmFtZSA9IHRoaXMuX2dldEluc3RydWN0aW9uTmFtZSh2YWx1ZSk7XG5cdFx0dGhpcy5fY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKFwiP1wiICsgbmFtZSwgXCI/XCIgKyB2YWx1ZSk7XG5cdH1cbn07XG5cblBhcnNlci5wcm90b3R5cGUub25jb21tZW50ID0gZnVuY3Rpb24odmFsdWUpe1xuXHR0aGlzLl91cGRhdGVQb3NpdGlvbig0KTtcblxuXHRpZih0aGlzLl9jYnMub25jb21tZW50KSB0aGlzLl9jYnMub25jb21tZW50KHZhbHVlKTtcblx0aWYodGhpcy5fY2JzLm9uY29tbWVudGVuZCkgdGhpcy5fY2JzLm9uY29tbWVudGVuZCgpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5vbmNkYXRhID0gZnVuY3Rpb24odmFsdWUpe1xuXHR0aGlzLl91cGRhdGVQb3NpdGlvbigxKTtcblxuXHRpZih0aGlzLl9vcHRpb25zLnhtbE1vZGUgfHwgdGhpcy5fb3B0aW9ucy5yZWNvZ25pemVDREFUQSl7XG5cdFx0aWYodGhpcy5fY2JzLm9uY2RhdGFzdGFydCkgdGhpcy5fY2JzLm9uY2RhdGFzdGFydCgpO1xuXHRcdGlmKHRoaXMuX2Nicy5vbnRleHQpIHRoaXMuX2Nicy5vbnRleHQodmFsdWUpO1xuXHRcdGlmKHRoaXMuX2Nicy5vbmNkYXRhZW5kKSB0aGlzLl9jYnMub25jZGF0YWVuZCgpO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMub25jb21tZW50KFwiW0NEQVRBW1wiICsgdmFsdWUgKyBcIl1dXCIpO1xuXHR9XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuXHRpZih0aGlzLl9jYnMub25lcnJvcikgdGhpcy5fY2JzLm9uZXJyb3IoZXJyKTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUub25lbmQgPSBmdW5jdGlvbigpe1xuXHRpZih0aGlzLl9jYnMub25jbG9zZXRhZyl7XG5cdFx0Zm9yKFxuXHRcdFx0dmFyIGkgPSB0aGlzLl9zdGFjay5sZW5ndGg7XG5cdFx0XHRpID4gMDtcblx0XHRcdHRoaXMuX2Nicy5vbmNsb3NldGFnKHRoaXMuX3N0YWNrWy0taV0pXG5cdFx0KTtcblx0fVxuXHRpZih0aGlzLl9jYnMub25lbmQpIHRoaXMuX2Nicy5vbmVuZCgpO1xufTtcblxuXG4vL1Jlc2V0cyB0aGUgcGFyc2VyIHRvIGEgYmxhbmsgc3RhdGUsIHJlYWR5IHRvIHBhcnNlIGEgbmV3IEhUTUwgZG9jdW1lbnRcblBhcnNlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuXHRpZih0aGlzLl9jYnMub25yZXNldCkgdGhpcy5fY2JzLm9ucmVzZXQoKTtcblx0dGhpcy5fdG9rZW5pemVyLnJlc2V0KCk7XG5cblx0dGhpcy5fdGFnbmFtZSA9IFwiXCI7XG5cdHRoaXMuX2F0dHJpYm5hbWUgPSBcIlwiO1xuXHR0aGlzLl9hdHRyaWJzID0gbnVsbDtcblx0dGhpcy5fc3RhY2sgPSBbXTtcblxuXHRpZih0aGlzLl9jYnMub25wYXJzZXJpbml0KSB0aGlzLl9jYnMub25wYXJzZXJpbml0KHRoaXMpO1xufTtcblxuLy9QYXJzZXMgYSBjb21wbGV0ZSBIVE1MIGRvY3VtZW50IGFuZCBwdXNoZXMgaXQgdG8gdGhlIGhhbmRsZXJcblBhcnNlci5wcm90b3R5cGUucGFyc2VDb21wbGV0ZSA9IGZ1bmN0aW9uKGRhdGEpe1xuXHR0aGlzLnJlc2V0KCk7XG5cdHRoaXMuZW5kKGRhdGEpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rKXtcblx0dGhpcy5fdG9rZW5pemVyLndyaXRlKGNodW5rKTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmspe1xuXHR0aGlzLl90b2tlbml6ZXIuZW5kKGNodW5rKTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpe1xuXHR0aGlzLl90b2tlbml6ZXIucGF1c2UoKTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKXtcblx0dGhpcy5fdG9rZW5pemVyLnJlc3VtZSgpO1xufTtcblxuLy9hbGlhcyBmb3IgYmFja3dhcmRzIGNvbXBhdFxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNodW5rID0gUGFyc2VyLnByb3RvdHlwZS53cml0ZTtcblBhcnNlci5wcm90b3R5cGUuZG9uZSA9IFBhcnNlci5wcm90b3R5cGUuZW5kO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gUHJveHlIYW5kbGVyO1xuXG5mdW5jdGlvbiBQcm94eUhhbmRsZXIoY2JzKXtcblx0dGhpcy5fY2JzID0gY2JzIHx8IHt9O1xufVxuXG52YXIgRVZFTlRTID0gcmVxdWlyZShcIi4vXCIpLkVWRU5UUztcbk9iamVjdC5rZXlzKEVWRU5UUykuZm9yRWFjaChmdW5jdGlvbihuYW1lKXtcblx0aWYoRVZFTlRTW25hbWVdID09PSAwKXtcblx0XHRuYW1lID0gXCJvblwiICsgbmFtZTtcblx0XHRQcm94eUhhbmRsZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKXtcblx0XHRcdGlmKHRoaXMuX2Nic1tuYW1lXSkgdGhpcy5fY2JzW25hbWVdKCk7XG5cdFx0fTtcblx0fSBlbHNlIGlmKEVWRU5UU1tuYW1lXSA9PT0gMSl7XG5cdFx0bmFtZSA9IFwib25cIiArIG5hbWU7XG5cdFx0UHJveHlIYW5kbGVyLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKGEpe1xuXHRcdFx0aWYodGhpcy5fY2JzW25hbWVdKSB0aGlzLl9jYnNbbmFtZV0oYSk7XG5cdFx0fTtcblx0fSBlbHNlIGlmKEVWRU5UU1tuYW1lXSA9PT0gMil7XG5cdFx0bmFtZSA9IFwib25cIiArIG5hbWU7XG5cdFx0UHJveHlIYW5kbGVyLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKGEsIGIpe1xuXHRcdFx0aWYodGhpcy5fY2JzW25hbWVdKSB0aGlzLl9jYnNbbmFtZV0oYSwgYik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBFcnJvcihcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHNcIik7XG5cdH1cbn0pOyIsIm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgUGFyc2VyID0gcmVxdWlyZShcIi4vV3JpdGFibGVTdHJlYW0uanNcIik7XG5cbmZ1bmN0aW9uIFN0cmVhbShvcHRpb25zKXtcblx0UGFyc2VyLmNhbGwodGhpcywgbmV3IENicyh0aGlzKSwgb3B0aW9ucyk7XG59XG5cbnJlcXVpcmUoXCJpbmhlcml0c1wiKShTdHJlYW0sIFBhcnNlcik7XG5cblN0cmVhbS5wcm90b3R5cGUucmVhZGFibGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBDYnMoc2NvcGUpe1xuXHR0aGlzLnNjb3BlID0gc2NvcGU7XG59XG5cbnZhciBFVkVOVFMgPSByZXF1aXJlKFwiLi4vXCIpLkVWRU5UUztcblxuT2JqZWN0LmtleXMoRVZFTlRTKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpe1xuXHRpZihFVkVOVFNbbmFtZV0gPT09IDApe1xuXHRcdENicy5wcm90b3R5cGVbXCJvblwiICsgbmFtZV0gPSBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5zY29wZS5lbWl0KG5hbWUpO1xuXHRcdH07XG5cdH0gZWxzZSBpZihFVkVOVFNbbmFtZV0gPT09IDEpe1xuXHRcdENicy5wcm90b3R5cGVbXCJvblwiICsgbmFtZV0gPSBmdW5jdGlvbihhKXtcblx0XHRcdHRoaXMuc2NvcGUuZW1pdChuYW1lLCBhKTtcblx0XHR9O1xuXHR9IGVsc2UgaWYoRVZFTlRTW25hbWVdID09PSAyKXtcblx0XHRDYnMucHJvdG90eXBlW1wib25cIiArIG5hbWVdID0gZnVuY3Rpb24oYSwgYil7XG5cdFx0XHR0aGlzLnNjb3BlLmVtaXQobmFtZSwgYSwgYik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBFcnJvcihcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMhXCIpO1xuXHR9XG59KTsiLCJtb2R1bGUuZXhwb3J0cyA9IFRva2VuaXplcjtcblxudmFyIGRlY29kZUNvZGVQb2ludCA9IHJlcXVpcmUoXCJlbnRpdGllcy9saWIvZGVjb2RlX2NvZGVwb2ludC5qc1wiKSxcbiAgICBlbnRpdHlNYXAgPSByZXF1aXJlKFwiZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uXCIpLFxuICAgIGxlZ2FjeU1hcCA9IHJlcXVpcmUoXCJlbnRpdGllcy9tYXBzL2xlZ2FjeS5qc29uXCIpLFxuICAgIHhtbE1hcCAgICA9IHJlcXVpcmUoXCJlbnRpdGllcy9tYXBzL3htbC5qc29uXCIpLFxuXG4gICAgaSA9IDAsXG5cbiAgICBURVhUICAgICAgICAgICAgICAgICAgICAgID0gaSsrLFxuICAgIEJFRk9SRV9UQUdfTkFNRSAgICAgICAgICAgPSBpKyssIC8vYWZ0ZXIgPFxuICAgIElOX1RBR19OQU1FICAgICAgICAgICAgICAgPSBpKyssXG4gICAgSU5fU0VMRl9DTE9TSU5HX1RBRyAgICAgICA9IGkrKyxcbiAgICBCRUZPUkVfQ0xPU0lOR19UQUdfTkFNRSAgID0gaSsrLFxuICAgIElOX0NMT1NJTkdfVEFHX05BTUUgICAgICAgPSBpKyssXG4gICAgQUZURVJfQ0xPU0lOR19UQUdfTkFNRSAgICA9IGkrKyxcblxuICAgIC8vYXR0cmlidXRlc1xuICAgIEJFRk9SRV9BVFRSSUJVVEVfTkFNRSAgICAgPSBpKyssXG4gICAgSU5fQVRUUklCVVRFX05BTUUgICAgICAgICA9IGkrKyxcbiAgICBBRlRFUl9BVFRSSUJVVEVfTkFNRSAgICAgID0gaSsrLFxuICAgIEJFRk9SRV9BVFRSSUJVVEVfVkFMVUUgICAgPSBpKyssXG4gICAgSU5fQVRUUklCVVRFX1ZBTFVFX0RRICAgICA9IGkrKywgLy8gXCJcbiAgICBJTl9BVFRSSUJVVEVfVkFMVUVfU1EgICAgID0gaSsrLCAvLyAnXG4gICAgSU5fQVRUUklCVVRFX1ZBTFVFX05RICAgICA9IGkrKyxcblxuICAgIC8vZGVjbGFyYXRpb25zXG4gICAgQkVGT1JFX0RFQ0xBUkFUSU9OICAgICAgICA9IGkrKywgLy8gIVxuICAgIElOX0RFQ0xBUkFUSU9OICAgICAgICAgICAgPSBpKyssXG5cbiAgICAvL3Byb2Nlc3NpbmcgaW5zdHJ1Y3Rpb25zXG4gICAgSU5fUFJPQ0VTU0lOR19JTlNUUlVDVElPTiA9IGkrKywgLy8gP1xuXG4gICAgLy9jb21tZW50c1xuICAgIEJFRk9SRV9DT01NRU5UICAgICAgICAgICAgPSBpKyssXG4gICAgSU5fQ09NTUVOVCAgICAgICAgICAgICAgICA9IGkrKyxcbiAgICBBRlRFUl9DT01NRU5UXzEgICAgICAgICAgID0gaSsrLFxuICAgIEFGVEVSX0NPTU1FTlRfMiAgICAgICAgICAgPSBpKyssXG5cbiAgICAvL2NkYXRhXG4gICAgQkVGT1JFX0NEQVRBXzEgICAgICAgICAgICA9IGkrKywgLy8gW1xuICAgIEJFRk9SRV9DREFUQV8yICAgICAgICAgICAgPSBpKyssIC8vIENcbiAgICBCRUZPUkVfQ0RBVEFfMyAgICAgICAgICAgID0gaSsrLCAvLyBEXG4gICAgQkVGT1JFX0NEQVRBXzQgICAgICAgICAgICA9IGkrKywgLy8gQVxuICAgIEJFRk9SRV9DREFUQV81ICAgICAgICAgICAgPSBpKyssIC8vIFRcbiAgICBCRUZPUkVfQ0RBVEFfNiAgICAgICAgICAgID0gaSsrLCAvLyBBXG4gICAgSU5fQ0RBVEEgICAgICAgICAgICAgICAgICA9IGkrKywgLy8gW1xuICAgIEFGVEVSX0NEQVRBXzEgICAgICAgICAgICAgPSBpKyssIC8vIF1cbiAgICBBRlRFUl9DREFUQV8yICAgICAgICAgICAgID0gaSsrLCAvLyBdXG5cbiAgICAvL3NwZWNpYWwgdGFnc1xuICAgIEJFRk9SRV9TUEVDSUFMICAgICAgICAgICAgPSBpKyssIC8vU1xuICAgIEJFRk9SRV9TUEVDSUFMX0VORCAgICAgICAgPSBpKyssICAgLy9TXG5cbiAgICBCRUZPUkVfU0NSSVBUXzEgICAgICAgICAgID0gaSsrLCAvL0NcbiAgICBCRUZPUkVfU0NSSVBUXzIgICAgICAgICAgID0gaSsrLCAvL1JcbiAgICBCRUZPUkVfU0NSSVBUXzMgICAgICAgICAgID0gaSsrLCAvL0lcbiAgICBCRUZPUkVfU0NSSVBUXzQgICAgICAgICAgID0gaSsrLCAvL1BcbiAgICBCRUZPUkVfU0NSSVBUXzUgICAgICAgICAgID0gaSsrLCAvL1RcbiAgICBBRlRFUl9TQ1JJUFRfMSAgICAgICAgICAgID0gaSsrLCAvL0NcbiAgICBBRlRFUl9TQ1JJUFRfMiAgICAgICAgICAgID0gaSsrLCAvL1JcbiAgICBBRlRFUl9TQ1JJUFRfMyAgICAgICAgICAgID0gaSsrLCAvL0lcbiAgICBBRlRFUl9TQ1JJUFRfNCAgICAgICAgICAgID0gaSsrLCAvL1BcbiAgICBBRlRFUl9TQ1JJUFRfNSAgICAgICAgICAgID0gaSsrLCAvL1RcblxuICAgIEJFRk9SRV9TVFlMRV8xICAgICAgICAgICAgPSBpKyssIC8vVFxuICAgIEJFRk9SRV9TVFlMRV8yICAgICAgICAgICAgPSBpKyssIC8vWVxuICAgIEJFRk9SRV9TVFlMRV8zICAgICAgICAgICAgPSBpKyssIC8vTFxuICAgIEJFRk9SRV9TVFlMRV80ICAgICAgICAgICAgPSBpKyssIC8vRVxuICAgIEFGVEVSX1NUWUxFXzEgICAgICAgICAgICAgPSBpKyssIC8vVFxuICAgIEFGVEVSX1NUWUxFXzIgICAgICAgICAgICAgPSBpKyssIC8vWVxuICAgIEFGVEVSX1NUWUxFXzMgICAgICAgICAgICAgPSBpKyssIC8vTFxuICAgIEFGVEVSX1NUWUxFXzQgICAgICAgICAgICAgPSBpKyssIC8vRVxuXG4gICAgQkVGT1JFX0VOVElUWSAgICAgICAgICAgICA9IGkrKywgLy8mXG4gICAgQkVGT1JFX05VTUVSSUNfRU5USVRZICAgICA9IGkrKywgLy8jXG4gICAgSU5fTkFNRURfRU5USVRZICAgICAgICAgICA9IGkrKyxcbiAgICBJTl9OVU1FUklDX0VOVElUWSAgICAgICAgID0gaSsrLFxuICAgIElOX0hFWF9FTlRJVFkgICAgICAgICAgICAgPSBpKyssIC8vWFxuXG4gICAgaiA9IDAsXG5cbiAgICBTUEVDSUFMX05PTkUgICAgICAgICAgICAgID0gaisrLFxuICAgIFNQRUNJQUxfU0NSSVBUICAgICAgICAgICAgPSBqKyssXG4gICAgU1BFQ0lBTF9TVFlMRSAgICAgICAgICAgICA9IGorKztcblxuZnVuY3Rpb24gd2hpdGVzcGFjZShjKXtcblx0cmV0dXJuIGMgPT09IFwiIFwiIHx8IGMgPT09IFwiXFxuXCIgfHwgYyA9PT0gXCJcXHRcIiB8fCBjID09PSBcIlxcZlwiIHx8IGMgPT09IFwiXFxyXCI7XG59XG5cbmZ1bmN0aW9uIGNoYXJhY3RlclN0YXRlKGNoYXIsIFNVQ0NFU1Mpe1xuXHRyZXR1cm4gZnVuY3Rpb24oYyl7XG5cdFx0aWYoYyA9PT0gY2hhcikgdGhpcy5fc3RhdGUgPSBTVUNDRVNTO1xuXHR9O1xufVxuXG5mdW5jdGlvbiBpZkVsc2VTdGF0ZSh1cHBlciwgU1VDQ0VTUywgRkFJTFVSRSl7XG5cdHZhciBsb3dlciA9IHVwcGVyLnRvTG93ZXJDYXNlKCk7XG5cblx0aWYodXBwZXIgPT09IGxvd2VyKXtcblx0XHRyZXR1cm4gZnVuY3Rpb24oYyl7XG5cdFx0XHRpZihjID09PSBsb3dlcil7XG5cdFx0XHRcdHRoaXMuX3N0YXRlID0gU1VDQ0VTUztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3N0YXRlID0gRkFJTFVSRTtcblx0XHRcdFx0dGhpcy5faW5kZXgtLTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBmdW5jdGlvbihjKXtcblx0XHRcdGlmKGMgPT09IGxvd2VyIHx8IGMgPT09IHVwcGVyKXtcblx0XHRcdFx0dGhpcy5fc3RhdGUgPSBTVUNDRVNTO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fc3RhdGUgPSBGQUlMVVJFO1xuXHRcdFx0XHR0aGlzLl9pbmRleC0tO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn1cblxuZnVuY3Rpb24gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcih1cHBlciwgTkVYVF9TVEFURSl7XG5cdHZhciBsb3dlciA9IHVwcGVyLnRvTG93ZXJDYXNlKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uKGMpe1xuXHRcdGlmKGMgPT09IGxvd2VyIHx8IGMgPT09IHVwcGVyKXtcblx0XHRcdHRoaXMuX3N0YXRlID0gTkVYVF9TVEFURTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fc3RhdGUgPSBJTl9UQUdfTkFNRTtcblx0XHRcdHRoaXMuX2luZGV4LS07IC8vY29uc3VtZSB0aGUgdG9rZW4gYWdhaW5cblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFRva2VuaXplcihvcHRpb25zLCBjYnMpe1xuXHR0aGlzLl9zdGF0ZSA9IFRFWFQ7XG5cdHRoaXMuX2J1ZmZlciA9IFwiXCI7XG5cdHRoaXMuX3NlY3Rpb25TdGFydCA9IDA7XG5cdHRoaXMuX2luZGV4ID0gMDtcblx0dGhpcy5fYnVmZmVyT2Zmc2V0ID0gMDsgLy9jaGFycyByZW1vdmVkIGZyb20gX2J1ZmZlclxuXHR0aGlzLl9iYXNlU3RhdGUgPSBURVhUO1xuXHR0aGlzLl9zcGVjaWFsID0gU1BFQ0lBTF9OT05FO1xuXHR0aGlzLl9jYnMgPSBjYnM7XG5cdHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXHR0aGlzLl9lbmRlZCA9IGZhbHNlO1xuXHR0aGlzLl94bWxNb2RlID0gISEob3B0aW9ucyAmJiBvcHRpb25zLnhtbE1vZGUpO1xuXHR0aGlzLl9kZWNvZGVFbnRpdGllcyA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWNvZGVFbnRpdGllcyk7XG59XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlVGV4dCA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIjxcIil7XG5cdFx0aWYodGhpcy5faW5kZXggPiB0aGlzLl9zZWN0aW9uU3RhcnQpe1xuXHRcdFx0dGhpcy5fY2JzLm9udGV4dCh0aGlzLl9nZXRTZWN0aW9uKCkpO1xuXHRcdH1cblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9UQUdfTkFNRTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcblx0fSBlbHNlIGlmKHRoaXMuX2RlY29kZUVudGl0aWVzICYmIHRoaXMuX3NwZWNpYWwgPT09IFNQRUNJQUxfTk9ORSAmJiBjID09PSBcIiZcIil7XG5cdFx0aWYodGhpcy5faW5kZXggPiB0aGlzLl9zZWN0aW9uU3RhcnQpe1xuXHRcdFx0dGhpcy5fY2JzLm9udGV4dCh0aGlzLl9nZXRTZWN0aW9uKCkpO1xuXHRcdH1cblx0XHR0aGlzLl9iYXNlU3RhdGUgPSBURVhUO1xuXHRcdHRoaXMuX3N0YXRlID0gQkVGT1JFX0VOVElUWTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcblx0fVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVUYWdOYW1lID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiL1wiKXtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9DTE9TSU5HX1RBR19OQU1FO1xuXHR9IGVsc2UgaWYoYyA9PT0gXCI8XCIpe1xuXHRcdHRoaXMuX2Nicy5vbnRleHQodGhpcy5fZ2V0U2VjdGlvbigpKTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcblx0fSBlbHNlIGlmKGMgPT09IFwiPlwiIHx8IHRoaXMuX3NwZWNpYWwgIT09IFNQRUNJQUxfTk9ORSB8fCB3aGl0ZXNwYWNlKGMpKSB7XG5cdFx0dGhpcy5fc3RhdGUgPSBURVhUO1xuXHR9IGVsc2UgaWYoYyA9PT0gXCIhXCIpe1xuXHRcdHRoaXMuX3N0YXRlID0gQkVGT1JFX0RFQ0xBUkFUSU9OO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcblx0fSBlbHNlIGlmKGMgPT09IFwiP1wiKXtcblx0XHR0aGlzLl9zdGF0ZSA9IElOX1BST0NFU1NJTkdfSU5TVFJVQ1RJT047XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuX3N0YXRlID0gKCF0aGlzLl94bWxNb2RlICYmIChjID09PSBcInNcIiB8fCBjID09PSBcIlNcIikpID9cblx0XHRcdFx0XHRcdEJFRk9SRV9TUEVDSUFMIDogSU5fVEFHX05BTUU7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5UYWdOYW1lID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiL1wiIHx8IGMgPT09IFwiPlwiIHx8IHdoaXRlc3BhY2UoYykpe1xuXHRcdHRoaXMuX2VtaXRUb2tlbihcIm9ub3BlbnRhZ25hbWVcIik7XG5cdFx0dGhpcy5fc3RhdGUgPSBCRUZPUkVfQVRUUklCVVRFX05BTUU7XG5cdFx0dGhpcy5faW5kZXgtLTtcblx0fVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVDbG9zZWluZ1RhZ05hbWUgPSBmdW5jdGlvbihjKXtcblx0aWYod2hpdGVzcGFjZShjKSk7XG5cdGVsc2UgaWYoYyA9PT0gXCI+XCIpe1xuXHRcdHRoaXMuX3N0YXRlID0gVEVYVDtcblx0fSBlbHNlIGlmKHRoaXMuX3NwZWNpYWwgIT09IFNQRUNJQUxfTk9ORSl7XG5cdFx0aWYoYyA9PT0gXCJzXCIgfHwgYyA9PT0gXCJTXCIpe1xuXHRcdFx0dGhpcy5fc3RhdGUgPSBCRUZPUkVfU1BFQ0lBTF9FTkQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3N0YXRlID0gVEVYVDtcblx0XHRcdHRoaXMuX2luZGV4LS07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMuX3N0YXRlID0gSU5fQ0xPU0lOR19UQUdfTkFNRTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcblx0fVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbkNsb3NlaW5nVGFnTmFtZSA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIj5cIiB8fCB3aGl0ZXNwYWNlKGMpKXtcblx0XHR0aGlzLl9lbWl0VG9rZW4oXCJvbmNsb3NldGFnXCIpO1xuXHRcdHRoaXMuX3N0YXRlID0gQUZURVJfQ0xPU0lOR19UQUdfTkFNRTtcblx0XHR0aGlzLl9pbmRleC0tO1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyQ2xvc2VpbmdUYWdOYW1lID0gZnVuY3Rpb24oYyl7XG5cdC8vc2tpcCBldmVyeXRoaW5nIHVudGlsIFwiPlwiXG5cdGlmKGMgPT09IFwiPlwiKXtcblx0XHR0aGlzLl9zdGF0ZSA9IFRFWFQ7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUF0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCI+XCIpe1xuXHRcdHRoaXMuX2Nicy5vbm9wZW50YWdlbmQoKTtcblx0XHR0aGlzLl9zdGF0ZSA9IFRFWFQ7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuXHR9IGVsc2UgaWYoYyA9PT0gXCIvXCIpe1xuXHRcdHRoaXMuX3N0YXRlID0gSU5fU0VMRl9DTE9TSU5HX1RBRztcblx0fSBlbHNlIGlmKCF3aGl0ZXNwYWNlKGMpKXtcblx0XHR0aGlzLl9zdGF0ZSA9IElOX0FUVFJJQlVURV9OQU1FO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluU2VsZkNsb3NpbmdUYWcgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCI+XCIpe1xuXHRcdHRoaXMuX2Nicy5vbnNlbGZjbG9zaW5ndGFnKCk7XG5cdFx0dGhpcy5fc3RhdGUgPSBURVhUO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcblx0fSBlbHNlIGlmKCF3aGl0ZXNwYWNlKGMpKXtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9BVFRSSUJVVEVfTkFNRTtcblx0XHR0aGlzLl9pbmRleC0tO1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIj1cIiB8fCBjID09PSBcIi9cIiB8fCBjID09PSBcIj5cIiB8fCB3aGl0ZXNwYWNlKGMpKXtcblx0XHR0aGlzLl9jYnMub25hdHRyaWJuYW1lKHRoaXMuX2dldFNlY3Rpb24oKSk7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gLTE7XG5cdFx0dGhpcy5fc3RhdGUgPSBBRlRFUl9BVFRSSUJVVEVfTkFNRTtcblx0XHR0aGlzLl9pbmRleC0tO1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIj1cIil7XG5cdFx0dGhpcy5fc3RhdGUgPSBCRUZPUkVfQVRUUklCVVRFX1ZBTFVFO1xuXHR9IGVsc2UgaWYoYyA9PT0gXCIvXCIgfHwgYyA9PT0gXCI+XCIpe1xuXHRcdHRoaXMuX2Nicy5vbmF0dHJpYmVuZCgpO1xuXHRcdHRoaXMuX3N0YXRlID0gQkVGT1JFX0FUVFJJQlVURV9OQU1FO1xuXHRcdHRoaXMuX2luZGV4LS07XG5cdH0gZWxzZSBpZighd2hpdGVzcGFjZShjKSl7XG5cdFx0dGhpcy5fY2JzLm9uYXR0cmliZW5kKCk7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9BVFRSSUJVVEVfTkFNRTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcblx0fVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVBdHRyaWJ1dGVWYWx1ZSA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIlxcXCJcIil7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9BVFRSSUJVVEVfVkFMVUVfRFE7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuXHR9IGVsc2UgaWYoYyA9PT0gXCInXCIpe1xuXHRcdHRoaXMuX3N0YXRlID0gSU5fQVRUUklCVVRFX1ZBTFVFX1NRO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcblx0fSBlbHNlIGlmKCF3aGl0ZXNwYWNlKGMpKXtcblx0XHR0aGlzLl9zdGF0ZSA9IElOX0FUVFJJQlVURV9WQUxVRV9OUTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcblx0XHR0aGlzLl9pbmRleC0tOyAvL3JlY29uc3VtZSB0b2tlblxuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluQXR0cmlidXRlVmFsdWVEb3VibGVRdW90ZXMgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCJcXFwiXCIpe1xuXHRcdHRoaXMuX2VtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTtcblx0XHR0aGlzLl9jYnMub25hdHRyaWJlbmQoKTtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9BVFRSSUJVVEVfTkFNRTtcblx0fSBlbHNlIGlmKHRoaXMuX2RlY29kZUVudGl0aWVzICYmIGMgPT09IFwiJlwiKXtcblx0XHR0aGlzLl9lbWl0VG9rZW4oXCJvbmF0dHJpYmRhdGFcIik7XG5cdFx0dGhpcy5fYmFzZVN0YXRlID0gdGhpcy5fc3RhdGU7XG5cdFx0dGhpcy5fc3RhdGUgPSBCRUZPUkVfRU5USVRZO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluQXR0cmlidXRlVmFsdWVTaW5nbGVRdW90ZXMgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCInXCIpe1xuXHRcdHRoaXMuX2VtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTtcblx0XHR0aGlzLl9jYnMub25hdHRyaWJlbmQoKTtcblx0XHR0aGlzLl9zdGF0ZSA9IEJFRk9SRV9BVFRSSUJVVEVfTkFNRTtcblx0fSBlbHNlIGlmKHRoaXMuX2RlY29kZUVudGl0aWVzICYmIGMgPT09IFwiJlwiKXtcblx0XHR0aGlzLl9lbWl0VG9rZW4oXCJvbmF0dHJpYmRhdGFcIik7XG5cdFx0dGhpcy5fYmFzZVN0YXRlID0gdGhpcy5fc3RhdGU7XG5cdFx0dGhpcy5fc3RhdGUgPSBCRUZPUkVfRU5USVRZO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluQXR0cmlidXRlVmFsdWVOb1F1b3RlcyA9IGZ1bmN0aW9uKGMpe1xuXHRpZih3aGl0ZXNwYWNlKGMpIHx8IGMgPT09IFwiPlwiKXtcblx0XHR0aGlzLl9lbWl0VG9rZW4oXCJvbmF0dHJpYmRhdGFcIik7XG5cdFx0dGhpcy5fY2JzLm9uYXR0cmliZW5kKCk7XG5cdFx0dGhpcy5fc3RhdGUgPSBCRUZPUkVfQVRUUklCVVRFX05BTUU7XG5cdFx0dGhpcy5faW5kZXgtLTtcblx0fSBlbHNlIGlmKHRoaXMuX2RlY29kZUVudGl0aWVzICYmIGMgPT09IFwiJlwiKXtcblx0XHR0aGlzLl9lbWl0VG9rZW4oXCJvbmF0dHJpYmRhdGFcIik7XG5cdFx0dGhpcy5fYmFzZVN0YXRlID0gdGhpcy5fc3RhdGU7XG5cdFx0dGhpcy5fc3RhdGUgPSBCRUZPUkVfRU5USVRZO1xuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZURlY2xhcmF0aW9uID0gZnVuY3Rpb24oYyl7XG5cdHRoaXMuX3N0YXRlID0gYyA9PT0gXCJbXCIgPyBCRUZPUkVfQ0RBVEFfMSA6XG5cdFx0XHRcdFx0YyA9PT0gXCItXCIgPyBCRUZPUkVfQ09NTUVOVCA6XG5cdFx0XHRcdFx0XHRJTl9ERUNMQVJBVElPTjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5EZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIj5cIil7XG5cdFx0dGhpcy5fY2JzLm9uZGVjbGFyYXRpb24odGhpcy5fZ2V0U2VjdGlvbigpKTtcblx0XHR0aGlzLl9zdGF0ZSA9IFRFWFQ7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiPlwiKXtcblx0XHR0aGlzLl9jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24odGhpcy5fZ2V0U2VjdGlvbigpKTtcblx0XHR0aGlzLl9zdGF0ZSA9IFRFWFQ7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUNvbW1lbnQgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCItXCIpe1xuXHRcdHRoaXMuX3N0YXRlID0gSU5fQ09NTUVOVDtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9ERUNMQVJBVElPTjtcblx0fVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbkNvbW1lbnQgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCItXCIpIHRoaXMuX3N0YXRlID0gQUZURVJfQ09NTUVOVF8xO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlckNvbW1lbnQxID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiLVwiKXtcblx0XHR0aGlzLl9zdGF0ZSA9IEFGVEVSX0NPTU1FTlRfMjtcblx0fSBlbHNlIHtcblx0XHR0aGlzLl9zdGF0ZSA9IElOX0NPTU1FTlQ7XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJDb21tZW50MiA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIj5cIil7XG5cdFx0Ly9yZW1vdmUgMiB0cmFpbGluZyBjaGFyc1xuXHRcdHRoaXMuX2Nicy5vbmNvbW1lbnQodGhpcy5fYnVmZmVyLnN1YnN0cmluZyh0aGlzLl9zZWN0aW9uU3RhcnQsIHRoaXMuX2luZGV4IC0gMikpO1xuXHRcdHRoaXMuX3N0YXRlID0gVEVYVDtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG5cdH0gZWxzZSBpZihjICE9PSBcIi1cIil7XG5cdFx0dGhpcy5fc3RhdGUgPSBJTl9DT01NRU5UO1xuXHR9XG5cdC8vIGVsc2U6IHN0YXkgaW4gQUZURVJfQ09NTUVOVF8yIChgLS0tPmApXG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUNkYXRhMSA9IGlmRWxzZVN0YXRlKFwiQ1wiLCBCRUZPUkVfQ0RBVEFfMiwgSU5fREVDTEFSQVRJT04pO1xuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVDZGF0YTIgPSBpZkVsc2VTdGF0ZShcIkRcIiwgQkVGT1JFX0NEQVRBXzMsIElOX0RFQ0xBUkFUSU9OKTtcblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlQ2RhdGEzID0gaWZFbHNlU3RhdGUoXCJBXCIsIEJFRk9SRV9DREFUQV80LCBJTl9ERUNMQVJBVElPTik7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUNkYXRhNCA9IGlmRWxzZVN0YXRlKFwiVFwiLCBCRUZPUkVfQ0RBVEFfNSwgSU5fREVDTEFSQVRJT04pO1xuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVDZGF0YTUgPSBpZkVsc2VTdGF0ZShcIkFcIiwgQkVGT1JFX0NEQVRBXzYsIElOX0RFQ0xBUkFUSU9OKTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVDZGF0YTYgPSBmdW5jdGlvbihjKXtcblx0aWYoYyA9PT0gXCJbXCIpe1xuXHRcdHRoaXMuX3N0YXRlID0gSU5fQ0RBVEE7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuX3N0YXRlID0gSU5fREVDTEFSQVRJT047XG5cdFx0dGhpcy5faW5kZXgtLTtcblx0fVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbkNkYXRhID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiXVwiKSB0aGlzLl9zdGF0ZSA9IEFGVEVSX0NEQVRBXzE7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyQ2RhdGExID0gY2hhcmFjdGVyU3RhdGUoXCJdXCIsIEFGVEVSX0NEQVRBXzIpO1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyQ2RhdGEyID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiPlwiKXtcblx0XHQvL3JlbW92ZSAyIHRyYWlsaW5nIGNoYXJzXG5cdFx0dGhpcy5fY2JzLm9uY2RhdGEodGhpcy5fYnVmZmVyLnN1YnN0cmluZyh0aGlzLl9zZWN0aW9uU3RhcnQsIHRoaXMuX2luZGV4IC0gMikpO1xuXHRcdHRoaXMuX3N0YXRlID0gVEVYVDtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG5cdH0gZWxzZSBpZihjICE9PSBcIl1cIikge1xuXHRcdHRoaXMuX3N0YXRlID0gSU5fQ0RBVEE7XG5cdH1cblx0Ly9lbHNlOiBzdGF5IGluIEFGVEVSX0NEQVRBXzIgKGBdXV0+YClcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlU3BlY2lhbCA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcImNcIiB8fCBjID09PSBcIkNcIil7XG5cdFx0dGhpcy5fc3RhdGUgPSBCRUZPUkVfU0NSSVBUXzE7XG5cdH0gZWxzZSBpZihjID09PSBcInRcIiB8fCBjID09PSBcIlRcIil7XG5cdFx0dGhpcy5fc3RhdGUgPSBCRUZPUkVfU1RZTEVfMTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLl9zdGF0ZSA9IElOX1RBR19OQU1FO1xuXHRcdHRoaXMuX2luZGV4LS07IC8vY29uc3VtZSB0aGUgdG9rZW4gYWdhaW5cblx0fVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTcGVjaWFsRW5kID0gZnVuY3Rpb24oYyl7XG5cdGlmKHRoaXMuX3NwZWNpYWwgPT09IFNQRUNJQUxfU0NSSVBUICYmIChjID09PSBcImNcIiB8fCBjID09PSBcIkNcIikpe1xuXHRcdHRoaXMuX3N0YXRlID0gQUZURVJfU0NSSVBUXzE7XG5cdH0gZWxzZSBpZih0aGlzLl9zcGVjaWFsID09PSBTUEVDSUFMX1NUWUxFICYmIChjID09PSBcInRcIiB8fCBjID09PSBcIlRcIikpe1xuXHRcdHRoaXMuX3N0YXRlID0gQUZURVJfU1RZTEVfMTtcblx0fVxuXHRlbHNlIHRoaXMuX3N0YXRlID0gVEVYVDtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlU2NyaXB0MSA9IGNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJSXCIsIEJFRk9SRV9TQ1JJUFRfMik7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZVNjcmlwdDIgPSBjb25zdW1lU3BlY2lhbE5hbWVDaGFyKFwiSVwiLCBCRUZPUkVfU0NSSVBUXzMpO1xuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTY3JpcHQzID0gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIlBcIiwgQkVGT1JFX1NDUklQVF80KTtcblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlU2NyaXB0NCA9IGNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJUXCIsIEJFRk9SRV9TQ1JJUFRfNSk7XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlU2NyaXB0NSA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIi9cIiB8fCBjID09PSBcIj5cIiB8fCB3aGl0ZXNwYWNlKGMpKXtcblx0XHR0aGlzLl9zcGVjaWFsID0gU1BFQ0lBTF9TQ1JJUFQ7XG5cdH1cblx0dGhpcy5fc3RhdGUgPSBJTl9UQUdfTkFNRTtcblx0dGhpcy5faW5kZXgtLTsgLy9jb25zdW1lIHRoZSB0b2tlbiBhZ2FpblxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlclNjcmlwdDEgPSBpZkVsc2VTdGF0ZShcIlJcIiwgQUZURVJfU0NSSVBUXzIsIFRFWFQpO1xuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlclNjcmlwdDIgPSBpZkVsc2VTdGF0ZShcIklcIiwgQUZURVJfU0NSSVBUXzMsIFRFWFQpO1xuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlclNjcmlwdDMgPSBpZkVsc2VTdGF0ZShcIlBcIiwgQUZURVJfU0NSSVBUXzQsIFRFWFQpO1xuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlclNjcmlwdDQgPSBpZkVsc2VTdGF0ZShcIlRcIiwgQUZURVJfU0NSSVBUXzUsIFRFWFQpO1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyU2NyaXB0NSA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIj5cIiB8fCB3aGl0ZXNwYWNlKGMpKXtcblx0XHR0aGlzLl9zcGVjaWFsID0gU1BFQ0lBTF9OT05FO1xuXHRcdHRoaXMuX3N0YXRlID0gSU5fQ0xPU0lOR19UQUdfTkFNRTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCAtIDY7XG5cdFx0dGhpcy5faW5kZXgtLTsgLy9yZWNvbnN1bWUgdGhlIHRva2VuXG5cdH1cblx0ZWxzZSB0aGlzLl9zdGF0ZSA9IFRFWFQ7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZVN0eWxlMSA9IGNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJZXCIsIEJFRk9SRV9TVFlMRV8yKTtcblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlU3R5bGUyID0gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIkxcIiwgQkVGT1JFX1NUWUxFXzMpO1xuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTdHlsZTMgPSBjb25zdW1lU3BlY2lhbE5hbWVDaGFyKFwiRVwiLCBCRUZPUkVfU1RZTEVfNCk7XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlU3R5bGU0ID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiL1wiIHx8IGMgPT09IFwiPlwiIHx8IHdoaXRlc3BhY2UoYykpe1xuXHRcdHRoaXMuX3NwZWNpYWwgPSBTUEVDSUFMX1NUWUxFO1xuXHR9XG5cdHRoaXMuX3N0YXRlID0gSU5fVEFHX05BTUU7XG5cdHRoaXMuX2luZGV4LS07IC8vY29uc3VtZSB0aGUgdG9rZW4gYWdhaW5cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJTdHlsZTEgPSBpZkVsc2VTdGF0ZShcIllcIiwgQUZURVJfU1RZTEVfMiwgVEVYVCk7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyU3R5bGUyID0gaWZFbHNlU3RhdGUoXCJMXCIsIEFGVEVSX1NUWUxFXzMsIFRFWFQpO1xuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlclN0eWxlMyA9IGlmRWxzZVN0YXRlKFwiRVwiLCBBRlRFUl9TVFlMRV80LCBURVhUKTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlclN0eWxlNCA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIj5cIiB8fCB3aGl0ZXNwYWNlKGMpKXtcblx0XHR0aGlzLl9zcGVjaWFsID0gU1BFQ0lBTF9OT05FO1xuXHRcdHRoaXMuX3N0YXRlID0gSU5fQ0xPU0lOR19UQUdfTkFNRTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCAtIDU7XG5cdFx0dGhpcy5faW5kZXgtLTsgLy9yZWNvbnN1bWUgdGhlIHRva2VuXG5cdH1cblx0ZWxzZSB0aGlzLl9zdGF0ZSA9IFRFWFQ7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUVudGl0eSA9IGlmRWxzZVN0YXRlKFwiI1wiLCBCRUZPUkVfTlVNRVJJQ19FTlRJVFksIElOX05BTUVEX0VOVElUWSk7XG5Ub2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZU51bWVyaWNFbnRpdHkgPSBpZkVsc2VTdGF0ZShcIlhcIiwgSU5fSEVYX0VOVElUWSwgSU5fTlVNRVJJQ19FTlRJVFkpO1xuXG4vL2ZvciBlbnRpdGllcyB0ZXJtaW5hdGVkIHdpdGggYSBzZW1pY29sb25cblRva2VuaXplci5wcm90b3R5cGUuX3BhcnNlTmFtZWRFbnRpdHlTdHJpY3QgPSBmdW5jdGlvbigpe1xuXHQvL29mZnNldCA9IDFcblx0aWYodGhpcy5fc2VjdGlvblN0YXJ0ICsgMSA8IHRoaXMuX2luZGV4KXtcblx0XHR2YXIgZW50aXR5ID0gdGhpcy5fYnVmZmVyLnN1YnN0cmluZyh0aGlzLl9zZWN0aW9uU3RhcnQgKyAxLCB0aGlzLl9pbmRleCksXG5cdFx0ICAgIG1hcCA9IHRoaXMuX3htbE1vZGUgPyB4bWxNYXAgOiBlbnRpdHlNYXA7XG5cblx0XHRpZihtYXAuaGFzT3duUHJvcGVydHkoZW50aXR5KSl7XG5cdFx0XHR0aGlzLl9lbWl0UGFydGlhbChtYXBbZW50aXR5XSk7XG5cdFx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG5cdFx0fVxuXHR9XG59O1xuXG5cbi8vcGFyc2VzIGxlZ2FjeSBlbnRpdGllcyAod2l0aG91dCB0cmFpbGluZyBzZW1pY29sb24pXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9wYXJzZUxlZ2FjeUVudGl0eSA9IGZ1bmN0aW9uKCl7XG5cdHZhciBzdGFydCA9IHRoaXMuX3NlY3Rpb25TdGFydCArIDEsXG5cdCAgICBsaW1pdCA9IHRoaXMuX2luZGV4IC0gc3RhcnQ7XG5cblx0aWYobGltaXQgPiA2KSBsaW1pdCA9IDY7IC8vdGhlIG1heCBsZW5ndGggb2YgbGVnYWN5IGVudGl0aWVzIGlzIDZcblxuXHR3aGlsZShsaW1pdCA+PSAyKXsgLy90aGUgbWluIGxlbmd0aCBvZiBsZWdhY3kgZW50aXRpZXMgaXMgMlxuXHRcdHZhciBlbnRpdHkgPSB0aGlzLl9idWZmZXIuc3Vic3RyKHN0YXJ0LCBsaW1pdCk7XG5cblx0XHRpZihsZWdhY3lNYXAuaGFzT3duUHJvcGVydHkoZW50aXR5KSl7XG5cdFx0XHR0aGlzLl9lbWl0UGFydGlhbChsZWdhY3lNYXBbZW50aXR5XSk7XG5cdFx0XHR0aGlzLl9zZWN0aW9uU3RhcnQgKz0gbGltaXQgKyAxO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsaW1pdC0tO1xuXHRcdH1cblx0fVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbk5hbWVkRW50aXR5ID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiO1wiKXtcblx0XHR0aGlzLl9wYXJzZU5hbWVkRW50aXR5U3RyaWN0KCk7XG5cdFx0aWYodGhpcy5fc2VjdGlvblN0YXJ0ICsgMSA8IHRoaXMuX2luZGV4ICYmICF0aGlzLl94bWxNb2RlKXtcblx0XHRcdHRoaXMuX3BhcnNlTGVnYWN5RW50aXR5KCk7XG5cdFx0fVxuXHRcdHRoaXMuX3N0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXHR9IGVsc2UgaWYoKGMgPCBcImFcIiB8fCBjID4gXCJ6XCIpICYmIChjIDwgXCJBXCIgfHwgYyA+IFwiWlwiKSAmJiAoYyA8IFwiMFwiIHx8IGMgPiBcIjlcIikpe1xuXHRcdGlmKHRoaXMuX3htbE1vZGUpO1xuXHRcdGVsc2UgaWYodGhpcy5fc2VjdGlvblN0YXJ0ICsgMSA9PT0gdGhpcy5faW5kZXgpO1xuXHRcdGVsc2UgaWYodGhpcy5fYmFzZVN0YXRlICE9PSBURVhUKXtcblx0XHRcdGlmKGMgIT09IFwiPVwiKXtcblx0XHRcdFx0dGhpcy5fcGFyc2VOYW1lZEVudGl0eVN0cmljdCgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9wYXJzZUxlZ2FjeUVudGl0eSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXHRcdHRoaXMuX2luZGV4LS07XG5cdH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2RlY29kZU51bWVyaWNFbnRpdHkgPSBmdW5jdGlvbihvZmZzZXQsIGJhc2Upe1xuXHR2YXIgc2VjdGlvblN0YXJ0ID0gdGhpcy5fc2VjdGlvblN0YXJ0ICsgb2Zmc2V0O1xuXG5cdGlmKHNlY3Rpb25TdGFydCAhPT0gdGhpcy5faW5kZXgpe1xuXHRcdC8vcGFyc2UgZW50aXR5XG5cdFx0dmFyIGVudGl0eSA9IHRoaXMuX2J1ZmZlci5zdWJzdHJpbmcoc2VjdGlvblN0YXJ0LCB0aGlzLl9pbmRleCk7XG5cdFx0dmFyIHBhcnNlZCA9IHBhcnNlSW50KGVudGl0eSwgYmFzZSk7XG5cblx0XHR0aGlzLl9lbWl0UGFydGlhbChkZWNvZGVDb2RlUG9pbnQocGFyc2VkKSk7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0LS07XG5cdH1cblxuXHR0aGlzLl9zdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5OdW1lcmljRW50aXR5ID0gZnVuY3Rpb24oYyl7XG5cdGlmKGMgPT09IFwiO1wiKXtcblx0XHR0aGlzLl9kZWNvZGVOdW1lcmljRW50aXR5KDIsIDEwKTtcblx0XHR0aGlzLl9zZWN0aW9uU3RhcnQrKztcblx0fSBlbHNlIGlmKGMgPCBcIjBcIiB8fCBjID4gXCI5XCIpe1xuXHRcdGlmKCF0aGlzLl94bWxNb2RlKXtcblx0XHRcdHRoaXMuX2RlY29kZU51bWVyaWNFbnRpdHkoMiwgMTApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblx0XHR9XG5cdFx0dGhpcy5faW5kZXgtLTtcblx0fVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbkhleEVudGl0eSA9IGZ1bmN0aW9uKGMpe1xuXHRpZihjID09PSBcIjtcIil7XG5cdFx0dGhpcy5fZGVjb2RlTnVtZXJpY0VudGl0eSgzLCAxNik7XG5cdFx0dGhpcy5fc2VjdGlvblN0YXJ0Kys7XG5cdH0gZWxzZSBpZigoYyA8IFwiYVwiIHx8IGMgPiBcImZcIikgJiYgKGMgPCBcIkFcIiB8fCBjID4gXCJGXCIpICYmIChjIDwgXCIwXCIgfHwgYyA+IFwiOVwiKSl7XG5cdFx0aWYoIXRoaXMuX3htbE1vZGUpe1xuXHRcdFx0dGhpcy5fZGVjb2RlTnVtZXJpY0VudGl0eSgzLCAxNik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3N0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXHRcdH1cblx0XHR0aGlzLl9pbmRleC0tO1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24gKCl7XG5cdGlmKHRoaXMuX3NlY3Rpb25TdGFydCA8IDApe1xuXHRcdHRoaXMuX2J1ZmZlciA9IFwiXCI7XG5cdFx0dGhpcy5fYnVmZmVyT2Zmc2V0ICs9IHRoaXMuX2luZGV4O1xuXHRcdHRoaXMuX2luZGV4ID0gMDtcblx0fSBlbHNlIGlmKHRoaXMuX3J1bm5pbmcpe1xuXHRcdGlmKHRoaXMuX3N0YXRlID09PSBURVhUKXtcblx0XHRcdGlmKHRoaXMuX3NlY3Rpb25TdGFydCAhPT0gdGhpcy5faW5kZXgpe1xuXHRcdFx0XHR0aGlzLl9jYnMub250ZXh0KHRoaXMuX2J1ZmZlci5zdWJzdHIodGhpcy5fc2VjdGlvblN0YXJ0KSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9idWZmZXIgPSBcIlwiO1xuXHRcdFx0dGhpcy5fYnVmZmVyT2Zmc2V0ICs9IHRoaXMuX2luZGV4O1xuXHRcdFx0dGhpcy5faW5kZXggPSAwO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zZWN0aW9uU3RhcnQgPT09IHRoaXMuX2luZGV4KXtcblx0XHRcdC8vdGhlIHNlY3Rpb24ganVzdCBzdGFydGVkXG5cdFx0XHR0aGlzLl9idWZmZXIgPSBcIlwiO1xuXHRcdFx0dGhpcy5fYnVmZmVyT2Zmc2V0ICs9IHRoaXMuX2luZGV4O1xuXHRcdFx0dGhpcy5faW5kZXggPSAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvL3JlbW92ZSBldmVyeXRoaW5nIHVubmVjZXNzYXJ5XG5cdFx0XHR0aGlzLl9idWZmZXIgPSB0aGlzLl9idWZmZXIuc3Vic3RyKHRoaXMuX3NlY3Rpb25TdGFydCk7XG5cdFx0XHR0aGlzLl9pbmRleCAtPSB0aGlzLl9zZWN0aW9uU3RhcnQ7XG5cdFx0XHR0aGlzLl9idWZmZXJPZmZzZXQgKz0gdGhpcy5fc2VjdGlvblN0YXJ0O1xuXHRcdH1cblxuXHRcdHRoaXMuX3NlY3Rpb25TdGFydCA9IDA7XG5cdH1cbn07XG5cbi8vVE9ETyBtYWtlIGV2ZW50cyBjb25kaXRpb25hbFxuVG9rZW5pemVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rKXtcblx0aWYodGhpcy5fZW5kZWQpIHRoaXMuX2Nicy5vbmVycm9yKEVycm9yKFwiLndyaXRlKCkgYWZ0ZXIgZG9uZSFcIikpO1xuXG5cdHRoaXMuX2J1ZmZlciArPSBjaHVuaztcblx0dGhpcy5fcGFyc2UoKTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3BhcnNlID0gZnVuY3Rpb24oKXtcblx0d2hpbGUodGhpcy5faW5kZXggPCB0aGlzLl9idWZmZXIubGVuZ3RoICYmIHRoaXMuX3J1bm5pbmcpe1xuXHRcdHZhciBjID0gdGhpcy5fYnVmZmVyLmNoYXJBdCh0aGlzLl9pbmRleCk7XG5cdFx0aWYodGhpcy5fc3RhdGUgPT09IFRFWFQpIHtcblx0XHRcdHRoaXMuX3N0YXRlVGV4dChjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9UQUdfTkFNRSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZVRhZ05hbWUoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBJTl9UQUdfTkFNRSkge1xuXHRcdFx0dGhpcy5fc3RhdGVJblRhZ05hbWUoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfQ0xPU0lOR19UQUdfTkFNRSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZUNsb3NlaW5nVGFnTmFtZShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX0NMT1NJTkdfVEFHX05BTUUpe1xuXHRcdFx0dGhpcy5fc3RhdGVJbkNsb3NlaW5nVGFnTmFtZShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEFGVEVSX0NMT1NJTkdfVEFHX05BTUUpe1xuXHRcdFx0dGhpcy5fc3RhdGVBZnRlckNsb3NlaW5nVGFnTmFtZShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX1NFTEZfQ0xPU0lOR19UQUcpe1xuXHRcdFx0dGhpcy5fc3RhdGVJblNlbGZDbG9zaW5nVGFnKGMpO1xuXHRcdH1cblxuXHRcdC8qXG5cdFx0Klx0YXR0cmlidXRlc1xuXHRcdCovXG5cdFx0ZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX0FUVFJJQlVURV9OQU1FKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlQXR0cmlidXRlTmFtZShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX0FUVFJJQlVURV9OQU1FKXtcblx0XHRcdHRoaXMuX3N0YXRlSW5BdHRyaWJ1dGVOYW1lKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQUZURVJfQVRUUklCVVRFX05BTUUpe1xuXHRcdFx0dGhpcy5fc3RhdGVBZnRlckF0dHJpYnV0ZU5hbWUoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfQVRUUklCVVRFX1ZBTFVFKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlQXR0cmlidXRlVmFsdWUoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBJTl9BVFRSSUJVVEVfVkFMVUVfRFEpe1xuXHRcdFx0dGhpcy5fc3RhdGVJbkF0dHJpYnV0ZVZhbHVlRG91YmxlUXVvdGVzKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gSU5fQVRUUklCVVRFX1ZBTFVFX1NRKXtcblx0XHRcdHRoaXMuX3N0YXRlSW5BdHRyaWJ1dGVWYWx1ZVNpbmdsZVF1b3RlcyhjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX0FUVFJJQlVURV9WQUxVRV9OUSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUluQXR0cmlidXRlVmFsdWVOb1F1b3RlcyhjKTtcblx0XHR9XG5cblx0XHQvKlxuXHRcdCpcdGRlY2xhcmF0aW9uc1xuXHRcdCovXG5cdFx0ZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX0RFQ0xBUkFUSU9OKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlRGVjbGFyYXRpb24oYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBJTl9ERUNMQVJBVElPTil7XG5cdFx0XHR0aGlzLl9zdGF0ZUluRGVjbGFyYXRpb24oYyk7XG5cdFx0fVxuXG5cdFx0Lypcblx0XHQqXHRwcm9jZXNzaW5nIGluc3RydWN0aW9uc1xuXHRcdCovXG5cdFx0ZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gSU5fUFJPQ0VTU0lOR19JTlNUUlVDVElPTil7XG5cdFx0XHR0aGlzLl9zdGF0ZUluUHJvY2Vzc2luZ0luc3RydWN0aW9uKGMpO1xuXHRcdH1cblxuXHRcdC8qXG5cdFx0Klx0Y29tbWVudHNcblx0XHQqL1xuXHRcdGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9DT01NRU5UKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlQ29tbWVudChjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX0NPTU1FTlQpe1xuXHRcdFx0dGhpcy5fc3RhdGVJbkNvbW1lbnQoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBBRlRFUl9DT01NRU5UXzEpe1xuXHRcdFx0dGhpcy5fc3RhdGVBZnRlckNvbW1lbnQxKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQUZURVJfQ09NTUVOVF8yKXtcblx0XHRcdHRoaXMuX3N0YXRlQWZ0ZXJDb21tZW50MihjKTtcblx0XHR9XG5cblx0XHQvKlxuXHRcdCpcdGNkYXRhXG5cdFx0Ki9cblx0XHRlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfQ0RBVEFfMSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZUNkYXRhMShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9DREFUQV8yKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlQ2RhdGEyKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX0NEQVRBXzMpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVDZGF0YTMoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfQ0RBVEFfNCl7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZUNkYXRhNChjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9DREFUQV81KXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlQ2RhdGE1KGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX0NEQVRBXzYpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVDZGF0YTYoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBJTl9DREFUQSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUluQ2RhdGEoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBBRlRFUl9DREFUQV8xKXtcblx0XHRcdHRoaXMuX3N0YXRlQWZ0ZXJDZGF0YTEoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBBRlRFUl9DREFUQV8yKXtcblx0XHRcdHRoaXMuX3N0YXRlQWZ0ZXJDZGF0YTIoYyk7XG5cdFx0fVxuXG5cdFx0Lypcblx0XHQqIHNwZWNpYWwgdGFnc1xuXHRcdCovXG5cdFx0ZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX1NQRUNJQUwpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVTcGVjaWFsKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX1NQRUNJQUxfRU5EKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlU3BlY2lhbEVuZChjKTtcblx0XHR9XG5cblx0XHQvKlxuXHRcdCogc2NyaXB0XG5cdFx0Ki9cblx0XHRlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfU0NSSVBUXzEpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVTY3JpcHQxKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX1NDUklQVF8yKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlU2NyaXB0MihjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9TQ1JJUFRfMyl7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZVNjcmlwdDMoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfU0NSSVBUXzQpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVTY3JpcHQ0KGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX1NDUklQVF81KXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlU2NyaXB0NShjKTtcblx0XHR9XG5cblx0XHRlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBBRlRFUl9TQ1JJUFRfMSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUFmdGVyU2NyaXB0MShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEFGVEVSX1NDUklQVF8yKXtcblx0XHRcdHRoaXMuX3N0YXRlQWZ0ZXJTY3JpcHQyKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQUZURVJfU0NSSVBUXzMpe1xuXHRcdFx0dGhpcy5fc3RhdGVBZnRlclNjcmlwdDMoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBBRlRFUl9TQ1JJUFRfNCl7XG5cdFx0XHR0aGlzLl9zdGF0ZUFmdGVyU2NyaXB0NChjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEFGVEVSX1NDUklQVF81KXtcblx0XHRcdHRoaXMuX3N0YXRlQWZ0ZXJTY3JpcHQ1KGMpO1xuXHRcdH1cblxuXHRcdC8qXG5cdFx0KiBzdHlsZVxuXHRcdCovXG5cdFx0ZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX1NUWUxFXzEpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVTdHlsZTEoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBCRUZPUkVfU1RZTEVfMil7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZVN0eWxlMihjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9TVFlMRV8zKXtcblx0XHRcdHRoaXMuX3N0YXRlQmVmb3JlU3R5bGUzKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX1NUWUxFXzQpe1xuXHRcdFx0dGhpcy5fc3RhdGVCZWZvcmVTdHlsZTQoYyk7XG5cdFx0fVxuXG5cdFx0ZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQUZURVJfU1RZTEVfMSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUFmdGVyU3R5bGUxKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQUZURVJfU1RZTEVfMil7XG5cdFx0XHR0aGlzLl9zdGF0ZUFmdGVyU3R5bGUyKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQUZURVJfU1RZTEVfMyl7XG5cdFx0XHR0aGlzLl9zdGF0ZUFmdGVyU3R5bGUzKGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQUZURVJfU1RZTEVfNCl7XG5cdFx0XHR0aGlzLl9zdGF0ZUFmdGVyU3R5bGU0KGMpO1xuXHRcdH1cblxuXHRcdC8qXG5cdFx0KiBlbnRpdGllc1xuXHRcdCovXG5cdFx0ZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gQkVGT1JFX0VOVElUWSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZUVudGl0eShjKTtcblx0XHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IEJFRk9SRV9OVU1FUklDX0VOVElUWSl7XG5cdFx0XHR0aGlzLl9zdGF0ZUJlZm9yZU51bWVyaWNFbnRpdHkoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBJTl9OQU1FRF9FTlRJVFkpe1xuXHRcdFx0dGhpcy5fc3RhdGVJbk5hbWVkRW50aXR5KGMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gSU5fTlVNRVJJQ19FTlRJVFkpe1xuXHRcdFx0dGhpcy5fc3RhdGVJbk51bWVyaWNFbnRpdHkoYyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBJTl9IRVhfRU5USVRZKXtcblx0XHRcdHRoaXMuX3N0YXRlSW5IZXhFbnRpdHkoYyk7XG5cdFx0fVxuXG5cdFx0ZWxzZSB7XG5cdFx0XHR0aGlzLl9jYnMub25lcnJvcihFcnJvcihcInVua25vd24gX3N0YXRlXCIpLCB0aGlzLl9zdGF0ZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5faW5kZXgrKztcblx0fVxuXG5cdHRoaXMuX2NsZWFudXAoKTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpe1xuXHR0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG59O1xuVG9rZW5pemVyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpe1xuXHR0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcblxuXHRpZih0aGlzLl9pbmRleCA8IHRoaXMuX2J1ZmZlci5sZW5ndGgpe1xuXHRcdHRoaXMuX3BhcnNlKCk7XG5cdH1cblx0aWYodGhpcy5fZW5kZWQpe1xuXHRcdHRoaXMuX2ZpbmlzaCgpO1xuXHR9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rKXtcblx0aWYodGhpcy5fZW5kZWQpIHRoaXMuX2Nicy5vbmVycm9yKEVycm9yKFwiLmVuZCgpIGFmdGVyIGRvbmUhXCIpKTtcblx0aWYoY2h1bmspIHRoaXMud3JpdGUoY2h1bmspO1xuXG5cdHRoaXMuX2VuZGVkID0gdHJ1ZTtcblxuXHRpZih0aGlzLl9ydW5uaW5nKSB0aGlzLl9maW5pc2goKTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uKCl7XG5cdC8vaWYgdGhlcmUgaXMgcmVtYWluaW5nIGRhdGEsIGVtaXQgaXQgaW4gYSByZWFzb25hYmxlIHdheVxuXHRpZih0aGlzLl9zZWN0aW9uU3RhcnQgPCB0aGlzLl9pbmRleCl7XG5cdFx0dGhpcy5faGFuZGxlVHJhaWxpbmdEYXRhKCk7XG5cdH1cblxuXHR0aGlzLl9jYnMub25lbmQoKTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2hhbmRsZVRyYWlsaW5nRGF0YSA9IGZ1bmN0aW9uKCl7XG5cdHZhciBkYXRhID0gdGhpcy5fYnVmZmVyLnN1YnN0cih0aGlzLl9zZWN0aW9uU3RhcnQpO1xuXG5cdGlmKHRoaXMuX3N0YXRlID09PSBJTl9DREFUQSB8fCB0aGlzLl9zdGF0ZSA9PT0gQUZURVJfQ0RBVEFfMSB8fCB0aGlzLl9zdGF0ZSA9PT0gQUZURVJfQ0RBVEFfMil7XG5cdFx0dGhpcy5fY2JzLm9uY2RhdGEoZGF0YSk7XG5cdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gSU5fQ09NTUVOVCB8fCB0aGlzLl9zdGF0ZSA9PT0gQUZURVJfQ09NTUVOVF8xIHx8IHRoaXMuX3N0YXRlID09PSBBRlRFUl9DT01NRU5UXzIpe1xuXHRcdHRoaXMuX2Nicy5vbmNvbW1lbnQoZGF0YSk7XG5cdH0gZWxzZSBpZih0aGlzLl9zdGF0ZSA9PT0gSU5fTkFNRURfRU5USVRZICYmICF0aGlzLl94bWxNb2RlKXtcblx0XHR0aGlzLl9wYXJzZUxlZ2FjeUVudGl0eSgpO1xuXHRcdGlmKHRoaXMuX3NlY3Rpb25TdGFydCA8IHRoaXMuX2luZGV4KXtcblx0XHRcdHRoaXMuX3N0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXHRcdFx0dGhpcy5faGFuZGxlVHJhaWxpbmdEYXRhKCk7XG5cdFx0fVxuXHR9IGVsc2UgaWYodGhpcy5fc3RhdGUgPT09IElOX05VTUVSSUNfRU5USVRZICYmICF0aGlzLl94bWxNb2RlKXtcblx0XHR0aGlzLl9kZWNvZGVOdW1lcmljRW50aXR5KDIsIDEwKTtcblx0XHRpZih0aGlzLl9zZWN0aW9uU3RhcnQgPCB0aGlzLl9pbmRleCl7XG5cdFx0XHR0aGlzLl9zdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblx0XHRcdHRoaXMuX2hhbmRsZVRyYWlsaW5nRGF0YSgpO1xuXHRcdH1cblx0fSBlbHNlIGlmKHRoaXMuX3N0YXRlID09PSBJTl9IRVhfRU5USVRZICYmICF0aGlzLl94bWxNb2RlKXtcblx0XHR0aGlzLl9kZWNvZGVOdW1lcmljRW50aXR5KDMsIDE2KTtcblx0XHRpZih0aGlzLl9zZWN0aW9uU3RhcnQgPCB0aGlzLl9pbmRleCl7XG5cdFx0XHR0aGlzLl9zdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblx0XHRcdHRoaXMuX2hhbmRsZVRyYWlsaW5nRGF0YSgpO1xuXHRcdH1cblx0fSBlbHNlIGlmKFxuXHRcdHRoaXMuX3N0YXRlICE9PSBJTl9UQUdfTkFNRSAmJlxuXHRcdHRoaXMuX3N0YXRlICE9PSBCRUZPUkVfQVRUUklCVVRFX05BTUUgJiZcblx0XHR0aGlzLl9zdGF0ZSAhPT0gQkVGT1JFX0FUVFJJQlVURV9WQUxVRSAmJlxuXHRcdHRoaXMuX3N0YXRlICE9PSBBRlRFUl9BVFRSSUJVVEVfTkFNRSAmJlxuXHRcdHRoaXMuX3N0YXRlICE9PSBJTl9BVFRSSUJVVEVfTkFNRSAmJlxuXHRcdHRoaXMuX3N0YXRlICE9PSBJTl9BVFRSSUJVVEVfVkFMVUVfU1EgJiZcblx0XHR0aGlzLl9zdGF0ZSAhPT0gSU5fQVRUUklCVVRFX1ZBTFVFX0RRICYmXG5cdFx0dGhpcy5fc3RhdGUgIT09IElOX0FUVFJJQlVURV9WQUxVRV9OUSAmJlxuXHRcdHRoaXMuX3N0YXRlICE9PSBJTl9DTE9TSU5HX1RBR19OQU1FXG5cdCl7XG5cdFx0dGhpcy5fY2JzLm9udGV4dChkYXRhKTtcblx0fVxuXHQvL2Vsc2UsIGlnbm9yZSByZW1haW5pbmcgZGF0YVxuXHQvL1RPRE8gYWRkIGEgd2F5IHRvIHJlbW92ZSBjdXJyZW50IHRhZ1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG5cdFRva2VuaXplci5jYWxsKHRoaXMsIHt4bWxNb2RlOiB0aGlzLl94bWxNb2RlLCBkZWNvZGVFbnRpdGllczogdGhpcy5fZGVjb2RlRW50aXRpZXN9LCB0aGlzLl9jYnMpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5nZXRBYnNvbHV0ZUluZGV4ID0gZnVuY3Rpb24oKXtcblx0cmV0dXJuIHRoaXMuX2J1ZmZlck9mZnNldCArIHRoaXMuX2luZGV4O1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0U2VjdGlvbiA9IGZ1bmN0aW9uKCl7XG5cdHJldHVybiB0aGlzLl9idWZmZXIuc3Vic3RyaW5nKHRoaXMuX3NlY3Rpb25TdGFydCwgdGhpcy5faW5kZXgpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fZW1pdFRva2VuID0gZnVuY3Rpb24obmFtZSl7XG5cdHRoaXMuX2Nic1tuYW1lXSh0aGlzLl9nZXRTZWN0aW9uKCkpO1xuXHR0aGlzLl9zZWN0aW9uU3RhcnQgPSAtMTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2VtaXRQYXJ0aWFsID0gZnVuY3Rpb24odmFsdWUpe1xuXHRpZih0aGlzLl9iYXNlU3RhdGUgIT09IFRFWFQpe1xuXHRcdHRoaXMuX2Nicy5vbmF0dHJpYmRhdGEodmFsdWUpOyAvL1RPRE8gaW1wbGVtZW50IHRoZSBuZXcgZXZlbnRcblx0fSBlbHNlIHtcblx0XHR0aGlzLl9jYnMub250ZXh0KHZhbHVlKTtcblx0fVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgUGFyc2VyID0gcmVxdWlyZShcIi4vUGFyc2VyLmpzXCIpLFxuICAgIFdyaXRhYmxlU3RyZWFtID0gcmVxdWlyZShcInN0cmVhbVwiKS5Xcml0YWJsZSB8fCByZXF1aXJlKFwicmVhZGFibGUtc3RyZWFtXCIpLldyaXRhYmxlLFxuICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKFwic3RyaW5nX2RlY29kZXJcIikuU3RyaW5nRGVjb2RlcixcbiAgICBCdWZmZXIgPSByZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcblxuZnVuY3Rpb24gU3RyZWFtKGNicywgb3B0aW9ucyl7XG5cdHZhciBwYXJzZXIgPSB0aGlzLl9wYXJzZXIgPSBuZXcgUGFyc2VyKGNicywgb3B0aW9ucyk7XG5cdHZhciBkZWNvZGVyID0gdGhpcy5fZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCk7XG5cblx0V3JpdGFibGVTdHJlYW0uY2FsbCh0aGlzLCB7ZGVjb2RlU3RyaW5nczogZmFsc2V9KTtcblxuXHR0aGlzLm9uY2UoXCJmaW5pc2hcIiwgZnVuY3Rpb24oKXtcblx0XHRwYXJzZXIuZW5kKGRlY29kZXIuZW5kKCkpO1xuXHR9KTtcbn1cblxucmVxdWlyZShcImluaGVyaXRzXCIpKFN0cmVhbSwgV3JpdGFibGVTdHJlYW0pO1xuXG5Xcml0YWJsZVN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYil7XG5cdGlmKGNodW5rIGluc3RhbmNlb2YgQnVmZmVyKSBjaHVuayA9IHRoaXMuX2RlY29kZXIud3JpdGUoY2h1bmspO1xuXHR0aGlzLl9wYXJzZXIud3JpdGUoY2h1bmspO1xuXHRjYigpO1xufTsiLCJ2YXIgUGFyc2VyID0gcmVxdWlyZShcIi4vUGFyc2VyLmpzXCIpLFxuICAgIERvbUhhbmRsZXIgPSByZXF1aXJlKFwiZG9taGFuZGxlclwiKTtcblxuZnVuY3Rpb24gZGVmaW5lUHJvcChuYW1lLCB2YWx1ZSl7XG5cdGRlbGV0ZSBtb2R1bGUuZXhwb3J0c1tuYW1lXTtcblx0bW9kdWxlLmV4cG9ydHNbbmFtZV0gPSB2YWx1ZTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0UGFyc2VyOiBQYXJzZXIsXG5cdFRva2VuaXplcjogcmVxdWlyZShcIi4vVG9rZW5pemVyLmpzXCIpLFxuXHRFbGVtZW50VHlwZTogcmVxdWlyZShcImRvbWVsZW1lbnR0eXBlXCIpLFxuXHREb21IYW5kbGVyOiBEb21IYW5kbGVyLFxuXHRnZXQgRmVlZEhhbmRsZXIoKXtcblx0XHRyZXR1cm4gZGVmaW5lUHJvcChcIkZlZWRIYW5kbGVyXCIsIHJlcXVpcmUoXCIuL0ZlZWRIYW5kbGVyLmpzXCIpKTtcblx0fSxcblx0Z2V0IFN0cmVhbSgpe1xuXHRcdHJldHVybiBkZWZpbmVQcm9wKFwiU3RyZWFtXCIsIHJlcXVpcmUoXCIuL1N0cmVhbS5qc1wiKSk7XG5cdH0sXG5cdGdldCBXcml0YWJsZVN0cmVhbSgpe1xuXHRcdHJldHVybiBkZWZpbmVQcm9wKFwiV3JpdGFibGVTdHJlYW1cIiwgcmVxdWlyZShcIi4vV3JpdGFibGVTdHJlYW0uanNcIikpO1xuXHR9LFxuXHRnZXQgUHJveHlIYW5kbGVyKCl7XG5cdFx0cmV0dXJuIGRlZmluZVByb3AoXCJQcm94eUhhbmRsZXJcIiwgcmVxdWlyZShcIi4vUHJveHlIYW5kbGVyLmpzXCIpKTtcblx0fSxcblx0Z2V0IERvbVV0aWxzKCl7XG5cdFx0cmV0dXJuIGRlZmluZVByb3AoXCJEb21VdGlsc1wiLCByZXF1aXJlKFwiZG9tdXRpbHNcIikpO1xuXHR9LFxuXHRnZXQgQ29sbGVjdGluZ0hhbmRsZXIoKXtcblx0XHRyZXR1cm4gZGVmaW5lUHJvcChcIkNvbGxlY3RpbmdIYW5kbGVyXCIsIHJlcXVpcmUoXCIuL0NvbGxlY3RpbmdIYW5kbGVyLmpzXCIpKTtcblx0fSxcblx0Ly8gRm9yIGxlZ2FjeSBzdXBwb3J0XG5cdERlZmF1bHRIYW5kbGVyOiBEb21IYW5kbGVyLFxuXHRnZXQgUnNzSGFuZGxlcigpe1xuXHRcdHJldHVybiBkZWZpbmVQcm9wKFwiUnNzSGFuZGxlclwiLCB0aGlzLkZlZWRIYW5kbGVyKTtcblx0fSxcblx0Ly9oZWxwZXIgbWV0aG9kc1xuXHRwYXJzZURPTTogZnVuY3Rpb24oZGF0YSwgb3B0aW9ucyl7XG5cdFx0dmFyIGhhbmRsZXIgPSBuZXcgRG9tSGFuZGxlcihvcHRpb25zKTtcblx0XHRuZXcgUGFyc2VyKGhhbmRsZXIsIG9wdGlvbnMpLmVuZChkYXRhKTtcblx0XHRyZXR1cm4gaGFuZGxlci5kb207XG5cdH0sXG5cdHBhcnNlRmVlZDogZnVuY3Rpb24oZmVlZCwgb3B0aW9ucyl7XG5cdFx0dmFyIGhhbmRsZXIgPSBuZXcgbW9kdWxlLmV4cG9ydHMuRmVlZEhhbmRsZXIob3B0aW9ucyk7XG5cdFx0bmV3IFBhcnNlcihoYW5kbGVyLCBvcHRpb25zKS5lbmQoZmVlZCk7XG5cdFx0cmV0dXJuIGhhbmRsZXIuZG9tO1xuXHR9LFxuXHRjcmVhdGVEb21TdHJlYW06IGZ1bmN0aW9uKGNiLCBvcHRpb25zLCBlbGVtZW50Q2Ipe1xuXHRcdHZhciBoYW5kbGVyID0gbmV3IERvbUhhbmRsZXIoY2IsIG9wdGlvbnMsIGVsZW1lbnRDYik7XG5cdFx0cmV0dXJuIG5ldyBQYXJzZXIoaGFuZGxlciwgb3B0aW9ucyk7XG5cdH0sXG5cdC8vIExpc3Qgb2YgYWxsIGV2ZW50cyB0aGF0IHRoZSBwYXJzZXIgZW1pdHNcblx0RVZFTlRTOiB7IC8qIEZvcm1hdDogZXZlbnRuYW1lOiBudW1iZXIgb2YgYXJndW1lbnRzICovXG5cdFx0YXR0cmlidXRlOiAyLFxuXHRcdGNkYXRhc3RhcnQ6IDAsXG5cdFx0Y2RhdGFlbmQ6IDAsXG5cdFx0dGV4dDogMSxcblx0XHRwcm9jZXNzaW5naW5zdHJ1Y3Rpb246IDIsXG5cdFx0Y29tbWVudDogMSxcblx0XHRjb21tZW50ZW5kOiAwLFxuXHRcdGNsb3NldGFnOiAxLFxuXHRcdG9wZW50YWc6IDIsXG5cdFx0b3BlbnRhZ25hbWU6IDEsXG5cdFx0ZXJyb3I6IDEsXG5cdFx0ZW5kOiAwXG5cdH1cbn07XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBNdHJlZSA9IHJlcXVpcmUoJzF0cmVlLWZhY3RvcnknKTtcblxudmFyIGNyZWF0ZVRyZWUgPSByZXF1aXJlKCcuL3BsdWdpbnMvY3JlYXRlVHJlZScpO1xudmFyIGluc2VydEJlZm9yZSA9IHJlcXVpcmUoJy4vcGx1Z2lucy9pbnNlcnRCZWZvcmUnKTtcbnZhciBkb20gPSByZXF1aXJlKCcuL3BsdWdpbnMvZG9tJyk7XG52YXIgcGFyc2UgPSByZXF1aXJlKCcuL3BsdWdpbnMvcGFyc2UnKTtcbnZhciBzZWxlY3QgPSByZXF1aXJlKCcuL3BsdWdpbnMvc2VsZWN0Jyk7XG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9wbHVnaW5zL3N0cmluZ2lmeScpO1xudmFyIHR5cGVzID0gcmVxdWlyZSgnLi9wbHVnaW5zL3R5cGVzJyk7XG52YXIgdmRvbSA9IHJlcXVpcmUoJy4vcGx1Z2lucy92ZG9tJyk7XG5cbnZhciBIdHJlZSA9IE10cmVlKGRvbSwgcGFyc2UsIHNlbGVjdCwgc3RyaW5naWZ5LCB0eXBlcywgdmRvbSk7XG5cbi8vIGFkZCBhZnRlcndhcmRzIGJlY2F1c2UgdGhlIG9yaWdpbmFsIGNyZWF0ZVRyZWUgZG9lc24ndCBleGlzdCB1bnRpbCBub3dcbkh0cmVlLnBsdWdpbihjcmVhdGVUcmVlKTtcbi8vIGFkZCBhZnRlcndhcmRzIHNvIHRoYXQgaXQgd3JhcHMgcGFyZW50TWFwIGFuZCBub3QgdGhlIG90aGVyIHdheSByb3VuZFxuSHRyZWUucGx1Z2luKGluc2VydEJlZm9yZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSHRyZWU7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRW50aXR5Tm9kZSA9IHJlcXVpcmUoJ210eXBlLW5vZGUnKTtcblxudmFyIERvbUhhbmRsZXIgPSBmdW5jdGlvbiBEb21IYW5kbGVyKG9wdGlvbnMpIHtcbiAgdmFyIHN0YXRlID0gU3RhdGUob3B0aW9ucyk7XG5cbiAgdmFyIGhhbmRsZXIgPSB7IHN0YXRlOiBzdGF0ZSB9O1xuXG4gIHZhciBhcGkgPSBBcGkoaGFuZGxlcik7XG5cbiAgcmV0dXJuIGFwaTtcbn07XG5cbi8vZGVmYXVsdCBvcHRpb25zXG52YXIgZGVmYXVsdE9wdHMgPSB7XG4gIG5vcm1hbGl6ZVdoaXRlc3BhY2U6IGZhbHNlXG59O1xuXG52YXIgd2hpdGVzcGFjZSA9IC9cXHMrL2c7XG5cbnZhciBTdGF0ZSA9IGZ1bmN0aW9uIFN0YXRlKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmYXVsdE9wdHM7XG5cbiAgdmFyIGRvbSA9IEVudGl0eU5vZGUoJ2RvY3VtZW50RnJhZ21lbnQnKTtcbiAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgdmFyIHRhZ1N0YWNrID0gW107XG4gIHZhciBwYXJzZXIgPSBudWxsO1xuXG4gIHZhciBzdGF0ZSA9IHtcbiAgICBvcHRpb25zOiBvcHRpb25zLCBkb206IGRvbSwgZG9uZTogZG9uZSwgdGFnU3RhY2s6IHRhZ1N0YWNrLCBwYXJzZXI6IHBhcnNlclxuICB9O1xuXG4gIHJldHVybiBzdGF0ZTtcbn07XG5cbnZhciBBcGkgPSBmdW5jdGlvbiBBcGkoaGFuZGxlcikge1xuICB2YXIgb25pbml0ID0gZnVuY3Rpb24gb25pbml0KHBhcnNlcikge1xuICAgIHJldHVybiBoYW5kbGVyLnN0YXRlLnBhcnNlciA9IHBhcnNlcjtcbiAgfTtcblxuICB2YXIgb25yZXNldCA9IGZ1bmN0aW9uIG9ucmVzZXQoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBoYW5kbGVyLnN0YXRlLm9wdGlvbnM7XG5cblxuICAgIGhhbmRsZXIuc3RhdGUgPSBTdGF0ZShvcHRpb25zKTtcbiAgfTtcblxuICB2YXIgb25lbmQgPSBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoaGFuZGxlci5zdGF0ZS5kb25lKSByZXR1cm47XG5cbiAgICBoYW5kbGVyLnN0YXRlLmRvbmUgPSB0cnVlO1xuICAgIGhhbmRsZXIuc3RhdGUucGFyc2VyID0gbnVsbDtcbiAgICBvbmVycm9yKG51bGwpO1xuICB9O1xuXG4gIHZhciBvbmVycm9yID0gZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICBpZiAoZXJyKSB0aHJvdyBlcnI7XG4gIH07XG5cbiAgdmFyIG9uY2xvc2V0YWcgPSBmdW5jdGlvbiBvbmNsb3NldGFnKCkge1xuICAgIHZhciB0YWdTdGFjayA9IGhhbmRsZXIuc3RhdGUudGFnU3RhY2s7XG5cblxuICAgIHRhZ1N0YWNrLnBvcCgpO1xuICB9O1xuXG4gIHZhciBvbm9wZW50YWcgPSBmdW5jdGlvbiBvbm9wZW50YWcobmFtZSwgYXR0cmlicykge1xuICAgIHZhciB0YWdTdGFjayA9IGhhbmRsZXIuc3RhdGUudGFnU3RhY2s7XG5cblxuICAgIHZhciBlbGVtZW50ID0gRW50aXR5Tm9kZSgnZWxlbWVudCcsIHtcbiAgICAgIHRhZ05hbWU6IG5hbWUsXG4gICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJzXG4gICAgfSk7XG5cbiAgICBhZGREb21FbGVtZW50KGhhbmRsZXIsIGVsZW1lbnQpO1xuICAgIHRhZ1N0YWNrLnB1c2goZWxlbWVudCk7XG4gIH07XG5cbiAgdmFyIG9udGV4dCA9IGZ1bmN0aW9uIG9udGV4dChkYXRhKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBoYW5kbGVyLnN0YXRlLm9wdGlvbnM7XG5cblxuICAgIHZhciBub3JtYWxpemUgPSBvcHRpb25zLm5vcm1hbGl6ZVdoaXRlc3BhY2UgfHwgb3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlID8gZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKHdoaXRlc3BhY2UsICcgJyk7XG4gICAgfSA6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcblxuICAgIHZhciBwcmV2aW91c1RleHQgPSBmaW5kUHJldmlvdXNUZXh0KGhhbmRsZXIpO1xuXG4gICAgaWYgKHByZXZpb3VzVGV4dCkge1xuICAgICAgcHJldmlvdXNUZXh0LnZhbHVlLm5vZGVWYWx1ZSA9IG5vcm1hbGl6ZShwcmV2aW91c1RleHQubm9kZVZhbHVlICsgZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSBub3JtYWxpemUoZGF0YSk7XG5cbiAgICAgIHZhciB0ZXh0ID0gRW50aXR5Tm9kZSgndGV4dCcsIHsgbm9kZVZhbHVlOiBkYXRhIH0pO1xuXG4gICAgICBhZGREb21FbGVtZW50KGhhbmRsZXIsIHRleHQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgb25jb21tZW50ID0gZnVuY3Rpb24gb25jb21tZW50KGRhdGEpIHtcbiAgICB2YXIgdGFnU3RhY2sgPSBoYW5kbGVyLnN0YXRlLnRhZ1N0YWNrO1xuXG5cbiAgICB2YXIgbGFzdFRhZyA9IHRhZ1N0YWNrW3RhZ1N0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGxhc3RUYWcgJiYgbGFzdFRhZy52YWx1ZS5ub2RlVHlwZSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgICBsYXN0VGFnLnZhbHVlLm5vZGVWYWx1ZSArPSBkYXRhO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNvbW1lbnQgPSBFbnRpdHlOb2RlKCdjb21tZW50JywgeyBub2RlVmFsdWU6IGRhdGEgfSk7XG5cbiAgICBhZGREb21FbGVtZW50KGhhbmRsZXIsIGNvbW1lbnQpO1xuICAgIHRhZ1N0YWNrLnB1c2goY29tbWVudCk7XG4gIH07XG5cbiAgdmFyIG9ucHJvY2Vzc2luZ2luc3RydWN0aW9uID0gZnVuY3Rpb24gb25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24obmFtZSwgZGF0YSkge1xuICAgIG9uY29tbWVudChkYXRhKTtcbiAgICBvbmNvbW1lbnRlbmQoKTtcbiAgfTtcblxuICB2YXIgb25jb21tZW50ZW5kID0gZnVuY3Rpb24gb25jb21tZW50ZW5kKCkge1xuICAgIHJldHVybiBoYW5kbGVyLnN0YXRlLnRhZ1N0YWNrLnBvcCgpO1xuICB9O1xuXG4gIHZhciBnZXREb20gPSBmdW5jdGlvbiBnZXREb20oKSB7XG4gICAgcmV0dXJuIGhhbmRsZXIuc3RhdGUuZG9tO1xuICB9O1xuXG4gIHZhciBhcGkgPSB7XG4gICAgb25pbml0OiBvbmluaXQsIG9ucmVzZXQ6IG9ucmVzZXQsIG9uZW5kOiBvbmVuZCwgb25lcnJvcjogb25lcnJvciwgb25jbG9zZXRhZzogb25jbG9zZXRhZywgb25vcGVudGFnOiBvbm9wZW50YWcsIG9udGV4dDogb250ZXh0LCBvbmNvbW1lbnQ6IG9uY29tbWVudCxcbiAgICBvbmNvbW1lbnRlbmQ6IG9uY29tbWVudGVuZCwgb25wcm9jZXNzaW5naW5zdHJ1Y3Rpb246IG9ucHJvY2Vzc2luZ2luc3RydWN0aW9uLCBnZXREb206IGdldERvbVxuICB9O1xuXG4gIHJldHVybiBhcGk7XG59O1xuXG52YXIgZmluZFByZXZpb3VzVGV4dCA9IGZ1bmN0aW9uIGZpbmRQcmV2aW91c1RleHQoaGFuZGxlcikge1xuICB2YXIgX2hhbmRsZXIkc3RhdGUgPSBoYW5kbGVyLnN0YXRlLFxuICAgICAgdGFnU3RhY2sgPSBfaGFuZGxlciRzdGF0ZS50YWdTdGFjayxcbiAgICAgIGRvbSA9IF9oYW5kbGVyJHN0YXRlLmRvbTtcblxuXG4gIGlmICh0YWdTdGFjay5sZW5ndGgpIHtcbiAgICB2YXIgbGFzdFRhZyA9IHRhZ1N0YWNrW3RhZ1N0YWNrLmxlbmd0aCAtIDFdO1xuICAgIHZhciBfY2hpbGRyZW4gPSBsYXN0VGFnLmNoaWxkcmVuO1xuXG4gICAgaWYgKF9jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHZhciBfbGFzdENoaWxkID0gX2NoaWxkcmVuW19jaGlsZHJlbi5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKF9sYXN0Q2hpbGQudmFsdWUubm9kZVR5cGUgPT09ICd0ZXh0JykgcmV0dXJuIF9sYXN0Q2hpbGQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoaWxkcmVuID0gZG9tLmNoaWxkcmVuO1xuXG4gIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHZhciBsYXN0Q2hpbGQgPSBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcblxuICBpZiAobGFzdENoaWxkLnZhbHVlLm5vZGVUeXBlID09PSAndGV4dCcpIHJldHVybiBsYXN0Q2hpbGQ7XG59O1xuXG52YXIgYWRkRG9tRWxlbWVudCA9IGZ1bmN0aW9uIGFkZERvbUVsZW1lbnQoaGFuZGxlciwgZWxlbWVudCkge1xuICB2YXIgX2hhbmRsZXIkc3RhdGUyID0gaGFuZGxlci5zdGF0ZSxcbiAgICAgIHRhZ1N0YWNrID0gX2hhbmRsZXIkc3RhdGUyLnRhZ1N0YWNrLFxuICAgICAgZG9tID0gX2hhbmRsZXIkc3RhdGUyLmRvbTtcblxuXG4gIHZhciBwYXJlbnQgPSB0YWdTdGFja1t0YWdTdGFjay5sZW5ndGggLSAxXTtcbiAgdmFyIHRhcmdldCA9IHBhcmVudCA/IHBhcmVudC5jaGlsZHJlbiA6IGRvbS5jaGlsZHJlbjtcblxuICB0YXJnZXQucHVzaChlbGVtZW50KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRG9tSGFuZGxlcjsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBodG1scGFyc2VyMiA9IHJlcXVpcmUoJ2h0bWxwYXJzZXIyJyk7XG52YXIgRG9tSGFuZGxlciA9IHJlcXVpcmUoJy4vZG9taGFuZGxlci1hZGFwdGVyJyk7XG5cbnZhciBwYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICB2YXIgaGFuZGxlciA9IERvbUhhbmRsZXIoKTtcbiAgbmV3IGh0bWxwYXJzZXIyLlBhcnNlcihoYW5kbGVyKS5lbmQoc3RyKTtcblxuICByZXR1cm4gaGFuZGxlci5nZXREb20oKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2U7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKlxuICBFeHRlbmQgY3JlYXRlVHJlZSB0byBhbGxvdyBjcmVhdGluZyBhIHRyZWUgZnJvbSBhbiBIVE1MIHN0cmluZ1xuKi9cblxudmFyIHBhcnNlU3RyID0gcmVxdWlyZSgnLi4vLi4vcGFyc2UnKTtcblxuLy8gc2hvdWxkIGJlIGFkZGVkIGFmdGVyIHRoZSBkZWZhdWx0IHBsdWdpbnMgc28gdGhhdCBjcmVhdGVUcmVlIGV4aXN0cyFcbnZhciBjcmVhdGVUcmVlRnJvbVN0ciA9IGZ1bmN0aW9uIGNyZWF0ZVRyZWVGcm9tU3RyKGZuKSB7XG4gIC8vIG92ZXJyaWRlIGNyZWF0ZVRyZWUgdG8gYWxsb3cgcGFzc2luZyBhIHN0cmluZ1xuICB2YXIgb3JpZ2luYWxDcmVhdGVUcmVlID0gZm4uY3JlYXRlVHJlZTtcblxuICB2YXIgY3JlYXRlVHJlZSA9IGZ1bmN0aW9uIGNyZWF0ZVRyZWUocm9vdFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiByb290VmFsdWUgPT09ICdzdHJpbmcnKSByb290VmFsdWUgPSBwYXJzZVN0cihyb290VmFsdWUpO1xuXG4gICAgcmV0dXJuIG9yaWdpbmFsQ3JlYXRlVHJlZShyb290VmFsdWUpO1xuICB9O1xuXG4gIGNyZWF0ZVRyZWUuZGVmID0gb3JpZ2luYWxDcmVhdGVUcmVlLmRlZjtcblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihmbiwgeyBjcmVhdGVUcmVlOiBjcmVhdGVUcmVlIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUcmVlRnJvbVN0cjsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBFbnRpdHlOb2RlID0gcmVxdWlyZSgnbXR5cGUtbm9kZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnbW9qdWxlLXV0aWxzJyk7XG5cbnZhciBjYXBpdGFsaXplRmlyc3RMZXR0ZXIgPSB1dGlscy5jYXBpdGFsaXplRmlyc3RMZXR0ZXI7XG5cblxudmFyIG5vZGVNYXAgPSB7XG4gIGVsZW1lbnQ6IGZ1bmN0aW9uIGVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZ05hbWU6ICdkaXYnLFxuICAgICAgYXR0cmlidXRlczoge31cbiAgICB9O1xuICB9LFxuICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICBub2RlVmFsdWU6ICcnLFxuICAgICAgaXNFbXB0eTogdHJ1ZVxuICAgIH07XG4gIH0sXG4gIHRleHQ6IGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGVWYWx1ZTogJycsXG4gICAgICBpc0VtcHR5OiB0cnVlXG4gICAgfTtcbiAgfSxcbiAgZG9jdW1lbnRUeXBlOiBmdW5jdGlvbiBkb2N1bWVudFR5cGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICdodG1sJyxcbiAgICAgIHB1YmxpY0lkOiAnJyxcbiAgICAgIHN5c3RlbUlkOiAnJyxcbiAgICAgIGlzRW1wdHk6IHRydWVcbiAgICB9O1xuICB9XG59O1xuXG52YXIgY3JlYXRlRG9tTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZURvbU5vZGUoZm4sIG5vZGVUeXBlLCB2YWx1ZSkge1xuICB2YXIgZGVmYXVsdFZhbHVlID0gbm9kZVR5cGUgaW4gbm9kZU1hcCA/IG5vZGVNYXBbbm9kZVR5cGVdKCkgOiB7fTtcblxuICB2YWx1ZSA9IE9iamVjdC5hc3NpZ24oeyBub2RlVHlwZTogbm9kZVR5cGUgfSwgZGVmYXVsdFZhbHVlLCB2YWx1ZSB8fCB7fSk7XG5cbiAgdmFyIGVudGl0eU5vZGUgPSBFbnRpdHlOb2RlKG5vZGVUeXBlLCB2YWx1ZSk7XG5cbiAgdmFyIG5vZGUgPSBmbi5jcmVhdGVOb2RlKGVudGl0eU5vZGUudmFsdWUpO1xuXG4gIHZhciBjYXBOb2RlVHlwZSA9IGNhcGl0YWxpemVGaXJzdExldHRlcihub2RlVHlwZSk7XG4gIHZhciBhc3NlcnROYW1lID0gJ2Fzc2VydCcgKyBjYXBOb2RlVHlwZTtcblxuICBmblthc3NlcnROYW1lXShub2RlKTtcblxuICByZXR1cm4gbm9kZTtcbn07XG5cbnZhciBjcmVhdGVEb21Ob2RlRGVmID0gZnVuY3Rpb24gY3JlYXRlRG9tTm9kZURlZihub2RlVHlwZSwgYXJnVHlwZXMpIHtcbiAgcmV0dXJuIHtcbiAgICBhcmdUeXBlczogYXJnVHlwZXMsXG4gICAgcmV0dXJuVHlwZTogJ25vZGUnLFxuICAgIHJlcXVpcmVzOiBbJ2NyZWF0ZU5vZGUnLCAnYXNzZXJ0JyArIGNhcGl0YWxpemVGaXJzdExldHRlcihub2RlVHlwZSldLFxuICAgIGNhdGVnb3JpZXM6IFsnY3JlYXRlJywgJ3BsdWdpbiddXG4gIH07XG59O1xuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGZuKSB7XG4gIHZhciBjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwge307XG5cbiAgICByZXR1cm4gY3JlYXRlRG9tTm9kZShmbiwgJ2VsZW1lbnQnLCB7IHRhZ05hbWU6IHRhZ05hbWUsIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMgfSk7XG4gIH07XG5cbiAgY3JlYXRlRWxlbWVudC5kZWYgPSBjcmVhdGVEb21Ob2RlRGVmKCdlbGVtZW50JywgWydzdHJpbmcnLCAnb2JqZWN0J10pO1xuXG4gIHZhciBjcmVhdGVDb21tZW50ID0gZnVuY3Rpb24gY3JlYXRlQ29tbWVudChub2RlVmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlRG9tTm9kZShmbiwgJ2VsZW1lbnQnLCB7IG5vZGVWYWx1ZTogbm9kZVZhbHVlIH0pO1xuICB9O1xuXG4gIGNyZWF0ZUNvbW1lbnQuZGVmID0gY3JlYXRlRG9tTm9kZURlZignY29tbWVudCcsIFsnc3RyaW5nJ10pO1xuXG4gIHZhciBjcmVhdGVEb2N1bWVudCA9IGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50KCkge1xuICAgIHJldHVybiBjcmVhdGVEb21Ob2RlKGZuLCAnZG9jdW1lbnQnKTtcbiAgfTtcblxuICBjcmVhdGVEb2N1bWVudC5kZWYgPSBjcmVhdGVEb21Ob2RlRGVmKCdkb2N1bWVudCcsIFtdKTtcblxuICB2YXIgY3JlYXRlRG9jdW1lbnRGcmFnbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURvbU5vZGUoZm4sICdkb2N1bWVudEZyYWdtZW50Jyk7XG4gIH07XG5cbiAgY3JlYXRlRG9jdW1lbnRGcmFnbWVudC5kZWYgPSBjcmVhdGVEb21Ob2RlRGVmKCdkb2N1bWVudEZyYWdtZW50JywgW10pO1xuXG4gIHZhciBjcmVhdGVUZXh0ID0gZnVuY3Rpb24gY3JlYXRlVGV4dChub2RlVmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlRG9tTm9kZShmbiwgJ3RleHQnLCB7XG4gICAgICBub2RlVmFsdWU6IFN0cmluZyhub2RlVmFsdWUpXG4gICAgfSk7XG4gIH07XG5cbiAgY3JlYXRlVGV4dC5kZWYgPSBjcmVhdGVEb21Ob2RlRGVmKCd0ZXh0JywgWydzdHJpbmcnXSk7XG5cbiAgdmFyIGNyZWF0ZURvY3VtZW50VHlwZSA9IGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50VHlwZShuYW1lLCBwdWJsaWNJZCwgc3lzdGVtSWQpIHtcbiAgICByZXR1cm4gY3JlYXRlRG9tTm9kZShmbiwgJ2RvY3VtZW50VHlwZScsIHsgbmFtZTogbmFtZSwgcHVibGljSWQ6IHB1YmxpY0lkLCBzeXN0ZW1JZDogc3lzdGVtSWQgfSk7XG4gIH07XG5cbiAgY3JlYXRlRG9jdW1lbnRUeXBlLmRlZiA9IGNyZWF0ZURvbU5vZGVEZWYoJ2RvY3VtZW50VHlwZScsIFsnc3RyaW5nJywgJ3N0cmluZycsICdzdHJpbmcnXSk7XG5cbiAgdmFyIHBsdWdpbnMgPSB7XG4gICAgY3JlYXRlVGV4dDogY3JlYXRlVGV4dCwgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCwgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCwgY3JlYXRlRG9jdW1lbnQ6IGNyZWF0ZURvY3VtZW50LFxuICAgIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQ6IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQsIGNyZWF0ZURvY3VtZW50VHlwZTogY3JlYXRlRG9jdW1lbnRUeXBlXG4gIH07XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZm4sIHBsdWdpbnMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJ21vanVsZS11dGlscycpO1xuXG52YXIgY2xvbmUgPSB1dGlscy5jbG9uZTtcblxuXG52YXIgZWxlbWVudCA9IGZ1bmN0aW9uIGVsZW1lbnQoZm4pIHtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBhdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZU1hcCkge1xuICAgIGZuLmFzc2VydEVsZW1lbnQobm9kZSk7XG5cbiAgICB2YXIgbm9kZVZhbHVlID0gZm4udmFsdWUobm9kZSk7XG5cbiAgICBpZiAoKHR5cGVvZiBhdHRyaWJ1dGVNYXAgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGF0dHJpYnV0ZU1hcCkpID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVWYWx1ZSA9IGF0dHJpYnV0ZU1hcFthdHRyaWJ1dGVOYW1lXTtcblxuICAgICAgICBmbi5hdHRyKG5vZGUsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChub2RlVmFsdWUuYXR0cmlidXRlcyA9PT0gdW5kZWZpbmVkKSByZXR1cm4ge307XG5cbiAgICByZXR1cm4gY2xvbmUobm9kZVZhbHVlLmF0dHJpYnV0ZXMpO1xuICB9O1xuXG4gIGF0dHJpYnV0ZXMuZGVmID0ge1xuICAgIGFyZ1R5cGVzOiBbJ25vZGUnLCAnb2JqZWN0PyddLFxuICAgIHJldHVyblR5cGU6ICdvYmplY3QnLFxuICAgIHJlcXVpcmVzOiBbJ3ZhbHVlJywgJ2Fzc2VydEVsZW1lbnQnLCAnYXR0ciddLFxuICAgIGNhdGVnb3JpZXM6IFsnZG9tJywgJ2F0dHJpYnV0ZXMnLCAncGx1Z2lucyddXG4gIH07XG5cbiAgdmFyIHRhZ05hbWUgPSBmdW5jdGlvbiB0YWdOYW1lKG5vZGUsIHZhbHVlKSB7XG4gICAgZm4uYXNzZXJ0RWxlbWVudChub2RlKTtcblxuICAgIHZhciBub2RlVmFsdWUgPSBmbi52YWx1ZShub2RlKTtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBub2RlVmFsdWUudGFnTmFtZSA9IHZhbHVlO1xuXG4gICAgICBmbi52YWx1ZShub2RlLCBub2RlVmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlVmFsdWUudGFnTmFtZTtcbiAgfTtcblxuICB0YWdOYW1lLmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydub2RlJywgJ3N0cmluZyddLFxuICAgIHJldHVyblR5cGU6ICdzdHJpbmcnLFxuICAgIHJlcXVpcmVzOiBbJ3ZhbHVlJywgJ2Fzc2VydEVsZW1lbnQnXSxcbiAgICBjYXRlZ29yaWVzOiBbJ2RvbScsICd0YWdOYW1lJywgJ3BsdWdpbnMnXVxuICB9O1xuXG4gIHZhciBhdHRyID0gZnVuY3Rpb24gYXR0cihub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGZuLmFzc2VydEVsZW1lbnQobm9kZSk7XG5cbiAgICB2YXIgbm9kZVZhbHVlID0gZm4udmFsdWUobm9kZSk7XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG5vZGVWYWx1ZS5hdHRyaWJ1dGVzID09PSB1bmRlZmluZWQpIG5vZGVWYWx1ZS5hdHRyaWJ1dGVzID0ge307XG5cbiAgICAgIG5vZGVWYWx1ZS5hdHRyaWJ1dGVzW25hbWVdID0gdmFsdWUudG9TdHJpbmcoKTtcblxuICAgICAgZm4udmFsdWUobm9kZSwgbm9kZVZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZihub2RlVmFsdWUuYXR0cmlidXRlcykgPT09ICdvYmplY3QnKSByZXR1cm4gbm9kZVZhbHVlLmF0dHJpYnV0ZXNbbmFtZV07XG4gIH07XG5cbiAgYXR0ci5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnbm9kZScsICdzdHJpbmcnLCAnc3RyaW5nJ10sXG4gICAgcmV0dXJuVHlwZTogJ3N0cmluZycsXG4gICAgcmVxdWlyZXM6IFsndmFsdWUnLCAnYXNzZXJ0RWxlbWVudCddLFxuICAgIGNhdGVnb3JpZXM6IFsnZG9tJywgJ2F0dHInLCAncGx1Z2lucyddXG4gIH07XG5cbiAgdmFyIGhhc0F0dHIgPSBmdW5jdGlvbiBoYXNBdHRyKG5vZGUsIG5hbWUpIHtcbiAgICBmbi5hc3NlcnRFbGVtZW50KG5vZGUpO1xuXG4gICAgcmV0dXJuIGZuLmF0dHIobm9kZSwgbmFtZSkgIT09IHVuZGVmaW5lZDtcbiAgfTtcblxuICBoYXNBdHRyLmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydub2RlJywgJ3N0cmluZyddLFxuICAgIHJldHVyblR5cGU6ICdib29sZWFuJyxcbiAgICByZXF1aXJlczogWyd2YWx1ZScsICdhc3NlcnRFbGVtZW50J10sXG4gICAgY2F0ZWdvcmllczogWydkb20nLCAnaGFzQXR0cicsICdwbHVnaW5zJ11cbiAgfTtcblxuICB2YXIgcmVtb3ZlQXR0ciA9IGZ1bmN0aW9uIHJlbW92ZUF0dHIobm9kZSwgbmFtZSkge1xuICAgIGZuLmFzc2VydEVsZW1lbnQobm9kZSk7XG5cbiAgICB2YXIgbm9kZVZhbHVlID0gZm4udmFsdWUobm9kZSk7XG5cbiAgICBpZiAoX3R5cGVvZihub2RlVmFsdWUuYXR0cmlidXRlcykgPT09ICdvYmplY3QnKSBkZWxldGUgbm9kZVZhbHVlLmF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICBmbi52YWx1ZShub2RlLCBub2RlVmFsdWUpO1xuICB9O1xuXG4gIHJlbW92ZUF0dHIuZGVmID0ge1xuICAgIGFyZ1R5cGVzOiBbJ25vZGUnLCAnc3RyaW5nJ10sXG4gICAgcmVxdWlyZXM6IFsndmFsdWUnLCAnYXNzZXJ0RWxlbWVudCddLFxuICAgIGNhdGVnb3JpZXM6IFsnZG9tJywgJ3JlbW92ZUF0dHInLCAncGx1Z2lucyddXG4gIH07XG5cbiAgdmFyIGNsZWFyQXR0cnMgPSBmdW5jdGlvbiBjbGVhckF0dHJzKG5vZGUpIHtcbiAgICBmbi5hc3NlcnRFbGVtZW50KG5vZGUpO1xuXG4gICAgdmFyIG5vZGVWYWx1ZSA9IGZuLnZhbHVlKG5vZGUpO1xuXG4gICAgbm9kZVZhbHVlLmF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIGZuLnZhbHVlKG5vZGUsIG5vZGVWYWx1ZSk7XG4gIH07XG5cbiAgY2xlYXJBdHRycy5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnbm9kZSddLFxuICAgIHJlcXVpcmVzOiBbJ3ZhbHVlJywgJ2Fzc2VydEVsZW1lbnQnXSxcbiAgICBjYXRlZ29yaWVzOiBbJ2RvbScsICdjbGVhckF0dHJzJywgJ3BsdWdpbnMnXVxuICB9O1xuXG4gIHZhciBjbGVhckNsYXNzZXMgPSBmdW5jdGlvbiBjbGVhckNsYXNzZXMobm9kZSkge1xuICAgIGZuLmFzc2VydEVsZW1lbnQobm9kZSk7XG5cbiAgICBmbi5hdHRyKG5vZGUsICdjbGFzcycsICcnKTtcbiAgfTtcblxuICBjbGVhckNsYXNzZXMuZGVmID0ge1xuICAgIGFyZ1R5cGVzOiBbJ25vZGUnXSxcbiAgICByZXF1aXJlczogWyd2YWx1ZScsICdhc3NlcnRFbGVtZW50J10sXG4gICAgY2F0ZWdvcmllczogWydkb20nLCAnY2xlYXJDbGFzc2VzJywgJ3BsdWdpbnMnXVxuICB9O1xuXG4gIHZhciBjbGFzc05hbWVzID0gZnVuY3Rpb24gY2xhc3NOYW1lcyhub2RlKSB7XG4gICAgZm4uYXNzZXJ0RWxlbWVudChub2RlKTtcblxuICAgIHZhciBjbGFzc05hbWVzID0gZm4uYXR0cihub2RlLCAnY2xhc3MnKTtcblxuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lcyA9PT0gJ3N0cmluZycpIHJldHVybiBjbGFzc05hbWVzLnNwbGl0KCcgJyk7XG5cbiAgICByZXR1cm4gW107XG4gIH07XG5cbiAgY2xhc3NOYW1lcy5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnbm9kZSddLFxuICAgIHJldHVyblR5cGU6ICdbc3RyaW5nXScsXG4gICAgcmVxdWlyZXM6IFsnYXR0cicsICdhc3NlcnRFbGVtZW50J10sXG4gICAgY2F0ZWdvcmllczogWydkb20nLCAnY2xhc3NOYW1lcycsICdwbHVnaW5zJ11cbiAgfTtcblxuICB2YXIgaGFzQ2xhc3MgPSBmdW5jdGlvbiBoYXNDbGFzcyhub2RlLCBjbGFzc05hbWUpIHtcbiAgICBmbi5hc3NlcnRFbGVtZW50KG5vZGUpO1xuXG4gICAgcmV0dXJuIGZuLmNsYXNzTmFtZXMobm9kZSkuc29tZShmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWUgPT09IGNsYXNzTmFtZTtcbiAgICB9KTtcbiAgfTtcblxuICBoYXNDbGFzcy5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnbm9kZScsICdzdHJpbmcnXSxcbiAgICByZXR1cm5UeXBlOiAnYm9vbGVhbicsXG4gICAgcmVxdWlyZXM6IFsnY2xhc3NOYW1lcycsICdhc3NlcnRFbGVtZW50J10sXG4gICAgY2F0ZWdvcmllczogWydkb20nLCAnaGFzQ2xhc3MnLCAncGx1Z2lucyddXG4gIH07XG5cbiAgdmFyIGFkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKSB7XG4gICAgZm4uYXNzZXJ0RWxlbWVudChub2RlKTtcblxuICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZS50cmltKCk7XG5cbiAgICB2YXIgZXhpc3RpbmcgPSBmbi5jbGFzc05hbWVzKG5vZGUpO1xuXG4gICAgZXhpc3RpbmcucHVzaChjbGFzc05hbWUpO1xuXG4gICAgZm4uYXR0cihub2RlLCAnY2xhc3MnLCBleGlzdGluZy5qb2luKCcgJykpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgYWRkQ2xhc3MuZGVmID0ge1xuICAgIGFyZ1R5cGVzOiBbJ25vZGUnLCAnc3RyaW5nJ10sXG4gICAgcmV0dXJuVHlwZTogJ25vZGUnLFxuICAgIHJlcXVpcmVzOiBbJ2NsYXNzTmFtZXMnLCAnYXR0cicsICdhc3NlcnRFbGVtZW50J10sXG4gICAgY2F0ZWdvcmllczogWydkb20nLCAnYWRkQ2xhc3MnLCAncGx1Z2lucyddXG4gIH07XG5cbiAgdmFyIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24gcmVtb3ZlQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKSB7XG4gICAgZm4uYXNzZXJ0RWxlbWVudChub2RlKTtcblxuICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZS50cmltKCk7XG5cbiAgICB2YXIgZXhpc3RpbmcgPSBmbi5jbGFzc05hbWVzKG5vZGUpLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWUgIT09IGNsYXNzTmFtZTtcbiAgICB9KTtcblxuICAgIGZuLmF0dHIobm9kZSwgJ2NsYXNzJywgZXhpc3Rpbmcuam9pbignICcpKTtcblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIHJlbW92ZUNsYXNzLmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydub2RlJywgJ3N0cmluZyddLFxuICAgIHJldHVyblR5cGU6ICdub2RlJyxcbiAgICByZXF1aXJlczogWydjbGFzc05hbWVzJywgJ2F0dHInLCAnYXNzZXJ0RWxlbWVudCddLFxuICAgIGNhdGVnb3JpZXM6IFsnZG9tJywgJ3JlbW92ZUNsYXNzJywgJ3BsdWdpbnMnXVxuICB9O1xuXG4gIHZhciB0b2dnbGVDbGFzcyA9IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKG5vZGUsIGNsYXNzTmFtZSwgc2hvdWxkSGF2ZSkge1xuICAgIGZuLmFzc2VydEVsZW1lbnQobm9kZSk7XG5cbiAgICB2YXIgYWxyZWFkeUhhcyA9IGZuLmhhc0NsYXNzKG5vZGUsIGNsYXNzTmFtZSk7XG5cbiAgICBpZiAodHlwZW9mIHNob3VsZEhhdmUgIT09ICdib29sZWFuJykgcmV0dXJuIGZuLnRvZ2dsZUNsYXNzKG5vZGUsIGNsYXNzTmFtZSwgIWFscmVhZHlIYXMpO1xuXG4gICAgaWYgKGFscmVhZHlIYXMpIHtcbiAgICAgIGlmIChzaG91bGRIYXZlKSByZXR1cm4gbm9kZTtcblxuICAgICAgcmV0dXJuIGZuLnJlbW92ZUNsYXNzKG5vZGUsIGNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZEhhdmUpIHJldHVybiBmbi5hZGRDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgdG9nZ2xlQ2xhc3MuZGVmID0ge1xuICAgIGFyZ1R5cGVzOiBbJ25vZGUnLCAnc3RyaW5nJywgJ2Jvb2xlYW4nXSxcbiAgICByZXR1cm5UeXBlOiAnbm9kZScsXG4gICAgcmVxdWlyZXM6IFsnaGFzQ2xhc3MnLCAncmVtb3ZlQ2xhc3MnLCAnYWRkQ2xhc3MnLCAnYXNzZXJ0RWxlbWVudCddLFxuICAgIGNhdGVnb3JpZXM6IFsnZG9tJywgJ3RvZ2dsZUNsYXNzJywgJ3BsdWdpbnMnXVxuICB9O1xuXG4gIHZhciBwbHVnaW5zID0ge1xuICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsIGF0dHI6IGF0dHIsIGhhc0F0dHI6IGhhc0F0dHIsIHJlbW92ZUF0dHI6IHJlbW92ZUF0dHIsIGNsYXNzTmFtZXM6IGNsYXNzTmFtZXMsIGhhc0NsYXNzOiBoYXNDbGFzcywgYWRkQ2xhc3M6IGFkZENsYXNzLFxuICAgIHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcywgdG9nZ2xlQ2xhc3M6IHRvZ2dsZUNsYXNzLCB0YWdOYW1lOiB0YWdOYW1lLCBjbGVhckF0dHJzOiBjbGVhckF0dHJzLCBjbGVhckNsYXNzZXM6IGNsZWFyQ2xhc3Nlc1xuICB9O1xuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKGZuLCBwbHVnaW5zKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlbWVudDsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbGVtZW50ID0gcmVxdWlyZSgnLi9lbGVtZW50Jyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9jcmVhdGUnKTtcbnZhciBub2RlID0gcmVxdWlyZSgnLi9ub2RlJyk7XG5cbnZhciBkb20gPSBmdW5jdGlvbiBkb20oZm4pIHtcbiAgZWxlbWVudChmbik7XG4gIGNyZWF0ZShmbik7XG4gIG5vZGUoZm4pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBkb207IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgSHRtbCA9IHJlcXVpcmUoJ2h0bWwtbm9kZScpO1xuXG52YXIgaHRtbCA9IEh0bWwoKTtcblxudmFyIGVtcHR5Tm9kZVR5cGVzID0gWyd0ZXh0JywgJ2NvbW1lbnQnLCAnZG9jdW1lbnRUeXBlJ107XG5cbnZhciBub2RlTmFtZU1hcCA9IHtcbiAgZWxlbWVudDogZnVuY3Rpb24gZWxlbWVudChmbiwgbm9kZSkge1xuICAgIHJldHVybiBmbi50YWdOYW1lKG5vZGUpO1xuICB9LFxuICBkb2N1bWVudFR5cGU6IGZ1bmN0aW9uIGRvY3VtZW50VHlwZShmbiwgbm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IGZuLnZhbHVlKG5vZGUpO1xuXG4gICAgcmV0dXJuIHZhbHVlLm5hbWU7XG4gIH1cbn07XG5cbnZhciBub2RlUGx1Z2lucyA9IGZ1bmN0aW9uIG5vZGVQbHVnaW5zKGZuKSB7XG4gIHZhciBub2RlVHlwZSA9IGZ1bmN0aW9uIG5vZGVUeXBlKGZuLCBub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gZm4udmFsdWUobm9kZSk7XG5cbiAgICByZXR1cm4gdmFsdWUubm9kZVR5cGU7XG4gIH07XG5cbiAgbm9kZVR5cGUuZGVmID0ge1xuICAgIGFyZ1R5cGVzOiBbJ2ZuJywgJ25vZGUnXSxcbiAgICByZXR1cm5UeXBlOiAnc3RyaW5nJyxcbiAgICByZXF1aXJlczogWyd2YWx1ZSddLFxuICAgIGNhdGVnb3JpZXM6IFsnbm9kZScsICdwbHVnaW4nXVxuICB9O1xuXG4gIHZhciBub2RlTmFtZSA9IGZ1bmN0aW9uIG5vZGVOYW1lKGZuLCBub2RlKSB7XG4gICAgdmFyIG5vZGVUeXBlID0gZm4ubm9kZVR5cGUoZm4sIG5vZGUpO1xuXG4gICAgaWYgKG5vZGVUeXBlIGluIG5vZGVOYW1lTWFwKSByZXR1cm4gbm9kZU5hbWVNYXBbbm9kZVR5cGVdKGZuLCBub2RlKTtcblxuICAgIHJldHVybiAnIycgKyBub2RlVHlwZTtcbiAgfTtcblxuICBub2RlTmFtZS5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnZm4nLCAnbm9kZSddLFxuICAgIHJldHVyblR5cGU6ICdzdHJpbmcnLFxuICAgIHJlcXVpcmVzOiBbJ25vZGVUeXBlJ10sXG4gICAgY2F0ZWdvcmllczogWydub2RlJywgJ3BsdWdpbiddXG4gIH07XG5cbiAgdmFyIGlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KGZuLCBub2RlKSB7XG4gICAgdmFyIG5vZGVUeXBlID0gZm4ubm9kZVR5cGUoZm4sIG5vZGUpO1xuXG4gICAgaWYgKGVtcHR5Tm9kZVR5cGVzLmluY2x1ZGVzKG5vZGVUeXBlKSkgcmV0dXJuIHRydWU7XG5cbiAgICBpZiAobm9kZVR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgICAgdmFyIHRhZ05hbWUgPSBmbi50YWdOYW1lKG5vZGUpO1xuXG4gICAgICByZXR1cm4gaHRtbC5pc0VtcHR5KHRhZ05hbWUpO1xuICAgIH1cblxuICAgIC8vIGFzc3VtZXMgcmVtYWluaW5nIG5vZGUgdHlwZXMgc2hvdWxkIGJlIGFibGUgdG8gaGF2ZSBjaGlsZHJlbiwgaXMgdGhpcyB0cnVlP1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBpc0VtcHR5LmRlZiA9IHtcbiAgICBhcmdUeXBlOiBbJ2ZuJywgJ25vZGUnXSxcbiAgICByZXR1cm5UeXBlOiAnYm9vbGVhbicsXG4gICAgcmVxdWlyZTogWydub2RlVHlwZScsICd0YWdOYW1lJ10sXG4gICAgY2F0ZWdvcmllczogWydub2RlJywgJ3BsdWdpbiddXG4gIH07XG5cbiAgdmFyIGFjY2VwdHMgPSBmdW5jdGlvbiBhY2NlcHRzKGZuLCBub2RlLCBjaGlsZE5vZGUpIHtcbiAgICB2YXIgaXNFbXB0eSA9IGZuLmlzRW1wdHkoZm4sIG5vZGUpO1xuXG4gICAgaWYgKGlzRW1wdHkpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBub2RlVHlwZSA9IGZuLm5vZGVUeXBlKGZuLCBub2RlKTtcbiAgICB2YXIgY2hpbGROb2RlVHlwZSA9IGZuLm5vZGVUeXBlKGZuLCBjaGlsZE5vZGUpO1xuXG4gICAgaWYgKGNoaWxkTm9kZVR5cGUgPT09ICdkb2N1bWVudFR5cGUnKSByZXR1cm4gbm9kZVR5cGUgPT09ICdkb2N1bWVudCc7XG5cbiAgICBpZiAobm9kZVR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgICAgaWYgKGNoaWxkTm9kZVR5cGUgPT09ICd0ZXh0JyB8fCBjaGlsZE5vZGVUeXBlID09PSAnY29tbWVudCcpIHJldHVybiB0cnVlO1xuXG4gICAgICB2YXIgX25vZGVOYW1lID0gZm4ubm9kZU5hbWUoZm4sIG5vZGUpO1xuICAgICAgdmFyIGNoaWxkTmFtZSA9IGZuLm5vZGVOYW1lKGZuLCBjaGlsZE5vZGUpO1xuXG4gICAgICByZXR1cm4gaHRtbC5hY2NlcHRzKF9ub2RlTmFtZSwgY2hpbGROYW1lKTtcbiAgICB9XG5cbiAgICAvLyBhc3N1bWVzIG5vbi1lbGVtZW50cyB0aGF0IGNhbiBoYXZlIGNoaWxkIG5vZGVzIGNhbiBoYXZlIGFueSBjaGlsZCBub2RlLFxuICAgIC8vIGlzIHRoaXMgdHJ1ZT9cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBhY2NlcHRzLmRlZiA9IHtcbiAgICBhcmdUeXBlOiBbJ2ZuJywgJ25vZGUnLCAnbm9kZSddLFxuICAgIHJldHVyblR5cGU6ICdib29sZWFuJyxcbiAgICByZXF1aXJlOiBbJ2lzRW1wdHknLCAnbm9kZVR5cGUnLCAnbm9kZU5hbWUnXSxcbiAgICBjYXRlZ29yaWVzOiBbJ25vZGUnLCAncGx1Z2luJ11cbiAgfTtcblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihmbiwgeyBub2RlVHlwZTogbm9kZVR5cGUsIG5vZGVOYW1lOiBub2RlTmFtZSwgaXNFbXB0eTogaXNFbXB0eSwgYWNjZXB0czogYWNjZXB0cyB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVBsdWdpbnM7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5zZXJ0QmVmb3JlV3JhcHBlciA9IGZ1bmN0aW9uIGluc2VydEJlZm9yZVdyYXBwZXIoZm4pIHtcbiAgdmFyIG9yaWdpbmFsSW5zZXJ0QmVmb3JlID0gZm4uaW5zZXJ0QmVmb3JlO1xuXG4gIHZhciBpbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiBpbnNlcnRCZWZvcmUoZm4sIHJvb3QsIHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAgIC8vIFRPRE9cbiAgICAvLyBoYW5kbGUgZG9jdW1lbnQgZnJhZ21lbnRzXG4gICAgLy8gaGFuZGxlIGNvbWJpbmluZyB0ZXh0IGVsZW1lbnRzXG4gICAgcmV0dXJuIG9yaWdpbmFsSW5zZXJ0QmVmb3JlKGZuLCByb290LCBwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICB9O1xuXG4gIGluc2VydEJlZm9yZS5kZWYgPSBvcmlnaW5hbEluc2VydEJlZm9yZS5kZWY7XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZm4sIHsgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJlZm9yZVdyYXBwZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2VTdHIgPSByZXF1aXJlKCcuLi8uLi9wYXJzZScpO1xuXG52YXIgcGFyc2VyID0gZnVuY3Rpb24gcGFyc2VyKGZuKSB7XG4gIHZhciBwYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgIHJldHVybiBmbi5kZXNlcmlhbGl6ZShwYXJzZVN0cihzdHIpKTtcbiAgfTtcblxuICBwYXJzZS5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnc3RyaW5nJ10sXG4gICAgcmV0dXJuVHlwZTogJ25vZGUnLFxuICAgIHJlcXVpcmVzOiBbJ2Rlc2VyaWFsaXplJ10sXG4gICAgY2F0ZWdvcmllczogWydwYXJzZXInLCAncGx1Z2luJ11cbiAgfTtcblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihmbiwgeyBwYXJzZTogcGFyc2UgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlcjsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBiYXNlQWRhcHRlciA9IHJlcXVpcmUoJ2Nzcy1zZWxlY3QtYmFzZS1hZGFwdGVyJyk7XG5cbnZhciBBZGFwdGVyID0gZnVuY3Rpb24gQWRhcHRlcihmbiwgcm9vdCkge1xuICB2YXIgaXNUYWcgPSBmdW5jdGlvbiBpc1RhZyhub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gZm4udmFsdWUobm9kZSk7XG5cbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUubm9kZVR5cGUgPT09ICdlbGVtZW50JztcbiAgfTtcblxuICB2YXIgZ2V0QXR0cmlidXRlVmFsdWUgPSBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVWYWx1ZShub2RlLCBuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gZm4udmFsdWUobm9kZSk7XG5cbiAgICBpZiAodmFsdWUgJiYgdmFsdWUuYXR0cmlidXRlcykgcmV0dXJuIHZhbHVlLmF0dHJpYnV0ZXNbbmFtZV07XG4gIH07XG5cbiAgdmFyIGdldENoaWxkcmVuID0gZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obm9kZSkge1xuICAgIHJldHVybiBmbi5nZXRDaGlsZHJlbihub2RlKTtcbiAgfTtcblxuICB2YXIgZ2V0TmFtZSA9IGZ1bmN0aW9uIGdldE5hbWUobm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IGZuLnZhbHVlKG5vZGUpO1xuXG4gICAgaWYgKHZhbHVlKSByZXR1cm4gdmFsdWUudGFnTmFtZTtcbiAgfTtcblxuICB2YXIgZ2V0UGFyZW50ID0gZnVuY3Rpb24gZ2V0UGFyZW50KG5vZGUpIHtcbiAgICByZXR1cm4gZm4uZ2V0UGFyZW50KGZuLCByb290LCBub2RlKTtcbiAgfTtcblxuICB2YXIgZ2V0VGV4dCA9IGZ1bmN0aW9uIGdldFRleHQobm9kZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gbm9kZS5tYXAoZ2V0VGV4dCkuam9pbignJyk7XG5cbiAgICBpZiAoaXNUYWcobm9kZSkpIHJldHVybiBnZXRUZXh0KGdldENoaWxkcmVuKG5vZGUpKTtcblxuICAgIHZhciB2YWx1ZSA9IGZuLnZhbHVlKG5vZGUpO1xuXG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLm5vZGVUeXBlID09PSAndGV4dCcpIHJldHVybiB2YWx1ZS5ub2RlVmFsdWU7XG5cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgdmFyIGFkYXB0ZXIgPSB7XG4gICAgaXNUYWc6IGlzVGFnLCBnZXRBdHRyaWJ1dGVWYWx1ZTogZ2V0QXR0cmlidXRlVmFsdWUsIGdldENoaWxkcmVuOiBnZXRDaGlsZHJlbiwgZ2V0TmFtZTogZ2V0TmFtZSwgZ2V0UGFyZW50OiBnZXRQYXJlbnQsIGdldFRleHQ6IGdldFRleHRcbiAgfTtcblxuICByZXR1cm4gYmFzZUFkYXB0ZXIoYWRhcHRlcik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFkYXB0ZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWRhcHRlciA9IHJlcXVpcmUoJy4vaHRtbHBhcnNlcjItYWRhcHRlcicpO1xudmFyIFNlbGVjdCA9IHJlcXVpcmUoJy4uLy4uL3NlbGVjdCcpO1xuXG52YXIgU2VsZWN0ZXIgPSBmdW5jdGlvbiBTZWxlY3Rlcihmbiwgcm9vdCkge1xuICByZXR1cm4gU2VsZWN0KEFkYXB0ZXIoZm4sIHJvb3QpKTtcbn07XG5cbnZhciBxdWVyeVNlbGVjdG9yID0gZnVuY3Rpb24gcXVlcnlTZWxlY3Rvcihmbikge1xuICB2YXIgc2VsZWN0ID0gZnVuY3Rpb24gc2VsZWN0KGZuLCByb290LCBub2RlLCBxdWVyeSkge1xuICAgIHJldHVybiBTZWxlY3Rlcihmbiwgcm9vdCkuc2VsZWN0KG5vZGUsIHF1ZXJ5KTtcbiAgfTtcblxuICBzZWxlY3QuZGVmID0ge1xuICAgIGFyZ1R5cGVzOiBbJ2ZuJywgJ3Jvb3ROb2RlJywgJ25vZGUnLCAnc3RyaW5nJ10sXG4gICAgcmV0dXJuVHlwZTogJ25vZGUnLFxuICAgIHJlcXVpcmVzOiBbJ3ZhbHVlJywgJ2dldENoaWxkcmVuJywgJ2dldFBhcmVudCddLFxuICAgIGNhdGVnb3JpZXM6IFsncXVlcnknLCAnc2VsZWN0JywgJ3BsdWdpbnMnXVxuICB9O1xuXG4gIHZhciBzZWxlY3RBbGwgPSBmdW5jdGlvbiBzZWxlY3RBbGwoZm4sIHJvb3QsIG5vZGUsIHF1ZXJ5KSB7XG4gICAgcmV0dXJuIFNlbGVjdGVyKGZuLCByb290KS5zZWxlY3RBbGwobm9kZSwgcXVlcnkpO1xuICB9O1xuXG4gIHNlbGVjdEFsbC5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnZm4nLCAncm9vdE5vZGUnLCAnbm9kZScsICdzdHJpbmcnXSxcbiAgICByZXR1cm5UeXBlOiAnW25vZGVdJyxcbiAgICByZXF1aXJlczogWyd2YWx1ZScsICdnZXRDaGlsZHJlbicsICdnZXRQYXJlbnQnXSxcbiAgICBjYXRlZ29yaWVzOiBbJ3F1ZXJ5JywgJ3NlbGVjdCcsICdwbHVnaW5zJ11cbiAgfTtcblxuICB2YXIgbWF0Y2hlcyA9IGZ1bmN0aW9uIG1hdGNoZXMoZm4sIHJvb3QsIG5vZGUsIHF1ZXJ5KSB7XG4gICAgcmV0dXJuIFNlbGVjdGVyKGZuLCByb290KS5tYXRjaGVzKG5vZGUsIHF1ZXJ5KTtcbiAgfTtcblxuICBtYXRjaGVzLmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydmbicsICdyb290Tm9kZScsICdub2RlJywgJ3N0cmluZyddLFxuICAgIHJldHVyblR5cGU6ICdib29sZWFuJyxcbiAgICByZXF1aXJlczogWyd2YWx1ZScsICdnZXRDaGlsZHJlbicsICdnZXRQYXJlbnQnXSxcbiAgICBjYXRlZ29yaWVzOiBbJ3F1ZXJ5JywgJ3NlbGVjdCcsICdwbHVnaW5zJ11cbiAgfTtcblxuICB2YXIgcGx1Z2luID0geyBzZWxlY3Q6IHNlbGVjdCwgc2VsZWN0QWxsOiBzZWxlY3RBbGwsIG1hdGNoZXM6IG1hdGNoZXMgfTtcblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihmbiwgcGx1Z2luKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcXVlcnlTZWxlY3RvcjsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlOb2RlID0gcmVxdWlyZSgnLi4vLi4vc3RyaW5naWZ5Jyk7XG5cbnZhciBzdHJpbmdpZmllciA9IGZ1bmN0aW9uIHN0cmluZ2lmaWVyKGZuKSB7XG4gIHZhciBzdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkobm9kZSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlOb2RlKG5vZGUpO1xuICB9O1xuXG4gIHN0cmluZ2lmeS5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnbm9kZSddLFxuICAgIHJldHVyblR5cGU6ICdzdHJpbmcnLFxuICAgIHJlcXVpcmVzOiBbXSxcbiAgICBjYXRlZ29yaWVzOiBbJ3N0cmluZ2lmeScsICdwbHVnaW4nXVxuICB9O1xuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKGZuLCB7IHN0cmluZ2lmeTogc3RyaW5naWZ5IH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdpZmllcjsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBWYWxpZGF0b3IgPSByZXF1aXJlKCdtdHlwZS10djQnKTtcbnZhciBzY2hlbWEgPSByZXF1aXJlKCcuLi8uLi9zY2hlbWEnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ21vanVsZS11dGlscycpO1xuXG52YXIgY2FwaXRhbGl6ZUZpcnN0TGV0dGVyID0gdXRpbHMuY2FwaXRhbGl6ZUZpcnN0TGV0dGVyO1xuXG4vLyBjb3VsZCBnZXQgdGhpcyBmcm9tIHRoZSBuYW1lcywgYnV0IGJldHRlciB0byBiZSBleHBsaWNpdFxuXG52YXIgbm9kZVR5cGVzID0gWyd0ZXh0JywgJ2VsZW1lbnQnLCAnY29tbWVudCcsICdkb2N1bWVudCcsICdkb2N1bWVudFR5cGUnLCAnZG9jdW1lbnRGcmFnbWVudCddO1xuXG52YXIgdmFsaWRhdG9yID0gVmFsaWRhdG9yKHNjaGVtYSk7XG52YXIgdCA9IFZhbGlkYXRvci5tdHlwZSh2YWxpZGF0b3IpO1xuXG52YXIgaXNUeXBlID0gZnVuY3Rpb24gaXNUeXBlKG5vZGUsIHR5cGVuYW1lKSB7XG4gIHJldHVybiB0LmlzKG5vZGUsIHR5cGVuYW1lKTtcbn07XG5cbmlzVHlwZS5kZWYgPSB7XG4gIGFyZ1R5cGVzOiBbJ25vZGUnLCAnc3RyaW5nJ10sXG4gIHJldHVyblR5cGU6ICdib29sZWFuJyxcbiAgcmVxdWlyZXM6IFtdLFxuICBjYXRlZ29yaWVzOiBbJ3R5cGUnLCAncGx1Z2luJ11cbn07XG5cbnZhciB0eXBlcyA9IGZ1bmN0aW9uIHR5cGVzKGZuKSB7XG4gIHZhciBhc3NlcnRUeXBlID0gZnVuY3Rpb24gYXNzZXJ0VHlwZShub2RlLCB0eXBlbmFtZSkge1xuICAgIGlmICghZm4uaXNUeXBlKG5vZGUsIHR5cGVuYW1lKSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbGlkYXRvci52YWxpZGF0ZU11bHRpcGxlKG5vZGUsIHNjaGVtYVt0eXBlbmFtZV0pO1xuICAgICAgdmFyIGVycm9ycyA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdC5lcnJvcnMpO1xuXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBub2RlIHRvIGJlICcgKyB0eXBlbmFtZSArICc7ICcgKyBlcnJvcnMpO1xuICAgIH1cbiAgfTtcblxuICBhc3NlcnRUeXBlLmRlZiA9IHtcbiAgICBhcmdUeXBlczogWydub2RlJywgJ3N0cmluZyddLFxuICAgIHJlcXVpcmVzOiBbJ2lzVHlwZSddLFxuICAgIGNhdGVnb3JpZXM6IFsndHlwZScsICdwbHVnaW4nXVxuICB9O1xuXG4gIHZhciBwbHVnaW5zID0geyBpc1R5cGU6IGlzVHlwZSwgYXNzZXJ0VHlwZTogYXNzZXJ0VHlwZSB9O1xuXG4gIC8vIGFkZCBpc0RvY3VtZW50LCBpc1RleHQgZXRjXG4gIG5vZGVUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlbmFtZSkge1xuICAgIHZhciBjYXBUeXBlbmFtZSA9IGNhcGl0YWxpemVGaXJzdExldHRlcih0eXBlbmFtZSk7XG4gICAgdmFyIGlzTmFtZSA9ICdpcycgKyBjYXBUeXBlbmFtZTtcbiAgICB2YXIgYXNzZXJ0TmFtZSA9ICdhc3NlcnQnICsgY2FwVHlwZW5hbWU7XG5cbiAgICBwbHVnaW5zW2lzTmFtZV0gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIGZuLmlzVHlwZShub2RlLCB0eXBlbmFtZSk7XG4gICAgfTtcbiAgICBwbHVnaW5zW2lzTmFtZV0uZGVmID0gaXNUeXBlLmRlZjtcblxuICAgIHBsdWdpbnNbYXNzZXJ0TmFtZV0gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIGZuLmFzc2VydFR5cGUobm9kZSwgdHlwZW5hbWUpO1xuICAgIH07XG4gICAgcGx1Z2luc1thc3NlcnROYW1lXS5kZWYgPSBhc3NlcnRUeXBlLmRlZjtcbiAgfSk7XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZm4sIHBsdWdpbnMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlczsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBtb3JwaGRvbSA9IHJlcXVpcmUoJ21vcnBoZG9tJyk7XG52YXIgVm5vZGUgPSByZXF1aXJlKCcuLi8uLi92ZG9tJyk7XG5cbnZhciBtb3JwaGRvbVBsdWdpbiA9IGZ1bmN0aW9uIG1vcnBoZG9tUGx1Z2luKGZuKSB7XG4gIHZhciBwYXRjaERvbSA9IGZ1bmN0aW9uIHBhdGNoRG9tKG5vZGUsIHRhcmdldEVsLCBvcHRpb25zKSB7XG4gICAgLy9Wbm9kZSBleHBlY3RzIHdyYXBwZWQgbm9kZSFcbiAgICB2YXIgd3JhcHBlZCA9IGZuLmNyZWF0ZVRyZWUobm9kZSk7XG4gICAgdmFyIHZkb20gPSBWbm9kZSh3cmFwcGVkKTtcblxuICAgIG1vcnBoZG9tKHRhcmdldEVsLCB2ZG9tLCBvcHRpb25zKTtcbiAgfTtcblxuICBwYXRjaERvbS5kZWYgPSB7XG4gICAgYXJnVHlwZXM6IFsnbm9kZScsICdvYmplY3QnLCAnb2JqZWN0J10sXG4gICAgcmVxdWlyZXM6IFsnY3JlYXRlVHJlZSddLFxuICAgIGNhdGVnb3JpZXM6IFsncGF0Y2gnLCAncGx1Z2luJ11cbiAgfTtcblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihmbiwgeyBtb3JwaGRvbTogcGF0Y2hEb20gfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1vcnBoZG9tUGx1Z2luOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVudGl0eU5vZGUgPSByZXF1aXJlKCdtdHlwZS1ub2RlL3NjaGVtYS9lbnRpdHlOb2RlLnNjaGVtYS5qc29uJyk7XG52YXIgZW50aXR5Tm9kZVZhbHVlID0gcmVxdWlyZSgnbXR5cGUtbm9kZS9zY2hlbWEvZW50aXR5Tm9kZVZhbHVlLnNjaGVtYS5qc29uJyk7XG52YXIgZW1wdHlOb2RlID0gcmVxdWlyZSgnbXR5cGUtbm9kZS9zY2hlbWEvZW1wdHlOb2RlLnNjaGVtYS5qc29uJyk7XG52YXIgcGFyZW50Tm9kZSA9IHJlcXVpcmUoJ210eXBlLW5vZGUvc2NoZW1hL3BhcmVudE5vZGUuc2NoZW1hLmpzb24nKTtcblxudmFyIGNvbW1lbnQgPSByZXF1aXJlKCcuLi8uLi9zY2hlbWEvY29tbWVudC5zY2hlbWEuanNvbicpO1xudmFyIGNvbW1lbnRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3NjaGVtYS9jb21tZW50VmFsdWUuc2NoZW1hLmpzb24nKTtcbnZhciBkb2N1bWVudEZyYWdtZW50ID0gcmVxdWlyZSgnLi4vLi4vc2NoZW1hL2RvY3VtZW50RnJhZ21lbnQuc2NoZW1hLmpzb24nKTtcbnZhciBkb2N1bWVudEZyYWdtZW50VmFsdWUgPSByZXF1aXJlKCcuLi8uLi9zY2hlbWEvZG9jdW1lbnRGcmFnbWVudFZhbHVlLnNjaGVtYS5qc29uJyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuLi8uLi9zY2hlbWEvZG9jdW1lbnQuc2NoZW1hLmpzb24nKTtcbnZhciBkb2N1bWVudFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vc2NoZW1hL2RvY3VtZW50VmFsdWUuc2NoZW1hLmpzb24nKTtcbnZhciBkb2N1bWVudFR5cGUgPSByZXF1aXJlKCcuLi8uLi9zY2hlbWEvZG9jdW1lbnRUeXBlLmpzb24nKTtcbnZhciBkb2N1bWVudFR5cGVWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3NjaGVtYS9kb2N1bWVudFR5cGVWYWx1ZS5zY2hlbWEuanNvbicpO1xudmFyIGVsZW1lbnQgPSByZXF1aXJlKCcuLi8uLi9zY2hlbWEvZWxlbWVudC5zY2hlbWEuanNvbicpO1xudmFyIGVsZW1lbnRWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3NjaGVtYS9lbGVtZW50VmFsdWUuc2NoZW1hLmpzb24nKTtcbnZhciB0ZXh0ID0gcmVxdWlyZSgnLi4vLi4vc2NoZW1hL3RleHQuc2NoZW1hLmpzb24nKTtcbnZhciB0ZXh0VmFsdWUgPSByZXF1aXJlKCcuLi8uLi9zY2hlbWEvdGV4dFZhbHVlLnNjaGVtYS5qc29uJyk7XG5cbnZhciBzY2hlbWEgPSB7XG4gIGNvbW1lbnQ6IGNvbW1lbnQsIGNvbW1lbnRWYWx1ZTogY29tbWVudFZhbHVlLCBkb2N1bWVudEZyYWdtZW50OiBkb2N1bWVudEZyYWdtZW50LFxuICBkb2N1bWVudEZyYWdtZW50VmFsdWU6IGRvY3VtZW50RnJhZ21lbnRWYWx1ZSwgZG9jdW1lbnQ6IGRvY3VtZW50LCBkb2N1bWVudFZhbHVlOiBkb2N1bWVudFZhbHVlLCBkb2N1bWVudFR5cGU6IGRvY3VtZW50VHlwZSxcbiAgZG9jdW1lbnRUeXBlVmFsdWU6IGRvY3VtZW50VHlwZVZhbHVlLCBlbGVtZW50OiBlbGVtZW50LCBlbGVtZW50VmFsdWU6IGVsZW1lbnRWYWx1ZSwgdGV4dDogdGV4dCwgdGV4dFZhbHVlOiB0ZXh0VmFsdWUsXG5cbiAgZW50aXR5Tm9kZTogZW50aXR5Tm9kZSwgZW50aXR5Tm9kZVZhbHVlOiBlbnRpdHlOb2RlVmFsdWUsIGVtcHR5Tm9kZTogZW1wdHlOb2RlLCBwYXJlbnROb2RlOiBwYXJlbnROb2RlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNjaGVtYTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBDU1NzZWxlY3QgPSByZXF1aXJlKCdjc3Mtc2VsZWN0Jyk7XG5cbnZhciBTZWxlY3QgPSBmdW5jdGlvbiBTZWxlY3QoYWRhcHRlcikge1xuICB2YXIgb3B0aW9ucyA9IHsgYWRhcHRlcjogYWRhcHRlciB9O1xuXG4gIHZhciBzZWxlY3QgPSBmdW5jdGlvbiBzZWxlY3Qobm9kZSwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gQ1NTc2VsZWN0LnNlbGVjdE9uZShzZWxlY3Rvciwgbm9kZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgdmFyIHNlbGVjdEFsbCA9IGZ1bmN0aW9uIHNlbGVjdEFsbChub2RlLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBDU1NzZWxlY3Qoc2VsZWN0b3IsIG5vZGUsIG9wdGlvbnMpO1xuICB9O1xuXG4gIHZhciBtYXRjaGVzID0gZnVuY3Rpb24gbWF0Y2hlcyhub2RlLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBDU1NzZWxlY3QuaXMobm9kZSwgc2VsZWN0b3IsIG9wdGlvbnMpO1xuICB9O1xuXG4gIHZhciBhcGkgPSB7XG4gICAgc2VsZWN0OiBzZWxlY3QsIHNlbGVjdEFsbDogc2VsZWN0QWxsLCBtYXRjaGVzOiBtYXRjaGVzXG4gIH07XG5cbiAgcmV0dXJuIGFwaTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEh0bWwgPSByZXF1aXJlKCdodG1sLW5vZGUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ21vanVsZS11dGlscycpO1xuXG52YXIgZXNjYXBlSHRtbCA9IHV0aWxzLmVzY2FwZUh0bWw7XG5cblxudmFyIGluZm8gPSBIdG1sKCk7XG5cbnZhciBzdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkobm9kZSkge1xuICB2YXIgZGVwdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgdmFyIGh0bWwgPSAnJztcblxuICB2YXIgbm9kZVR5cGUgPSBub2RlLnZhbHVlLm5vZGVUeXBlO1xuXG5cbiAgaWYgKG5vZGVUeXBlID09PSAndGV4dCcpIGh0bWwgKz0gZXNjYXBlSHRtbChub2RlLnZhbHVlLm5vZGVWYWx1ZSk7XG5cbiAgaWYgKG5vZGVUeXBlID09PSAnY29tbWVudCcpIGh0bWwgKz0gJzwhLS0nICsgbm9kZS52YWx1ZS5ub2RlVmFsdWUgKyAnLS0+JztcblxuICBpZiAobm9kZVR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX25vZGUkdmFsdWUgPSBub2RlLnZhbHVlLFxuICAgICAgICAgIHRhZ05hbWUgPSBfbm9kZSR2YWx1ZS50YWdOYW1lLFxuICAgICAgICAgIGF0dHJpYnV0ZXMgPSBfbm9kZSR2YWx1ZS5hdHRyaWJ1dGVzO1xuXG5cbiAgICAgIGh0bWwgKz0gJzwnICsgdGFnTmFtZTtcblxuICAgICAgaWYgKGF0dHJpYnV0ZXMpIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgICBodG1sICs9ICcgJyArIG5hbWU7XG5cbiAgICAgICAgaWYgKHZhbHVlKSBodG1sICs9ICc9XCInICsgdmFsdWUgKyAnXCInO1xuICAgICAgfSk7XG5cbiAgICAgIGh0bWwgKz0gaW5mby5pc0VtcHR5KHRhZ05hbWUpID8gJyAvPicgOiAnPic7XG5cbiAgICAgIGRlcHRoKys7XG4gICAgfSkoKTtcbiAgfVxuXG4gIGlmIChub2RlVHlwZSA9PT0gJ2RvY3VtZW50VHlwZScpIHtcbiAgICB2YXIgX25vZGUkdmFsdWUyID0gbm9kZS52YWx1ZSxcbiAgICAgICAgbmFtZSA9IF9ub2RlJHZhbHVlMi5uYW1lLFxuICAgICAgICBwdWJsaWNJZCA9IF9ub2RlJHZhbHVlMi5wdWJsaWNJZCxcbiAgICAgICAgc3lzdGVtSWQgPSBfbm9kZSR2YWx1ZTIuc3lzdGVtSWQ7XG5cblxuICAgIGh0bWwgKz0gJzwhZG9jdHlwZSAnICsgbmFtZTtcblxuICAgIGlmIChwdWJsaWNJZCkge1xuICAgICAgaHRtbCArPSAnIHB1YmxpYyBcIicgKyBwdWJsaWNJZCArICdcIic7XG4gICAgfVxuXG4gICAgaWYgKHN5c3RlbUlkKSB7XG4gICAgICBodG1sICs9ICcgXCInICsgc3lzdGVtSWQgKyAnXCInO1xuICAgIH1cblxuICAgIGh0bWwgKz0gJz4nO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikpIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gaHRtbCArPSBzdHJpbmdpZnkoY2hpbGQsIGRlcHRoKTtcbiAgfSk7XG5cbiAgaWYgKG5vZGVUeXBlID09PSAnZWxlbWVudCcgJiYgIWluZm8uaXNFbXB0eShub2RlLnZhbHVlLnRhZ05hbWUpKSB7XG4gICAgaHRtbCArPSAnPC8nICsgbm9kZS52YWx1ZS50YWdOYW1lICsgJz4nO1xuICB9XG5cbiAgcmV0dXJuIGh0bWw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ2lmeTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBWbm9kZSA9IGZ1bmN0aW9uIFZub2RlKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB2YXIgdm5vZGUgPSB7XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7XG4gICAgICByZXR1cm4gVm5vZGUobm9kZS5maXJzdENoaWxkKCkpO1xuICAgIH0sXG5cbiAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgICByZXR1cm4gVm5vZGUobm9kZS5uZXh0U2libGluZygpKTtcbiAgICB9LFxuXG4gICAgZ2V0IG5vZGVUeXBlKCkge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUoKTtcbiAgICB9LFxuXG4gICAgZ2V0IG5vZGVOYW1lKCkge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZU5hbWUoKTtcbiAgICB9LFxuXG4gICAgLy8gc2hvdWxkIGJlIHNvbWV0aGluZyBmb3Igc3ZnIG9yIG1hdGggZXRjLiFcbiAgICBnZXQgbmFtZXNwYWNlVVJJKCkge1xuICAgICAgcmV0dXJuICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbiAgICB9LFxuXG4gICAgZ2V0IG5vZGVWYWx1ZSgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG5vZGUudmFsdWUoKTtcblxuICAgICAgcmV0dXJuIHZhbHVlLm5vZGVWYWx1ZSB8fCAnJztcbiAgICB9LFxuXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZSgpO1xuXG4gICAgICByZXR1cm4gdmFsdWUudmFsdWU7XG4gICAgfSxcblxuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG5vZGUudmFsdWUoKTtcblxuICAgICAgcmV0dXJuICEhdmFsdWUuc2VsZWN0ZWQ7XG4gICAgfSxcblxuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG5vZGUudmFsdWUoKTtcblxuICAgICAgcmV0dXJuICEhdmFsdWUuZGlzYWJsZWQ7XG4gICAgfSxcblxuICAgIC8vIHNob3VsZCBiZSBzb21ldGhpbmcgZm9yIHN2ZyBvciBtYXRoIGV0Yy4hXG4gICAgLy8gaGFzQXR0cmlidXRlTlM6ICggbmFtZXNwYWNlVVJJLCBuYW1lICkgPT4ge1xuICAgIGhhc0F0dHJpYnV0ZU5TOiBmdW5jdGlvbiBoYXNBdHRyaWJ1dGVOUyhuYW1lc3BhY2VVUkkpIHtcbiAgICAgIHJldHVybiBuYW1lc3BhY2VVUkkgPT09IHZub2RlLm5hbWVzcGFjZVVSSTtcbiAgICB9LFxuXG4gICAgYXNzaWduQXR0cmlidXRlczogZnVuY3Rpb24gYXNzaWduQXR0cmlidXRlcyh0YXJnZXROb2RlKSB7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcygpO1xuXG4gICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXROb2RlLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyaWJ1dGVzW25hbWVdKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBhY3R1YWxpemU6IGZ1bmN0aW9uIGFjdHVhbGl6ZShkb2N1bWVudCkge1xuICAgICAgcmV0dXJuIF9hY3R1YWxpemVbdm5vZGUubm9kZVR5cGVdKGRvY3VtZW50LCB2bm9kZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB2bm9kZTtcbn07XG5cbnZhciBhZGRDaGlsZHJlbiA9IGZ1bmN0aW9uIGFkZENoaWxkcmVuKGRvY3VtZW50LCBlbCwgdm5vZGUpIHtcbiAgdmFyIGNoaWxkID0gdm5vZGUuZmlyc3RDaGlsZDtcblxuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBlbC5hcHBlbmRDaGlsZChjaGlsZC5hY3R1YWxpemUoZG9jdW1lbnQpKTtcbiAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICB9XG59O1xuXG52YXIgX2FjdHVhbGl6ZSA9IHtcbiAgdGV4dDogZnVuY3Rpb24gdGV4dChkb2N1bWVudCwgdm5vZGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodm5vZGUubm9kZVZhbHVlKTtcbiAgfSxcbiAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudChkb2N1bWVudCwgdm5vZGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh2bm9kZS5ub2RlVmFsdWUpO1xuICB9LFxuICBlbGVtZW50OiBmdW5jdGlvbiBlbGVtZW50KGRvY3VtZW50LCB2bm9kZSkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodm5vZGUubm9kZU5hbWUpO1xuXG4gICAgdm5vZGUuYXNzaWduQXR0cmlidXRlcyhlbCk7XG5cbiAgICBhZGRDaGlsZHJlbihkb2N1bWVudCwgZWwsIHZub2RlKTtcblxuICAgIHJldHVybiBlbDtcbiAgfSxcbiAgZG9jdW1lbnRGcmFnbWVudDogZnVuY3Rpb24gZG9jdW1lbnRGcmFnbWVudChkb2N1bWVudCwgdm5vZGUpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICBhZGRDaGlsZHJlbihkb2N1bWVudCwgZWwsIHZub2RlKTtcblxuICAgIHJldHVybiBlbDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWbm9kZTsiLCJtb2R1bGUuZXhwb3J0cz17XHJcbiAgXCJpZFwiOiBcImNvbW1lbnRcIixcclxuICBcImFsbE9mXCI6IFtcclxuICAgIHsgXCIkcmVmXCI6IFwiZW1wdHlOb2RlXCIgfSxcclxuICAgIHtcclxuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcclxuICAgICAgICBcInZhbHVlXCI6IHsgXCIkcmVmXCI6IFwiY29tbWVudFZhbHVlXCIgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgXVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzPXtcclxuICBcImlkXCI6IFwiY29tbWVudFZhbHVlXCIsXHJcbiAgXCJhbGxPZlwiOiAgW1xyXG4gICAgeyBcIiRyZWZcIjogXCJlbnRpdHlOb2RlVmFsdWVcIiB9LFxyXG4gICAge1xyXG4gICAgICBcInByb3BlcnRpZXNcIjoge1xyXG4gICAgICAgIFwibm9kZVR5cGVcIjoge1xyXG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICBcImVudW1cIjogWyBcImNvbW1lbnRcIiBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIm5vZGVWYWx1ZVwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiIH1cclxuICAgICAgfSxcclxuICAgICAgXCJyZXF1aXJlZFwiOiBbIFwibm9kZVR5cGVcIiwgXCJub2RlVmFsdWVcIiBdXHJcbiAgICB9XHJcbiAgXVxyXG59IiwibW9kdWxlLmV4cG9ydHM9e1xyXG4gIFwiaWRcIjogXCJkb2N1bWVudFwiLFxyXG4gIFwiYWxsT2ZcIjogW1xyXG4gICAgeyBcIiRyZWZcIjogXCJwYXJlbnROb2RlXCIgfSxcclxuICAgIHtcclxuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcclxuICAgICAgICBcInZhbHVlXCI6IHsgXCIkcmVmXCI6IFwiZG9jdW1lbnRWYWx1ZVwiIH1cclxuICAgICAgfSAgICAgIFxyXG4gICAgfSAgICBcclxuICBdXHJcbn1cclxuIiwibW9kdWxlLmV4cG9ydHM9e1xyXG4gIFwiaWRcIjogXCJkb2N1bWVudEZyYWdtZW50XCIsXHJcbiAgXCJhbGxPZlwiOiBbXHJcbiAgICB7IFwiJHJlZlwiOiBcInBhcmVudE5vZGVcIiB9LFxyXG4gICAge1xyXG4gICAgICBcInByb3BlcnRpZXNcIjoge1xyXG4gICAgICAgIFwidmFsdWVcIjogeyBcIiRyZWZcIjogXCJkb2N1bWVudEZyYWdtZW50VmFsdWVcIiB9XHJcbiAgICAgIH0gICAgICBcclxuICAgIH0gICAgXHJcbiAgXVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzPXtcclxuICBcImlkXCI6IFwiZG9jdW1lbnRGcmFnbWVudFZhbHVlXCIsXHJcbiAgXCJhbGxPZlwiOiAgW1xyXG4gICAgeyBcIiRyZWZcIjogXCJlbnRpdHlOb2RlVmFsdWVcIiB9LFxyXG4gICAge1xyXG4gICAgICBcInByb3BlcnRpZXNcIjoge1xyXG4gICAgICAgIFwibm9kZVR5cGVcIjoge1xyXG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICBcImVudW1cIjogWyBcImRvY3VtZW50RnJhZ21lbnRcIiBdXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBcInJlcXVpcmVkXCI6IFsgXCJub2RlVHlwZVwiIF1cclxuICAgIH1cclxuICBdXHJcbn1cclxuIiwibW9kdWxlLmV4cG9ydHM9e1xyXG4gIFwiaWRcIjogXCJkb2N1bWVudFR5cGVcIixcclxuICBcImFsbE9mXCI6IFtcclxuICAgIHsgXCIkcmVmXCI6IFwiZW1wdHlOb2RlXCIgfSxcclxuICAgIHtcclxuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcclxuICAgICAgICBcInZhbHVlXCI6IHsgXCIkcmVmXCI6IFwiZG9jdW1lbnRUeXBlVmFsdWVcIiB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBdXHJcbn1cclxuIiwibW9kdWxlLmV4cG9ydHM9e1xyXG4gIFwiaWRcIjogXCJkb2N1bWVudFR5cGVWYWx1ZVwiLFxyXG4gIFwiYWxsT2ZcIjogIFtcclxuICAgIHsgXCIkcmVmXCI6IFwiZW50aXR5Tm9kZVZhbHVlXCIgfSxcclxuICAgIHtcclxuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcclxuICAgICAgICBcIm5vZGVUeXBlXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgXCJlbnVtXCI6IFsgXCJkb2N1bWVudFR5cGVcIiBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIm5hbWVcIjogeyBcInR5cGVcIjogXCJzdHJpbmdcIiB9LFxyXG4gICAgICAgIFwicHVibGljSWRcIjogeyBcInR5cGVcIjogXCJzdHJpbmdcIiB9LFxyXG4gICAgICAgIFwic3lzdGVtSWRcIjogeyBcInR5cGVcIjogXCJzdHJpbmdcIiB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFwicmVxdWlyZWRcIjogWyBcIm5vZGVUeXBlXCIsIFwibmFtZVwiLCBcInB1YmxpY0lkXCIsIFwic3lzdGVtSWRcIiBdXHJcbiAgICB9XHJcbiAgXVxyXG59IiwibW9kdWxlLmV4cG9ydHM9e1xyXG4gIFwiaWRcIjogXCJkb2N1bWVudFZhbHVlXCIsXHJcbiAgXCJhbGxPZlwiOiAgW1xyXG4gICAgeyBcIiRyZWZcIjogXCJlbnRpdHlOb2RlVmFsdWVcIiB9LFxyXG4gICAge1xyXG4gICAgICBcInByb3BlcnRpZXNcIjoge1xyXG4gICAgICAgIFwibm9kZVR5cGVcIjoge1xyXG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICBcImVudW1cIjogWyBcImRvY3VtZW50XCIgXVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgXCJyZXF1aXJlZFwiOiBbIFwibm9kZVR5cGVcIiBdXHJcbiAgICB9XHJcbiAgXVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzPXtcclxuICBcImlkXCI6IFwiZWxlbWVudFwiLFxyXG4gIFwiYWxsT2ZcIjogW1xyXG4gICAgeyBcIiRyZWZcIjogXCJwYXJlbnROb2RlXCIgfSxcclxuICAgIHtcclxuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcclxuICAgICAgICBcInZhbHVlXCI6IHsgXCIkcmVmXCI6IFwiZWxlbWVudFZhbHVlXCIgfVxyXG4gICAgICB9ICAgICAgXHJcbiAgICB9ICAgIFxyXG4gIF1cclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cz17XHJcbiAgXCJpZFwiOiBcImVsZW1lbnRWYWx1ZVwiLFxyXG4gIFwiYWxsT2ZcIjogIFtcclxuICAgIHsgXCIkcmVmXCI6IFwiZW50aXR5Tm9kZVZhbHVlXCIgfSxcclxuICAgIHtcclxuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcclxuICAgICAgICBcIm5vZGVUeXBlXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgXCJlbnVtXCI6IFsgXCJlbGVtZW50XCIgXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxyXG4gICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFwicmVxdWlyZWRcIjogWyBcIm5vZGVUeXBlXCIsIFwiYXR0cmlidXRlc1wiIF1cclxuICAgIH1cclxuICBdXHJcbn1cclxuIiwibW9kdWxlLmV4cG9ydHM9e1xyXG4gIFwiaWRcIjogXCJ0ZXh0XCIsXHJcbiAgXCJhbGxPZlwiOiBbXHJcbiAgICB7IFwiJHJlZlwiOiBcImVtcHR5Tm9kZVwiIH0sXHJcbiAgICB7XHJcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XHJcbiAgICAgICAgXCJ2YWx1ZVwiOiB7IFwiJHJlZlwiOiBcInRleHRWYWx1ZVwiIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIF1cclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cz17XHJcbiAgXCJpZFwiOiBcInRleHRWYWx1ZVwiLFxyXG4gIFwiYWxsT2ZcIjogIFtcclxuICAgIHsgXCIkcmVmXCI6IFwiZW50aXR5Tm9kZVZhbHVlXCIgfSxcclxuICAgIHtcclxuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcclxuICAgICAgICBcIm5vZGVUeXBlXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgXCJlbnVtXCI6IFsgXCJ0ZXh0XCIgXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJub2RlVmFsdWVcIjogeyBcInR5cGVcIjogXCJzdHJpbmdcIiB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFwicmVxdWlyZWRcIjogWyBcIm5vZGVUeXBlXCIsIFwibm9kZVZhbHVlXCIgXVxyXG4gICAgfVxyXG4gIF1cclxufVxyXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBIdHJlZSA9IHJlcXVpcmUoJ21vanVsZS1kb20nKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ21vanVsZS11dGlscycpO1xuXG52YXIgY2xvbmUgPSB1dGlscy5jbG9uZTtcblxuXG52YXIgdG9rZW5zID0gWyd0YWcnLCAndGV4dCcsICdodG1sJywgJ2lmJywgJ25vdCcsICdlYWNoJywgJ2VtcHR5JywgJ2NvbnRleHQnLCAnaW5jbHVkZSddO1xuXG52YXIgdG9rZW5TZWxlY3RvciA9IGZ1bmN0aW9uIHRva2VuU2VsZWN0b3IodG9rZW4pIHtcbiAgcmV0dXJuICdbZGF0YS0nICsgdG9rZW4gKyAnXSc7XG59O1xudmFyIHNlbGVjdG9ycyA9IHRva2Vucy5tYXAodG9rZW5TZWxlY3Rvcik7XG5cbnZhciByZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShzY29wZSwgcHJvcGVydHlOYW1lKSB7XG4gIGlmIChfdHlwZW9mKHNjb3BlLmN1cnJlbnQpID09PSAnb2JqZWN0JyAmJiBwcm9wZXJ0eU5hbWUgaW4gc2NvcGUuY3VycmVudCkgcmV0dXJuIHNjb3BlLmN1cnJlbnRbcHJvcGVydHlOYW1lXTtcblxuICBpZiAocHJvcGVydHlOYW1lID09PSAnLicpIHJldHVybiBzY29wZS5jdXJyZW50O1xuXG4gIGlmIChzY29wZS5wYXJlbnQpIHJldHVybiByZXNvbHZlKHNjb3BlLnBhcmVudCwgcHJvcGVydHlOYW1lKTtcbn07XG5cbnZhciBhY3Rpb25XaGl0ZWxpc3QgPSBbJ3RhZ05hbWUnLCAnYXR0cicsICdyZW1vdmVBdHRyJywgJ2FkZENsYXNzJywgJ3JlbW92ZUNsYXNzJywgJ3RvZ2dsZUNsYXNzJywgJ2NsZWFyQXR0cnMnLCAnY2xlYXJDbGFzc2VzJywgJ2F0dHJpYnV0ZXMnXTtcblxudmFyIGhhbmRsZUFjdGlvbiA9IGZ1bmN0aW9uIGhhbmRsZUFjdGlvbihlbCwgYWN0aW9uKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhhY3Rpb24pLmZpbHRlcihmdW5jdGlvbiAoZm5hbWUpIHtcbiAgICByZXR1cm4gYWN0aW9uV2hpdGVsaXN0LmluY2x1ZGVzKGZuYW1lKTtcbiAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZm5hbWUpIHtcbiAgICB2YXIgYXJncyA9IGFjdGlvbltmbmFtZV07XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJncykpIGFyZ3MgPSBbYXJnc107XG5cbiAgICBlbFtmbmFtZV0uYXBwbHkoZWwsIF90b0NvbnN1bWFibGVBcnJheShhcmdzKSk7XG4gIH0pO1xufTtcblxudmFyIFRlbXBsYXRpbmcgPSBmdW5jdGlvbiBUZW1wbGF0aW5nKHRlbXBsYXRlcykge1xuICB2YXIgZ2V0VGVtcGxhdGVGcmFnbWVudCA9IGZ1bmN0aW9uIGdldFRlbXBsYXRlRnJhZ21lbnQobmFtZSkge1xuICAgIHJldHVybiBIdHJlZShjbG9uZSh0ZW1wbGF0ZXNbbmFtZV0pKTtcbiAgfTtcblxuICB2YXIgcG9wdWxhdGVFbCA9IHtcbiAgICB0YWc6IGZ1bmN0aW9uIHRhZyhlbCwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB2YWx1ZSA9IFt2YWx1ZV07XG5cbiAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gaGFuZGxlQWN0aW9uKGVsLCBhY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICB0ZXh0OiBmdW5jdGlvbiB0ZXh0KGVsLCBzY29wZSwgdmFsdWUpIHtcbiAgICAgIGVsLmVtcHR5KCk7XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgIHZhciB0ZXh0Tm9kZSA9IGVsLmNyZWF0ZVRleHQodmFsdWUpO1xuXG4gICAgICBlbC5hcHBlbmQodGV4dE5vZGUpO1xuICAgIH0sXG4gICAgaHRtbDogZnVuY3Rpb24gaHRtbChlbCwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbC5lbXB0eSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLnBhcnNlKHZhbHVlKTtcblxuICAgICAgZWwuYXBwZW5kKGNoaWxkcmVuKTtcbiAgICB9LFxuICAgIGlmOiBmdW5jdGlvbiBfaWYoZWwsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSkgZWwuZW1wdHkoKTtcbiAgICB9LFxuICAgIG5vdDogZnVuY3Rpb24gbm90KGVsLCBzY29wZSwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkgZWwuZW1wdHkoKTtcbiAgICB9LFxuICAgIGVhY2g6IGZ1bmN0aW9uIGVhY2goZWwsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWwuZW1wdHkoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcG9wdWxhdGVFbC5jb250ZXh0KGVsLCBzY29wZSwgdmFsdWUpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuZW1wdHkoKTtcblxuICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgY2hpbGRTY29wZSA9IHtcbiAgICAgICAgICBwYXJlbnQ6IHNjb3BlLFxuICAgICAgICAgIGN1cnJlbnQ6IGl0ZW1cbiAgICAgICAgfTtcblxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgIGVsLmFwcGVuZChjaGlsZC5jbG9uZSgpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcG9wdWxhdGVOZXh0KGVsLCBjaGlsZFNjb3BlKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZW1wdHk6IGZ1bmN0aW9uIGVtcHR5KGVsLCBzY29wZSwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVsLmVtcHR5KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggPiAwKSBlbC5lbXB0eSgpO1xuICAgIH0sXG4gICAgY29udGV4dDogZnVuY3Rpb24gY29udGV4dChlbCwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICB2YXIgbmV3U2NvcGUgPSB7XG4gICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgY3VycmVudDogdmFsdWVcbiAgICAgIH07XG5cbiAgICAgIHBvcHVsYXRlTmV4dChlbCwgbmV3U2NvcGUpO1xuICAgIH0sXG4gICAgaW5jbHVkZTogZnVuY3Rpb24gaW5jbHVkZShlbCwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICBlbC5lbXB0eSgpO1xuXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICBlbC5hcHBlbmQoZ2V0VGVtcGxhdGVGcmFnbWVudCh2YWx1ZSkpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcG9wdWxhdGVOZXh0ID0gZnVuY3Rpb24gcG9wdWxhdGVOZXh0KHRlbXBsYXRlLCBzY29wZSkge1xuICAgIHZhciBuZXh0ID0gdGVtcGxhdGUuc2VsZWN0KHNlbGVjdG9ycy5qb2luKCcsICcpKTtcblxuICAgIGlmICghbmV4dCkgcmV0dXJuIHRlbXBsYXRlO1xuXG4gICAgdmFyIGN1cnJlbnRUb2tlbiA9IHRva2Vucy5maW5kKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgcmV0dXJuIG5leHQubWF0Y2hlcyh0b2tlblNlbGVjdG9yKHRva2VuKSk7XG4gICAgfSk7XG5cbiAgICB2YXIgYXR0ck5hbWUgPSAnZGF0YS0nICsgY3VycmVudFRva2VuO1xuICAgIHZhciBuYW1lID0gbmV4dC5hdHRyKGF0dHJOYW1lKTtcblxuICAgIGlmIChjdXJyZW50VG9rZW4gPT09ICdpbmNsdWRlJykge1xuICAgICAgcG9wdWxhdGVFbFtjdXJyZW50VG9rZW5dKG5leHQsIHNjb3BlLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZhbHVlID0gcmVzb2x2ZShzY29wZSwgbmFtZSk7XG5cbiAgICAgIHBvcHVsYXRlRWxbY3VycmVudFRva2VuXShuZXh0LCBzY29wZSwgdmFsdWUpO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzY29wZSA9IHtcbiAgICAgICAgICBwYXJlbnQ6IHNjb3BlLFxuICAgICAgICAgIGN1cnJlbnQ6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmV4dC5yZW1vdmVBdHRyKGF0dHJOYW1lKTtcblxuICAgIHJldHVybiBwb3B1bGF0ZU5leHQodGVtcGxhdGUsIHNjb3BlKTtcbiAgfTtcblxuICB2YXIgdW53cmFwRnJhZ21lbnRDaGlsZHJlbiA9IGZ1bmN0aW9uIHVud3JhcEZyYWdtZW50Q2hpbGRyZW4oZnJhZ21lbnQpIHtcbiAgICB2YXIgbm90RnJhZ21lbnQgPSBmcmFnbWVudC5maW5kKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gIW4ubWF0Y2hlcygnZnJhZ21lbnQnKTtcbiAgICB9KTtcblxuICAgIGlmICghbm90RnJhZ21lbnQpIHJldHVybiBmcmFnbWVudDtcblxuICAgIHZhciBmcmFnbWVudFBhcmVudCA9IGZyYWdtZW50LmdldFBhcmVudCgpO1xuXG4gICAgZnJhZ21lbnRQYXJlbnQuaW5zZXJ0QmVmb3JlKG5vdEZyYWdtZW50LCBmcmFnbWVudCk7XG5cbiAgICByZXR1cm4gdW53cmFwRnJhZ21lbnRDaGlsZHJlbihmcmFnbWVudCk7XG4gIH07XG5cbiAgdmFyIHVud3JhcE5leHRGcmFnbWVudCA9IGZ1bmN0aW9uIHVud3JhcE5leHRGcmFnbWVudCh0ZW1wbGF0ZSkge1xuICAgIHZhciBmcmFnbWVudCA9IHRlbXBsYXRlLnNlbGVjdCgnZnJhZ21lbnQnKTtcblxuICAgIGlmICghZnJhZ21lbnQpIHJldHVybiB0ZW1wbGF0ZTtcblxuICAgIHVud3JhcEZyYWdtZW50Q2hpbGRyZW4oZnJhZ21lbnQpO1xuXG4gICAgZnJhZ21lbnQucmVtb3ZlKCk7XG5cbiAgICByZXR1cm4gdW53cmFwTmV4dEZyYWdtZW50KHRlbXBsYXRlKTtcbiAgfTtcblxuICB2YXIgcG9wdWxhdGUgPSBmdW5jdGlvbiBwb3B1bGF0ZShuYW1lLCBtb2RlbCkge1xuICAgIHZhciB0ZW1wbGF0ZSA9IGdldFRlbXBsYXRlRnJhZ21lbnQobmFtZSk7XG5cbiAgICB2YXIgc2NvcGUgPSB7XG4gICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICBjdXJyZW50OiBtb2RlbFxuICAgIH07XG5cbiAgICBwb3B1bGF0ZU5leHQodGVtcGxhdGUsIHNjb3BlKTtcbiAgICB1bndyYXBOZXh0RnJhZ21lbnQodGVtcGxhdGUpO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9O1xuXG4gIHJldHVybiBwb3B1bGF0ZTtcbn07XG5cblRlbXBsYXRpbmcuZ2V0VGVtcGxhdGVzID0gZnVuY3Rpb24gKGh0cmVlKSB7XG4gIGlmICh0eXBlb2YgaHRyZWUgPT09ICdzdHJpbmcnKSBodHJlZSA9IEh0cmVlKGh0cmVlKTtcblxuICB2YXIgdGVtcGxhdGVFbHMgPSBodHJlZS5jbG9uZSgpLnNlbGVjdEFsbCgndGVtcGxhdGVbaWRdOm5vdChbaWQ9XCJcIl0pJyk7XG5cbiAgcmV0dXJuIHRlbXBsYXRlRWxzLnJlZHVjZShmdW5jdGlvbiAodGVtcGxhdGVzLCBlbCkge1xuICAgIHZhciBpZCA9IGVsLmF0dHIoJ2lkJyk7XG5cbiAgICB2YXIgZnJhZ21lbnQgPSBodHJlZS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICBlbC5nZXRDaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gZnJhZ21lbnQuYXBwZW5kKGNoaWxkKTtcbiAgICB9KTtcblxuICAgIHRlbXBsYXRlc1tpZF0gPSBmcmFnbWVudC5zZXJpYWxpemUoKTtcblxuICAgIHJldHVybiB0ZW1wbGF0ZXM7XG4gIH0sIHt9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGVtcGxhdGluZzsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnbW9qdWxlLXV0aWxzJyksXG4gICAgY2xvbmUgPSBfcmVxdWlyZS5jbG9uZTtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJzF0cmVlLWpzb24nKSxcbiAgICB0b1RyZWUgPSBfcmVxdWlyZTIudG9UcmVlLFxuICAgIHRvSnNvbiA9IF9yZXF1aXJlMi50b0pzb247XG5cbnZhciB0cmFuc2Zvcm1zID0ge1xuICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcyhkYXRhKSB7XG4gICAgdmFyIG1vZGVsID0gZGF0YS5tb2RlbCxcbiAgICAgICAgdHJhbnNmb3JtID0gZGF0YS50cmFuc2Zvcm07XG5cblxuICAgIHZhciB0cmFuc2Zvcm1UcmVlID0gdG9UcmVlKHRyYW5zZm9ybSk7XG5cbiAgICB2YXIgdmFsdWVQcm9wZXJ0eU5vZGVzID0gdHJhbnNmb3JtVHJlZS5maW5kQWxsKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gbi52YWx1ZSgpLnByb3BlcnR5TmFtZSA9PT0gJyR2YWx1ZSc7XG4gICAgfSk7XG5cbiAgICBpZiAodmFsdWVQcm9wZXJ0eU5vZGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGRhdGE7XG5cbiAgICB2YWx1ZVByb3BlcnR5Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHlOb2RlKSB7XG4gICAgICB2YXIgb2JqZWN0Tm9kZSA9IHByb3BlcnR5Tm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIHZhciBvYmplY3ROb2RlUGFyZW50ID0gb2JqZWN0Tm9kZS5nZXRQYXJlbnQoKTtcblxuICAgICAgdmFyIHZhbHVlID0gcHJvcGVydHlOb2RlLnZhbHVlKCk7XG4gICAgICB2YXIgc291cmNlUHJvcGVydHlOYW1lID0gdmFsdWUubm9kZVZhbHVlO1xuXG4gICAgICB2YXIgbmV3VmFsdWVOb2RlID0gc291cmNlUHJvcGVydHlOYW1lIGluIG1vZGVsID8gdG9UcmVlKG1vZGVsW3NvdXJjZVByb3BlcnR5TmFtZV0pIDogdG9UcmVlKCckZGVsZXRlJyk7XG5cbiAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBvYmplY3ROb2RlLnZhbHVlKCkucHJvcGVydHlOYW1lO1xuXG4gICAgICBpZiAocHJvcGVydHlOYW1lKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IG5ld1ZhbHVlTm9kZS52YWx1ZSgpO1xuICAgICAgICBuZXdWYWx1ZS5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG4gICAgICAgIG5ld1ZhbHVlTm9kZS52YWx1ZShuZXdWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIG9iamVjdE5vZGVQYXJlbnQucmVwbGFjZUNoaWxkKG5ld1ZhbHVlTm9kZSwgb2JqZWN0Tm9kZSk7XG4gICAgfSk7XG5cbiAgICB0cmFuc2Zvcm0gPSB0b0pzb24odHJhbnNmb3JtVHJlZSk7XG5cbiAgICByZXR1cm4geyBtb2RlbDogbW9kZWwsIHRyYW5zZm9ybTogdHJhbnNmb3JtIH07XG4gIH0sXG4gIGlmczogZnVuY3Rpb24gaWZzKGRhdGEpIHtcbiAgICB2YXIgbW9kZWwgPSBkYXRhLm1vZGVsLFxuICAgICAgICB0cmFuc2Zvcm0gPSBkYXRhLnRyYW5zZm9ybTtcblxuXG4gICAgdmFyIHRyYW5zZm9ybVRyZWUgPSB0b1RyZWUodHJhbnNmb3JtKTtcblxuICAgIHZhciBpZlByb3BlcnR5Tm9kZXMgPSB0cmFuc2Zvcm1UcmVlLmZpbmRBbGwoZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBuLnZhbHVlKCkucHJvcGVydHlOYW1lID09PSAnJGlmJztcbiAgICB9KTtcblxuICAgIGlmUHJvcGVydHlOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eU5vZGUpIHtcbiAgICAgIHZhciBvYmplY3ROb2RlID0gcHJvcGVydHlOb2RlLmdldFBhcmVudCgpO1xuICAgICAgdmFyIG9iamVjdE5vZGVQYXJlbnQgPSBvYmplY3ROb2RlLmdldFBhcmVudCgpO1xuXG4gICAgICB2YXIgaWZBcmdOb2RlcyA9IHByb3BlcnR5Tm9kZS5nZXRDaGlsZHJlbigpO1xuXG4gICAgICB2YXIgaXNWYWx1ZSA9IGlmQXJnTm9kZXNbMF0udmFsdWUoKS5ub2RlVmFsdWU7XG5cbiAgICAgIGlmIChpc1ZhbHVlICYmIGlzVmFsdWUgIT09ICckZGVsZXRlJykge1xuICAgICAgICB2YXIgaWZWYWx1ZU5vZGUgPSBpZkFyZ05vZGVzWzFdO1xuXG4gICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBvYmplY3ROb2RlLnZhbHVlKCkucHJvcGVydHlOYW1lO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBpZlZhbHVlTm9kZS52YWx1ZSgpO1xuICAgICAgICAgIG5ld1ZhbHVlLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcbiAgICAgICAgICBpZlZhbHVlTm9kZS52YWx1ZShuZXdWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmplY3ROb2RlUGFyZW50Lmluc2VydEJlZm9yZShpZlZhbHVlTm9kZSwgb2JqZWN0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIG9iamVjdE5vZGUucmVtb3ZlKCk7XG4gICAgfSk7XG5cbiAgICB0cmFuc2Zvcm0gPSB0b0pzb24odHJhbnNmb3JtVHJlZSk7XG5cbiAgICByZXR1cm4geyBtb2RlbDogbW9kZWwsIHRyYW5zZm9ybTogdHJhbnNmb3JtIH07XG4gIH0sXG4gIGRlbGV0ZXM6IGZ1bmN0aW9uIGRlbGV0ZXMoZGF0YSkge1xuICAgIHZhciBtb2RlbCA9IGRhdGEubW9kZWwsXG4gICAgICAgIHRyYW5zZm9ybSA9IGRhdGEudHJhbnNmb3JtO1xuXG5cbiAgICB2YXIgdHJhbnNmb3JtS2V5cyA9IE9iamVjdC5rZXlzKHRyYW5zZm9ybSk7XG5cbiAgICB0cmFuc2Zvcm1LZXlzLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgICAgaWYgKHRyYW5zZm9ybVtwcm9wZXJ0eU5hbWVdID09PSAnJGRlbGV0ZScpIHtcbiAgICAgICAgZGVsZXRlIG1vZGVsW3Byb3BlcnR5TmFtZV07XG4gICAgICAgIGRlbGV0ZSB0cmFuc2Zvcm1bcHJvcGVydHlOYW1lXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7IG1vZGVsOiBtb2RlbCwgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gfTtcbiAgfSxcbiAgc3Vic3RpdHV0ZXM6IGZ1bmN0aW9uIHN1YnN0aXR1dGVzKGRhdGEpIHtcbiAgICB2YXIgbW9kZWwgPSBkYXRhLm1vZGVsLFxuICAgICAgICB0cmFuc2Zvcm0gPSBkYXRhLnRyYW5zZm9ybTtcblxuXG4gICAgdmFyIHRyYW5zZm9ybUtleXMgPSBPYmplY3Qua2V5cyh0cmFuc2Zvcm0pO1xuXG4gICAgdHJhbnNmb3JtS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgIG1vZGVsW3Byb3BlcnR5TmFtZV0gPSB0cmFuc2Zvcm1bcHJvcGVydHlOYW1lXTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7IG1vZGVsOiBtb2RlbCwgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gfTtcbiAgfVxufTtcblxudmFyIHRyYW5zZm9ybU1hcHBlciA9IGZ1bmN0aW9uIHRyYW5zZm9ybU1hcHBlcihtb2RlbCwgdHJhbnNmb3JtKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG1vZGVsKSkge1xuICAgIHJldHVybiBtb2RlbC5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtTWFwcGVyKGVsLCB0cmFuc2Zvcm0pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCh0eXBlb2YgbW9kZWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG1vZGVsKSkgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBjbG9uZSh7IG1vZGVsOiBtb2RlbCwgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gfSk7XG5cbiAgT2JqZWN0LmtleXModHJhbnNmb3JtcykuZm9yRWFjaChmdW5jdGlvbiAodHJhbnNmb3JtTmFtZSkge1xuICAgIHZhciBmbiA9IHRyYW5zZm9ybXNbdHJhbnNmb3JtTmFtZV07XG5cbiAgICBkYXRhID0gZm4oZGF0YSk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhLm1vZGVsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXBwZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgdmFyIG9iaiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufTtcblxudmFyIG1hdGNoZXMgPSBmdW5jdGlvbiBtYXRjaGVzKCkge1xuICB2YXIgb2JqID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gb2JqW2tleV0gPT09IHNvdXJjZVtrZXldO1xuICB9KTtcbn07XG5cbnZhciBpZCA9IGZ1bmN0aW9uIGlkKCkge1xuICB2YXIgcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMzI7XG5cbiAgaWYgKHByZWZpeCkgcHJlZml4ID0gaWRlbnRpZmllcihwcmVmaXgpICsgJy0nO1xuXG4gIHZhciBzdHIgPSBwcmVmaXg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHN0ciArPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNikudG9TdHJpbmcoMTYpO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbnZhciBpZGVudGlmaWVyID0gZnVuY3Rpb24gaWRlbnRpZmllcigpIHtcbiAgdmFyIHZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgdmFyIGNhc2VTZW5zaXRpdmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBpZCA9IHZhbHVlLnJlcGxhY2UoL1teYS16MC05XS9naSwgJy0nKS5yZXBsYWNlKC8tezIsfS9nLCAnLScpO1xuXG4gIGlmICghY2FzZVNlbnNpdGl2ZSkgaWQgPSBpZC50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbnZhciBlc2NhcGVIdG1sID0gZnVuY3Rpb24gZXNjYXBlSHRtbCgpIHtcbiAgdmFyIHN0ciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG5cbiAgdmFyIHJlc3VsdCA9IHN0ci5yZXBsYWNlKC88L2csICcmbHQ7Jyk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgY2FwaXRhbGl6ZUZpcnN0TGV0dGVyID0gZnVuY3Rpb24gY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKCkge1xuICB2YXIgc3RyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn07XG5cbnZhciB1dGlscyA9IHtcbiAgaWQ6IGlkLCBpZGVudGlmaWVyOiBpZGVudGlmaWVyLCBtYXRjaGVzOiBtYXRjaGVzLCBjbG9uZTogY2xvbmUsIGVzY2FwZUh0bWw6IGVzY2FwZUh0bWwsIGNhcGl0YWxpemVGaXJzdExldHRlcjogY2FwaXRhbGl6ZUZpcnN0TGV0dGVyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWxzOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJhbmdlOyAvLyBDcmVhdGUgYSByYW5nZSBvYmplY3QgZm9yIGVmZmljZW50bHkgcmVuZGVyaW5nIHN0cmluZ3MgdG8gZWxlbWVudHMuXG52YXIgTlNfWEhUTUwgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5cbnZhciBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZG9jdW1lbnQ7XG5cbnZhciB0ZXN0RWwgPSBkb2MgP1xuICAgIGRvYy5ib2R5IHx8IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKSA6XG4gICAge307XG5cbi8vIEZpeGVzIDxodHRwczovL2dpdGh1Yi5jb20vcGF0cmljay1zdGVlbGUtaWRlbS9tb3JwaGRvbS9pc3N1ZXMvMzI+XG4vLyAoSUU3KyBzdXBwb3J0KSA8PUlFNyBkb2VzIG5vdCBzdXBwb3J0IGVsLmhhc0F0dHJpYnV0ZShuYW1lKVxudmFyIGFjdHVhbEhhc0F0dHJpYnV0ZU5TO1xuXG5pZiAodGVzdEVsLmhhc0F0dHJpYnV0ZU5TKSB7XG4gICAgYWN0dWFsSGFzQXR0cmlidXRlTlMgPSBmdW5jdGlvbihlbCwgbmFtZXNwYWNlVVJJLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBlbC5oYXNBdHRyaWJ1dGVOUyhuYW1lc3BhY2VVUkksIG5hbWUpO1xuICAgIH07XG59IGVsc2UgaWYgKHRlc3RFbC5oYXNBdHRyaWJ1dGUpIHtcbiAgICBhY3R1YWxIYXNBdHRyaWJ1dGVOUyA9IGZ1bmN0aW9uKGVsLCBuYW1lc3BhY2VVUkksIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZShuYW1lKTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBhY3R1YWxIYXNBdHRyaWJ1dGVOUyA9IGZ1bmN0aW9uKGVsLCBuYW1lc3BhY2VVUkksIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZU5vZGUobmFtZXNwYWNlVVJJLCBuYW1lKSAhPSBudWxsO1xuICAgIH07XG59XG5cbnZhciBoYXNBdHRyaWJ1dGVOUyA9IGFjdHVhbEhhc0F0dHJpYnV0ZU5TO1xuXG5cbmZ1bmN0aW9uIHRvRWxlbWVudChzdHIpIHtcbiAgICBpZiAoIXJhbmdlICYmIGRvYy5jcmVhdGVSYW5nZSkge1xuICAgICAgICByYW5nZSA9IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgICAgICByYW5nZS5zZWxlY3ROb2RlKGRvYy5ib2R5KTtcbiAgICB9XG5cbiAgICB2YXIgZnJhZ21lbnQ7XG4gICAgaWYgKHJhbmdlICYmIHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCkge1xuICAgICAgICBmcmFnbWVudCA9IHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChzdHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2JvZHknKTtcbiAgICAgICAgZnJhZ21lbnQuaW5uZXJIVE1MID0gc3RyO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQuY2hpbGROb2Rlc1swXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdHdvIG5vZGUncyBuYW1lcyBhcmUgdGhlIHNhbWUuXG4gKlxuICogTk9URTogV2UgZG9uJ3QgYm90aGVyIGNoZWNraW5nIGBuYW1lc3BhY2VVUklgIGJlY2F1c2UgeW91IHdpbGwgbmV2ZXIgZmluZCB0d28gSFRNTCBlbGVtZW50cyB3aXRoIHRoZSBzYW1lXG4gKiAgICAgICBub2RlTmFtZSBhbmQgZGlmZmVyZW50IG5hbWVzcGFjZSBVUklzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiIFRoZSB0YXJnZXQgZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29tcGFyZU5vZGVOYW1lcyhmcm9tRWwsIHRvRWwpIHtcbiAgICB2YXIgZnJvbU5vZGVOYW1lID0gZnJvbUVsLm5vZGVOYW1lO1xuICAgIHZhciB0b05vZGVOYW1lID0gdG9FbC5ub2RlTmFtZTtcblxuICAgIGlmIChmcm9tTm9kZU5hbWUgPT09IHRvTm9kZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRvRWwuYWN0dWFsaXplICYmXG4gICAgICAgIGZyb21Ob2RlTmFtZS5jaGFyQ29kZUF0KDApIDwgOTEgJiYgLyogZnJvbSB0YWcgbmFtZSBpcyB1cHBlciBjYXNlICovXG4gICAgICAgIHRvTm9kZU5hbWUuY2hhckNvZGVBdCgwKSA+IDkwIC8qIHRhcmdldCB0YWcgbmFtZSBpcyBsb3dlciBjYXNlICovKSB7XG4gICAgICAgIC8vIElmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBhIHZpcnR1YWwgRE9NIG5vZGUgdGhlbiB3ZSBtYXkgbmVlZCB0byBub3JtYWxpemUgdGhlIHRhZyBuYW1lXG4gICAgICAgIC8vIGJlZm9yZSBjb21wYXJpbmcuIE5vcm1hbCBIVE1MIGVsZW1lbnRzIHRoYXQgYXJlIGluIHRoZSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIlxuICAgICAgICAvLyBhcmUgY29udmVydGVkIHRvIHVwcGVyIGNhc2VcbiAgICAgICAgcmV0dXJuIGZyb21Ob2RlTmFtZSA9PT0gdG9Ob2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGVsZW1lbnQsIG9wdGlvbmFsbHkgd2l0aCBhIGtub3duIG5hbWVzcGFjZSBVUkkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGVsZW1lbnQgbmFtZSwgZS5nLiAnZGl2JyBvciAnc3ZnJ1xuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lc3BhY2VVUkldIHRoZSBlbGVtZW50J3MgbmFtZXNwYWNlIFVSSSwgaS5lLiB0aGUgdmFsdWUgb2ZcbiAqIGl0cyBgeG1sbnNgIGF0dHJpYnV0ZSBvciBpdHMgaW5mZXJyZWQgbmFtZXNwYWNlLlxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhuYW1lLCBuYW1lc3BhY2VVUkkpIHtcbiAgICByZXR1cm4gIW5hbWVzcGFjZVVSSSB8fCBuYW1lc3BhY2VVUkkgPT09IE5TX1hIVE1MID9cbiAgICAgICAgZG9jLmNyZWF0ZUVsZW1lbnQobmFtZSkgOlxuICAgICAgICBkb2MuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgbmFtZSk7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSBjaGlsZHJlbiBvZiBvbmUgRE9NIGVsZW1lbnQgdG8gYW5vdGhlciBET00gZWxlbWVudFxuICovXG5mdW5jdGlvbiBtb3ZlQ2hpbGRyZW4oZnJvbUVsLCB0b0VsKSB7XG4gICAgdmFyIGN1ckNoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgdG9FbC5hcHBlbmRDaGlsZChjdXJDaGlsZCk7XG4gICAgICAgIGN1ckNoaWxkID0gbmV4dENoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gdG9FbDtcbn1cblxuZnVuY3Rpb24gbW9ycGhBdHRycyhmcm9tTm9kZSwgdG9Ob2RlKSB7XG4gICAgdmFyIGF0dHJzID0gdG9Ob2RlLmF0dHJpYnV0ZXM7XG4gICAgdmFyIGk7XG4gICAgdmFyIGF0dHI7XG4gICAgdmFyIGF0dHJOYW1lO1xuICAgIHZhciBhdHRyTmFtZXNwYWNlVVJJO1xuICAgIHZhciBhdHRyVmFsdWU7XG4gICAgdmFyIGZyb21WYWx1ZTtcblxuICAgIGZvciAoaSA9IGF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGF0dHIgPSBhdHRyc1tpXTtcbiAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICAgIGF0dHJOYW1lc3BhY2VVUkkgPSBhdHRyLm5hbWVzcGFjZVVSSTtcbiAgICAgICAgYXR0clZhbHVlID0gYXR0ci52YWx1ZTtcblxuICAgICAgICBpZiAoYXR0ck5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLmxvY2FsTmFtZSB8fCBhdHRyTmFtZTtcbiAgICAgICAgICAgIGZyb21WYWx1ZSA9IGZyb21Ob2RlLmdldEF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKTtcblxuICAgICAgICAgICAgaWYgKGZyb21WYWx1ZSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZnJvbU5vZGUuc2V0QXR0cmlidXRlTlMoYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUsIGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcm9tVmFsdWUgPSBmcm9tTm9kZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoZnJvbVZhbHVlICE9PSBhdHRyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYW55IGV4dHJhIGF0dHJpYnV0ZXMgZm91bmQgb24gdGhlIG9yaWdpbmFsIERPTSBlbGVtZW50IHRoYXRcbiAgICAvLyB3ZXJlbid0IGZvdW5kIG9uIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICBhdHRycyA9IGZyb21Ob2RlLmF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKGkgPSBhdHRycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBhdHRyID0gYXR0cnNbaV07XG4gICAgICAgIGlmIChhdHRyLnNwZWNpZmllZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ci5uYW1lO1xuICAgICAgICAgICAgYXR0ck5hbWVzcGFjZVVSSSA9IGF0dHIubmFtZXNwYWNlVVJJO1xuXG4gICAgICAgICAgICBpZiAoYXR0ck5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ci5sb2NhbE5hbWUgfHwgYXR0ck5hbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWhhc0F0dHJpYnV0ZU5TKHRvTm9kZSwgYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21Ob2RlLnJlbW92ZUF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghaGFzQXR0cmlidXRlTlModG9Ob2RlLCBudWxsLCBhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbU5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCBuYW1lKSB7XG4gICAgaWYgKGZyb21FbFtuYW1lXSAhPT0gdG9FbFtuYW1lXSkge1xuICAgICAgICBmcm9tRWxbbmFtZV0gPSB0b0VsW25hbWVdO1xuICAgICAgICBpZiAoZnJvbUVsW25hbWVdKSB7XG4gICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgc3BlY2lhbEVsSGFuZGxlcnMgPSB7XG4gICAgLyoqXG4gICAgICogTmVlZGVkIGZvciBJRS4gQXBwYXJlbnRseSBJRSBkb2Vzbid0IHRoaW5rIHRoYXQgXCJzZWxlY3RlZFwiIGlzIGFuXG4gICAgICogYXR0cmlidXRlIHdoZW4gcmVhZGluZyBvdmVyIHRoZSBhdHRyaWJ1dGVzIHVzaW5nIHNlbGVjdEVsLmF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBPUFRJT046IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ3NlbGVjdGVkJyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgXCJ2YWx1ZVwiIGF0dHJpYnV0ZSBpcyBzcGVjaWFsIGZvciB0aGUgPGlucHV0PiBlbGVtZW50IHNpbmNlIGl0IHNldHNcbiAgICAgKiB0aGUgaW5pdGlhbCB2YWx1ZS4gQ2hhbmdpbmcgdGhlIFwidmFsdWVcIiBhdHRyaWJ1dGUgd2l0aG91dCBjaGFuZ2luZyB0aGVcbiAgICAgKiBcInZhbHVlXCIgcHJvcGVydHkgd2lsbCBoYXZlIG5vIGVmZmVjdCBzaW5jZSBpdCBpcyBvbmx5IHVzZWQgdG8gdGhlIHNldCB0aGVcbiAgICAgKiBpbml0aWFsIHZhbHVlLiAgU2ltaWxhciBmb3IgdGhlIFwiY2hlY2tlZFwiIGF0dHJpYnV0ZSwgYW5kIFwiZGlzYWJsZWRcIi5cbiAgICAgKi9cbiAgICBJTlBVVDogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCAnY2hlY2tlZCcpO1xuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ2Rpc2FibGVkJyk7XG5cbiAgICAgICAgaWYgKGZyb21FbC52YWx1ZSAhPT0gdG9FbC52YWx1ZSkge1xuICAgICAgICAgICAgZnJvbUVsLnZhbHVlID0gdG9FbC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFzQXR0cmlidXRlTlModG9FbCwgbnVsbCwgJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgVEVYVEFSRUE6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSB0b0VsLnZhbHVlO1xuICAgICAgICBpZiAoZnJvbUVsLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgZnJvbUVsLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnJvbUVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIE5lZWRlZCBmb3IgSUUuIEFwcGFyZW50bHkgSUUgc2V0cyB0aGUgcGxhY2Vob2xkZXIgYXMgdGhlXG4gICAgICAgICAgICAvLyBub2RlIHZhbHVlIGFuZCB2aXNlIHZlcnNhLiBUaGlzIGlnbm9yZXMgYW4gZW1wdHkgdXBkYXRlLlxuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSAnJyAmJiBmcm9tRWwuZmlyc3RDaGlsZC5ub2RlVmFsdWUgPT09IGZyb21FbC5wbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJvbUVsLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFNFTEVDVDogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIGlmICghaGFzQXR0cmlidXRlTlModG9FbCwgbnVsbCwgJ211bHRpcGxlJykpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB2YXIgY3VyQ2hpbGQgPSB0b0VsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZShjdXJDaGlsZCkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IGN1ckNoaWxkLm5vZGVOYW1lO1xuICAgICAgICAgICAgICAgIGlmIChub2RlTmFtZSAmJiBub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnT1BUSU9OJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQXR0cmlidXRlTlMoY3VyQ2hpbGQsIG51bGwsICdzZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJvbUVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gZGVmYXVsdEdldE5vZGVLZXkobm9kZSkge1xuICAgIHJldHVybiBub2RlLmlkO1xufVxuXG5mdW5jdGlvbiBtb3JwaGRvbUZhY3RvcnkobW9ycGhBdHRycykge1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1vcnBoZG9tKGZyb21Ob2RlLCB0b05vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRvTm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChmcm9tTm9kZS5ub2RlTmFtZSA9PT0gJyNkb2N1bWVudCcgfHwgZnJvbU5vZGUubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgICAgICAgICAgIHZhciB0b05vZGVIdG1sID0gdG9Ob2RlO1xuICAgICAgICAgICAgICAgIHRvTm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdodG1sJyk7XG4gICAgICAgICAgICAgICAgdG9Ob2RlLmlubmVySFRNTCA9IHRvTm9kZUh0bWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvTm9kZSA9IHRvRWxlbWVudCh0b05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdldE5vZGVLZXkgPSBvcHRpb25zLmdldE5vZGVLZXkgfHwgZGVmYXVsdEdldE5vZGVLZXk7XG4gICAgICAgIHZhciBvbkJlZm9yZU5vZGVBZGRlZCA9IG9wdGlvbnMub25CZWZvcmVOb2RlQWRkZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uTm9kZUFkZGVkID0gb3B0aW9ucy5vbk5vZGVBZGRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25CZWZvcmVFbFVwZGF0ZWQgPSBvcHRpb25zLm9uQmVmb3JlRWxVcGRhdGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbkVsVXBkYXRlZCA9IG9wdGlvbnMub25FbFVwZGF0ZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uQmVmb3JlTm9kZURpc2NhcmRlZCA9IG9wdGlvbnMub25CZWZvcmVOb2RlRGlzY2FyZGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbk5vZGVEaXNjYXJkZWQgPSBvcHRpb25zLm9uTm9kZURpc2NhcmRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZCA9IG9wdGlvbnMub25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZCB8fCBub29wO1xuICAgICAgICB2YXIgY2hpbGRyZW5Pbmx5ID0gb3B0aW9ucy5jaGlsZHJlbk9ubHkgPT09IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBvYmplY3QgaXMgdXNlZCBhcyBhIGxvb2t1cCB0byBxdWlja2x5IGZpbmQgYWxsIGtleWVkIGVsZW1lbnRzIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZS5cbiAgICAgICAgdmFyIGZyb21Ob2Rlc0xvb2t1cCA9IHt9O1xuICAgICAgICB2YXIga2V5ZWRSZW1vdmFsTGlzdDtcblxuICAgICAgICBmdW5jdGlvbiBhZGRLZXllZFJlbW92YWwoa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ZWRSZW1vdmFsTGlzdCkge1xuICAgICAgICAgICAgICAgIGtleWVkUmVtb3ZhbExpc3QucHVzaChrZXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXllZFJlbW92YWxMaXN0ID0gW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB3YWxrRGlzY2FyZGVkQ2hpbGROb2Rlcyhub2RlLCBza2lwS2V5ZWROb2Rlcykge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChza2lwS2V5ZWROb2RlcyAmJiAoa2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgc2tpcHBpbmcga2V5ZWQgbm9kZXMgdGhlbiB3ZSBhZGQgdGhlIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYSBsaXN0IHNvIHRoYXQgaXQgY2FuIGJlIGhhbmRsZWQgYXQgdGhlIHZlcnkgZW5kLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHJlcG9ydCB0aGUgbm9kZSBhcyBkaXNjYXJkZWQgaWYgaXQgaXMgbm90IGtleWVkLiBXZSBkbyB0aGlzIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0IHRoZSBlbmQgd2UgbG9vcCB0aHJvdWdoIGFsbCBrZXllZCBlbGVtZW50cyB0aGF0IHdlcmUgdW5tYXRjaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlbiBkaXNjYXJkIHRoZW0gaW4gb25lIGZpbmFsIHBhc3MuXG4gICAgICAgICAgICAgICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckNoaWxkLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxrRGlzY2FyZGVkQ2hpbGROb2RlcyhjdXJDaGlsZCwgc2tpcEtleWVkTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIERPTSBub2RlIG91dCBvZiB0aGUgb3JpZ2luYWwgRE9NXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gICAgICAgICAqIEBwYXJhbSAge05vZGV9IHBhcmVudE5vZGUgVGhlIG5vZGVzIHBhcmVudFxuICAgICAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBza2lwS2V5ZWROb2RlcyBJZiB0cnVlIHRoZW4gZWxlbWVudHMgd2l0aCBrZXlzIHdpbGwgYmUgc2tpcHBlZCBhbmQgbm90IGRpc2NhcmRlZC5cbiAgICAgICAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlLCBwYXJlbnROb2RlLCBza2lwS2V5ZWROb2Rlcykge1xuICAgICAgICAgICAgaWYgKG9uQmVmb3JlTm9kZURpc2NhcmRlZChub2RlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKG5vZGUpO1xuICAgICAgICAgICAgd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMobm9kZSwgc2tpcEtleWVkTm9kZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLy8gVHJlZVdhbGtlciBpbXBsZW1lbnRhdGlvbiBpcyBubyBmYXN0ZXIsIGJ1dCBrZWVwaW5nIHRoaXMgYXJvdW5kIGluIGNhc2UgdGhpcyBjaGFuZ2VzIGluIHRoZSBmdXR1cmVcbiAgICAgICAgLy8gZnVuY3Rpb24gaW5kZXhUcmVlKHJvb3QpIHtcbiAgICAgICAgLy8gICAgIHZhciB0cmVlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihcbiAgICAgICAgLy8gICAgICAgICByb290LFxuICAgICAgICAvLyAgICAgICAgIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIHZhciBlbDtcbiAgICAgICAgLy8gICAgIHdoaWxlKChlbCA9IHRyZWVXYWxrZXIubmV4dE5vZGUoKSkpIHtcbiAgICAgICAgLy8gICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShlbCk7XG4gICAgICAgIC8vICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAvLyAgICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGVsO1xuICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIC8vIE5vZGVJdGVyYXRvciBpbXBsZW1lbnRhdGlvbiBpcyBubyBmYXN0ZXIsIGJ1dCBrZWVwaW5nIHRoaXMgYXJvdW5kIGluIGNhc2UgdGhpcyBjaGFuZ2VzIGluIHRoZSBmdXR1cmVcbiAgICAgICAgLy9cbiAgICAgICAgLy8gZnVuY3Rpb24gaW5kZXhUcmVlKG5vZGUpIHtcbiAgICAgICAgLy8gICAgIHZhciBub2RlSXRlcmF0b3IgPSBkb2N1bWVudC5jcmVhdGVOb2RlSXRlcmF0b3Iobm9kZSwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQpO1xuICAgICAgICAvLyAgICAgdmFyIGVsO1xuICAgICAgICAvLyAgICAgd2hpbGUoKGVsID0gbm9kZUl0ZXJhdG9yLm5leHROb2RlKCkpKSB7XG4gICAgICAgIC8vICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoZWwpO1xuICAgICAgICAvLyAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBlbDtcbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cblxuICAgICAgICBmdW5jdGlvbiBpbmRleFRyZWUobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGN1ckNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2FsayByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgICAgICBpbmRleFRyZWUoY3VyQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXhUcmVlKGZyb21Ob2RlKTtcblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVOb2RlQWRkZWQoZWwpIHtcbiAgICAgICAgICAgIG9uTm9kZUFkZGVkKGVsKTtcblxuICAgICAgICAgICAgdmFyIGN1ckNoaWxkID0gZWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0U2libGluZyA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVubWF0Y2hlZEZyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5tYXRjaGVkRnJvbUVsICYmIGNvbXBhcmVOb2RlTmFtZXMoY3VyQ2hpbGQsIHVubWF0Y2hlZEZyb21FbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHVubWF0Y2hlZEZyb21FbCwgY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9ycGhFbCh1bm1hdGNoZWRGcm9tRWwsIGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGhhbmRsZU5vZGVBZGRlZChjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBuZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1vcnBoRWwoZnJvbUVsLCB0b0VsLCBjaGlsZHJlbk9ubHkpIHtcbiAgICAgICAgICAgIHZhciB0b0VsS2V5ID0gZ2V0Tm9kZUtleSh0b0VsKTtcbiAgICAgICAgICAgIHZhciBjdXJGcm9tTm9kZUtleTtcblxuICAgICAgICAgICAgaWYgKHRvRWxLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbiBlbGVtZW50IHdpdGggYW4gSUQgaXMgYmVpbmcgbW9ycGhlZCB0aGVuIGl0IGlzIHdpbGwgYmUgaW4gdGhlIGZpbmFsXG4gICAgICAgICAgICAgICAgLy8gRE9NIHNvIGNsZWFyIGl0IG91dCBvZiB0aGUgc2F2ZWQgZWxlbWVudHMgY29sbGVjdGlvblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBmcm9tTm9kZXNMb29rdXBbdG9FbEtleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b05vZGUuaXNTYW1lTm9kZSAmJiB0b05vZGUuaXNTYW1lTm9kZShmcm9tTm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghY2hpbGRyZW5Pbmx5KSB7XG4gICAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlRWxVcGRhdGVkKGZyb21FbCwgdG9FbCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb3JwaEF0dHJzKGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICAgICAgb25FbFVwZGF0ZWQoZnJvbUVsKTtcblxuICAgICAgICAgICAgICAgIGlmIChvbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkKGZyb21FbCwgdG9FbCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmcm9tRWwubm9kZU5hbWUgIT09ICdURVhUQVJFQScpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyVG9Ob2RlQ2hpbGQgPSB0b0VsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgdmFyIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB2YXIgY3VyVG9Ob2RlS2V5O1xuXG4gICAgICAgICAgICAgICAgdmFyIGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB2YXIgdG9OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hpbmdGcm9tRWw7XG5cbiAgICAgICAgICAgICAgICBvdXRlcjogd2hpbGUgKGN1clRvTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvTmV4dFNpYmxpbmcgPSBjdXJUb05vZGVDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlS2V5ID0gZ2V0Tm9kZUtleShjdXJUb05vZGVDaGlsZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1ckZyb21Ob2RlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVDaGlsZC5pc1NhbWVOb2RlICYmIGN1clRvTm9kZUNoaWxkLmlzU2FtZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVLZXkgPSBnZXROb2RlS2V5KGN1ckZyb21Ob2RlQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyRnJvbU5vZGVUeXBlID0gY3VyRnJvbU5vZGVDaGlsZC5ub2RlVHlwZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzQ29tcGF0aWJsZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PT0gY3VyVG9Ob2RlQ2hpbGQubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQm90aCBub2RlcyBiZWluZyBjb21wYXJlZCBhcmUgRWxlbWVudCBub2Rlc1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0YXJnZXQgbm9kZSBoYXMgYSBrZXkgc28gd2Ugd2FudCB0byBtYXRjaCBpdCB1cCB3aXRoIHRoZSBjb3JyZWN0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUtleSAhPT0gY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBlbGVtZW50IGluIHRoZSBvcmlnaW5hbCBET00gdHJlZSBkb2VzIG5vdCBoYXZlIGEgbWF0Y2hpbmcga2V5IHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgY2hlY2sgb3VyIGxvb2t1cCB0byBzZWUgaWYgdGhlcmUgaXMgYSBtYXRjaGluZyBlbGVtZW50IGluIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERPTSB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtYXRjaGluZ0Zyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtjdXJUb05vZGVLZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZyA9PT0gbWF0Y2hpbmdGcm9tRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3Igc2luZ2xlIGVsZW1lbnQgcmVtb3ZhbHMuIFRvIGF2b2lkIHJlbW92aW5nIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRE9NIG5vZGUgb3V0IG9mIHRoZSB0cmVlIChzaW5jZSB0aGF0IGNhbiBicmVhayBDU1MgdHJhbnNpdGlvbnMsIGV0Yy4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2lsbCBpbnN0ZWFkIGRpc2NhcmQgdGhlIGN1cnJlbnQgbm9kZSBhbmQgd2FpdCB1bnRpbCB0aGUgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXRlcmF0aW9uIHRvIHByb3Blcmx5IG1hdGNoIHVwIHRoZSBrZXllZCB0YXJnZXQgZWxlbWVudCB3aXRoIGl0cyBtYXRjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudCBpbiB0aGUgb3JpZ2luYWwgdHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBhIG1hdGNoaW5nIGtleWVkIGVsZW1lbnQgc29tZXdoZXJlIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExldCdzIG1vdmluZyB0aGUgb3JpZ2luYWwgRE9NIG5vZGUgaW50byB0aGUgY3VycmVudCBwb3NpdGlvbiBhbmQgbW9ycGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0LlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBXZSB1c2UgaW5zZXJ0QmVmb3JlIGluc3RlYWQgb2YgcmVwbGFjZUNoaWxkIGJlY2F1c2Ugd2Ugd2FudCB0byBnbyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYHJlbW92ZU5vZGUoKWAgZnVuY3Rpb24gZm9yIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgZGlzY2FyZGVkIHNvIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBsaWZlY3ljbGUgaG9va3MgYXJlIGNvcnJlY3RseSBpbnZva2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tRWwuaW5zZXJ0QmVmb3JlKG1hdGNoaW5nRnJvbUVsLCBjdXJGcm9tTm9kZUNoaWxkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbU5leHRTaWJsaW5nID0gY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhY3R1YWwgcmVtb3ZhbCB0byBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChjdXJGcm9tTm9kZUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIHNraXAgbmVzdGVkIGtleWVkIG5vZGVzIGZyb20gYmVpbmcgcmVtb3ZlZCBzaW5jZSB0aGVyZSBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIHN0aWxsIGEgY2hhbmNlIHRoZXkgd2lsbCBiZSBtYXRjaGVkIHVwIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBtYXRjaGluZ0Zyb21FbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBub2RlcyBhcmUgbm90IGNvbXBhdGlibGUgc2luY2UgdGhlIFwidG9cIiBub2RlIGhhcyBhIGtleSBhbmQgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgbm8gbWF0Y2hpbmcga2V5ZWQgbm9kZSBpbiB0aGUgc291cmNlIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3JpZ2luYWwgaGFzIGEga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGlzQ29tcGF0aWJsZSAhPT0gZmFsc2UgJiYgY29tcGFyZU5vZGVOYW1lcyhjdXJGcm9tTm9kZUNoaWxkLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIGNvbXBhdGlibGUgRE9NIGVsZW1lbnRzIHNvIHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgXCJmcm9tXCIgbm9kZSB0byBtYXRjaCB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFyZ2V0IERPTSBub2RlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9ycGhFbChjdXJGcm9tTm9kZUNoaWxkLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBURVhUX05PREUgfHwgY3VyRnJvbU5vZGVUeXBlID09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCb3RoIG5vZGVzIGJlaW5nIGNvbXBhcmVkIGFyZSBUZXh0IG9yIENvbW1lbnQgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2ltcGx5IHVwZGF0ZSBub2RlVmFsdWUgb24gdGhlIG9yaWdpbmFsIG5vZGUgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIHRoZSB0ZXh0IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQubm9kZVZhbHVlID0gY3VyVG9Ob2RlQ2hpbGQubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgYm90aCB0aGUgXCJ0b1wiIGNoaWxkIGFuZCB0aGUgXCJmcm9tXCIgY2hpbGQgc2luY2Ugd2UgZm91bmQgYSBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBjb21wYXRpYmxlIG1hdGNoIHNvIHJlbW92ZSB0aGUgb2xkIG5vZGUgZnJvbSB0aGUgRE9NIGFuZCBjb250aW51ZSB0cnlpbmcgdG8gZmluZCBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaCBpbiB0aGUgb3JpZ2luYWwgRE9NLiBIb3dldmVyLCB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIGZyb20gbm9kZSBpcyBub3Qga2V5ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIGl0IGlzIHBvc3NpYmxlIHRoYXQgYSBrZXllZCBub2RlIG1pZ2h0IG1hdGNoIHVwIHdpdGggYSBub2RlIHNvbWV3aGVyZSBlbHNlIGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFyZ2V0IHRyZWUgYW5kIHdlIGRvbid0IHdhbnQgdG8gZGlzY2FyZCBpdCBqdXN0IHlldCBzaW5jZSBpdCBzdGlsbCBtaWdodCBmaW5kIGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhvbWUgaW4gdGhlIGZpbmFsIERPTSB0cmVlLiBBZnRlciBldmVyeXRoaW5nIGlzIGRvbmUgd2Ugd2lsbCByZW1vdmUgYW55IGtleWVkIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGRpZG4ndCBmaW5kIGEgaG9tZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhY3R1YWwgcmVtb3ZhbCB0byBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChjdXJGcm9tTm9kZUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIHNraXAgbmVzdGVkIGtleWVkIG5vZGVzIGZyb20gYmVpbmcgcmVtb3ZlZCBzaW5jZSB0aGVyZSBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIHN0aWxsIGEgY2hhbmNlIHRoZXkgd2lsbCBiZSBtYXRjaGVkIHVwIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBnb3QgdGhpcyBmYXIgdGhlbiB3ZSBkaWQgbm90IGZpbmQgYSBjYW5kaWRhdGUgbWF0Y2ggZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG91ciBcInRvIG5vZGVcIiBhbmQgd2UgZXhoYXVzdGVkIGFsbCBvZiB0aGUgY2hpbGRyZW4gXCJmcm9tXCJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9kZXMuIFRoZXJlZm9yZSwgd2Ugd2lsbCBqdXN0IGFwcGVuZCB0aGUgY3VycmVudCBcInRvXCIgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyB0byB0aGUgZW5kXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkgJiYgKG1hdGNoaW5nRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2N1clRvTm9kZUtleV0pICYmIGNvbXBhcmVOb2RlTmFtZXMobWF0Y2hpbmdGcm9tRWwsIGN1clRvTm9kZUNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUVsLmFwcGVuZENoaWxkKG1hdGNoaW5nRnJvbUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcnBoRWwobWF0Y2hpbmdGcm9tRWwsIGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCA9IG9uQmVmb3JlTm9kZUFkZGVkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob25CZWZvcmVOb2RlQWRkZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSBvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlQ2hpbGQuYWN0dWFsaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gY3VyVG9Ob2RlQ2hpbGQuYWN0dWFsaXplKGZyb21FbC5vd25lckRvY3VtZW50IHx8IGRvYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21FbC5hcHBlbmRDaGlsZChjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTm9kZUFkZGVkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHByb2Nlc3NlZCBhbGwgb2YgdGhlIFwidG8gbm9kZXNcIi4gSWYgY3VyRnJvbU5vZGVDaGlsZCBpc1xuICAgICAgICAgICAgICAgIC8vIG5vbi1udWxsIHRoZW4gd2Ugc3RpbGwgaGF2ZSBzb21lIGZyb20gbm9kZXMgbGVmdCBvdmVyIHRoYXQgbmVlZFxuICAgICAgICAgICAgICAgIC8vIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyRnJvbU5vZGVDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tTmV4dFNpYmxpbmcgPSBjdXJGcm9tTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGN1ckZyb21Ob2RlS2V5ID0gZ2V0Tm9kZUtleShjdXJGcm9tTm9kZUNoaWxkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBub2RlIGlzIGtleWVkIGl0IG1pZ2h0IGJlIG1hdGNoZWQgdXAgbGF0ZXIgc28gd2UgZGVmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhY3R1YWwgcmVtb3ZhbCB0byBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIHNraXAgbmVzdGVkIGtleWVkIG5vZGVzIGZyb20gYmVpbmcgcmVtb3ZlZCBzaW5jZSB0aGVyZSBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgc3RpbGwgYSBjaGFuY2UgdGhleSB3aWxsIGJlIG1hdGNoZWQgdXAgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlIC8qIHNraXAga2V5ZWQgbm9kZXMgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3BlY2lhbEVsSGFuZGxlciA9IHNwZWNpYWxFbEhhbmRsZXJzW2Zyb21FbC5ub2RlTmFtZV07XG4gICAgICAgICAgICBpZiAoc3BlY2lhbEVsSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHNwZWNpYWxFbEhhbmRsZXIoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBFTkQ6IG1vcnBoRWwoLi4uKVxuXG4gICAgICAgIHZhciBtb3JwaGVkTm9kZSA9IGZyb21Ob2RlO1xuICAgICAgICB2YXIgbW9ycGhlZE5vZGVUeXBlID0gbW9ycGhlZE5vZGUubm9kZVR5cGU7XG4gICAgICAgIHZhciB0b05vZGVUeXBlID0gdG9Ob2RlLm5vZGVUeXBlO1xuXG4gICAgICAgIGlmICghY2hpbGRyZW5Pbmx5KSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgYXJlIGdpdmVuIHR3byBET00gbm9kZXMgdGhhdCBhcmUgbm90XG4gICAgICAgICAgICAvLyBjb21wYXRpYmxlIChlLmcuIDxkaXY+IC0tPiA8c3Bhbj4gb3IgPGRpdj4gLS0+IFRFWFQpXG4gICAgICAgICAgICBpZiAobW9ycGhlZE5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9Ob2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGFyZU5vZGVOYW1lcyhmcm9tTm9kZSwgdG9Ob2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGZyb21Ob2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gbW92ZUNoaWxkcmVuKGZyb21Ob2RlLCBjcmVhdGVFbGVtZW50TlModG9Ob2RlLm5vZGVOYW1lLCB0b05vZGUubmFtZXNwYWNlVVJJKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBHb2luZyBmcm9tIGFuIGVsZW1lbnQgbm9kZSB0byBhIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZSA9IHRvTm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vcnBoZWROb2RlVHlwZSA9PT0gVEVYVF9OT0RFIHx8IG1vcnBoZWROb2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7IC8vIFRleHQgb3IgY29tbWVudCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKHRvTm9kZVR5cGUgPT09IG1vcnBoZWROb2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZS5ub2RlVmFsdWUgPSB0b05vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9ycGhlZE5vZGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGV4dCBub2RlIHRvIHNvbWV0aGluZyBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gdG9Ob2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb3JwaGVkTm9kZSA9PT0gdG9Ob2RlKSB7XG4gICAgICAgICAgICAvLyBUaGUgXCJ0byBub2RlXCIgd2FzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIFwiZnJvbSBub2RlXCIgc28gd2UgaGFkIHRvXG4gICAgICAgICAgICAvLyB0b3NzIG91dCB0aGUgXCJmcm9tIG5vZGVcIiBhbmQgdXNlIHRoZSBcInRvIG5vZGVcIlxuICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGZyb21Ob2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vcnBoRWwobW9ycGhlZE5vZGUsIHRvTm9kZSwgY2hpbGRyZW5Pbmx5KTtcblxuICAgICAgICAgICAgLy8gV2Ugbm93IG5lZWQgdG8gbG9vcCBvdmVyIGFueSBrZXllZCBub2RlcyB0aGF0IG1pZ2h0IG5lZWQgdG8gYmVcbiAgICAgICAgICAgIC8vIHJlbW92ZWQuIFdlIG9ubHkgZG8gdGhlIHJlbW92YWwgaWYgd2Uga25vdyB0aGF0IHRoZSBrZXllZCBub2RlXG4gICAgICAgICAgICAvLyBuZXZlciBmb3VuZCBhIG1hdGNoLiBXaGVuIGEga2V5ZWQgbm9kZSBpcyBtYXRjaGVkIHVwIHdlIHJlbW92ZVxuICAgICAgICAgICAgLy8gaXQgb3V0IG9mIGZyb21Ob2Rlc0xvb2t1cCBhbmQgd2UgdXNlIGZyb21Ob2Rlc0xvb2t1cCB0byBkZXRlcm1pbmVcbiAgICAgICAgICAgIC8vIGlmIGEga2V5ZWQgbm9kZSBoYXMgYmVlbiBtYXRjaGVkIHVwIG9yIG5vdFxuICAgICAgICAgICAgaWYgKGtleWVkUmVtb3ZhbExpc3QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTAsIGxlbj1rZXllZFJlbW92YWxMaXN0Lmxlbmd0aDsgaTxsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxUb1JlbW92ZSA9IGZyb21Ob2Rlc0xvb2t1cFtrZXllZFJlbW92YWxMaXN0W2ldXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsVG9SZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoZWxUb1JlbW92ZSwgZWxUb1JlbW92ZS5wYXJlbnROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNoaWxkcmVuT25seSAmJiBtb3JwaGVkTm9kZSAhPT0gZnJvbU5vZGUgJiYgZnJvbU5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgaWYgKG1vcnBoZWROb2RlLmFjdHVhbGl6ZSkge1xuICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gbW9ycGhlZE5vZGUuYWN0dWFsaXplKGZyb21Ob2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGhhZCB0byBzd2FwIG91dCB0aGUgZnJvbSBub2RlIHdpdGggYSBuZXcgbm9kZSBiZWNhdXNlIHRoZSBvbGRcbiAgICAgICAgICAgIC8vIG5vZGUgd2FzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIHRhcmdldCBub2RlIHRoZW4gd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgb2xkIERPTSBub2RlIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZS4gVGhpcyBpcyBvbmx5XG4gICAgICAgICAgICAvLyBwb3NzaWJsZSBpZiB0aGUgb3JpZ2luYWwgRE9NIG5vZGUgd2FzIHBhcnQgb2YgYSBET00gdHJlZSB3aGljaFxuICAgICAgICAgICAgLy8gd2Uga25vdyBpcyB0aGUgY2FzZSBpZiBpdCBoYXMgYSBwYXJlbnQgbm9kZS5cbiAgICAgICAgICAgIGZyb21Ob2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG1vcnBoZWROb2RlLCBmcm9tTm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9ycGhlZE5vZGU7XG4gICAgfTtcbn1cblxudmFyIG1vcnBoZG9tID0gbW9ycGhkb21GYWN0b3J5KG1vcnBoQXR0cnMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1vcnBoZG9tO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmFsaWRhdG9yID0gcmVxdWlyZSgnbXR5cGUtdHY0Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdtb2p1bGUtdXRpbHMnKTtcbnZhciBzY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYScpO1xuXG52YXIgaWQgPSB1dGlscy5pZDtcblxuXG52YXIgdmFsaWRhdG9yID0gVmFsaWRhdG9yKHNjaGVtYSk7XG52YXIgdCA9IFZhbGlkYXRvci5tdHlwZSh2YWxpZGF0b3IpO1xuXG52YXIgRW50aXR5Tm9kZVZhbHVlID0gZnVuY3Rpb24gRW50aXR5Tm9kZVZhbHVlKCkge1xuICB2YXIgbm9kZVR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdlbnRpdHlOb2RlJztcbiAgdmFyIGFkZGl0aW9uYWxWYWx1ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIHZhciB2YWx1ZSA9IE9iamVjdC5hc3NpZ24oeyBub2RlVHlwZTogbm9kZVR5cGUgfSwgYWRkaXRpb25hbFZhbHVlcyk7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZS5faWQgIT09ICdzdHJpbmcnKSB2YWx1ZS5faWQgPSBpZCh2YWx1ZS5ub2RlVHlwZSk7XG5cbiAgaWYgKCF0LmlzKHZhbHVlLCAnZW50aXR5Tm9kZVZhbHVlJykpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgYW4gZW50aXR5Tm9kZVZhbHVlIHdpdGggdGhvc2UgYXJndW1lbnRzJyk7XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIEVudGl0eU5vZGUgPSBmdW5jdGlvbiBFbnRpdHlOb2RlKCkge1xuICB2YXIgbm9kZVR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdlbnRpdHlOb2RlJztcbiAgdmFyIGFkZGl0aW9uYWxWYWx1ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIHZhciB2YWx1ZSA9IEVudGl0eU5vZGVWYWx1ZShub2RlVHlwZSwgYWRkaXRpb25hbFZhbHVlcyk7XG4gIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgY2hpbGRyZW46IGNoaWxkcmVuIH07XG59O1xuXG5FbnRpdHlOb2RlLlZhbHVlID0gRW50aXR5Tm9kZVZhbHVlO1xuRW50aXR5Tm9kZS5tdHlwZSA9IHQ7XG5cbm1vZHVsZS5leHBvcnRzID0gRW50aXR5Tm9kZTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbnRpdHlOb2RlID0gcmVxdWlyZSgnLi4vc2NoZW1hL2VudGl0eU5vZGUuc2NoZW1hLmpzb24nKTtcbnZhciBlbnRpdHlOb2RlVmFsdWUgPSByZXF1aXJlKCcuLi9zY2hlbWEvZW50aXR5Tm9kZVZhbHVlLnNjaGVtYS5qc29uJyk7XG52YXIgZW1wdHlOb2RlID0gcmVxdWlyZSgnLi4vc2NoZW1hL2VtcHR5Tm9kZS5zY2hlbWEuanNvbicpO1xudmFyIHBhcmVudE5vZGUgPSByZXF1aXJlKCcuLi9zY2hlbWEvcGFyZW50Tm9kZS5zY2hlbWEuanNvbicpO1xuXG52YXIgc2NoZW1hID0ge1xuICBlbnRpdHlOb2RlOiBlbnRpdHlOb2RlLCBlbnRpdHlOb2RlVmFsdWU6IGVudGl0eU5vZGVWYWx1ZSwgZW1wdHlOb2RlOiBlbXB0eU5vZGUsIHBhcmVudE5vZGU6IHBhcmVudE5vZGVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc2NoZW1hOyIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJpZFwiOiBcImVtcHR5Tm9kZVwiLFxuICBcImFsbE9mXCI6IFtcbiAgICB7IFwiJHJlZlwiOiBcImVudGl0eU5vZGVcIiB9LFxuICAgIHtcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwidmFsdWVcIjogeyBcIiRyZWZcIjogXCJlbnRpdHlOb2RlVmFsdWVcIiB9LFxuICAgICAgICBcImNoaWxkcmVuXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICAgIFwibWF4TGVuZ3RoXCI6IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcImlkXCI6IFwiZW50aXR5Tm9kZVwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcInZhbHVlXCI6IHsgXCIkcmVmXCI6IFwiZW50aXR5Tm9kZVZhbHVlXCIgfVxuICB9LFxuICBcInJlcXVpcmVkXCI6IFsgXCJ2YWx1ZVwiIF1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJpZFwiOiBcImVudGl0eU5vZGVWYWx1ZVwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcIl9pZFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwibWluTGVuZ3RoXCI6IDFcbiAgICB9LFxuICAgIFwibm9kZVR5cGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcIm1pbkxlbmd0aFwiOiAxXG4gICAgfVxuICB9LFxuICBcInJlcXVpcmVkXCI6IFsgXCJfaWRcIiwgXCJub2RlVHlwZVwiIF1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJpZFwiOiBcInBhcmVudE5vZGVcIixcbiAgXCJhbGxPZlwiOiBbXG4gICAgeyBcIiRyZWZcIjogXCJlbnRpdHlOb2RlXCIgfSxcbiAgICB7XG4gICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICBcImNoaWxkcmVuXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICAgIFwiaXRlbXNcIjogeyBcIiRyZWZcIjogXCJlbnRpdHlOb2RlXCIgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlZFwiOiBbIFwiY2hpbGRyZW5cIiBdXG4gICAgfVxuICBdXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0djQgPSByZXF1aXJlKCd0djQnKTtcbnZhciBUID0gcmVxdWlyZSgnbXR5cGUnKTtcblxudmFyIFZhbGlkYXRvciA9IGZ1bmN0aW9uIFZhbGlkYXRvcigpIHtcbiAgdmFyIHNjaGVtYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgdmFyIHZhbGlkYXRvciA9IHR2NC5mcmVzaEFwaSgpO1xuXG4gIHZhciBzY2hlbWFzID0gT2JqZWN0LmtleXMoc2NoZW1hKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gc2NoZW1hW25hbWVdO1xuICB9KTtcblxuICBzY2hlbWFzLmZvckVhY2goZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgIHJldHVybiB2YWxpZGF0b3IuYWRkU2NoZW1hKHNjaGVtYSk7XG4gIH0pO1xuXG4gIHJldHVybiB2YWxpZGF0b3I7XG59O1xuXG5WYWxpZGF0b3IubXR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2YWxpZGF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFZhbGlkYXRvcigpO1xuXG4gIHZhciBzY2hlbWFOYW1lcyA9IHZhbGlkYXRvci5nZXRTY2hlbWFVcmlzKCk7XG5cbiAgdmFyIGlzID0gc2NoZW1hTmFtZXMucmVkdWNlKGZ1bmN0aW9uIChtYXAsIG5hbWUpIHtcbiAgICBtYXBbbmFtZV0gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdmFsaWRhdG9yLnZhbGlkYXRlKG9iaiwgbmFtZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBtYXA7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gVChpcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRvcjsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBqc29uUHJlZGljYXRlcyA9IHJlcXVpcmUoJy4vanNvbi1wcmVkaWNhdGVzJyk7XG5cbnZhciBtdHlwZSA9IGZ1bmN0aW9uIG10eXBlKHR5cGVQcmVkaWNhdGVzKSB7XG4gIHR5cGVQcmVkaWNhdGVzID0gdHlwZVByZWRpY2F0ZXMgfHwganNvblByZWRpY2F0ZXM7XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0eXBlUHJlZGljYXRlcyk7XG5cbiAgdmFyIGlzID0gZnVuY3Rpb24gaXMoc3ViamVjdCwgdHlwZW5hbWUpIHtcbiAgICByZXR1cm4gdHlwZVByZWRpY2F0ZXNbdHlwZW5hbWVdICYmIHR5cGVQcmVkaWNhdGVzW3R5cGVuYW1lXShzdWJqZWN0KTtcbiAgfTtcblxuICB2YXIgaXNPbmx5ID0gZnVuY3Rpb24gaXNPbmx5KHN1YmplY3QsIHR5cGVuYW1lKSB7XG4gICAgcmV0dXJuIGlzKHN1YmplY3QsIHR5cGVuYW1lKSAmJiBhbGxPZihzdWJqZWN0KS5sZW5ndGggPT09IDE7XG4gIH07XG5cbiAgdmFyIHNvbWUgPSBmdW5jdGlvbiBzb21lKHN1YmplY3QpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZW5hbWVzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgdHlwZW5hbWVzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZW5hbWVzLnNvbWUoZnVuY3Rpb24gKHR5cGVuYW1lKSB7XG4gICAgICByZXR1cm4gaXMoc3ViamVjdCwgdHlwZW5hbWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBldmVyeSA9IGZ1bmN0aW9uIGV2ZXJ5KHN1YmplY3QpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVuYW1lcyA9IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIHR5cGVuYW1lc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZW5hbWVzLmV2ZXJ5KGZ1bmN0aW9uICh0eXBlbmFtZSkge1xuICAgICAgcmV0dXJuIGlzKHN1YmplY3QsIHR5cGVuYW1lKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgb2YgPSBmdW5jdGlvbiBvZihzdWJqZWN0KSB7XG4gICAgcmV0dXJuIGtleXMuZmluZChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gaXMoc3ViamVjdCwga2V5KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgYWxsT2YgPSBmdW5jdGlvbiBhbGxPZihzdWJqZWN0KSB7XG4gICAgcmV0dXJuIGtleXMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBpcyhzdWJqZWN0LCBrZXkpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciB0eXBlcyA9IGZ1bmN0aW9uIHR5cGVzKCkge1xuICAgIHJldHVybiBrZXlzLnNsaWNlKCk7XG4gIH07XG5cbiAgcmV0dXJuIHsgaXM6IGlzLCBpc09ubHk6IGlzT25seSwgc29tZTogc29tZSwgZXZlcnk6IGV2ZXJ5LCBvZjogb2YsIGFsbE9mOiBhbGxPZiwgdHlwZXM6IHR5cGVzIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG10eXBlOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIganNvblByZWRpY2F0ZXMgPSB7XG4gIG51bWJlcjogZnVuY3Rpb24gbnVtYmVyKHN1YmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHN1YmplY3QpO1xuICB9LFxuICBzdHJpbmc6IGZ1bmN0aW9uIHN0cmluZyhzdWJqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAnc3RyaW5nJztcbiAgfSxcbiAgYm9vbGVhbjogZnVuY3Rpb24gYm9vbGVhbihzdWJqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAnYm9vbGVhbic7XG4gIH0sXG4gIGFycmF5OiBmdW5jdGlvbiBhcnJheShzdWJqZWN0KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3ViamVjdCk7XG4gIH0sXG4gIG51bGw6IGZ1bmN0aW9uIF9udWxsKHN1YmplY3QpIHtcbiAgICByZXR1cm4gc3ViamVjdCA9PT0gbnVsbDtcbiAgfSxcbiAgb2JqZWN0OiBmdW5jdGlvbiBvYmplY3Qoc3ViamVjdCkge1xuICAgIHJldHVybiAodHlwZW9mIHN1YmplY3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHN1YmplY3QpKSA9PT0gJ29iamVjdCcgJiYgIWpzb25QcmVkaWNhdGVzLm51bGwoc3ViamVjdCkgJiYgIWpzb25QcmVkaWNhdGVzLmFycmF5KHN1YmplY3QpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGpzb25QcmVkaWNhdGVzOyIsIm1vZHVsZS5leHBvcnRzID0gY29tcGlsZTtcblxudmFyIEJhc2VGdW5jcyA9IHJlcXVpcmUoXCJib29sYmFzZVwiKSxcbiAgICB0cnVlRnVuYyAgPSBCYXNlRnVuY3MudHJ1ZUZ1bmMsXG4gICAgZmFsc2VGdW5jID0gQmFzZUZ1bmNzLmZhbHNlRnVuYztcblxuLypcblx0cmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGFuIGVsZW1lbnRzIGluZGV4IG1hdGNoZXMgdGhlIGdpdmVuIHJ1bGVcblx0aGlnaGx5IG9wdGltaXplZCB0byByZXR1cm4gdGhlIGZhc3Rlc3Qgc29sdXRpb25cbiovXG5mdW5jdGlvbiBjb21waWxlKHBhcnNlZCl7XG5cdHZhciBhID0gcGFyc2VkWzBdLFxuXHQgICAgYiA9IHBhcnNlZFsxXSAtIDE7XG5cblx0Ly93aGVuIGIgPD0gMCwgYSpuIHdvbid0IGJlIHBvc3NpYmxlIGZvciBhbnkgbWF0Y2hlcyB3aGVuIGEgPCAwXG5cdC8vYmVzaWRlcywgdGhlIHNwZWNpZmljYXRpb24gc2F5cyB0aGF0IG5vIGVsZW1lbnQgaXMgbWF0Y2hlZCB3aGVuIGEgYW5kIGIgYXJlIDBcblx0aWYoYiA8IDAgJiYgYSA8PSAwKSByZXR1cm4gZmFsc2VGdW5jO1xuXG5cdC8vd2hlbiBhIGlzIGluIHRoZSByYW5nZSAtMS4uMSwgaXQgbWF0Y2hlcyBhbnkgZWxlbWVudCAoc28gb25seSBiIGlzIGNoZWNrZWQpXG5cdGlmKGEgPT09LTEpIHJldHVybiBmdW5jdGlvbihwb3MpeyByZXR1cm4gcG9zIDw9IGI7IH07XG5cdGlmKGEgPT09IDApIHJldHVybiBmdW5jdGlvbihwb3MpeyByZXR1cm4gcG9zID09PSBiOyB9O1xuXHQvL3doZW4gYiA8PSAwIGFuZCBhID09PSAxLCB0aGV5IG1hdGNoIGFueSBlbGVtZW50XG5cdGlmKGEgPT09IDEpIHJldHVybiBiIDwgMCA/IHRydWVGdW5jIDogZnVuY3Rpb24ocG9zKXsgcmV0dXJuIHBvcyA+PSBiOyB9O1xuXG5cdC8vd2hlbiBhID4gMCwgbW9kdWxvIGNhbiBiZSB1c2VkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIGEgbWF0Y2hcblx0dmFyIGJNb2QgPSBiICUgYTtcblx0aWYoYk1vZCA8IDApIGJNb2QgKz0gYTtcblxuXHRpZihhID4gMSl7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHBvcyl7XG5cdFx0XHRyZXR1cm4gcG9zID49IGIgJiYgcG9zICUgYSA9PT0gYk1vZDtcblx0XHR9O1xuXHR9XG5cblx0YSAqPSAtMTsgLy9tYWtlIGBhYCBwb3NpdGl2ZVxuXG5cdHJldHVybiBmdW5jdGlvbihwb3Mpe1xuXHRcdHJldHVybiBwb3MgPD0gYiAmJiBwb3MgJSBhID09PSBiTW9kO1xuXHR9O1xufSIsInZhciBwYXJzZSA9IHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpLFxuICAgIGNvbXBpbGUgPSByZXF1aXJlKFwiLi9jb21waWxlLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG50aENoZWNrKGZvcm11bGEpe1xuXHRyZXR1cm4gY29tcGlsZShwYXJzZShmb3JtdWxhKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xubW9kdWxlLmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGU7IiwibW9kdWxlLmV4cG9ydHMgPSBwYXJzZTtcblxuLy9mb2xsb3dpbmcgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI250aC1jaGlsZC1wc2V1ZG9cblxuLy9bIFsnLSd8JysnXT8gSU5URUdFUj8ge059IFsgUyogWyctJ3wnKyddIFMqIElOVEVHRVIgXT9cbnZhciByZV9udGhFbGVtZW50ID0gL14oWytcXC1dP1xcZCpuKT9cXHMqKD86KFsrXFwtXT8pXFxzKihcXGQrKSk/JC87XG5cbi8qXG5cdHBhcnNlcyBhIG50aC1jaGVjayBmb3JtdWxhLCByZXR1cm5zIGFuIGFycmF5IG9mIHR3byBudW1iZXJzXG4qL1xuZnVuY3Rpb24gcGFyc2UoZm9ybXVsYSl7XG5cdGZvcm11bGEgPSBmb3JtdWxhLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG5cdGlmKGZvcm11bGEgPT09IFwiZXZlblwiKXtcblx0XHRyZXR1cm4gWzIsIDBdO1xuXHR9IGVsc2UgaWYoZm9ybXVsYSA9PT0gXCJvZGRcIil7XG5cdFx0cmV0dXJuIFsyLCAxXTtcblx0fSBlbHNlIHtcblx0XHR2YXIgcGFyc2VkID0gZm9ybXVsYS5tYXRjaChyZV9udGhFbGVtZW50KTtcblxuXHRcdGlmKCFwYXJzZWQpe1xuXHRcdFx0dGhyb3cgbmV3IFN5bnRheEVycm9yKFwibi10aCBydWxlIGNvdWxkbid0IGJlIHBhcnNlZCAoJ1wiICsgZm9ybXVsYSArIFwiJylcIik7XG5cdFx0fVxuXG5cdFx0dmFyIGE7XG5cblx0XHRpZihwYXJzZWRbMV0pe1xuXHRcdFx0YSA9IHBhcnNlSW50KHBhcnNlZFsxXSwgMTApO1xuXHRcdFx0aWYoaXNOYU4oYSkpe1xuXHRcdFx0XHRpZihwYXJzZWRbMV0uY2hhckF0KDApID09PSBcIi1cIikgYSA9IC0xO1xuXHRcdFx0XHRlbHNlIGEgPSAxO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBhID0gMDtcblxuXHRcdHJldHVybiBbXG5cdFx0XHRhLFxuXHRcdFx0cGFyc2VkWzNdID8gcGFyc2VJbnQoKHBhcnNlZFsyXSB8fCBcIlwiKSArIHBhcnNlZFszXSwgMTApIDogMFxuXHRcdF07XG5cdH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKCFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBuZXh0VGljaztcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5uZXh0VGljaztcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCIpXG4iLCIvLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbnZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHByb2Nlc3NOZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufSIsIi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW07XG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIFN0cmVhbSA9IHJlcXVpcmUoJ3N0JyArICdyZWFtJyk7XG4gIH0gY2F0Y2ggKF8pIHt9IGZpbmFsbHkge1xuICAgIGlmICghU3RyZWFtKSBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4gIH1cbn0pKCk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYnVmZmVyU2hpbSA9IHJlcXVpcmUoJ2J1ZmZlci1zaGltcycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAgIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAgIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gICAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfiB+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gYnVmZmVyU2hpbS5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgX2UgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBfZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBza2lwQWRkO1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgIHNraXBBZGQgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBjaHVuay5sZW5ndGggPT09IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICghYWRkVG9Gcm9udCkgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyBEb24ndCBhZGQgdG8gdGhlIGJ1ZmZlciBpZiB3ZSd2ZSBkZWNvZGVkIHRvIGFuIGVtcHR5IHN0cmluZyBjaHVuayBhbmRcbiAgICAgIC8vIHdlJ3JlIG5vdCBpbiBvYmplY3QgbW9kZVxuICAgICAgaWYgKCFza2lwQWRkKSB7XG4gICAgICAgIC8vIGlmIHdlIHdhbnQgdGhlIGRhdGEgbm93LCBqdXN0IGVtaXQgaXQuXG4gICAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICAgIHN0cmVhbS5yZWFkKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwcm9jZXNzTmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwcm9jZXNzTmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzc05leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbiAoZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IGJ1ZmZlclNoaW0uYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwiLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbiAgdGhpcy53cml0ZWVuY29kaW5nID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKTtcblxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoc3RyZWFtLCBlciwgZGF0YSk7XG4gICAgfSk7ZWxzZSBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwcm9jZXNzTmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbTtcbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbiAgfSBjYXRjaCAoXykge30gZmluYWxseSB7XG4gICAgaWYgKCFTdHJlYW0pIFN0cmVhbSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiAgfVxufSkoKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH4gfnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcbiAgLy8gQWx3YXlzIHRocm93IGVycm9yIGlmIGEgbnVsbCBpcyB3cml0dGVuXG4gIC8vIGlmIHdlIGFyZSBub3QgaW4gb2JqZWN0IG1vZGUgdGhlbiB0aHJvd1xuICAvLyBpZiBpdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgb3IgdW5kZWZpbmVkLlxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IGJ1ZmZlclNoaW0uZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG4gIGlmIChzeW5jKSBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtlbHNlIGNiKGVyKTtcblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3NOZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdmFyIGVudHJ5ID0gX3RoaXMuZW50cnk7XG4gICAgX3RoaXMuZW50cnkgPSBudWxsO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgIGNiKGVycik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gX3RoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IF90aGlzO1xuICAgIH1cbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGJ1ZmZlclNoaW0gPSByZXF1aXJlKCdidWZmZXItc2hpbXMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3Q7XG5cbmZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gIHRoaXMuaGVhZCA9IG51bGw7XG4gIHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gIHRoaXMudGFpbCA9IGVudHJ5O1xuICArK3RoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gIHRoaXMuaGVhZCA9IGVudHJ5O1xuICArK3RoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAtLXRoaXMubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAocykge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgfXJldHVybiByZXQ7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAobikge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBidWZmZXJTaGltLmFsbG9jKDApO1xuICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgdmFyIHJldCA9IGJ1ZmZlclNoaW0uYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gIHZhciBwID0gdGhpcy5oZWFkO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChwKSB7XG4gICAgcC5kYXRhLmNvcHkocmV0LCBpKTtcbiAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuICByZXR1cm4gcmV0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpXG4iLCJ2YXIgU3RyZWFtID0gKGZ1bmN0aW9uICgpe1xuICB0cnkge1xuICAgIHJldHVybiByZXF1aXJlKCdzdCcgKyAncmVhbScpOyAvLyBoYWNrIHRvIGZpeCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgaXNzdWUgd2hlbiB1c2VkIHdpdGggYnJvd3NlcmlmeVxuICB9IGNhdGNoKF8pe31cbn0oKSk7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IFN0cmVhbSB8fCBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcblxuaWYgKCFwcm9jZXNzLmJyb3dzZXIgJiYgcHJvY2Vzcy5lbnYuUkVBREFCTEVfU1RSRUFNID09PSAnZGlzYWJsZScgJiYgU3RyZWFtKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcIilcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcIilcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcbi8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4vL1xuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXG4vLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIDAsIGF2YWlsYWJsZSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhclN0cjtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgYW5kIHNldCBjaGFyTGVuZ3RoIC8gY2hhclJlY2VpdmVkXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcbi8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG59XG4iLCJ2YXIgc2kgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nLCB0aWNrO1xuaWYgKHNpKSB7XG4gIHRpY2sgPSBmdW5jdGlvbiAoZm4pIHsgc2V0SW1tZWRpYXRlKGZuKTsgfTtcbn0gZWxzZSB7XG4gIHRpY2sgPSBmdW5jdGlvbiAoZm4pIHsgc2V0VGltZW91dChmbiwgMCk7IH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGljazsiLCIvKlxuQXV0aG9yOiBHZXJhaW50IEx1ZmYgYW5kIG90aGVyc1xuWWVhcjogMjAxM1xuXG5UaGlzIGNvZGUgaXMgcmVsZWFzZWQgaW50byB0aGUgXCJwdWJsaWMgZG9tYWluXCIgYnkgaXRzIGF1dGhvcihzKS4gIEFueWJvZHkgbWF5IHVzZSwgYWx0ZXIgYW5kIGRpc3RyaWJ1dGUgdGhlIGNvZGUgd2l0aG91dCByZXN0cmljdGlvbi4gIFRoZSBhdXRob3IgbWFrZXMgbm8gZ3VhcmFudGVlcywgYW5kIHRha2VzIG5vIGxpYWJpbGl0eSBvZiBhbnkga2luZCBmb3IgdXNlIG9mIHRoaXMgY29kZS5cblxuSWYgeW91IGZpbmQgYSBidWcgb3IgbWFrZSBhbiBpbXByb3ZlbWVudCwgaXQgd291bGQgYmUgY291cnRlb3VzIHRvIGxldCB0aGUgYXV0aG9yIGtub3csIGJ1dCBpdCBpcyBub3QgY29tcHVsc29yeS5cbiovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpe1xuICAgIC8vIENvbW1vbkpTLiBEZWZpbmUgZXhwb3J0LlxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgIGdsb2JhbC50djQgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3Qva2V5cz9yZWRpcmVjdGxvY2FsZT1lbi1VUyZyZWRpcmVjdHNsdWc9SmF2YVNjcmlwdCUyRlJlZmVyZW5jZSUyRkdsb2JhbF9PYmplY3RzJTJGT2JqZWN0JTJGa2V5c1xuaWYgKCFPYmplY3Qua2V5cykge1xuXHRPYmplY3Qua2V5cyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcblx0XHRcdGhhc0RvbnRFbnVtQnVnID0gISh7dG9TdHJpbmc6IG51bGx9KS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKSxcblx0XHRcdGRvbnRFbnVtcyA9IFtcblx0XHRcdFx0J3RvU3RyaW5nJyxcblx0XHRcdFx0J3RvTG9jYWxlU3RyaW5nJyxcblx0XHRcdFx0J3ZhbHVlT2YnLFxuXHRcdFx0XHQnaGFzT3duUHJvcGVydHknLFxuXHRcdFx0XHQnaXNQcm90b3R5cGVPZicsXG5cdFx0XHRcdCdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG5cdFx0XHRcdCdjb25zdHJ1Y3Rvcidcblx0XHRcdF0sXG5cdFx0XHRkb250RW51bXNMZW5ndGggPSBkb250RW51bXMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nIHx8IG9iaiA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gbm9uLW9iamVjdCcpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cblx0XHRcdGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG5cdFx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaChwcm9wKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaGFzRG9udEVudW1CdWcpIHtcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpIDwgZG9udEVudW1zTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGRvbnRFbnVtc1tpXSkpIHtcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKGRvbnRFbnVtc1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdH0pKCk7XG59XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlXG5pZiAoIU9iamVjdC5jcmVhdGUpIHtcblx0T2JqZWN0LmNyZWF0ZSA9IChmdW5jdGlvbigpe1xuXHRcdGZ1bmN0aW9uIEYoKXt9XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24obyl7XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ09iamVjdC5jcmVhdGUgaW1wbGVtZW50YXRpb24gb25seSBhY2NlcHRzIG9uZSBwYXJhbWV0ZXIuJyk7XG5cdFx0XHR9XG5cdFx0XHRGLnByb3RvdHlwZSA9IG87XG5cdFx0XHRyZXR1cm4gbmV3IEYoKTtcblx0XHR9O1xuXHR9KSgpO1xufVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheT9yZWRpcmVjdGxvY2FsZT1lbi1VUyZyZWRpcmVjdHNsdWc9SmF2YVNjcmlwdCUyRlJlZmVyZW5jZSUyRkdsb2JhbF9PYmplY3RzJTJGQXJyYXklMkZpc0FycmF5XG5pZighQXJyYXkuaXNBcnJheSkge1xuXHRBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24gKHZBcmcpIHtcblx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZBcmcpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG5cdH07XG59XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mP3JlZGlyZWN0bG9jYWxlPWVuLVVTJnJlZGlyZWN0c2x1Zz1KYXZhU2NyaXB0JTJGUmVmZXJlbmNlJTJGR2xvYmFsX09iamVjdHMlMkZBcnJheSUyRmluZGV4T2ZcbmlmICghQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcblx0QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovICkge1xuXHRcdGlmICh0aGlzID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cdFx0fVxuXHRcdHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuXHRcdHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuXHRcdGlmIChsZW4gPT09IDApIHtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9XG5cdFx0dmFyIG4gPSAwO1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0biA9IE51bWJlcihhcmd1bWVudHNbMV0pO1xuXHRcdFx0aWYgKG4gIT09IG4pIHsgLy8gc2hvcnRjdXQgZm9yIHZlcmlmeWluZyBpZiBpdCdzIE5hTlxuXHRcdFx0XHRuID0gMDtcblx0XHRcdH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSBJbmZpbml0eSAmJiBuICE9PSAtSW5maW5pdHkpIHtcblx0XHRcdFx0biA9IChuID4gMCB8fCAtMSkgKiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG4gPj0gbGVuKSB7XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fVxuXHRcdHZhciBrID0gbiA+PSAwID8gbiA6IE1hdGgubWF4KGxlbiAtIE1hdGguYWJzKG4pLCAwKTtcblx0XHRmb3IgKDsgayA8IGxlbjsgaysrKSB7XG5cdFx0XHRpZiAoayBpbiB0ICYmIHRba10gPT09IHNlYXJjaEVsZW1lbnQpIHtcblx0XHRcdFx0cmV0dXJuIGs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fTtcbn1cblxuLy8gR3J1bmdleSBPYmplY3QuaXNGcm96ZW4gaGFja1xuaWYgKCFPYmplY3QuaXNGcm96ZW4pIHtcblx0T2JqZWN0LmlzRnJvemVuID0gZnVuY3Rpb24gKG9iaikge1xuXHRcdHZhciBrZXkgPSBcInR2NF90ZXN0X2Zyb3plbl9rZXlcIjtcblx0XHR3aGlsZSAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdGtleSArPSBNYXRoLnJhbmRvbSgpO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0b2JqW2tleV0gPSB0cnVlO1xuXHRcdFx0ZGVsZXRlIG9ialtrZXldO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fTtcbn1cbi8vIEJhc2VkIG9uOiBodHRwczovL2dpdGh1Yi5jb20vZ2VyYWludGx1ZmYvdXJpLXRlbXBsYXRlcywgYnV0IHdpdGggYWxsIHRoZSBkZS1zdWJzdGl0dXRpb24gc3R1ZmYgcmVtb3ZlZFxuXG52YXIgdXJpVGVtcGxhdGVHbG9iYWxNb2RpZmllcnMgPSB7XG5cdFwiK1wiOiB0cnVlLFxuXHRcIiNcIjogdHJ1ZSxcblx0XCIuXCI6IHRydWUsXG5cdFwiL1wiOiB0cnVlLFxuXHRcIjtcIjogdHJ1ZSxcblx0XCI/XCI6IHRydWUsXG5cdFwiJlwiOiB0cnVlXG59O1xudmFyIHVyaVRlbXBsYXRlU3VmZmljZXMgPSB7XG5cdFwiKlwiOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBub3RSZWFsbHlQZXJjZW50RW5jb2RlKHN0cmluZykge1xuXHRyZXR1cm4gZW5jb2RlVVJJKHN0cmluZykucmVwbGFjZSgvJTI1WzAtOV1bMC05XS9nLCBmdW5jdGlvbiAoZG91YmxlRW5jb2RlZCkge1xuXHRcdHJldHVybiBcIiVcIiArIGRvdWJsZUVuY29kZWQuc3Vic3RyaW5nKDMpO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gdXJpVGVtcGxhdGVTdWJzdGl0dXRpb24oc3BlYykge1xuXHR2YXIgbW9kaWZpZXIgPSBcIlwiO1xuXHRpZiAodXJpVGVtcGxhdGVHbG9iYWxNb2RpZmllcnNbc3BlYy5jaGFyQXQoMCldKSB7XG5cdFx0bW9kaWZpZXIgPSBzcGVjLmNoYXJBdCgwKTtcblx0XHRzcGVjID0gc3BlYy5zdWJzdHJpbmcoMSk7XG5cdH1cblx0dmFyIHNlcGFyYXRvciA9IFwiXCI7XG5cdHZhciBwcmVmaXggPSBcIlwiO1xuXHR2YXIgc2hvdWxkRXNjYXBlID0gdHJ1ZTtcblx0dmFyIHNob3dWYXJpYWJsZXMgPSBmYWxzZTtcblx0dmFyIHRyaW1FbXB0eVN0cmluZyA9IGZhbHNlO1xuXHRpZiAobW9kaWZpZXIgPT09ICcrJykge1xuXHRcdHNob3VsZEVzY2FwZSA9IGZhbHNlO1xuXHR9IGVsc2UgaWYgKG1vZGlmaWVyID09PSBcIi5cIikge1xuXHRcdHByZWZpeCA9IFwiLlwiO1xuXHRcdHNlcGFyYXRvciA9IFwiLlwiO1xuXHR9IGVsc2UgaWYgKG1vZGlmaWVyID09PSBcIi9cIikge1xuXHRcdHByZWZpeCA9IFwiL1wiO1xuXHRcdHNlcGFyYXRvciA9IFwiL1wiO1xuXHR9IGVsc2UgaWYgKG1vZGlmaWVyID09PSAnIycpIHtcblx0XHRwcmVmaXggPSBcIiNcIjtcblx0XHRzaG91bGRFc2NhcGUgPSBmYWxzZTtcblx0fSBlbHNlIGlmIChtb2RpZmllciA9PT0gJzsnKSB7XG5cdFx0cHJlZml4ID0gXCI7XCI7XG5cdFx0c2VwYXJhdG9yID0gXCI7XCI7XG5cdFx0c2hvd1ZhcmlhYmxlcyA9IHRydWU7XG5cdFx0dHJpbUVtcHR5U3RyaW5nID0gdHJ1ZTtcblx0fSBlbHNlIGlmIChtb2RpZmllciA9PT0gJz8nKSB7XG5cdFx0cHJlZml4ID0gXCI/XCI7XG5cdFx0c2VwYXJhdG9yID0gXCImXCI7XG5cdFx0c2hvd1ZhcmlhYmxlcyA9IHRydWU7XG5cdH0gZWxzZSBpZiAobW9kaWZpZXIgPT09ICcmJykge1xuXHRcdHByZWZpeCA9IFwiJlwiO1xuXHRcdHNlcGFyYXRvciA9IFwiJlwiO1xuXHRcdHNob3dWYXJpYWJsZXMgPSB0cnVlO1xuXHR9XG5cblx0dmFyIHZhck5hbWVzID0gW107XG5cdHZhciB2YXJMaXN0ID0gc3BlYy5zcGxpdChcIixcIik7XG5cdHZhciB2YXJTcGVjcyA9IFtdO1xuXHR2YXIgdmFyU3BlY01hcCA9IHt9O1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHZhckxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgdmFyTmFtZSA9IHZhckxpc3RbaV07XG5cdFx0dmFyIHRydW5jYXRlID0gbnVsbDtcblx0XHRpZiAodmFyTmFtZS5pbmRleE9mKFwiOlwiKSAhPT0gLTEpIHtcblx0XHRcdHZhciBwYXJ0cyA9IHZhck5hbWUuc3BsaXQoXCI6XCIpO1xuXHRcdFx0dmFyTmFtZSA9IHBhcnRzWzBdO1xuXHRcdFx0dHJ1bmNhdGUgPSBwYXJzZUludChwYXJ0c1sxXSwgMTApO1xuXHRcdH1cblx0XHR2YXIgc3VmZmljZXMgPSB7fTtcblx0XHR3aGlsZSAodXJpVGVtcGxhdGVTdWZmaWNlc1t2YXJOYW1lLmNoYXJBdCh2YXJOYW1lLmxlbmd0aCAtIDEpXSkge1xuXHRcdFx0c3VmZmljZXNbdmFyTmFtZS5jaGFyQXQodmFyTmFtZS5sZW5ndGggLSAxKV0gPSB0cnVlO1xuXHRcdFx0dmFyTmFtZSA9IHZhck5hbWUuc3Vic3RyaW5nKDAsIHZhck5hbWUubGVuZ3RoIC0gMSk7XG5cdFx0fVxuXHRcdHZhciB2YXJTcGVjID0ge1xuXHRcdFx0dHJ1bmNhdGU6IHRydW5jYXRlLFxuXHRcdFx0bmFtZTogdmFyTmFtZSxcblx0XHRcdHN1ZmZpY2VzOiBzdWZmaWNlc1xuXHRcdH07XG5cdFx0dmFyU3BlY3MucHVzaCh2YXJTcGVjKTtcblx0XHR2YXJTcGVjTWFwW3Zhck5hbWVdID0gdmFyU3BlYztcblx0XHR2YXJOYW1lcy5wdXNoKHZhck5hbWUpO1xuXHR9XG5cdHZhciBzdWJGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZUZ1bmN0aW9uKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFwiXCI7XG5cdFx0dmFyIHN0YXJ0SW5kZXggPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdmFyU3BlY3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB2YXJTcGVjID0gdmFyU3BlY3NbaV07XG5cdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZUZ1bmN0aW9uKHZhclNwZWMubmFtZSk7XG5cdFx0XHRpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB8fCAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwKSkge1xuXHRcdFx0XHRzdGFydEluZGV4Kys7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGkgPT09IHN0YXJ0SW5kZXgpIHtcblx0XHRcdFx0cmVzdWx0ICs9IHByZWZpeDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdCArPSAoc2VwYXJhdG9yIHx8IFwiLFwiKTtcblx0XHRcdH1cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoc2hvd1ZhcmlhYmxlcykge1xuXHRcdFx0XHRcdHJlc3VsdCArPSB2YXJTcGVjLm5hbWUgKyBcIj1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0aWYgKGogPiAwKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gdmFyU3BlYy5zdWZmaWNlc1snKiddID8gKHNlcGFyYXRvciB8fCBcIixcIikgOiBcIixcIjtcblx0XHRcdFx0XHRcdGlmICh2YXJTcGVjLnN1ZmZpY2VzWycqJ10gJiYgc2hvd1ZhcmlhYmxlcykge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQgKz0gdmFyU3BlYy5uYW1lICsgXCI9XCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc3VsdCArPSBzaG91bGRFc2NhcGUgPyBlbmNvZGVVUklDb21wb25lbnQodmFsdWVbal0pLnJlcGxhY2UoLyEvZywgXCIlMjFcIikgOiBub3RSZWFsbHlQZXJjZW50RW5jb2RlKHZhbHVlW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0aWYgKHNob3dWYXJpYWJsZXMgJiYgIXZhclNwZWMuc3VmZmljZXNbJyonXSkge1xuXHRcdFx0XHRcdHJlc3VsdCArPSB2YXJTcGVjLm5hbWUgKyBcIj1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgZmlyc3QgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoIWZpcnN0KSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gdmFyU3BlYy5zdWZmaWNlc1snKiddID8gKHNlcGFyYXRvciB8fCBcIixcIikgOiBcIixcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcblx0XHRcdFx0XHRyZXN1bHQgKz0gc2hvdWxkRXNjYXBlID8gZW5jb2RlVVJJQ29tcG9uZW50KGtleSkucmVwbGFjZSgvIS9nLCBcIiUyMVwiKSA6IG5vdFJlYWxseVBlcmNlbnRFbmNvZGUoa2V5KTtcblx0XHRcdFx0XHRyZXN1bHQgKz0gdmFyU3BlYy5zdWZmaWNlc1snKiddID8gJz0nIDogXCIsXCI7XG5cdFx0XHRcdFx0cmVzdWx0ICs9IHNob3VsZEVzY2FwZSA/IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZVtrZXldKS5yZXBsYWNlKC8hL2csIFwiJTIxXCIpIDogbm90UmVhbGx5UGVyY2VudEVuY29kZSh2YWx1ZVtrZXldKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHNob3dWYXJpYWJsZXMpIHtcblx0XHRcdFx0XHRyZXN1bHQgKz0gdmFyU3BlYy5uYW1lO1xuXHRcdFx0XHRcdGlmICghdHJpbUVtcHR5U3RyaW5nIHx8IHZhbHVlICE9PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gXCI9XCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2YXJTcGVjLnRydW5jYXRlICE9IG51bGwpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCB2YXJTcGVjLnRydW5jYXRlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXN1bHQgKz0gc2hvdWxkRXNjYXBlID8gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKS5yZXBsYWNlKC8hL2csIFwiJTIxXCIpOiBub3RSZWFsbHlQZXJjZW50RW5jb2RlKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblx0c3ViRnVuY3Rpb24udmFyTmFtZXMgPSB2YXJOYW1lcztcblx0cmV0dXJuIHtcblx0XHRwcmVmaXg6IHByZWZpeCxcblx0XHRzdWJzdGl0dXRpb246IHN1YkZ1bmN0aW9uXG5cdH07XG59XG5cbmZ1bmN0aW9uIFVyaVRlbXBsYXRlKHRlbXBsYXRlKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmlUZW1wbGF0ZSkpIHtcblx0XHRyZXR1cm4gbmV3IFVyaVRlbXBsYXRlKHRlbXBsYXRlKTtcblx0fVxuXHR2YXIgcGFydHMgPSB0ZW1wbGF0ZS5zcGxpdChcIntcIik7XG5cdHZhciB0ZXh0UGFydHMgPSBbcGFydHMuc2hpZnQoKV07XG5cdHZhciBwcmVmaXhlcyA9IFtdO1xuXHR2YXIgc3Vic3RpdHV0aW9ucyA9IFtdO1xuXHR2YXIgdmFyTmFtZXMgPSBbXTtcblx0d2hpbGUgKHBhcnRzLmxlbmd0aCA+IDApIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0dmFyIHNwZWMgPSBwYXJ0LnNwbGl0KFwifVwiKVswXTtcblx0XHR2YXIgcmVtYWluZGVyID0gcGFydC5zdWJzdHJpbmcoc3BlYy5sZW5ndGggKyAxKTtcblx0XHR2YXIgZnVuY3MgPSB1cmlUZW1wbGF0ZVN1YnN0aXR1dGlvbihzcGVjKTtcblx0XHRzdWJzdGl0dXRpb25zLnB1c2goZnVuY3Muc3Vic3RpdHV0aW9uKTtcblx0XHRwcmVmaXhlcy5wdXNoKGZ1bmNzLnByZWZpeCk7XG5cdFx0dGV4dFBhcnRzLnB1c2gocmVtYWluZGVyKTtcblx0XHR2YXJOYW1lcyA9IHZhck5hbWVzLmNvbmNhdChmdW5jcy5zdWJzdGl0dXRpb24udmFyTmFtZXMpO1xuXHR9XG5cdHRoaXMuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZUZ1bmN0aW9uKSB7XG5cdFx0dmFyIHJlc3VsdCA9IHRleHRQYXJ0c1swXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN1YnN0aXR1dGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBzdWJzdGl0dXRpb24gPSBzdWJzdGl0dXRpb25zW2ldO1xuXHRcdFx0cmVzdWx0ICs9IHN1YnN0aXR1dGlvbih2YWx1ZUZ1bmN0aW9uKTtcblx0XHRcdHJlc3VsdCArPSB0ZXh0UGFydHNbaSArIDFdO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXHR0aGlzLnZhck5hbWVzID0gdmFyTmFtZXM7XG5cdHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbn1cblVyaVRlbXBsYXRlLnByb3RvdHlwZSA9IHtcblx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy50ZW1wbGF0ZTtcblx0fSxcblx0ZmlsbEZyb21PYmplY3Q6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRyZXR1cm4gdGhpcy5maWxsKGZ1bmN0aW9uICh2YXJOYW1lKSB7XG5cdFx0XHRyZXR1cm4gb2JqW3Zhck5hbWVdO1xuXHRcdH0pO1xuXHR9XG59O1xudmFyIFZhbGlkYXRvckNvbnRleHQgPSBmdW5jdGlvbiBWYWxpZGF0b3JDb250ZXh0KHBhcmVudCwgY29sbGVjdE11bHRpcGxlLCBlcnJvclJlcG9ydGVyLCBjaGVja1JlY3Vyc2l2ZSwgdHJhY2tVbmtub3duUHJvcGVydGllcykge1xuXHR0aGlzLm1pc3NpbmcgPSBbXTtcblx0dGhpcy5taXNzaW5nTWFwID0ge307XG5cdHRoaXMuZm9ybWF0VmFsaWRhdG9ycyA9IHBhcmVudCA/IE9iamVjdC5jcmVhdGUocGFyZW50LmZvcm1hdFZhbGlkYXRvcnMpIDoge307XG5cdHRoaXMuc2NoZW1hcyA9IHBhcmVudCA/IE9iamVjdC5jcmVhdGUocGFyZW50LnNjaGVtYXMpIDoge307XG5cdHRoaXMuY29sbGVjdE11bHRpcGxlID0gY29sbGVjdE11bHRpcGxlO1xuXHR0aGlzLmVycm9ycyA9IFtdO1xuXHR0aGlzLmhhbmRsZUVycm9yID0gY29sbGVjdE11bHRpcGxlID8gdGhpcy5jb2xsZWN0RXJyb3IgOiB0aGlzLnJldHVybkVycm9yO1xuXHRpZiAoY2hlY2tSZWN1cnNpdmUpIHtcblx0XHR0aGlzLmNoZWNrUmVjdXJzaXZlID0gdHJ1ZTtcblx0XHR0aGlzLnNjYW5uZWQgPSBbXTtcblx0XHR0aGlzLnNjYW5uZWRGcm96ZW4gPSBbXTtcblx0XHR0aGlzLnNjYW5uZWRGcm96ZW5TY2hlbWFzID0gW107XG5cdFx0dGhpcy5zY2FubmVkRnJvemVuVmFsaWRhdGlvbkVycm9ycyA9IFtdO1xuXHRcdHRoaXMudmFsaWRhdGVkU2NoZW1hc0tleSA9ICd0djRfdmFsaWRhdGlvbl9pZCc7XG5cdFx0dGhpcy52YWxpZGF0aW9uRXJyb3JzS2V5ID0gJ3R2NF92YWxpZGF0aW9uX2Vycm9yc19pZCc7XG5cdH1cblx0aWYgKHRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHR0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMgPSB0cnVlO1xuXHRcdHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzID0ge307XG5cdFx0dGhpcy51bmtub3duUHJvcGVydHlQYXRocyA9IHt9O1xuXHR9XG5cdHRoaXMuZXJyb3JSZXBvcnRlciA9IGVycm9yUmVwb3J0ZXIgfHwgZGVmYXVsdEVycm9yUmVwb3J0ZXIoJ2VuJyk7XG5cdGlmICh0eXBlb2YgdGhpcy5lcnJvclJlcG9ydGVyID09PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBFcnJvcignZGVidWcnKTtcblx0fVxuXHR0aGlzLmRlZmluZWRLZXl3b3JkcyA9IHt9O1xuXHRpZiAocGFyZW50KSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHBhcmVudC5kZWZpbmVkS2V5d29yZHMpIHtcblx0XHRcdHRoaXMuZGVmaW5lZEtleXdvcmRzW2tleV0gPSBwYXJlbnQuZGVmaW5lZEtleXdvcmRzW2tleV0uc2xpY2UoMCk7XG5cdFx0fVxuXHR9XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuZGVmaW5lS2V5d29yZCA9IGZ1bmN0aW9uIChrZXl3b3JkLCBrZXl3b3JkRnVuY3Rpb24pIHtcblx0dGhpcy5kZWZpbmVkS2V5d29yZHNba2V5d29yZF0gPSB0aGlzLmRlZmluZWRLZXl3b3Jkc1trZXl3b3JkXSB8fCBbXTtcblx0dGhpcy5kZWZpbmVkS2V5d29yZHNba2V5d29yZF0ucHVzaChrZXl3b3JkRnVuY3Rpb24pO1xufTtcblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLmNyZWF0ZUVycm9yID0gZnVuY3Rpb24gKGNvZGUsIG1lc3NhZ2VQYXJhbXMsIGRhdGFQYXRoLCBzY2hlbWFQYXRoLCBzdWJFcnJvcnMsIGRhdGEsIHNjaGVtYSkge1xuXHR2YXIgZXJyb3IgPSBuZXcgVmFsaWRhdGlvbkVycm9yKGNvZGUsIG1lc3NhZ2VQYXJhbXMsIGRhdGFQYXRoLCBzY2hlbWFQYXRoLCBzdWJFcnJvcnMpO1xuXHRlcnJvci5tZXNzYWdlID0gdGhpcy5lcnJvclJlcG9ydGVyKGVycm9yLCBkYXRhLCBzY2hlbWEpO1xuXHRyZXR1cm4gZXJyb3I7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUucmV0dXJuRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcblx0cmV0dXJuIGVycm9yO1xufTtcblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLmNvbGxlY3RFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuXHRpZiAoZXJyb3IpIHtcblx0XHR0aGlzLmVycm9ycy5wdXNoKGVycm9yKTtcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5wcmVmaXhFcnJvcnMgPSBmdW5jdGlvbiAoc3RhcnRJbmRleCwgZGF0YVBhdGgsIHNjaGVtYVBhdGgpIHtcblx0Zm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0aGlzLmVycm9ycy5sZW5ndGg7IGkrKykge1xuXHRcdHRoaXMuZXJyb3JzW2ldID0gdGhpcy5lcnJvcnNbaV0ucHJlZml4V2l0aChkYXRhUGF0aCwgc2NoZW1hUGF0aCk7XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuYmFuVW5rbm93blByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZGF0YSwgc2NoZW1hKSB7XG5cdGZvciAodmFyIHVua25vd25QYXRoIGluIHRoaXMudW5rbm93blByb3BlcnR5UGF0aHMpIHtcblx0XHR2YXIgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuVU5LTk9XTl9QUk9QRVJUWSwge3BhdGg6IHVua25vd25QYXRofSwgdW5rbm93blBhdGgsIFwiXCIsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0dmFyIHJlc3VsdCA9IHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuXHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuYWRkRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCwgdmFsaWRhdG9yKSB7XG5cdGlmICh0eXBlb2YgZm9ybWF0ID09PSAnb2JqZWN0Jykge1xuXHRcdGZvciAodmFyIGtleSBpbiBmb3JtYXQpIHtcblx0XHRcdHRoaXMuYWRkRm9ybWF0KGtleSwgZm9ybWF0W2tleV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0aGlzLmZvcm1hdFZhbGlkYXRvcnNbZm9ybWF0XSA9IHZhbGlkYXRvcjtcbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5yZXNvbHZlUmVmcyA9IGZ1bmN0aW9uIChzY2hlbWEsIHVybEhpc3RvcnkpIHtcblx0aWYgKHNjaGVtYVsnJHJlZiddICE9PSB1bmRlZmluZWQpIHtcblx0XHR1cmxIaXN0b3J5ID0gdXJsSGlzdG9yeSB8fCB7fTtcblx0XHRpZiAodXJsSGlzdG9yeVtzY2hlbWFbJyRyZWYnXV0pIHtcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuQ0lSQ1VMQVJfUkVGRVJFTkNFLCB7dXJsczogT2JqZWN0LmtleXModXJsSGlzdG9yeSkuam9pbignLCAnKX0sICcnLCAnJywgbnVsbCwgdW5kZWZpbmVkLCBzY2hlbWEpO1xuXHRcdH1cblx0XHR1cmxIaXN0b3J5W3NjaGVtYVsnJHJlZiddXSA9IHRydWU7XG5cdFx0c2NoZW1hID0gdGhpcy5nZXRTY2hlbWEoc2NoZW1hWyckcmVmJ10sIHVybEhpc3RvcnkpO1xuXHR9XG5cdHJldHVybiBzY2hlbWE7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuZ2V0U2NoZW1hID0gZnVuY3Rpb24gKHVybCwgdXJsSGlzdG9yeSkge1xuXHR2YXIgc2NoZW1hO1xuXHRpZiAodGhpcy5zY2hlbWFzW3VybF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdHNjaGVtYSA9IHRoaXMuc2NoZW1hc1t1cmxdO1xuXHRcdHJldHVybiB0aGlzLnJlc29sdmVSZWZzKHNjaGVtYSwgdXJsSGlzdG9yeSk7XG5cdH1cblx0dmFyIGJhc2VVcmwgPSB1cmw7XG5cdHZhciBmcmFnbWVudCA9IFwiXCI7XG5cdGlmICh1cmwuaW5kZXhPZignIycpICE9PSAtMSkge1xuXHRcdGZyYWdtZW50ID0gdXJsLnN1YnN0cmluZyh1cmwuaW5kZXhPZihcIiNcIikgKyAxKTtcblx0XHRiYXNlVXJsID0gdXJsLnN1YnN0cmluZygwLCB1cmwuaW5kZXhPZihcIiNcIikpO1xuXHR9XG5cdGlmICh0eXBlb2YgdGhpcy5zY2hlbWFzW2Jhc2VVcmxdID09PSAnb2JqZWN0Jykge1xuXHRcdHNjaGVtYSA9IHRoaXMuc2NoZW1hc1tiYXNlVXJsXTtcblx0XHR2YXIgcG9pbnRlclBhdGggPSBkZWNvZGVVUklDb21wb25lbnQoZnJhZ21lbnQpO1xuXHRcdGlmIChwb2ludGVyUGF0aCA9PT0gXCJcIikge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVzb2x2ZVJlZnMoc2NoZW1hLCB1cmxIaXN0b3J5KTtcblx0XHR9IGVsc2UgaWYgKHBvaW50ZXJQYXRoLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHZhciBwYXJ0cyA9IHBvaW50ZXJQYXRoLnNwbGl0KFwiL1wiKS5zbGljZSgxKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50ID0gcGFydHNbaV0ucmVwbGFjZSgvfjEvZywgXCIvXCIpLnJlcGxhY2UoL34wL2csIFwiflwiKTtcblx0XHRcdGlmIChzY2hlbWFbY29tcG9uZW50XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHNjaGVtYSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRzY2hlbWEgPSBzY2hlbWFbY29tcG9uZW50XTtcblx0XHR9XG5cdFx0aWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXNvbHZlUmVmcyhzY2hlbWEsIHVybEhpc3RvcnkpO1xuXHRcdH1cblx0fVxuXHRpZiAodGhpcy5taXNzaW5nW2Jhc2VVcmxdID09PSB1bmRlZmluZWQpIHtcblx0XHR0aGlzLm1pc3NpbmcucHVzaChiYXNlVXJsKTtcblx0XHR0aGlzLm1pc3NpbmdbYmFzZVVybF0gPSBiYXNlVXJsO1xuXHRcdHRoaXMubWlzc2luZ01hcFtiYXNlVXJsXSA9IGJhc2VVcmw7XG5cdH1cbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5zZWFyY2hTY2hlbWFzID0gZnVuY3Rpb24gKHNjaGVtYSwgdXJsKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5zZWFyY2hTY2hlbWFzKHNjaGVtYVtpXSwgdXJsKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIpIHtcblx0XHRpZiAodHlwZW9mIHNjaGVtYS5pZCA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0aWYgKGlzVHJ1c3RlZFVybCh1cmwsIHNjaGVtYS5pZCkpIHtcblx0XHRcdFx0aWYgKHRoaXMuc2NoZW1hc1tzY2hlbWEuaWRdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0aGlzLnNjaGVtYXNbc2NoZW1hLmlkXSA9IHNjaGVtYTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG5cdFx0XHRpZiAoa2V5ICE9PSBcImVudW1cIikge1xuXHRcdFx0XHRpZiAodHlwZW9mIHNjaGVtYVtrZXldID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdFx0dGhpcy5zZWFyY2hTY2hlbWFzKHNjaGVtYVtrZXldLCB1cmwpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gXCIkcmVmXCIpIHtcblx0XHRcdFx0XHR2YXIgdXJpID0gZ2V0RG9jdW1lbnRVcmkoc2NoZW1hW2tleV0pO1xuXHRcdFx0XHRcdGlmICh1cmkgJiYgdGhpcy5zY2hlbWFzW3VyaV0gPT09IHVuZGVmaW5lZCAmJiB0aGlzLm1pc3NpbmdNYXBbdXJpXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1pc3NpbmdNYXBbdXJpXSA9IHVyaTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5hZGRTY2hlbWEgPSBmdW5jdGlvbiAodXJsLCBzY2hlbWEpIHtcblx0Ly9vdmVybG9hZFxuXHRpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHNjaGVtYSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRpZiAodHlwZW9mIHVybCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHVybC5pZCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHNjaGVtYSA9IHVybDtcblx0XHRcdHVybCA9IHNjaGVtYS5pZDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cdGlmICh1cmwgPT09IGdldERvY3VtZW50VXJpKHVybCkgKyBcIiNcIikge1xuXHRcdC8vIFJlbW92ZSBlbXB0eSBmcmFnbWVudFxuXHRcdHVybCA9IGdldERvY3VtZW50VXJpKHVybCk7XG5cdH1cblx0dGhpcy5zY2hlbWFzW3VybF0gPSBzY2hlbWE7XG5cdGRlbGV0ZSB0aGlzLm1pc3NpbmdNYXBbdXJsXTtcblx0bm9ybVNjaGVtYShzY2hlbWEsIHVybCk7XG5cdHRoaXMuc2VhcmNoU2NoZW1hcyhzY2hlbWEsIHVybCk7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5nZXRTY2hlbWFNYXAgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBtYXAgPSB7fTtcblx0Zm9yICh2YXIga2V5IGluIHRoaXMuc2NoZW1hcykge1xuXHRcdG1hcFtrZXldID0gdGhpcy5zY2hlbWFzW2tleV07XG5cdH1cblx0cmV0dXJuIG1hcDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLmdldFNjaGVtYVVyaXMgPSBmdW5jdGlvbiAoZmlsdGVyUmVnRXhwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cdGZvciAodmFyIGtleSBpbiB0aGlzLnNjaGVtYXMpIHtcblx0XHRpZiAoIWZpbHRlclJlZ0V4cCB8fCBmaWx0ZXJSZWdFeHAudGVzdChrZXkpKSB7XG5cdFx0XHRsaXN0LnB1c2goa2V5KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5nZXRNaXNzaW5nVXJpcyA9IGZ1bmN0aW9uIChmaWx0ZXJSZWdFeHApIHtcblx0dmFyIGxpc3QgPSBbXTtcblx0Zm9yICh2YXIga2V5IGluIHRoaXMubWlzc2luZ01hcCkge1xuXHRcdGlmICghZmlsdGVyUmVnRXhwIHx8IGZpbHRlclJlZ0V4cC50ZXN0KGtleSkpIHtcblx0XHRcdGxpc3QucHVzaChrZXkpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbGlzdDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLmRyb3BTY2hlbWFzID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLnNjaGVtYXMgPSB7fTtcblx0dGhpcy5yZXNldCgpO1xufTtcblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLm1pc3NpbmcgPSBbXTtcblx0dGhpcy5taXNzaW5nTWFwID0ge307XG5cdHRoaXMuZXJyb3JzID0gW107XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZUFsbCA9IGZ1bmN0aW9uIChkYXRhLCBzY2hlbWEsIGRhdGFQYXRoUGFydHMsIHNjaGVtYVBhdGhQYXJ0cywgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdHZhciB0b3BMZXZlbDtcblx0c2NoZW1hID0gdGhpcy5yZXNvbHZlUmVmcyhzY2hlbWEpO1xuXHRpZiAoIXNjaGVtYSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFZhbGlkYXRpb25FcnJvcikge1xuXHRcdHRoaXMuZXJyb3JzLnB1c2goc2NoZW1hKTtcblx0XHRyZXR1cm4gc2NoZW1hO1xuXHR9XG5cblx0dmFyIHN0YXJ0RXJyb3JDb3VudCA9IHRoaXMuZXJyb3JzLmxlbmd0aDtcblx0dmFyIGZyb3plbkluZGV4LCBzY2FubmVkRnJvemVuU2NoZW1hSW5kZXggPSBudWxsLCBzY2FubmVkU2NoZW1hc0luZGV4ID0gbnVsbDtcblx0aWYgKHRoaXMuY2hlY2tSZWN1cnNpdmUgJiYgZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcblx0XHR0b3BMZXZlbCA9ICF0aGlzLnNjYW5uZWQubGVuZ3RoO1xuXHRcdGlmIChkYXRhW3RoaXMudmFsaWRhdGVkU2NoZW1hc0tleV0pIHtcblx0XHRcdHZhciBzY2hlbWFJbmRleCA9IGRhdGFbdGhpcy52YWxpZGF0ZWRTY2hlbWFzS2V5XS5pbmRleE9mKHNjaGVtYSk7XG5cdFx0XHRpZiAoc2NoZW1hSW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMuY29uY2F0KGRhdGFbdGhpcy52YWxpZGF0aW9uRXJyb3JzS2V5XVtzY2hlbWFJbmRleF0pO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKE9iamVjdC5pc0Zyb3plbihkYXRhKSkge1xuXHRcdFx0ZnJvemVuSW5kZXggPSB0aGlzLnNjYW5uZWRGcm96ZW4uaW5kZXhPZihkYXRhKTtcblx0XHRcdGlmIChmcm96ZW5JbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0dmFyIGZyb3plblNjaGVtYUluZGV4ID0gdGhpcy5zY2FubmVkRnJvemVuU2NoZW1hc1tmcm96ZW5JbmRleF0uaW5kZXhPZihzY2hlbWEpO1xuXHRcdFx0XHRpZiAoZnJvemVuU2NoZW1hSW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdFx0dGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycy5jb25jYXQodGhpcy5zY2FubmVkRnJvemVuVmFsaWRhdGlvbkVycm9yc1tmcm96ZW5JbmRleF1bZnJvemVuU2NoZW1hSW5kZXhdKTtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLnNjYW5uZWQucHVzaChkYXRhKTtcblx0XHRpZiAoT2JqZWN0LmlzRnJvemVuKGRhdGEpKSB7XG5cdFx0XHRpZiAoZnJvemVuSW5kZXggPT09IC0xKSB7XG5cdFx0XHRcdGZyb3plbkluZGV4ID0gdGhpcy5zY2FubmVkRnJvemVuLmxlbmd0aDtcblx0XHRcdFx0dGhpcy5zY2FubmVkRnJvemVuLnB1c2goZGF0YSk7XG5cdFx0XHRcdHRoaXMuc2Nhbm5lZEZyb3plblNjaGVtYXMucHVzaChbXSk7XG5cdFx0XHR9XG5cdFx0XHRzY2FubmVkRnJvemVuU2NoZW1hSW5kZXggPSB0aGlzLnNjYW5uZWRGcm96ZW5TY2hlbWFzW2Zyb3plbkluZGV4XS5sZW5ndGg7XG5cdFx0XHR0aGlzLnNjYW5uZWRGcm96ZW5TY2hlbWFzW2Zyb3plbkluZGV4XVtzY2FubmVkRnJvemVuU2NoZW1hSW5kZXhdID0gc2NoZW1hO1xuXHRcdFx0dGhpcy5zY2FubmVkRnJvemVuVmFsaWRhdGlvbkVycm9yc1tmcm96ZW5JbmRleF1bc2Nhbm5lZEZyb3plblNjaGVtYUluZGV4XSA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIWRhdGFbdGhpcy52YWxpZGF0ZWRTY2hlbWFzS2V5XSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhLCB0aGlzLnZhbGlkYXRlZFNjaGVtYXNLZXksIHtcblx0XHRcdFx0XHRcdHZhbHVlOiBbXSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhLCB0aGlzLnZhbGlkYXRpb25FcnJvcnNLZXksIHtcblx0XHRcdFx0XHRcdHZhbHVlOiBbXSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Ly9JRSA3Lzggd29ya2Fyb3VuZFxuXHRcdFx0XHRcdGRhdGFbdGhpcy52YWxpZGF0ZWRTY2hlbWFzS2V5XSA9IFtdO1xuXHRcdFx0XHRcdGRhdGFbdGhpcy52YWxpZGF0aW9uRXJyb3JzS2V5XSA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzY2FubmVkU2NoZW1hc0luZGV4ID0gZGF0YVt0aGlzLnZhbGlkYXRlZFNjaGVtYXNLZXldLmxlbmd0aDtcblx0XHRcdGRhdGFbdGhpcy52YWxpZGF0ZWRTY2hlbWFzS2V5XVtzY2FubmVkU2NoZW1hc0luZGV4XSA9IHNjaGVtYTtcblx0XHRcdGRhdGFbdGhpcy52YWxpZGF0aW9uRXJyb3JzS2V5XVtzY2FubmVkU2NoZW1hc0luZGV4XSA9IFtdO1xuXHRcdH1cblx0fVxuXG5cdHZhciBlcnJvckNvdW50ID0gdGhpcy5lcnJvcnMubGVuZ3RoO1xuXHR2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRlQmFzaWMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZU51bWVyaWMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZVN0cmluZyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlQXJyYXkoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZU9iamVjdChkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlQ29tYmluYXRpb25zKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVIeXBlcm1lZGlhKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVGb3JtYXQoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZURlZmluZWRLZXl3b3JkcyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCBudWxsO1xuXG5cdGlmICh0b3BMZXZlbCkge1xuXHRcdHdoaWxlICh0aGlzLnNjYW5uZWQubGVuZ3RoKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHRoaXMuc2Nhbm5lZC5wb3AoKTtcblx0XHRcdGRlbGV0ZSBpdGVtW3RoaXMudmFsaWRhdGVkU2NoZW1hc0tleV07XG5cdFx0fVxuXHRcdHRoaXMuc2Nhbm5lZEZyb3plbiA9IFtdO1xuXHRcdHRoaXMuc2Nhbm5lZEZyb3plblNjaGVtYXMgPSBbXTtcblx0fVxuXG5cdGlmIChlcnJvciB8fCBlcnJvckNvdW50ICE9PSB0aGlzLmVycm9ycy5sZW5ndGgpIHtcblx0XHR3aGlsZSAoKGRhdGFQYXRoUGFydHMgJiYgZGF0YVBhdGhQYXJ0cy5sZW5ndGgpIHx8IChzY2hlbWFQYXRoUGFydHMgJiYgc2NoZW1hUGF0aFBhcnRzLmxlbmd0aCkpIHtcblx0XHRcdHZhciBkYXRhUGFydCA9IChkYXRhUGF0aFBhcnRzICYmIGRhdGFQYXRoUGFydHMubGVuZ3RoKSA/IFwiXCIgKyBkYXRhUGF0aFBhcnRzLnBvcCgpIDogbnVsbDtcblx0XHRcdHZhciBzY2hlbWFQYXJ0ID0gKHNjaGVtYVBhdGhQYXJ0cyAmJiBzY2hlbWFQYXRoUGFydHMubGVuZ3RoKSA/IFwiXCIgKyBzY2hlbWFQYXRoUGFydHMucG9wKCkgOiBudWxsO1xuXHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdGVycm9yID0gZXJyb3IucHJlZml4V2l0aChkYXRhUGFydCwgc2NoZW1hUGFydCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnByZWZpeEVycm9ycyhlcnJvckNvdW50LCBkYXRhUGFydCwgc2NoZW1hUGFydCk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHNjYW5uZWRGcm96ZW5TY2hlbWFJbmRleCAhPT0gbnVsbCkge1xuXHRcdHRoaXMuc2Nhbm5lZEZyb3plblZhbGlkYXRpb25FcnJvcnNbZnJvemVuSW5kZXhdW3NjYW5uZWRGcm96ZW5TY2hlbWFJbmRleF0gPSB0aGlzLmVycm9ycy5zbGljZShzdGFydEVycm9yQ291bnQpO1xuXHR9IGVsc2UgaWYgKHNjYW5uZWRTY2hlbWFzSW5kZXggIT09IG51bGwpIHtcblx0XHRkYXRhW3RoaXMudmFsaWRhdGlvbkVycm9yc0tleV1bc2Nhbm5lZFNjaGVtYXNJbmRleF0gPSB0aGlzLmVycm9ycy5zbGljZShzdGFydEVycm9yQ291bnQpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xufTtcblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gKGRhdGEsIHNjaGVtYSkge1xuXHRpZiAodHlwZW9mIHNjaGVtYS5mb3JtYXQgIT09ICdzdHJpbmcnIHx8ICF0aGlzLmZvcm1hdFZhbGlkYXRvcnNbc2NoZW1hLmZvcm1hdF0pIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR2YXIgZXJyb3JNZXNzYWdlID0gdGhpcy5mb3JtYXRWYWxpZGF0b3JzW3NjaGVtYS5mb3JtYXRdLmNhbGwobnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0aWYgKHR5cGVvZiBlcnJvck1lc3NhZ2UgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlcnJvck1lc3NhZ2UgPT09ICdudW1iZXInKSB7XG5cdFx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5GT1JNQVRfQ1VTVE9NLCB7bWVzc2FnZTogZXJyb3JNZXNzYWdlfSwgJycsICcvZm9ybWF0JywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0fSBlbHNlIGlmIChlcnJvck1lc3NhZ2UgJiYgdHlwZW9mIGVycm9yTWVzc2FnZSA9PT0gJ29iamVjdCcpIHtcblx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLkZPUk1BVF9DVVNUT00sIHttZXNzYWdlOiBlcnJvck1lc3NhZ2UubWVzc2FnZSB8fCBcIj9cIn0sIGVycm9yTWVzc2FnZS5kYXRhUGF0aCB8fCAnJywgZXJyb3JNZXNzYWdlLnNjaGVtYVBhdGggfHwgXCIvZm9ybWF0XCIsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVEZWZpbmVkS2V5d29yZHMgPSBmdW5jdGlvbiAoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0Zm9yICh2YXIga2V5IGluIHRoaXMuZGVmaW5lZEtleXdvcmRzKSB7XG5cdFx0aWYgKHR5cGVvZiBzY2hlbWFba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHR2YXIgdmFsaWRhdGlvbkZ1bmN0aW9ucyA9IHRoaXMuZGVmaW5lZEtleXdvcmRzW2tleV07XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2YWxpZGF0aW9uRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZnVuYyA9IHZhbGlkYXRpb25GdW5jdGlvbnNbaV07XG5cdFx0XHR2YXIgcmVzdWx0ID0gZnVuYyhkYXRhLCBzY2hlbWFba2V5XSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpO1xuXHRcdFx0aWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiByZXN1bHQgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuS0VZV09SRF9DVVNUT00sIHtrZXk6IGtleSwgbWVzc2FnZTogcmVzdWx0fSwgJycsICcnLCBudWxsLCBkYXRhLCBzY2hlbWEpLnByZWZpeFdpdGgobnVsbCwga2V5KTtcblx0XHRcdH0gZWxzZSBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHZhciBjb2RlID0gcmVzdWx0LmNvZGU7XG5cdFx0XHRcdGlmICh0eXBlb2YgY29kZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRpZiAoIUVycm9yQ29kZXNbY29kZV0pIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5kZWZpbmVkIGVycm9yIGNvZGUgKHVzZSBkZWZpbmVFcnJvcik6ICcgKyBjb2RlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29kZSA9IEVycm9yQ29kZXNbY29kZV07XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGNvZGUgIT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0Y29kZSA9IEVycm9yQ29kZXMuS0VZV09SRF9DVVNUT007XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIG1lc3NhZ2VQYXJhbXMgPSAodHlwZW9mIHJlc3VsdC5tZXNzYWdlID09PSAnb2JqZWN0JykgPyByZXN1bHQubWVzc2FnZSA6IHtrZXk6IGtleSwgbWVzc2FnZTogcmVzdWx0Lm1lc3NhZ2UgfHwgXCI/XCJ9O1xuXHRcdFx0XHR2YXIgc2NoZW1hUGF0aCA9IHJlc3VsdC5zY2hlbWFQYXRoIHx8IChcIi9cIiArIGtleS5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKSk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKGNvZGUsIG1lc3NhZ2VQYXJhbXMsIHJlc3VsdC5kYXRhUGF0aCB8fCBudWxsLCBzY2hlbWFQYXRoLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZUNvbXBhcmUoQSwgQikge1xuXHRpZiAoQSA9PT0gQikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmIChBICYmIEIgJiYgdHlwZW9mIEEgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIEIgPT09IFwib2JqZWN0XCIpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShBKSAhPT0gQXJyYXkuaXNBcnJheShCKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShBKSkge1xuXHRcdFx0aWYgKEEubGVuZ3RoICE9PSBCLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IEEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKCFyZWN1cnNpdmVDb21wYXJlKEFbaV0sIEJbaV0pKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBrZXk7XG5cdFx0XHRmb3IgKGtleSBpbiBBKSB7XG5cdFx0XHRcdGlmIChCW2tleV0gPT09IHVuZGVmaW5lZCAmJiBBW2tleV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Zm9yIChrZXkgaW4gQikge1xuXHRcdFx0XHRpZiAoQVtrZXldID09PSB1bmRlZmluZWQgJiYgQltrZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZvciAoa2V5IGluIEEpIHtcblx0XHRcdFx0aWYgKCFyZWN1cnNpdmVDb21wYXJlKEFba2V5XSwgQltrZXldKSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlQmFzaWMgPSBmdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdHZhciBlcnJvcjtcblx0aWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZVR5cGUoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpKSB7XG5cdFx0cmV0dXJuIGVycm9yLnByZWZpeFdpdGgobnVsbCwgXCJ0eXBlXCIpO1xuXHR9XG5cdGlmIChlcnJvciA9IHRoaXMudmFsaWRhdGVFbnVtKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSkge1xuXHRcdHJldHVybiBlcnJvci5wcmVmaXhXaXRoKG51bGwsIFwidHlwZVwiKTtcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlVHlwZSA9IGZ1bmN0aW9uIHZhbGlkYXRlVHlwZShkYXRhLCBzY2hlbWEpIHtcblx0aWYgKHNjaGVtYS50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR2YXIgZGF0YVR5cGUgPSB0eXBlb2YgZGF0YTtcblx0aWYgKGRhdGEgPT09IG51bGwpIHtcblx0XHRkYXRhVHlwZSA9IFwibnVsbFwiO1xuXHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcblx0XHRkYXRhVHlwZSA9IFwiYXJyYXlcIjtcblx0fVxuXHR2YXIgYWxsb3dlZFR5cGVzID0gc2NoZW1hLnR5cGU7XG5cdGlmICghQXJyYXkuaXNBcnJheShhbGxvd2VkVHlwZXMpKSB7XG5cdFx0YWxsb3dlZFR5cGVzID0gW2FsbG93ZWRUeXBlc107XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFsbG93ZWRUeXBlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciB0eXBlID0gYWxsb3dlZFR5cGVzW2ldO1xuXHRcdGlmICh0eXBlID09PSBkYXRhVHlwZSB8fCAodHlwZSA9PT0gXCJpbnRlZ2VyXCIgJiYgZGF0YVR5cGUgPT09IFwibnVtYmVyXCIgJiYgKGRhdGEgJSAxID09PSAwKSkpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLklOVkFMSURfVFlQRSwge3R5cGU6IGRhdGFUeXBlLCBleHBlY3RlZDogYWxsb3dlZFR5cGVzLmpvaW4oXCIvXCIpfSwgJycsICcnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVFbnVtID0gZnVuY3Rpb24gdmFsaWRhdGVFbnVtKGRhdGEsIHNjaGVtYSkge1xuXHRpZiAoc2NoZW1hW1wiZW51bVwiXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzY2hlbWFbXCJlbnVtXCJdLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGVudW1WYWwgPSBzY2hlbWFbXCJlbnVtXCJdW2ldO1xuXHRcdGlmIChyZWN1cnNpdmVDb21wYXJlKGRhdGEsIGVudW1WYWwpKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5FTlVNX01JU01BVENILCB7dmFsdWU6ICh0eXBlb2YgSlNPTiAhPT0gJ3VuZGVmaW5lZCcpID8gSlNPTi5zdHJpbmdpZnkoZGF0YSkgOiBkYXRhfSwgJycsICcnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVOdW1lcmljID0gZnVuY3Rpb24gdmFsaWRhdGVOdW1lcmljKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdHJldHVybiB0aGlzLnZhbGlkYXRlTXVsdGlwbGVPZihkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlTWluTWF4KGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVOYU4oZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgbnVsbDtcbn07XG5cbnZhciBDTE9TRV9FTk9VR0hfTE9XID0gTWF0aC5wb3coMiwgLTUxKTtcbnZhciBDTE9TRV9FTk9VR0hfSElHSCA9IDEgLSBDTE9TRV9FTk9VR0hfTE9XO1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVNdWx0aXBsZU9mID0gZnVuY3Rpb24gdmFsaWRhdGVNdWx0aXBsZU9mKGRhdGEsIHNjaGVtYSkge1xuXHR2YXIgbXVsdGlwbGVPZiA9IHNjaGVtYS5tdWx0aXBsZU9mIHx8IHNjaGVtYS5kaXZpc2libGVCeTtcblx0aWYgKG11bHRpcGxlT2YgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdGlmICh0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuXHRcdHZhciByZW1haW5kZXIgPSAoZGF0YS9tdWx0aXBsZU9mKSUxO1xuXHRcdGlmIChyZW1haW5kZXIgPj0gQ0xPU0VfRU5PVUdIX0xPVyAmJiByZW1haW5kZXIgPCBDTE9TRV9FTk9VR0hfSElHSCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5OVU1CRVJfTVVMVElQTEVfT0YsIHt2YWx1ZTogZGF0YSwgbXVsdGlwbGVPZjogbXVsdGlwbGVPZn0sICcnLCAnJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZU1pbk1heCA9IGZ1bmN0aW9uIHZhbGlkYXRlTWluTWF4KGRhdGEsIHNjaGVtYSkge1xuXHRpZiAodHlwZW9mIGRhdGEgIT09IFwibnVtYmVyXCIpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRpZiAoc2NoZW1hLm1pbmltdW0gIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChkYXRhIDwgc2NoZW1hLm1pbmltdW0pIHtcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuTlVNQkVSX01JTklNVU0sIHt2YWx1ZTogZGF0YSwgbWluaW11bTogc2NoZW1hLm1pbmltdW19LCAnJywgJy9taW5pbXVtJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHR9XG5cdFx0aWYgKHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtICYmIGRhdGEgPT09IHNjaGVtYS5taW5pbXVtKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk5VTUJFUl9NSU5JTVVNX0VYQ0xVU0lWRSwge3ZhbHVlOiBkYXRhLCBtaW5pbXVtOiBzY2hlbWEubWluaW11bX0sICcnLCAnL2V4Y2x1c2l2ZU1pbmltdW0nLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdH1cblx0fVxuXHRpZiAoc2NoZW1hLm1heGltdW0gIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChkYXRhID4gc2NoZW1hLm1heGltdW0pIHtcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuTlVNQkVSX01BWElNVU0sIHt2YWx1ZTogZGF0YSwgbWF4aW11bTogc2NoZW1hLm1heGltdW19LCAnJywgJy9tYXhpbXVtJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHR9XG5cdFx0aWYgKHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtICYmIGRhdGEgPT09IHNjaGVtYS5tYXhpbXVtKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk5VTUJFUl9NQVhJTVVNX0VYQ0xVU0lWRSwge3ZhbHVlOiBkYXRhLCBtYXhpbXVtOiBzY2hlbWEubWF4aW11bX0sICcnLCAnL2V4Y2x1c2l2ZU1heGltdW0nLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlTmFOID0gZnVuY3Rpb24gdmFsaWRhdGVOYU4oZGF0YSwgc2NoZW1hKSB7XG5cdGlmICh0eXBlb2YgZGF0YSAhPT0gXCJudW1iZXJcIikge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdGlmIChpc05hTihkYXRhKSA9PT0gdHJ1ZSB8fCBkYXRhID09PSBJbmZpbml0eSB8fCBkYXRhID09PSAtSW5maW5pdHkpIHtcblx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk5VTUJFUl9OT1RfQV9OVU1CRVIsIHt2YWx1ZTogZGF0YX0sICcnLCAnL3R5cGUnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVTdHJpbmcgPSBmdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCkge1xuXHRyZXR1cm4gdGhpcy52YWxpZGF0ZVN0cmluZ0xlbmd0aChkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlU3RyaW5nUGF0dGVybihkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVTdHJpbmdMZW5ndGggPSBmdW5jdGlvbiB2YWxpZGF0ZVN0cmluZ0xlbmd0aChkYXRhLCBzY2hlbWEpIHtcblx0aWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0aWYgKHNjaGVtYS5taW5MZW5ndGggIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChkYXRhLmxlbmd0aCA8IHNjaGVtYS5taW5MZW5ndGgpIHtcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuU1RSSU5HX0xFTkdUSF9TSE9SVCwge2xlbmd0aDogZGF0YS5sZW5ndGgsIG1pbmltdW06IHNjaGVtYS5taW5MZW5ndGh9LCAnJywgJy9taW5MZW5ndGgnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdH1cblx0fVxuXHRpZiAoc2NoZW1hLm1heExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGRhdGEubGVuZ3RoID4gc2NoZW1hLm1heExlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5TVFJJTkdfTEVOR1RIX0xPTkcsIHtsZW5ndGg6IGRhdGEubGVuZ3RoLCBtYXhpbXVtOiBzY2hlbWEubWF4TGVuZ3RofSwgJycsICcvbWF4TGVuZ3RoJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZVN0cmluZ1BhdHRlcm4gPSBmdW5jdGlvbiB2YWxpZGF0ZVN0cmluZ1BhdHRlcm4oZGF0YSwgc2NoZW1hKSB7XG5cdGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiB8fCAodHlwZW9mIHNjaGVtYS5wYXR0ZXJuICE9PSBcInN0cmluZ1wiICYmICEoc2NoZW1hLnBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApKSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHZhciByZWdleHA7XG5cdGlmIChzY2hlbWEucGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHQgIHJlZ2V4cCA9IHNjaGVtYS5wYXR0ZXJuO1xuXHR9XG5cdGVsc2Uge1xuXHQgIHZhciBib2R5LCBmbGFncyA9ICcnO1xuXHQgIC8vIENoZWNrIGZvciByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbHNcblx0ICAvLyBAc2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy03LjguNVxuXHQgIHZhciBsaXRlcmFsID0gc2NoZW1hLnBhdHRlcm4ubWF0Y2goL15cXC8oLispXFwvKFtpbWddKikkLyk7XG5cdCAgaWYgKGxpdGVyYWwpIHtcblx0ICAgIGJvZHkgPSBsaXRlcmFsWzFdO1xuXHQgICAgZmxhZ3MgPSBsaXRlcmFsWzJdO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIGJvZHkgPSBzY2hlbWEucGF0dGVybjtcblx0ICB9XG5cdCAgcmVnZXhwID0gbmV3IFJlZ0V4cChib2R5LCBmbGFncyk7XG5cdH1cblx0aWYgKCFyZWdleHAudGVzdChkYXRhKSkge1xuXHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuU1RSSU5HX1BBVFRFUk4sIHtwYXR0ZXJuOiBzY2hlbWEucGF0dGVybn0sICcnLCAnL3BhdHRlcm4nLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVBcnJheSA9IGZ1bmN0aW9uIHZhbGlkYXRlQXJyYXkoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0cmV0dXJuIHRoaXMudmFsaWRhdGVBcnJheUxlbmd0aChkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlQXJyYXlVbmlxdWVJdGVtcyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlQXJyYXlJdGVtcyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVBcnJheUxlbmd0aCA9IGZ1bmN0aW9uIHZhbGlkYXRlQXJyYXlMZW5ndGgoZGF0YSwgc2NoZW1hKSB7XG5cdHZhciBlcnJvcjtcblx0aWYgKHNjaGVtYS5taW5JdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGRhdGEubGVuZ3RoIDwgc2NoZW1hLm1pbkl0ZW1zKSB7XG5cdFx0XHRlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5BUlJBWV9MRU5HVEhfU0hPUlQsIHtsZW5ndGg6IGRhdGEubGVuZ3RoLCBtaW5pbXVtOiBzY2hlbWEubWluSXRlbXN9LCAnJywgJy9taW5JdGVtcycsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0XHRpZiAodGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRpZiAoc2NoZW1hLm1heEl0ZW1zICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoZGF0YS5sZW5ndGggPiBzY2hlbWEubWF4SXRlbXMpIHtcblx0XHRcdGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLkFSUkFZX0xFTkdUSF9MT05HLCB7bGVuZ3RoOiBkYXRhLmxlbmd0aCwgbWF4aW11bTogc2NoZW1hLm1heEl0ZW1zfSwgJycsICcvbWF4SXRlbXMnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdFx0aWYgKHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpKSB7XG5cdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZUFycmF5VW5pcXVlSXRlbXMgPSBmdW5jdGlvbiB2YWxpZGF0ZUFycmF5VW5pcXVlSXRlbXMoZGF0YSwgc2NoZW1hKSB7XG5cdGlmIChzY2hlbWEudW5pcXVlSXRlbXMpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSBpICsgMTsgaiA8IGRhdGEubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0aWYgKHJlY3Vyc2l2ZUNvbXBhcmUoZGF0YVtpXSwgZGF0YVtqXSkpIHtcblx0XHRcdFx0XHR2YXIgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuQVJSQVlfVU5JUVVFLCB7bWF0Y2gxOiBpLCBtYXRjaDI6IGp9LCAnJywgJy91bmlxdWVJdGVtcycsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0XHRcdFx0aWYgKHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVBcnJheUl0ZW1zID0gZnVuY3Rpb24gdmFsaWRhdGVBcnJheUl0ZW1zKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdGlmIChzY2hlbWEuaXRlbXMgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHZhciBlcnJvciwgaTtcblx0aWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLml0ZW1zKSkge1xuXHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoaSA8IHNjaGVtYS5pdGVtcy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhW2ldLCBzY2hlbWEuaXRlbXNbaV0sIFtpXSwgW1wiaXRlbXNcIiwgaV0sIGRhdGFQb2ludGVyUGF0aCArIFwiL1wiICsgaSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmICh0eXBlb2Ygc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0XHRpZiAoIXNjaGVtYS5hZGRpdGlvbmFsSXRlbXMpIHtcblx0XHRcdFx0XHRcdGVycm9yID0gKHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5BUlJBWV9BRERJVElPTkFMX0lURU1TLCB7fSwgJy8nICsgaSwgJy9hZGRpdGlvbmFsSXRlbXMnLCBudWxsLCBkYXRhLCBzY2hlbWEpKTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLmhhbmRsZUVycm9yKGVycm9yKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhW2ldLCBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zLCBbaV0sIFtcImFkZGl0aW9uYWxJdGVtc1wiXSwgZGF0YVBvaW50ZXJQYXRoICsgXCIvXCIgKyBpKSkge1xuXHRcdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhW2ldLCBzY2hlbWEuaXRlbXMsIFtpXSwgW1wiaXRlbXNcIl0sIGRhdGFQb2ludGVyUGF0aCArIFwiL1wiICsgaSkpIHtcblx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlT2JqZWN0ID0gZnVuY3Rpb24gdmFsaWRhdGVPYmplY3QoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0aWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiIHx8IGRhdGEgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHJldHVybiB0aGlzLnZhbGlkYXRlT2JqZWN0TWluTWF4UHJvcGVydGllcyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlT2JqZWN0UmVxdWlyZWRQcm9wZXJ0aWVzKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVPYmplY3RQcm9wZXJ0aWVzKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVPYmplY3REZXBlbmRlbmNpZXMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlT2JqZWN0TWluTWF4UHJvcGVydGllcyA9IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0TWluTWF4UHJvcGVydGllcyhkYXRhLCBzY2hlbWEpIHtcblx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcblx0dmFyIGVycm9yO1xuXHRpZiAoc2NoZW1hLm1pblByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChrZXlzLmxlbmd0aCA8IHNjaGVtYS5taW5Qcm9wZXJ0aWVzKSB7XG5cdFx0XHRlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5PQkpFQ1RfUFJPUEVSVElFU19NSU5JTVVNLCB7cHJvcGVydHlDb3VudDoga2V5cy5sZW5ndGgsIG1pbmltdW06IHNjaGVtYS5taW5Qcm9wZXJ0aWVzfSwgJycsICcvbWluUHJvcGVydGllcycsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0XHRpZiAodGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRpZiAoc2NoZW1hLm1heFByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChrZXlzLmxlbmd0aCA+IHNjaGVtYS5tYXhQcm9wZXJ0aWVzKSB7XG5cdFx0XHRlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5PQkpFQ1RfUFJPUEVSVElFU19NQVhJTVVNLCB7cHJvcGVydHlDb3VudDoga2V5cy5sZW5ndGgsIG1heGltdW06IHNjaGVtYS5tYXhQcm9wZXJ0aWVzfSwgJycsICcvbWF4UHJvcGVydGllcycsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0XHRpZiAodGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlT2JqZWN0UmVxdWlyZWRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gdmFsaWRhdGVPYmplY3RSZXF1aXJlZFByb3BlcnRpZXMoZGF0YSwgc2NoZW1hKSB7XG5cdGlmIChzY2hlbWEucmVxdWlyZWQgIT09IHVuZGVmaW5lZCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2NoZW1hLnJlcXVpcmVkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIga2V5ID0gc2NoZW1hLnJlcXVpcmVkW2ldO1xuXHRcdFx0aWYgKGRhdGFba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHZhciBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5PQkpFQ1RfUkVRVUlSRUQsIHtrZXk6IGtleX0sICcnLCAnL3JlcXVpcmVkLycgKyBpLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdFx0XHRpZiAodGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZU9iamVjdFByb3BlcnRpZXMgPSBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdFByb3BlcnRpZXMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0dmFyIGVycm9yO1xuXHRmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuXHRcdHZhciBrZXlQb2ludGVyUGF0aCA9IGRhdGFQb2ludGVyUGF0aCArIFwiL1wiICsga2V5LnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xuXHRcdHZhciBmb3VuZE1hdGNoID0gZmFsc2U7XG5cdFx0aWYgKHNjaGVtYS5wcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQgJiYgc2NoZW1hLnByb3BlcnRpZXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRmb3VuZE1hdGNoID0gdHJ1ZTtcblx0XHRcdGlmIChlcnJvciA9IHRoaXMudmFsaWRhdGVBbGwoZGF0YVtrZXldLCBzY2hlbWEucHJvcGVydGllc1trZXldLCBba2V5XSwgW1wicHJvcGVydGllc1wiLCBrZXldLCBrZXlQb2ludGVyUGF0aCkpIHtcblx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGZvciAodmFyIHBhdHRlcm5LZXkgaW4gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKSB7XG5cdFx0XHRcdHZhciByZWdleHAgPSBuZXcgUmVnRXhwKHBhdHRlcm5LZXkpO1xuXHRcdFx0XHRpZiAocmVnZXhwLnRlc3Qoa2V5KSkge1xuXHRcdFx0XHRcdGZvdW5kTWF0Y2ggPSB0cnVlO1xuXHRcdFx0XHRcdGlmIChlcnJvciA9IHRoaXMudmFsaWRhdGVBbGwoZGF0YVtrZXldLCBzY2hlbWEucGF0dGVyblByb3BlcnRpZXNbcGF0dGVybktleV0sIFtrZXldLCBbXCJwYXR0ZXJuUHJvcGVydGllc1wiLCBwYXR0ZXJuS2V5XSwga2V5UG9pbnRlclBhdGgpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghZm91bmRNYXRjaCkge1xuXHRcdFx0aWYgKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRcdFx0XHR0aGlzLmtub3duUHJvcGVydHlQYXRoc1trZXlQb2ludGVyUGF0aF0gPSB0cnVlO1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzW2tleVBvaW50ZXJQYXRoXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZW9mIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0XHRpZiAoIXNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcykge1xuXHRcdFx0XHRcdFx0ZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuT0JKRUNUX0FERElUSU9OQUxfUFJPUEVSVElFUywge2tleToga2V5fSwgJycsICcvYWRkaXRpb25hbFByb3BlcnRpZXMnLCBudWxsLCBkYXRhLCBzY2hlbWEpLnByZWZpeFdpdGgoa2V5LCBudWxsKTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLmhhbmRsZUVycm9yKGVycm9yKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChlcnJvciA9IHRoaXMudmFsaWRhdGVBbGwoZGF0YVtrZXldLCBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsIFtrZXldLCBbXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiXSwga2V5UG9pbnRlclBhdGgpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcyAmJiAhdGhpcy5rbm93blByb3BlcnR5UGF0aHNba2V5UG9pbnRlclBhdGhdKSB7XG5cdFx0XHRcdHRoaXMudW5rbm93blByb3BlcnR5UGF0aHNba2V5UG9pbnRlclBhdGhdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcykge1xuXHRcdFx0dGhpcy5rbm93blByb3BlcnR5UGF0aHNba2V5UG9pbnRlclBhdGhdID0gdHJ1ZTtcblx0XHRcdGRlbGV0ZSB0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzW2tleVBvaW50ZXJQYXRoXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZU9iamVjdERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0RGVwZW5kZW5jaWVzKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdHZhciBlcnJvcjtcblx0aWYgKHNjaGVtYS5kZXBlbmRlbmNpZXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdGZvciAodmFyIGRlcEtleSBpbiBzY2hlbWEuZGVwZW5kZW5jaWVzKSB7XG5cdFx0XHRpZiAoZGF0YVtkZXBLZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dmFyIGRlcCA9IHNjaGVtYS5kZXBlbmRlbmNpZXNbZGVwS2V5XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBkZXAgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRpZiAoZGF0YVtkZXBdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk9CSkVDVF9ERVBFTkRFTkNZX0tFWSwge2tleTogZGVwS2V5LCBtaXNzaW5nOiBkZXB9LCAnJywgJycsIG51bGwsIGRhdGEsIHNjaGVtYSkucHJlZml4V2l0aChudWxsLCBkZXBLZXkpLnByZWZpeFdpdGgobnVsbCwgXCJkZXBlbmRlbmNpZXNcIik7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRlcCkpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyIHJlcXVpcmVkS2V5ID0gZGVwW2ldO1xuXHRcdFx0XHRcdFx0aWYgKGRhdGFbcmVxdWlyZWRLZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0ZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuT0JKRUNUX0RFUEVOREVOQ1lfS0VZLCB7a2V5OiBkZXBLZXksIG1pc3Npbmc6IHJlcXVpcmVkS2V5fSwgJycsICcvJyArIGksIG51bGwsIGRhdGEsIHNjaGVtYSkucHJlZml4V2l0aChudWxsLCBkZXBLZXkpLnByZWZpeFdpdGgobnVsbCwgXCJkZXBlbmRlbmNpZXNcIik7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLmhhbmRsZUVycm9yKGVycm9yKSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoZXJyb3IgPSB0aGlzLnZhbGlkYXRlQWxsKGRhdGEsIGRlcCwgW10sIFtcImRlcGVuZGVuY2llc1wiLCBkZXBLZXldLCBkYXRhUG9pbnRlclBhdGgpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVDb21iaW5hdGlvbnMgPSBmdW5jdGlvbiB2YWxpZGF0ZUNvbWJpbmF0aW9ucyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCkge1xuXHRyZXR1cm4gdGhpcy52YWxpZGF0ZUFsbE9mKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVBbnlPZihkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlT25lT2YoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZU5vdChkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVBbGxPZiA9IGZ1bmN0aW9uIHZhbGlkYXRlQWxsT2YoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0aWYgKHNjaGVtYS5hbGxPZiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dmFyIGVycm9yO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYS5hbGxPZi5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBzdWJTY2hlbWEgPSBzY2hlbWEuYWxsT2ZbaV07XG5cdFx0aWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhLCBzdWJTY2hlbWEsIFtdLCBbXCJhbGxPZlwiLCBpXSwgZGF0YVBvaW50ZXJQYXRoKSkge1xuXHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlQW55T2YgPSBmdW5jdGlvbiB2YWxpZGF0ZUFueU9mKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdGlmIChzY2hlbWEuYW55T2YgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHZhciBlcnJvcnMgPSBbXTtcblx0dmFyIHN0YXJ0RXJyb3JDb3VudCA9IHRoaXMuZXJyb3JzLmxlbmd0aDtcblx0dmFyIG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzLCBvbGRLbm93blByb3BlcnR5UGF0aHM7XG5cdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRvbGRVbmtub3duUHJvcGVydHlQYXRocyA9IHRoaXMudW5rbm93blByb3BlcnR5UGF0aHM7XG5cdFx0b2xkS25vd25Qcm9wZXJ0eVBhdGhzID0gdGhpcy5rbm93blByb3BlcnR5UGF0aHM7XG5cdH1cblx0dmFyIGVycm9yQXRFbmQgPSB0cnVlO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYS5hbnlPZi5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRcdHRoaXMudW5rbm93blByb3BlcnR5UGF0aHMgPSB7fTtcblx0XHRcdHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzID0ge307XG5cdFx0fVxuXHRcdHZhciBzdWJTY2hlbWEgPSBzY2hlbWEuYW55T2ZbaV07XG5cblx0XHR2YXIgZXJyb3JDb3VudCA9IHRoaXMuZXJyb3JzLmxlbmd0aDtcblx0XHR2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRlQWxsKGRhdGEsIHN1YlNjaGVtYSwgW10sIFtcImFueU9mXCIsIGldLCBkYXRhUG9pbnRlclBhdGgpO1xuXG5cdFx0aWYgKGVycm9yID09PSBudWxsICYmIGVycm9yQ291bnQgPT09IHRoaXMuZXJyb3JzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycy5zbGljZSgwLCBzdGFydEVycm9yQ291bnQpO1xuXG5cdFx0XHRpZiAodGhpcy50cmFja1Vua25vd25Qcm9wZXJ0aWVzKSB7XG5cdFx0XHRcdGZvciAodmFyIGtub3duS2V5IGluIHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzKSB7XG5cdFx0XHRcdFx0b2xkS25vd25Qcm9wZXJ0eVBhdGhzW2tub3duS2V5XSA9IHRydWU7XG5cdFx0XHRcdFx0ZGVsZXRlIG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzW2tub3duS2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHZhciB1bmtub3duS2V5IGluIHRoaXMudW5rbm93blByb3BlcnR5UGF0aHMpIHtcblx0XHRcdFx0XHRpZiAoIW9sZEtub3duUHJvcGVydHlQYXRoc1t1bmtub3duS2V5XSkge1xuXHRcdFx0XHRcdFx0b2xkVW5rbm93blByb3BlcnR5UGF0aHNbdW5rbm93bktleV0gPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBXZSBuZWVkIHRvIGNvbnRpbnVlIGxvb3Bpbmcgc28gd2UgY2F0Y2ggYWxsIHRoZSBwcm9wZXJ0eSBkZWZpbml0aW9ucywgYnV0IHdlIGRvbid0IHdhbnQgdG8gcmV0dXJuIGFuIGVycm9yXG5cdFx0XHRcdGVycm9yQXRFbmQgPSBmYWxzZTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdGVycm9ycy5wdXNoKGVycm9yLnByZWZpeFdpdGgobnVsbCwgXCJcIiArIGkpLnByZWZpeFdpdGgobnVsbCwgXCJhbnlPZlwiKSk7XG5cdFx0fVxuXHR9XG5cdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHR0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzID0gb2xkVW5rbm93blByb3BlcnR5UGF0aHM7XG5cdFx0dGhpcy5rbm93blByb3BlcnR5UGF0aHMgPSBvbGRLbm93blByb3BlcnR5UGF0aHM7XG5cdH1cblx0aWYgKGVycm9yQXRFbmQpIHtcblx0XHRlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHRoaXMuZXJyb3JzLnNsaWNlKHN0YXJ0RXJyb3JDb3VudCkpO1xuXHRcdHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMuc2xpY2UoMCwgc3RhcnRFcnJvckNvdW50KTtcblx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLkFOWV9PRl9NSVNTSU5HLCB7fSwgXCJcIiwgXCIvYW55T2ZcIiwgZXJyb3JzLCBkYXRhLCBzY2hlbWEpO1xuXHR9XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZU9uZU9mID0gZnVuY3Rpb24gdmFsaWRhdGVPbmVPZihkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCkge1xuXHRpZiAoc2NoZW1hLm9uZU9mID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR2YXIgdmFsaWRJbmRleCA9IG51bGw7XG5cdHZhciBlcnJvcnMgPSBbXTtcblx0dmFyIHN0YXJ0RXJyb3JDb3VudCA9IHRoaXMuZXJyb3JzLmxlbmd0aDtcblx0dmFyIG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzLCBvbGRLbm93blByb3BlcnR5UGF0aHM7XG5cdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRvbGRVbmtub3duUHJvcGVydHlQYXRocyA9IHRoaXMudW5rbm93blByb3BlcnR5UGF0aHM7XG5cdFx0b2xkS25vd25Qcm9wZXJ0eVBhdGhzID0gdGhpcy5rbm93blByb3BlcnR5UGF0aHM7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzY2hlbWEub25lT2YubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAodGhpcy50cmFja1Vua25vd25Qcm9wZXJ0aWVzKSB7XG5cdFx0XHR0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzID0ge307XG5cdFx0XHR0aGlzLmtub3duUHJvcGVydHlQYXRocyA9IHt9O1xuXHRcdH1cblx0XHR2YXIgc3ViU2NoZW1hID0gc2NoZW1hLm9uZU9mW2ldO1xuXG5cdFx0dmFyIGVycm9yQ291bnQgPSB0aGlzLmVycm9ycy5sZW5ndGg7XG5cdFx0dmFyIGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhLCBzdWJTY2hlbWEsIFtdLCBbXCJvbmVPZlwiLCBpXSwgZGF0YVBvaW50ZXJQYXRoKTtcblxuXHRcdGlmIChlcnJvciA9PT0gbnVsbCAmJiBlcnJvckNvdW50ID09PSB0aGlzLmVycm9ycy5sZW5ndGgpIHtcblx0XHRcdGlmICh2YWxpZEluZGV4ID09PSBudWxsKSB7XG5cdFx0XHRcdHZhbGlkSW5kZXggPSBpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycy5zbGljZSgwLCBzdGFydEVycm9yQ291bnQpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk9ORV9PRl9NVUxUSVBMRSwge2luZGV4MTogdmFsaWRJbmRleCwgaW5kZXgyOiBpfSwgXCJcIiwgXCIvb25lT2ZcIiwgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRcdFx0Zm9yICh2YXIga25vd25LZXkgaW4gdGhpcy5rbm93blByb3BlcnR5UGF0aHMpIHtcblx0XHRcdFx0XHRvbGRLbm93blByb3BlcnR5UGF0aHNba25vd25LZXldID0gdHJ1ZTtcblx0XHRcdFx0XHRkZWxldGUgb2xkVW5rbm93blByb3BlcnR5UGF0aHNba25vd25LZXldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAodmFyIHVua25vd25LZXkgaW4gdGhpcy51bmtub3duUHJvcGVydHlQYXRocykge1xuXHRcdFx0XHRcdGlmICghb2xkS25vd25Qcm9wZXJ0eVBhdGhzW3Vua25vd25LZXldKSB7XG5cdFx0XHRcdFx0XHRvbGRVbmtub3duUHJvcGVydHlQYXRoc1t1bmtub3duS2V5XSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChlcnJvcikge1xuXHRcdFx0ZXJyb3JzLnB1c2goZXJyb3IpO1xuXHRcdH1cblx0fVxuXHRpZiAodGhpcy50cmFja1Vua25vd25Qcm9wZXJ0aWVzKSB7XG5cdFx0dGhpcy51bmtub3duUHJvcGVydHlQYXRocyA9IG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzO1xuXHRcdHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzID0gb2xkS25vd25Qcm9wZXJ0eVBhdGhzO1xuXHR9XG5cdGlmICh2YWxpZEluZGV4ID09PSBudWxsKSB7XG5cdFx0ZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh0aGlzLmVycm9ycy5zbGljZShzdGFydEVycm9yQ291bnQpKTtcblx0XHR0aGlzLmVycm9ycyA9IHRoaXMuZXJyb3JzLnNsaWNlKDAsIHN0YXJ0RXJyb3JDb3VudCk7XG5cdFx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5PTkVfT0ZfTUlTU0lORywge30sIFwiXCIsIFwiL29uZU9mXCIsIGVycm9ycywgZGF0YSwgc2NoZW1hKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmVycm9ycyA9IHRoaXMuZXJyb3JzLnNsaWNlKDAsIHN0YXJ0RXJyb3JDb3VudCk7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZU5vdCA9IGZ1bmN0aW9uIHZhbGlkYXRlTm90KGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdGlmIChzY2hlbWEubm90ID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR2YXIgb2xkRXJyb3JDb3VudCA9IHRoaXMuZXJyb3JzLmxlbmd0aDtcblx0dmFyIG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzLCBvbGRLbm93blByb3BlcnR5UGF0aHM7XG5cdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRvbGRVbmtub3duUHJvcGVydHlQYXRocyA9IHRoaXMudW5rbm93blByb3BlcnR5UGF0aHM7XG5cdFx0b2xkS25vd25Qcm9wZXJ0eVBhdGhzID0gdGhpcy5rbm93blByb3BlcnR5UGF0aHM7XG5cdFx0dGhpcy51bmtub3duUHJvcGVydHlQYXRocyA9IHt9O1xuXHRcdHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzID0ge307XG5cdH1cblx0dmFyIGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhLCBzY2hlbWEubm90LCBudWxsLCBudWxsLCBkYXRhUG9pbnRlclBhdGgpO1xuXHR2YXIgbm90RXJyb3JzID0gdGhpcy5lcnJvcnMuc2xpY2Uob2xkRXJyb3JDb3VudCk7XG5cdHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMuc2xpY2UoMCwgb2xkRXJyb3JDb3VudCk7XG5cdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHR0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzID0gb2xkVW5rbm93blByb3BlcnR5UGF0aHM7XG5cdFx0dGhpcy5rbm93blByb3BlcnR5UGF0aHMgPSBvbGRLbm93blByb3BlcnR5UGF0aHM7XG5cdH1cblx0aWYgKGVycm9yID09PSBudWxsICYmIG5vdEVycm9ycy5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk5PVF9QQVNTRUQsIHt9LCBcIlwiLCBcIi9ub3RcIiwgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlSHlwZXJtZWRpYSA9IGZ1bmN0aW9uIHZhbGlkYXRlQ29tYmluYXRpb25zKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdGlmICghc2NoZW1hLmxpbmtzKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dmFyIGVycm9yO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYS5saW5rcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBsZG8gPSBzY2hlbWEubGlua3NbaV07XG5cdFx0aWYgKGxkby5yZWwgPT09IFwiZGVzY3JpYmVkYnlcIikge1xuXHRcdFx0dmFyIHRlbXBsYXRlID0gbmV3IFVyaVRlbXBsYXRlKGxkby5ocmVmKTtcblx0XHRcdHZhciBhbGxQcmVzZW50ID0gdHJ1ZTtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgdGVtcGxhdGUudmFyTmFtZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0aWYgKCEodGVtcGxhdGUudmFyTmFtZXNbal0gaW4gZGF0YSkpIHtcblx0XHRcdFx0XHRhbGxQcmVzZW50ID0gZmFsc2U7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChhbGxQcmVzZW50KSB7XG5cdFx0XHRcdHZhciBzY2hlbWFVcmwgPSB0ZW1wbGF0ZS5maWxsRnJvbU9iamVjdChkYXRhKTtcblx0XHRcdFx0dmFyIHN1YlNjaGVtYSA9IHtcIiRyZWZcIjogc2NoZW1hVXJsfTtcblx0XHRcdFx0aWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhLCBzdWJTY2hlbWEsIFtdLCBbXCJsaW5rc1wiLCBpXSwgZGF0YVBvaW50ZXJQYXRoKSkge1xuXHRcdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gcGFyc2VVUkkoKSBhbmQgcmVzb2x2ZVVybCgpIGFyZSBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzEwODg4NTBcbi8vICAgLSAgcmVsZWFzZWQgYXMgcHVibGljIGRvbWFpbiBieSBhdXRob3IgKFwiWWFmZmxlXCIpIC0gc2VlIGNvbW1lbnRzIG9uIGdpc3RcblxuZnVuY3Rpb24gcGFyc2VVUkkodXJsKSB7XG5cdHZhciBtID0gU3RyaW5nKHVybCkucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpLm1hdGNoKC9eKFteOlxcLz8jXSs6KT8oXFwvXFwvKD86W146QF0qKD86OlteOkBdKik/QCk/KChbXjpcXC8/I10qKSg/OjooXFxkKikpPykpPyhbXj8jXSopKFxcP1teI10qKT8oI1tcXHNcXFNdKik/Lyk7XG5cdC8vIGF1dGhvcml0eSA9ICcvLycgKyB1c2VyICsgJzonICsgcGFzcyAnQCcgKyBob3N0bmFtZSArICc6JyBwb3J0XG5cdHJldHVybiAobSA/IHtcblx0XHRocmVmICAgICA6IG1bMF0gfHwgJycsXG5cdFx0cHJvdG9jb2wgOiBtWzFdIHx8ICcnLFxuXHRcdGF1dGhvcml0eTogbVsyXSB8fCAnJyxcblx0XHRob3N0ICAgICA6IG1bM10gfHwgJycsXG5cdFx0aG9zdG5hbWUgOiBtWzRdIHx8ICcnLFxuXHRcdHBvcnQgICAgIDogbVs1XSB8fCAnJyxcblx0XHRwYXRobmFtZSA6IG1bNl0gfHwgJycsXG5cdFx0c2VhcmNoICAgOiBtWzddIHx8ICcnLFxuXHRcdGhhc2ggICAgIDogbVs4XSB8fCAnJ1xuXHR9IDogbnVsbCk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVVcmwoYmFzZSwgaHJlZikgey8vIFJGQyAzOTg2XG5cblx0ZnVuY3Rpb24gcmVtb3ZlRG90U2VnbWVudHMoaW5wdXQpIHtcblx0XHR2YXIgb3V0cHV0ID0gW107XG5cdFx0aW5wdXQucmVwbGFjZSgvXihcXC5cXC4/KFxcL3wkKSkrLywgJycpXG5cdFx0XHQucmVwbGFjZSgvXFwvKFxcLihcXC98JCkpKy9nLCAnLycpXG5cdFx0XHQucmVwbGFjZSgvXFwvXFwuXFwuJC8sICcvLi4vJylcblx0XHRcdC5yZXBsYWNlKC9cXC8/W15cXC9dKi9nLCBmdW5jdGlvbiAocCkge1xuXHRcdFx0XHRpZiAocCA9PT0gJy8uLicpIHtcblx0XHRcdFx0XHRvdXRwdXQucG9wKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3V0cHV0LnB1c2gocCk7XG5cdFx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpLnJlcGxhY2UoL15cXC8vLCBpbnB1dC5jaGFyQXQoMCkgPT09ICcvJyA/ICcvJyA6ICcnKTtcblx0fVxuXG5cdGhyZWYgPSBwYXJzZVVSSShocmVmIHx8ICcnKTtcblx0YmFzZSA9IHBhcnNlVVJJKGJhc2UgfHwgJycpO1xuXG5cdHJldHVybiAhaHJlZiB8fCAhYmFzZSA/IG51bGwgOiAoaHJlZi5wcm90b2NvbCB8fCBiYXNlLnByb3RvY29sKSArXG5cdFx0KGhyZWYucHJvdG9jb2wgfHwgaHJlZi5hdXRob3JpdHkgPyBocmVmLmF1dGhvcml0eSA6IGJhc2UuYXV0aG9yaXR5KSArXG5cdFx0cmVtb3ZlRG90U2VnbWVudHMoaHJlZi5wcm90b2NvbCB8fCBocmVmLmF1dGhvcml0eSB8fCBocmVmLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nID8gaHJlZi5wYXRobmFtZSA6IChocmVmLnBhdGhuYW1lID8gKChiYXNlLmF1dGhvcml0eSAmJiAhYmFzZS5wYXRobmFtZSA/ICcvJyA6ICcnKSArIGJhc2UucGF0aG5hbWUuc2xpY2UoMCwgYmFzZS5wYXRobmFtZS5sYXN0SW5kZXhPZignLycpICsgMSkgKyBocmVmLnBhdGhuYW1lKSA6IGJhc2UucGF0aG5hbWUpKSArXG5cdFx0KGhyZWYucHJvdG9jb2wgfHwgaHJlZi5hdXRob3JpdHkgfHwgaHJlZi5wYXRobmFtZSA/IGhyZWYuc2VhcmNoIDogKGhyZWYuc2VhcmNoIHx8IGJhc2Uuc2VhcmNoKSkgK1xuXHRcdGhyZWYuaGFzaDtcbn1cblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRVcmkodXJpKSB7XG5cdHJldHVybiB1cmkuc3BsaXQoJyMnKVswXTtcbn1cbmZ1bmN0aW9uIG5vcm1TY2hlbWEoc2NoZW1hLCBiYXNlVXJpKSB7XG5cdGlmIChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIikge1xuXHRcdGlmIChiYXNlVXJpID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGJhc2VVcmkgPSBzY2hlbWEuaWQ7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hLmlkID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRiYXNlVXJpID0gcmVzb2x2ZVVybChiYXNlVXJpLCBzY2hlbWEuaWQpO1xuXHRcdFx0c2NoZW1hLmlkID0gYmFzZVVyaTtcblx0XHR9XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzY2hlbWEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0bm9ybVNjaGVtYShzY2hlbWFbaV0sIGJhc2VVcmkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIHNjaGVtYVsnJHJlZiddID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHNjaGVtYVsnJHJlZiddID0gcmVzb2x2ZVVybChiYXNlVXJpLCBzY2hlbWFbJyRyZWYnXSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG5cdFx0XHRcdGlmIChrZXkgIT09IFwiZW51bVwiKSB7XG5cdFx0XHRcdFx0bm9ybVNjaGVtYShzY2hlbWFba2V5XSwgYmFzZVVyaSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdEVycm9yUmVwb3J0ZXIobGFuZ3VhZ2UpIHtcblx0bGFuZ3VhZ2UgPSBsYW5ndWFnZSB8fCAnZW4nO1xuXG5cdHZhciBlcnJvck1lc3NhZ2VzID0gbGFuZ3VhZ2VzW2xhbmd1YWdlXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0dmFyIG1lc3NhZ2VUZW1wbGF0ZSA9IGVycm9yTWVzc2FnZXNbZXJyb3IuY29kZV0gfHwgRXJyb3JNZXNzYWdlc0RlZmF1bHRbZXJyb3IuY29kZV07XG5cdFx0aWYgKHR5cGVvZiBtZXNzYWdlVGVtcGxhdGUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gXCJVbmtub3duIGVycm9yIGNvZGUgXCIgKyBlcnJvci5jb2RlICsgXCI6IFwiICsgSlNPTi5zdHJpbmdpZnkoZXJyb3IubWVzc2FnZVBhcmFtcyk7XG5cdFx0fVxuXHRcdHZhciBtZXNzYWdlUGFyYW1zID0gZXJyb3IucGFyYW1zO1xuXHRcdC8vIEFkYXB0ZWQgZnJvbSBDcm9ja2ZvcmQncyBzdXBwbGFudCgpXG5cdFx0cmV0dXJuIG1lc3NhZ2VUZW1wbGF0ZS5yZXBsYWNlKC9cXHsoW157fV0qKVxcfS9nLCBmdW5jdGlvbiAod2hvbGUsIHZhck5hbWUpIHtcblx0XHRcdHZhciBzdWJWYWx1ZSA9IG1lc3NhZ2VQYXJhbXNbdmFyTmFtZV07XG5cdFx0XHRyZXR1cm4gdHlwZW9mIHN1YlZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygc3ViVmFsdWUgPT09ICdudW1iZXInID8gc3ViVmFsdWUgOiB3aG9sZTtcblx0XHR9KTtcblx0fTtcbn1cblxudmFyIEVycm9yQ29kZXMgPSB7XG5cdElOVkFMSURfVFlQRTogMCxcblx0RU5VTV9NSVNNQVRDSDogMSxcblx0QU5ZX09GX01JU1NJTkc6IDEwLFxuXHRPTkVfT0ZfTUlTU0lORzogMTEsXG5cdE9ORV9PRl9NVUxUSVBMRTogMTIsXG5cdE5PVF9QQVNTRUQ6IDEzLFxuXHQvLyBOdW1lcmljIGVycm9yc1xuXHROVU1CRVJfTVVMVElQTEVfT0Y6IDEwMCxcblx0TlVNQkVSX01JTklNVU06IDEwMSxcblx0TlVNQkVSX01JTklNVU1fRVhDTFVTSVZFOiAxMDIsXG5cdE5VTUJFUl9NQVhJTVVNOiAxMDMsXG5cdE5VTUJFUl9NQVhJTVVNX0VYQ0xVU0lWRTogMTA0LFxuXHROVU1CRVJfTk9UX0FfTlVNQkVSOiAxMDUsXG5cdC8vIFN0cmluZyBlcnJvcnNcblx0U1RSSU5HX0xFTkdUSF9TSE9SVDogMjAwLFxuXHRTVFJJTkdfTEVOR1RIX0xPTkc6IDIwMSxcblx0U1RSSU5HX1BBVFRFUk46IDIwMixcblx0Ly8gT2JqZWN0IGVycm9yc1xuXHRPQkpFQ1RfUFJPUEVSVElFU19NSU5JTVVNOiAzMDAsXG5cdE9CSkVDVF9QUk9QRVJUSUVTX01BWElNVU06IDMwMSxcblx0T0JKRUNUX1JFUVVJUkVEOiAzMDIsXG5cdE9CSkVDVF9BRERJVElPTkFMX1BST1BFUlRJRVM6IDMwMyxcblx0T0JKRUNUX0RFUEVOREVOQ1lfS0VZOiAzMDQsXG5cdC8vIEFycmF5IGVycm9yc1xuXHRBUlJBWV9MRU5HVEhfU0hPUlQ6IDQwMCxcblx0QVJSQVlfTEVOR1RIX0xPTkc6IDQwMSxcblx0QVJSQVlfVU5JUVVFOiA0MDIsXG5cdEFSUkFZX0FERElUSU9OQUxfSVRFTVM6IDQwMyxcblx0Ly8gQ3VzdG9tL3VzZXItZGVmaW5lZCBlcnJvcnNcblx0Rk9STUFUX0NVU1RPTTogNTAwLFxuXHRLRVlXT1JEX0NVU1RPTTogNTAxLFxuXHQvLyBTY2hlbWEgc3RydWN0dXJlXG5cdENJUkNVTEFSX1JFRkVSRU5DRTogNjAwLFxuXHQvLyBOb24tc3RhbmRhcmQgdmFsaWRhdGlvbiBvcHRpb25zXG5cdFVOS05PV05fUFJPUEVSVFk6IDEwMDBcbn07XG52YXIgRXJyb3JDb2RlTG9va3VwID0ge307XG5mb3IgKHZhciBrZXkgaW4gRXJyb3JDb2Rlcykge1xuXHRFcnJvckNvZGVMb29rdXBbRXJyb3JDb2Rlc1trZXldXSA9IGtleTtcbn1cbnZhciBFcnJvck1lc3NhZ2VzRGVmYXVsdCA9IHtcblx0SU5WQUxJRF9UWVBFOiBcIkludmFsaWQgdHlwZToge3R5cGV9IChleHBlY3RlZCB7ZXhwZWN0ZWR9KVwiLFxuXHRFTlVNX01JU01BVENIOiBcIk5vIGVudW0gbWF0Y2ggZm9yOiB7dmFsdWV9XCIsXG5cdEFOWV9PRl9NSVNTSU5HOiBcIkRhdGEgZG9lcyBub3QgbWF0Y2ggYW55IHNjaGVtYXMgZnJvbSBcXFwiYW55T2ZcXFwiXCIsXG5cdE9ORV9PRl9NSVNTSU5HOiBcIkRhdGEgZG9lcyBub3QgbWF0Y2ggYW55IHNjaGVtYXMgZnJvbSBcXFwib25lT2ZcXFwiXCIsXG5cdE9ORV9PRl9NVUxUSVBMRTogXCJEYXRhIGlzIHZhbGlkIGFnYWluc3QgbW9yZSB0aGFuIG9uZSBzY2hlbWEgZnJvbSBcXFwib25lT2ZcXFwiOiBpbmRpY2VzIHtpbmRleDF9IGFuZCB7aW5kZXgyfVwiLFxuXHROT1RfUEFTU0VEOiBcIkRhdGEgbWF0Y2hlcyBzY2hlbWEgZnJvbSBcXFwibm90XFxcIlwiLFxuXHQvLyBOdW1lcmljIGVycm9yc1xuXHROVU1CRVJfTVVMVElQTEVfT0Y6IFwiVmFsdWUge3ZhbHVlfSBpcyBub3QgYSBtdWx0aXBsZSBvZiB7bXVsdGlwbGVPZn1cIixcblx0TlVNQkVSX01JTklNVU06IFwiVmFsdWUge3ZhbHVlfSBpcyBsZXNzIHRoYW4gbWluaW11bSB7bWluaW11bX1cIixcblx0TlVNQkVSX01JTklNVU1fRVhDTFVTSVZFOiBcIlZhbHVlIHt2YWx1ZX0gaXMgZXF1YWwgdG8gZXhjbHVzaXZlIG1pbmltdW0ge21pbmltdW19XCIsXG5cdE5VTUJFUl9NQVhJTVVNOiBcIlZhbHVlIHt2YWx1ZX0gaXMgZ3JlYXRlciB0aGFuIG1heGltdW0ge21heGltdW19XCIsXG5cdE5VTUJFUl9NQVhJTVVNX0VYQ0xVU0lWRTogXCJWYWx1ZSB7dmFsdWV9IGlzIGVxdWFsIHRvIGV4Y2x1c2l2ZSBtYXhpbXVtIHttYXhpbXVtfVwiLFxuXHROVU1CRVJfTk9UX0FfTlVNQkVSOiBcIlZhbHVlIHt2YWx1ZX0gaXMgbm90IGEgdmFsaWQgbnVtYmVyXCIsXG5cdC8vIFN0cmluZyBlcnJvcnNcblx0U1RSSU5HX0xFTkdUSF9TSE9SVDogXCJTdHJpbmcgaXMgdG9vIHNob3J0ICh7bGVuZ3RofSBjaGFycyksIG1pbmltdW0ge21pbmltdW19XCIsXG5cdFNUUklOR19MRU5HVEhfTE9ORzogXCJTdHJpbmcgaXMgdG9vIGxvbmcgKHtsZW5ndGh9IGNoYXJzKSwgbWF4aW11bSB7bWF4aW11bX1cIixcblx0U1RSSU5HX1BBVFRFUk46IFwiU3RyaW5nIGRvZXMgbm90IG1hdGNoIHBhdHRlcm46IHtwYXR0ZXJufVwiLFxuXHQvLyBPYmplY3QgZXJyb3JzXG5cdE9CSkVDVF9QUk9QRVJUSUVTX01JTklNVU06IFwiVG9vIGZldyBwcm9wZXJ0aWVzIGRlZmluZWQgKHtwcm9wZXJ0eUNvdW50fSksIG1pbmltdW0ge21pbmltdW19XCIsXG5cdE9CSkVDVF9QUk9QRVJUSUVTX01BWElNVU06IFwiVG9vIG1hbnkgcHJvcGVydGllcyBkZWZpbmVkICh7cHJvcGVydHlDb3VudH0pLCBtYXhpbXVtIHttYXhpbXVtfVwiLFxuXHRPQkpFQ1RfUkVRVUlSRUQ6IFwiTWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eToge2tleX1cIixcblx0T0JKRUNUX0FERElUSU9OQUxfUFJPUEVSVElFUzogXCJBZGRpdGlvbmFsIHByb3BlcnRpZXMgbm90IGFsbG93ZWRcIixcblx0T0JKRUNUX0RFUEVOREVOQ1lfS0VZOiBcIkRlcGVuZGVuY3kgZmFpbGVkIC0ga2V5IG11c3QgZXhpc3Q6IHttaXNzaW5nfSAoZHVlIHRvIGtleToge2tleX0pXCIsXG5cdC8vIEFycmF5IGVycm9yc1xuXHRBUlJBWV9MRU5HVEhfU0hPUlQ6IFwiQXJyYXkgaXMgdG9vIHNob3J0ICh7bGVuZ3RofSksIG1pbmltdW0ge21pbmltdW19XCIsXG5cdEFSUkFZX0xFTkdUSF9MT05HOiBcIkFycmF5IGlzIHRvbyBsb25nICh7bGVuZ3RofSksIG1heGltdW0ge21heGltdW19XCIsXG5cdEFSUkFZX1VOSVFVRTogXCJBcnJheSBpdGVtcyBhcmUgbm90IHVuaXF1ZSAoaW5kaWNlcyB7bWF0Y2gxfSBhbmQge21hdGNoMn0pXCIsXG5cdEFSUkFZX0FERElUSU9OQUxfSVRFTVM6IFwiQWRkaXRpb25hbCBpdGVtcyBub3QgYWxsb3dlZFwiLFxuXHQvLyBGb3JtYXQgZXJyb3JzXG5cdEZPUk1BVF9DVVNUT006IFwiRm9ybWF0IHZhbGlkYXRpb24gZmFpbGVkICh7bWVzc2FnZX0pXCIsXG5cdEtFWVdPUkRfQ1VTVE9NOiBcIktleXdvcmQgZmFpbGVkOiB7a2V5fSAoe21lc3NhZ2V9KVwiLFxuXHQvLyBTY2hlbWEgc3RydWN0dXJlXG5cdENJUkNVTEFSX1JFRkVSRU5DRTogXCJDaXJjdWxhciAkcmVmczoge3VybHN9XCIsXG5cdC8vIE5vbi1zdGFuZGFyZCB2YWxpZGF0aW9uIG9wdGlvbnNcblx0VU5LTk9XTl9QUk9QRVJUWTogXCJVbmtub3duIHByb3BlcnR5IChub3QgaW4gc2NoZW1hKVwiXG59O1xuXG5mdW5jdGlvbiBWYWxpZGF0aW9uRXJyb3IoY29kZSwgcGFyYW1zLCBkYXRhUGF0aCwgc2NoZW1hUGF0aCwgc3ViRXJyb3JzKSB7XG5cdEVycm9yLmNhbGwodGhpcyk7XG5cdGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IgKFwiTm8gZXJyb3IgY29kZSBzdXBwbGllZDogXCIgKyBzY2hlbWFQYXRoKTtcblx0fVxuXHR0aGlzLm1lc3NhZ2UgPSAnJztcblx0dGhpcy5wYXJhbXMgPSBwYXJhbXM7XG5cdHRoaXMuY29kZSA9IGNvZGU7XG5cdHRoaXMuZGF0YVBhdGggPSBkYXRhUGF0aCB8fCBcIlwiO1xuXHR0aGlzLnNjaGVtYVBhdGggPSBzY2hlbWFQYXRoIHx8IFwiXCI7XG5cdHRoaXMuc3ViRXJyb3JzID0gc3ViRXJyb3JzIHx8IG51bGw7XG5cblx0dmFyIGVyciA9IG5ldyBFcnJvcih0aGlzLm1lc3NhZ2UpO1xuXHR0aGlzLnN0YWNrID0gZXJyLnN0YWNrIHx8IGVyci5zdGFja3RyYWNlO1xuXHRpZiAoIXRoaXMuc3RhY2spIHtcblx0XHR0cnkge1xuXHRcdFx0dGhyb3cgZXJyO1xuXHRcdH1cblx0XHRjYXRjaChlcnIpIHtcblx0XHRcdHRoaXMuc3RhY2sgPSBlcnIuc3RhY2sgfHwgZXJyLnN0YWNrdHJhY2U7XG5cdFx0fVxuXHR9XG59XG5WYWxpZGF0aW9uRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZhbGlkYXRpb25FcnJvcjtcblZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdWYWxpZGF0aW9uRXJyb3InO1xuXG5WYWxpZGF0aW9uRXJyb3IucHJvdG90eXBlLnByZWZpeFdpdGggPSBmdW5jdGlvbiAoZGF0YVByZWZpeCwgc2NoZW1hUHJlZml4KSB7XG5cdGlmIChkYXRhUHJlZml4ICE9PSBudWxsKSB7XG5cdFx0ZGF0YVByZWZpeCA9IGRhdGFQcmVmaXgucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcLy9nLCBcIn4xXCIpO1xuXHRcdHRoaXMuZGF0YVBhdGggPSBcIi9cIiArIGRhdGFQcmVmaXggKyB0aGlzLmRhdGFQYXRoO1xuXHR9XG5cdGlmIChzY2hlbWFQcmVmaXggIT09IG51bGwpIHtcblx0XHRzY2hlbWFQcmVmaXggPSBzY2hlbWFQcmVmaXgucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcLy9nLCBcIn4xXCIpO1xuXHRcdHRoaXMuc2NoZW1hUGF0aCA9IFwiL1wiICsgc2NoZW1hUHJlZml4ICsgdGhpcy5zY2hlbWFQYXRoO1xuXHR9XG5cdGlmICh0aGlzLnN1YkVycm9ycyAhPT0gbnVsbCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJFcnJvcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMuc3ViRXJyb3JzW2ldLnByZWZpeFdpdGgoZGF0YVByZWZpeCwgc2NoZW1hUHJlZml4KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBpc1RydXN0ZWRVcmwoYmFzZVVybCwgdGVzdFVybCkge1xuXHRpZih0ZXN0VXJsLnN1YnN0cmluZygwLCBiYXNlVXJsLmxlbmd0aCkgPT09IGJhc2VVcmwpe1xuXHRcdHZhciByZW1haW5kZXIgPSB0ZXN0VXJsLnN1YnN0cmluZyhiYXNlVXJsLmxlbmd0aCk7XG5cdFx0aWYgKCh0ZXN0VXJsLmxlbmd0aCA+IDAgJiYgdGVzdFVybC5jaGFyQXQoYmFzZVVybC5sZW5ndGggLSAxKSA9PT0gXCIvXCIpXG5cdFx0XHR8fCByZW1haW5kZXIuY2hhckF0KDApID09PSBcIiNcIlxuXHRcdFx0fHwgcmVtYWluZGVyLmNoYXJBdCgwKSA9PT0gXCI/XCIpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbnZhciBsYW5ndWFnZXMgPSB7fTtcbmZ1bmN0aW9uIGNyZWF0ZUFwaShsYW5ndWFnZSkge1xuXHR2YXIgZ2xvYmFsQ29udGV4dCA9IG5ldyBWYWxpZGF0b3JDb250ZXh0KCk7XG5cdHZhciBjdXJyZW50TGFuZ3VhZ2U7XG5cdHZhciBjdXN0b21FcnJvclJlcG9ydGVyO1xuXHR2YXIgYXBpID0ge1xuXHRcdHNldEVycm9yUmVwb3J0ZXI6IGZ1bmN0aW9uIChyZXBvcnRlcikge1xuXHRcdFx0aWYgKHR5cGVvZiByZXBvcnRlciA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubGFuZ3VhZ2UocmVwb3J0ZXIpO1xuXHRcdFx0fVxuXHRcdFx0Y3VzdG9tRXJyb3JSZXBvcnRlciA9IHJlcG9ydGVyO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHRhZGRGb3JtYXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGdsb2JhbENvbnRleHQuYWRkRm9ybWF0LmFwcGx5KGdsb2JhbENvbnRleHQsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblx0XHRsYW5ndWFnZTogZnVuY3Rpb24gKGNvZGUpIHtcblx0XHRcdGlmICghY29kZSkge1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudExhbmd1YWdlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFsYW5ndWFnZXNbY29kZV0pIHtcblx0XHRcdFx0Y29kZSA9IGNvZGUuc3BsaXQoJy0nKVswXTsgLy8gZmFsbCBiYWNrIHRvIGJhc2UgbGFuZ3VhZ2Vcblx0XHRcdH1cblx0XHRcdGlmIChsYW5ndWFnZXNbY29kZV0pIHtcblx0XHRcdFx0Y3VycmVudExhbmd1YWdlID0gY29kZTtcblx0XHRcdFx0cmV0dXJuIGNvZGU7IC8vIHNvIHlvdSBjYW4gdGVsbCBpZiBmYWxsLWJhY2sgaGFzIGhhcHBlbmVkXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRhZGRMYW5ndWFnZTogZnVuY3Rpb24gKGNvZGUsIG1lc3NhZ2VNYXApIHtcblx0XHRcdHZhciBrZXk7XG5cdFx0XHRmb3IgKGtleSBpbiBFcnJvckNvZGVzKSB7XG5cdFx0XHRcdGlmIChtZXNzYWdlTWFwW2tleV0gJiYgIW1lc3NhZ2VNYXBbRXJyb3JDb2Rlc1trZXldXSkge1xuXHRcdFx0XHRcdG1lc3NhZ2VNYXBbRXJyb3JDb2Rlc1trZXldXSA9IG1lc3NhZ2VNYXBba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIHJvb3RDb2RlID0gY29kZS5zcGxpdCgnLScpWzBdO1xuXHRcdFx0aWYgKCFsYW5ndWFnZXNbcm9vdENvZGVdKSB7IC8vIHVzZSBmb3IgYmFzZSBsYW5ndWFnZSBpZiBub3QgeWV0IGRlZmluZWRcblx0XHRcdFx0bGFuZ3VhZ2VzW2NvZGVdID0gbWVzc2FnZU1hcDtcblx0XHRcdFx0bGFuZ3VhZ2VzW3Jvb3RDb2RlXSA9IG1lc3NhZ2VNYXA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsYW5ndWFnZXNbY29kZV0gPSBPYmplY3QuY3JlYXRlKGxhbmd1YWdlc1tyb290Q29kZV0pO1xuXHRcdFx0XHRmb3IgKGtleSBpbiBtZXNzYWdlTWFwKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBsYW5ndWFnZXNbcm9vdENvZGVdW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0XHRsYW5ndWFnZXNbcm9vdENvZGVdW2tleV0gPSBtZXNzYWdlTWFwW2tleV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxhbmd1YWdlc1tjb2RlXVtrZXldID0gbWVzc2FnZU1hcFtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXHRcdGZyZXNoQXBpOiBmdW5jdGlvbiAobGFuZ3VhZ2UpIHtcblx0XHRcdHZhciByZXN1bHQgPSBjcmVhdGVBcGkoKTtcblx0XHRcdGlmIChsYW5ndWFnZSkge1xuXHRcdFx0XHRyZXN1bHQubGFuZ3VhZ2UobGFuZ3VhZ2UpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXHRcdHZhbGlkYXRlOiBmdW5jdGlvbiAoZGF0YSwgc2NoZW1hLCBjaGVja1JlY3Vyc2l2ZSwgYmFuVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRcdHZhciBkZWYgPSBkZWZhdWx0RXJyb3JSZXBvcnRlcihjdXJyZW50TGFuZ3VhZ2UpO1xuXHRcdFx0dmFyIGVycm9yUmVwb3J0ZXIgPSBjdXN0b21FcnJvclJlcG9ydGVyID8gZnVuY3Rpb24gKGVycm9yLCBkYXRhLCBzY2hlbWEpIHtcblx0XHRcdFx0cmV0dXJuIGN1c3RvbUVycm9yUmVwb3J0ZXIoZXJyb3IsIGRhdGEsIHNjaGVtYSkgfHwgZGVmKGVycm9yLCBkYXRhLCBzY2hlbWEpO1xuXHRcdFx0fSA6IGRlZjtcblx0XHRcdHZhciBjb250ZXh0ID0gbmV3IFZhbGlkYXRvckNvbnRleHQoZ2xvYmFsQ29udGV4dCwgZmFsc2UsIGVycm9yUmVwb3J0ZXIsIGNoZWNrUmVjdXJzaXZlLCBiYW5Vbmtub3duUHJvcGVydGllcyk7XG5cdFx0XHRpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRzY2hlbWEgPSB7XCIkcmVmXCI6IHNjaGVtYX07XG5cdFx0XHR9XG5cdFx0XHRjb250ZXh0LmFkZFNjaGVtYShcIlwiLCBzY2hlbWEpO1xuXHRcdFx0dmFyIGVycm9yID0gY29udGV4dC52YWxpZGF0ZUFsbChkYXRhLCBzY2hlbWEsIG51bGwsIG51bGwsIFwiXCIpO1xuXHRcdFx0aWYgKCFlcnJvciAmJiBiYW5Vbmtub3duUHJvcGVydGllcykge1xuXHRcdFx0XHRlcnJvciA9IGNvbnRleHQuYmFuVW5rbm93blByb3BlcnRpZXMoZGF0YSwgc2NoZW1hKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZXJyb3IgPSBlcnJvcjtcblx0XHRcdHRoaXMubWlzc2luZyA9IGNvbnRleHQubWlzc2luZztcblx0XHRcdHRoaXMudmFsaWQgPSAoZXJyb3IgPT09IG51bGwpO1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsaWQ7XG5cdFx0fSxcblx0XHR2YWxpZGF0ZVJlc3VsdDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHt9O1xuXHRcdFx0dGhpcy52YWxpZGF0ZS5hcHBseShyZXN1bHQsIGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cdFx0dmFsaWRhdGVNdWx0aXBsZTogZnVuY3Rpb24gKGRhdGEsIHNjaGVtYSwgY2hlY2tSZWN1cnNpdmUsIGJhblVua25vd25Qcm9wZXJ0aWVzKSB7XG5cdFx0XHR2YXIgZGVmID0gZGVmYXVsdEVycm9yUmVwb3J0ZXIoY3VycmVudExhbmd1YWdlKTtcblx0XHRcdHZhciBlcnJvclJlcG9ydGVyID0gY3VzdG9tRXJyb3JSZXBvcnRlciA/IGZ1bmN0aW9uIChlcnJvciwgZGF0YSwgc2NoZW1hKSB7XG5cdFx0XHRcdHJldHVybiBjdXN0b21FcnJvclJlcG9ydGVyKGVycm9yLCBkYXRhLCBzY2hlbWEpIHx8IGRlZihlcnJvciwgZGF0YSwgc2NoZW1hKTtcblx0XHRcdH0gOiBkZWY7XG5cdFx0XHR2YXIgY29udGV4dCA9IG5ldyBWYWxpZGF0b3JDb250ZXh0KGdsb2JhbENvbnRleHQsIHRydWUsIGVycm9yUmVwb3J0ZXIsIGNoZWNrUmVjdXJzaXZlLCBiYW5Vbmtub3duUHJvcGVydGllcyk7XG5cdFx0XHRpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRzY2hlbWEgPSB7XCIkcmVmXCI6IHNjaGVtYX07XG5cdFx0XHR9XG5cdFx0XHRjb250ZXh0LmFkZFNjaGVtYShcIlwiLCBzY2hlbWEpO1xuXHRcdFx0Y29udGV4dC52YWxpZGF0ZUFsbChkYXRhLCBzY2hlbWEsIG51bGwsIG51bGwsIFwiXCIpO1xuXHRcdFx0aWYgKGJhblVua25vd25Qcm9wZXJ0aWVzKSB7XG5cdFx0XHRcdGNvbnRleHQuYmFuVW5rbm93blByb3BlcnRpZXMoZGF0YSwgc2NoZW1hKTtcblx0XHRcdH1cblx0XHRcdHZhciByZXN1bHQgPSB7fTtcblx0XHRcdHJlc3VsdC5lcnJvcnMgPSBjb250ZXh0LmVycm9ycztcblx0XHRcdHJlc3VsdC5taXNzaW5nID0gY29udGV4dC5taXNzaW5nO1xuXHRcdFx0cmVzdWx0LnZhbGlkID0gKHJlc3VsdC5lcnJvcnMubGVuZ3RoID09PSAwKTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblx0XHRhZGRTY2hlbWE6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBnbG9iYWxDb250ZXh0LmFkZFNjaGVtYS5hcHBseShnbG9iYWxDb250ZXh0LCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cdFx0Z2V0U2NoZW1hOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZ2xvYmFsQ29udGV4dC5nZXRTY2hlbWEuYXBwbHkoZ2xvYmFsQ29udGV4dCwgYXJndW1lbnRzKTtcblx0XHR9LFxuXHRcdGdldFNjaGVtYU1hcDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGdsb2JhbENvbnRleHQuZ2V0U2NoZW1hTWFwLmFwcGx5KGdsb2JhbENvbnRleHQsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblx0XHRnZXRTY2hlbWFVcmlzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZ2xvYmFsQ29udGV4dC5nZXRTY2hlbWFVcmlzLmFwcGx5KGdsb2JhbENvbnRleHQsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblx0XHRnZXRNaXNzaW5nVXJpczogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGdsb2JhbENvbnRleHQuZ2V0TWlzc2luZ1VyaXMuYXBwbHkoZ2xvYmFsQ29udGV4dCwgYXJndW1lbnRzKTtcblx0XHR9LFxuXHRcdGRyb3BTY2hlbWFzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRnbG9iYWxDb250ZXh0LmRyb3BTY2hlbWFzLmFwcGx5KGdsb2JhbENvbnRleHQsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblx0XHRkZWZpbmVLZXl3b3JkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRnbG9iYWxDb250ZXh0LmRlZmluZUtleXdvcmQuYXBwbHkoZ2xvYmFsQ29udGV4dCwgYXJndW1lbnRzKTtcblx0XHR9LFxuXHRcdGRlZmluZUVycm9yOiBmdW5jdGlvbiAoY29kZU5hbWUsIGNvZGVOdW1iZXIsIGRlZmF1bHRNZXNzYWdlKSB7XG5cdFx0XHRpZiAodHlwZW9mIGNvZGVOYW1lICE9PSAnc3RyaW5nJyB8fCAhL15bQS1aXSsoX1tBLVpdKykqJC8udGVzdChjb2RlTmFtZSkpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDb2RlIG5hbWUgbXVzdCBiZSBhIHN0cmluZyBpbiBVUFBFUl9DQVNFX1dJVEhfVU5ERVJTQ09SRVMnKTtcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2YgY29kZU51bWJlciAhPT0gJ251bWJlcicgfHwgY29kZU51bWJlciUxICE9PSAwIHx8IGNvZGVOdW1iZXIgPCAxMDAwMCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvZGUgbnVtYmVyIG11c3QgYmUgYW4gaW50ZWdlciA+IDEwMDAwJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIEVycm9yQ29kZXNbY29kZU5hbWVdICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGFscmVhZHkgZGVmaW5lZDogJyArIGNvZGVOYW1lICsgJyBhcyAnICsgRXJyb3JDb2Rlc1tjb2RlTmFtZV0pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBFcnJvckNvZGVMb29rdXBbY29kZU51bWJlcl0gIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXJyb3IgY29kZSBhbHJlYWR5IHVzZWQ6ICcgKyBFcnJvckNvZGVMb29rdXBbY29kZU51bWJlcl0gKyAnIGFzICcgKyBjb2RlTnVtYmVyKTtcblx0XHRcdH1cblx0XHRcdEVycm9yQ29kZXNbY29kZU5hbWVdID0gY29kZU51bWJlcjtcblx0XHRcdEVycm9yQ29kZUxvb2t1cFtjb2RlTnVtYmVyXSA9IGNvZGVOYW1lO1xuXHRcdFx0RXJyb3JNZXNzYWdlc0RlZmF1bHRbY29kZU5hbWVdID0gRXJyb3JNZXNzYWdlc0RlZmF1bHRbY29kZU51bWJlcl0gPSBkZWZhdWx0TWVzc2FnZTtcblx0XHRcdGZvciAodmFyIGxhbmdDb2RlIGluIGxhbmd1YWdlcykge1xuXHRcdFx0XHR2YXIgbGFuZ3VhZ2UgPSBsYW5ndWFnZXNbbGFuZ0NvZGVdO1xuXHRcdFx0XHRpZiAobGFuZ3VhZ2VbY29kZU5hbWVdKSB7XG5cdFx0XHRcdFx0bGFuZ3VhZ2VbY29kZU51bWJlcl0gPSBsYW5ndWFnZVtjb2RlTnVtYmVyXSB8fCBsYW5ndWFnZVtjb2RlTmFtZV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRnbG9iYWxDb250ZXh0LnJlc2V0KCk7XG5cdFx0XHR0aGlzLmVycm9yID0gbnVsbDtcblx0XHRcdHRoaXMubWlzc2luZyA9IFtdO1xuXHRcdFx0dGhpcy52YWxpZCA9IHRydWU7XG5cdFx0fSxcblx0XHRtaXNzaW5nOiBbXSxcblx0XHRlcnJvcjogbnVsbCxcblx0XHR2YWxpZDogdHJ1ZSxcblx0XHRub3JtU2NoZW1hOiBub3JtU2NoZW1hLFxuXHRcdHJlc29sdmVVcmw6IHJlc29sdmVVcmwsXG5cdFx0Z2V0RG9jdW1lbnRVcmk6IGdldERvY3VtZW50VXJpLFxuXHRcdGVycm9yQ29kZXM6IEVycm9yQ29kZXNcblx0fTtcblx0YXBpLmxhbmd1YWdlKGxhbmd1YWdlIHx8ICdlbicpO1xuXHRyZXR1cm4gYXBpO1xufVxuXG52YXIgdHY0ID0gY3JlYXRlQXBpKCk7XG50djQuYWRkTGFuZ3VhZ2UoJ2VuLWdiJywgRXJyb3JNZXNzYWdlc0RlZmF1bHQpO1xuXG4vL2xlZ2FjeSBwcm9wZXJ0eVxudHY0LnR2NCA9IHR2NDtcblxucmV0dXJuIHR2NDsgLy8gdXNlZCBieSBfaGVhZGVyLmpzIHRvIGdsb2JhbGlzZS5cblxufSkpOyIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIid1c2Ugc3RyaWN0J1xyXG5cclxuLy8gc2V0dXAgdGhlIGRyYWtlIChkcmFndWxhIGluc3RhbmNlKSBmb3Igb3VyIGNvbXBvc2VyIGRyYWcgZHJvcCByZXF1aXJlbWVudHNcclxuY29uc3QgRHJha2UgPSBkZXBzID0+IHtcclxuICBjb25zdCBjbG9uZVNlbGVjdG9yID0gJy5jb21wb3Nlci1ub2RlX190b29sYmFyIFtkYXRhLWRyYWdzb3VyY2U9XCJjb21wb3NlclwiXSdcclxuICBjb25zdCBjb250YWluZXJTZWxlY3RvciA9ICdbZGF0YS1kcmFnc291cmNlPVwiY29tcG9zZXJcIl0nXHJcbiAgY29uc3QgeyB1cGRhdGVOb2RlLCBkcmFndWxhLCBmaW5kLCBvbmRyb3AgfSA9IGRlcHNcclxuXHJcbiAgY29uc3QgaXNDb250YWluZXIgPSBlbCA9PiBlbC5tYXRjaGVzKCBjb250YWluZXJTZWxlY3RvciApXHJcblxyXG4gIGNvbnN0IGFjY2VwdHMgPSAoIGVsLCBjb250YWluZXJFbCApID0+IHtcclxuICAgIGxldCBhY2NlcHRzID0gY29udGFpbmVyRWwubWF0Y2hlcyggY29udGFpbmVyU2VsZWN0b3IgKVxyXG5cclxuICAgIGlmKCBhY2NlcHRzICl7XHJcbiAgICAgIGFjY2VwdHMgPSAhY29udGFpbmVyRWwubWF0Y2hlcyggY2xvbmVTZWxlY3RvciApXHJcbiAgICB9XHJcblxyXG4gICAgaWYoIGFjY2VwdHMgKXtcclxuICAgICAgY29uc3Qgbm9kZSA9IGZpbmQuZWxOb2RlKCBlbCApXHJcbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBmaW5kLmNvbnRhaW5lckVsTm9kZSggY29udGFpbmVyRWwgKVxyXG5cclxuICAgICAgaWYoIG5vZGUgPT09IHBhcmVudE5vZGUgKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgICAgIGFjY2VwdHMgPSBwYXJlbnROb2RlLmFjY2VwdHMoIG5vZGUgKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhY2NlcHRzXHJcbiAgfVxyXG5cclxuICBjb25zdCBvcHRpb25zID0geyBpc0NvbnRhaW5lciwgYWNjZXB0cyB9XHJcblxyXG4gIGNvbnN0IGRyYWtlID0gZHJhZ3VsYSggb3B0aW9ucyApXHJcblxyXG4gIGRyYWtlLm9uKCAnZHJvcCcsICggZWwsIGNvbnRhaW5lckVsLCBzb3VyY2VDb250YWluZXJFbCwgbmV4dEVsICkgPT4ge1xyXG4gICAgY29uc3Qgbm9kZSA9IGZpbmQuZWxOb2RlKCBlbCApXHJcbiAgICBjb25zdCBwYXJlbnROb2RlID0gZmluZC5jb250YWluZXJFbE5vZGUoIGNvbnRhaW5lckVsIClcclxuXHJcbiAgICBpZiggbmV4dEVsICl7XHJcbiAgICAgIGNvbnN0IHJlZmVyZW5jZU5vZGUgPSBmaW5kLmVsTm9kZSggbmV4dEVsIClcclxuICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIG5vZGUsIHJlZmVyZW5jZU5vZGUgKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcGFyZW50Tm9kZS5hcHBlbmQoIG5vZGUgKVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZU5vZGUoIG5vZGUgKVxyXG5cclxuICAgIG9uZHJvcCggbm9kZSwgcGFyZW50Tm9kZSwgZWwsIGNvbnRhaW5lckVsLCBzb3VyY2VDb250YWluZXJFbCwgbmV4dEVsIClcclxuICB9KVxyXG5cclxuICByZXR1cm4gZHJha2VcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEcmFrZVxyXG4iLCIndXNlIHN0cmljdCdcclxuXHJcbi8vIGZ1bmN0aW9ucyBmb3IgZmluZGluZyBkaWZmZXJlbnQgdHJlZSBub2RlIHR5cGVzIGluIHRoZSBjb21wb3NlciBET01cclxuY29uc3QgRmluZCA9IGlkTWFwID0+IHtcclxuICBjb25zdCBub2RlRWwgPSBlbCA9PiBlbC5xdWVyeVNlbGVjdG9yKCAnLmNvbXBvc2VyLW5vZGUnIClcclxuICBjb25zdCBjb250YWluZXJFbCA9IGVsID0+IGVsLmNsb3Nlc3QoICcuY29tcG9zZXItbm9kZScgKVxyXG4gIGNvbnN0IGVsTm9kZSA9IGVsID0+IGlkTWFwLmZpbmRCeUlkKCBub2RlRWwoIGVsICkuaWQgKVxyXG4gIGNvbnN0IGNvbnRhaW5lckVsTm9kZSA9IGVsID0+IGlkTWFwLmZpbmRCeUlkKCBjb250YWluZXJFbCggZWwgKS5pZCApXHJcblxyXG4gIHJldHVybiB7IG5vZGVFbCwgY29udGFpbmVyRWwsIGVsTm9kZSwgY29udGFpbmVyRWxOb2RlIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGaW5kXHJcbiIsIid1c2Ugc3RyaWN0J1xyXG5cclxuLypcclxuICBjYWNoZSB0aGF0IG1hcHMgYmV0d2VlbiB0cmVlIG5vZGVzIGFuZCB0aGVpciBET00gcmVwcmVzZW50YXRpb25zIHVzaW5nIHRoZSBpZFxyXG4gIGF0dHJpYnV0ZVxyXG4qL1xyXG5jb25zdCBJZE1hcCA9IHRyZWUgPT4ge1xyXG4gIGNvbnN0IGlkTWFwID0gbmV3IE1hcCgpXHJcblxyXG4gIGNvbnN0IGZpbmRCeUlkID0gaWQgPT4ge1xyXG4gICAgaWYoIGlkTWFwLmhhcyggaWQgKSApIHJldHVybiBpZE1hcC5nZXQoIGlkIClcclxuXHJcbiAgICBjb25zdCBub2RlID0gdHJlZS5maW5kKCBuID0+IG4uaWQoKSA9PT0gaWQgKVxyXG5cclxuICAgIGlkTWFwLnNldCggaWQsIG5vZGUgKVxyXG5cclxuICAgIHJldHVybiBub2RlXHJcbiAgfVxyXG5cclxuICBjb25zdCByZWZyZXNoID0gbm9kZSA9PiB7XHJcbiAgICBub2RlLndhbGsoIG4gPT4gaWRNYXAuc2V0KCBuLmlkKCksIG4gKSApXHJcbiAgfVxyXG5cclxuICByZWZyZXNoKCB0cmVlIClcclxuXHJcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oIGlkTWFwLCB7IGZpbmRCeUlkLCByZWZyZXNoIH0gKVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElkTWFwXHJcbiIsIid1c2Ugc3RyaWN0J1xyXG5cclxuY29uc3QgZHJhZ3VsYSA9IHJlcXVpcmUoICdkcmFndWxhJyApXHJcbmNvbnN0IG1vcnBoZG9tID0gcmVxdWlyZSggJ21vcnBoZG9tJyApXHJcbmNvbnN0IElkTWFwID0gcmVxdWlyZSggJy4vaWRtYXAnIClcclxuY29uc3QgRHJha2UgPSByZXF1aXJlKCAnLi9kcmFrZScgKVxyXG5jb25zdCBGaW5kID0gcmVxdWlyZSggJy4vZmluZCcgKVxyXG5cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgZG9jdW1lbnQ6IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdy5kb2N1bWVudCxcclxuICBkcmFndWxhLFxyXG4gIG1vcnBoZG9tLFxyXG4gIHNlbGVjdG9yOiAnLmNvbXBvc2VyJ1xyXG59XHJcblxyXG5jb25zdCB2YWxpZGF0ZU9iaiA9ICggb2JqLCBuYW1lLCB0eXBlTmFtZSApID0+IHtcclxuICBpZiggdHlwZW9mIG9iaiAhPT0gdHlwZU5hbWUgKVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCBgQSAkeyBuYW1lIH0gJHsgdHlwZU5hbWUgfSBpcyByZXF1aXJlZGAgKVxyXG59XHJcblxyXG4vKlxyXG4gIFRPRE9cclxuXHJcbiAgKiB0aGUgZXhwYW5kL2NvbGxhcHNlIGNoaWxkcmVuIGFjdGlvbnMgc2hvdWxkIGJlIGRpc2FibGVkIGlmIHRoYXQgYWN0aW9uIGlzXHJcbiAgICBub3QgcG9zc2libGUgb3IgbmVjZXNzYXJ5XHJcbiAgKiB0aGUgdHJlZSBvciBvcHRpb25zIG9yIHNvbWV0aGluZyBzaG91bGQgYmUgYWJsZSB0byBvdmVycmlkZSB0aGUgYWN0aW9uc1xyXG4gICAgZWcgbm90IGFsbCBub2RlcyBtYXkgaGF2ZSBhbGwgYWN0aW9uc1xyXG5cclxuKi9cclxuY29uc3QgQ29tcG9zZXIgPSAoIHRyZWUsIHJlbmRlck5vZGUsIG9wdGlvbnMgKSA9PiB7XHJcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oIHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyApXHJcblxyXG4gIGNvbnN0IHsgZG9jdW1lbnQsIGRyYWd1bGEsIG1vcnBoZG9tLCBzZWxlY3RvciB9ID0gb3B0aW9uc1xyXG5cclxuICB2YWxpZGF0ZU9iaiggZG9jdW1lbnQsICdkb2N1bWVudCcsICdvYmplY3QnIClcclxuICB2YWxpZGF0ZU9iaiggcmVuZGVyTm9kZSwgJ3JlbmRlck5vZGUnLCAnZnVuY3Rpb24nIClcclxuICB2YWxpZGF0ZU9iaiggc2VsZWN0b3IsICdzZWxlY3RvcicsICdzdHJpbmcnIClcclxuXHJcbiAgY29uc3QgaWRNYXAgPSBJZE1hcCggdHJlZSApXHJcbiAgY29uc3QgZmluZCA9IEZpbmQoIGlkTWFwIClcclxuXHJcbiAgY29uc3QgY29tcG9zZXJWaWV3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvciggc2VsZWN0b3IgKVxyXG5cclxuICBjb25zdCBpbml0aWFsRG9tID0gcmVuZGVyTm9kZSggdHJlZSApXHJcblxyXG4gIG1vcnBoZG9tKCBjb21wb3NlclZpZXcsIGluaXRpYWxEb20uc3RyaW5naWZ5KCkgKVxyXG5cclxuICAvKlxyXG4gICBUT0RPIHRoZSBmdW5jdGlvbnMgc2hvdWxkIHRha2UgdGhlIGFjdHVhbCBlbCBub2RlLCBub3QgdGhlIGNsaWNrZWQgbm9kZSwgYW55XHJcbiAgIGxvZ2ljIGluc2lkZSB0aGUgdmFyaW91cyBmbnMgYmVsb3cgZm9yIGZpbmRpbmcgdGhlIGVsIG5vZGUgc2hvdWxkIGJlIG1vdmVkXHJcbiAgIGhlcmVcclxuICAqL1xyXG4gIGNvbnN0IGNsaWNrSGFuZGxlciA9IHtcclxuICAgICcuY29tcG9zZXItbm9kZV9fdGl0bGUsIC5jb21wb3Nlci1ub2RlX19hY3Rpb24gPiBpJzpcclxuICAgICAgZWwgPT4gZWwucGFyZW50Tm9kZSxcclxuXHJcbiAgICAnLmNvbXBvc2VyLW5vZGVfX3Rvb2xiYXInOiBlbCA9PiB7XHJcbiAgICAgIHRvZ2dsZUVsKCBlbCApXHJcbiAgICB9LFxyXG5cclxuICAgICcuY29tcG9zZXItbm9kZV9fZGVsZXRlJzogZWwgPT4ge1xyXG4gICAgICBjb25zdCBzaG91bGREZWxldGUgPSB3aW5kb3cuY29uZmlybSggJ0FyZSB5b3Ugc3VyZT8nIClcclxuXHJcbiAgICAgIGlmKCBzaG91bGREZWxldGUgKVxyXG4gICAgICAgIHJlbW92ZUVsKCBlbCApXHJcbiAgICB9LFxyXG5cclxuICAgICcuY29tcG9zZXItbm9kZV9fY29sbGFwc2UtY2hpbGRyZW4nOiBlbCA9PiB7XHJcbiAgICAgIGNvbGxhcHNlRWxDaGlsZHJlbiggZWwgKVxyXG4gICAgfSxcclxuXHJcbiAgICAnLmNvbXBvc2VyLW5vZGVfX2V4cGFuZC1jaGlsZHJlbic6IGVsID0+IHtcclxuICAgICAgZXhwYW5kRWxDaGlsZHJlbiggZWwgKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgY2xpY2tTZWxlY3RvcnMgPSBPYmplY3Qua2V5cyggY2xpY2tIYW5kbGVyIClcclxuXHJcbiAgY29uc3QgaGFuZGxlQ2xpY2sgPSBlbCA9PiB7XHJcbiAgICBjb25zdCBzZWxlY3RvciA9IGNsaWNrU2VsZWN0b3JzLmZpbmQoIHNlbCA9PiBlbC5tYXRjaGVzKCBzZWwgKSApXHJcblxyXG4gICAgaWYoIHNlbGVjdG9yICl7XHJcbiAgICAgIGVsID0gY2xpY2tIYW5kbGVyWyBzZWxlY3RvciBdKCBlbCApXHJcbiAgICB9XHJcblxyXG4gICAgaWYoIGVsIClcclxuICAgICAgaGFuZGxlQ2xpY2soIGVsIClcclxuICB9XHJcblxyXG4gIGNvbXBvc2VyVmlldy5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCBlID0+IHtcclxuICAgIGhhbmRsZUNsaWNrKCBlLnRhcmdldCApXHJcbiAgfSlcclxuXHJcbiAgY29uc3QgdG9nZ2xlRWwgPSBlbCA9PiB7XHJcbiAgICBjb25zdCBpc05vZGUgPSBlbC5wYXJlbnROb2RlLm1hdGNoZXMoICcuY29tcG9zZXItbm9kZScgKVxyXG4gICAgY29uc3Qga2V5ID0gaXNOb2RlID8gJ2lzQ29sbGFwc2VkJyA6ICdpc0NoaWxkcmVuQ29sbGFwc2VkJ1xyXG4gICAgY29uc3QgY29sbGFwc2VkQ2xhc3MgPSBpc05vZGUgPyAnY29tcG9zZXItbm9kZS0tY29sbGFwc2VkJyA6ICdjb21wb3Nlci1ub2RlX19jaGlsZHJlbi0tY29sbGFwc2VkJ1xyXG5cclxuICAgIGVsLnBhcmVudE5vZGUuY2xhc3NMaXN0LnRvZ2dsZSggY29sbGFwc2VkQ2xhc3MgKVxyXG5cclxuICAgIGNvbnN0IG5vZGUgPSBpc05vZGUgP1xyXG4gICAgICBpZE1hcC5maW5kQnlJZCggZWwucGFyZW50Tm9kZS5pZCApIDpcclxuICAgICAgZmluZC5jb250YWluZXJFbE5vZGUoIGVsLnBhcmVudE5vZGUgKVxyXG5cclxuICAgIGNvbnN0IGlzQ29sbGFwc2VkID0gZWwucGFyZW50Tm9kZS5tYXRjaGVzKCAnLmNvbXBvc2VyLW5vZGUtLWNvbGxhcHNlZCwgLmNvbXBvc2VyLW5vZGVfX2NoaWxkcmVuLS1jb2xsYXBzZWQnIClcclxuXHJcbiAgICB0b2dnbGUoIG5vZGUsIGtleSwgaXNDb2xsYXBzZWQgKVxyXG4gICAgdXBkYXRlTm9kZSggbm9kZSApXHJcbiAgfVxyXG5cclxuICBjb25zdCBjb2xsYXBzZUVsQ2hpbGRyZW4gPSBlbCA9PiB7XHJcbiAgICBjb25zdCBjb250YWluZXJFbE5vZGUgPSBmaW5kLmNvbnRhaW5lckVsTm9kZSggZWwgKVxyXG4gICAgY29uc3QgY2hpbGRyZW4gPSBjb250YWluZXJFbE5vZGUuZ2V0Q2hpbGRyZW4oKVxyXG5cclxuICAgIGNoaWxkcmVuLmZvckVhY2goIG5vZGUgPT4ge1xyXG4gICAgICB0b2dnbGUoIG5vZGUsICdpc0NvbGxhcHNlZCcsIHRydWUgKVxyXG4gICAgfSlcclxuXHJcbiAgICB1cGRhdGVOb2RlKCBjb250YWluZXJFbE5vZGUgKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgZXhwYW5kRWxDaGlsZHJlbiA9IGVsID0+IHtcclxuICAgIGNvbnN0IGNvbnRhaW5lckVsTm9kZSA9IGZpbmQuY29udGFpbmVyRWxOb2RlKCBlbCApXHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IGNvbnRhaW5lckVsTm9kZS5nZXRDaGlsZHJlbigpXHJcblxyXG4gICAgY2hpbGRyZW4uZm9yRWFjaCggbm9kZSA9PiB7XHJcbiAgICAgIHRvZ2dsZSggbm9kZSwgJ2lzQ29sbGFwc2VkJywgZmFsc2UgKVxyXG4gICAgfSlcclxuXHJcbiAgICB1cGRhdGVOb2RlKCBjb250YWluZXJFbE5vZGUgKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgcmVtb3ZlRWwgPSBlbCA9PiB7XHJcbiAgICBjb25zdCBub2RlRWwgPSBlbC5jbG9zZXN0KCAnLmNvbXBvc2VyLW5vZGUnIClcclxuICAgIGNvbnN0IGlkID0gbm9kZUVsLmlkXHJcbiAgICBjb25zdCBub2RlID0gaWRNYXAuZmluZEJ5SWQoIGlkIClcclxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLmdldFBhcmVudCgpXHJcblxyXG4gICAgbm9kZS5yZW1vdmUoKVxyXG4gICAgLypcclxuICAgICAgSXQgbWF5IHNlZW0gYXMgdGhvdWdoIGJ5IGp1c3QgcmVtb3ZpbmcgdGhlIG5vZGUsIHRoZSBwYXJlbnROb2RlIHdpbGwgYmVcclxuICAgICAgcmVnZW5lcmF0ZWQgY29ycmVjdGx5LCBob3dldmVyIHRoaXMgaXMgbm90IHRoZSBjYXNlIHNvbWV0aW1lcywgbGlrZSB3aGVuXHJcbiAgICAgIHRoZSBub2RlIGlzIHRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgZWxlbWVudC4gTm90IHN1cmUgaWYgcHJvYmxlbSB3aXRoXHJcbiAgICAgIG1vcnBoZG9tIG9yIGlmIEkndmUgbWFkZSBzb21lIG1pc3Rha2VuIGFzc3VtcHRpb24gc29tZXdoZXJlLCBidXQgaW4gYW55XHJcbiAgICAgIGNhc2UgYWxzbyByZW1vdmluZyB0aGUgbm9kZSdzIGVsZW1lbnQgcmVwcmVzZW50YXRpb24gZnJvbSB0aGUgRE9NIGVuc3VyZXNcclxuICAgICAgdGhhdCB0aGlzIHdvcmtzIGNvcnJlY3RseS4gTm90IHJlbW92aW5nIHRoZSBET00gbm9kZSBhbmQgY2FsbGluZ1xyXG4gICAgICB1cGRhdGVOb2RlIHR3aWNlIGFsc28gd29ya3MgLSBnbyBmaWd1cmUgOi9cclxuICAgICovXHJcbiAgICBub2RlRWwucmVtb3ZlKClcclxuXHJcbiAgICB1cGRhdGVOb2RlKCBwYXJlbnROb2RlIClcclxuICB9XHJcblxyXG4gIGNvbnN0IHRvZ2dsZSA9ICggbm9kZSwga2V5LCBpc0NvbGxhcHNlZCApID0+IHtcclxuICAgIG5vZGUubWV0YSgga2V5LCBpc0NvbGxhcHNlZCApXHJcbiAgfVxyXG5cclxuICBjb25zdCB1cGRhdGVOb2RlID0gbm9kZSA9PiB7XHJcbiAgICBjb25zdCBub2RlRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbm9kZS5pZCgpIClcclxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLmdldFBhcmVudCgpXHJcblxyXG4gICAgbGV0IGRlcHRoID0gMFxyXG4gICAgbGV0IHBhcmVudEVsXHJcblxyXG4gICAgaWYoIHBhcmVudE5vZGUgKXtcclxuICAgICAgcGFyZW50RWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggcGFyZW50Tm9kZS5pZCgpIClcclxuICAgICAgZGVwdGggPSBwYXJlbnRFbC5kYXRhc2V0LmRlcHRoICogMSArIDFcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBuZXdFbERvbSA9IHJlbmRlck5vZGUoIG5vZGUsIHsgZGVwdGggfSApXHJcbiAgICBjb25zdCBuZXdFbEh0bWwgPSBuZXdFbERvbS5zdHJpbmdpZnkoKVxyXG5cclxuICAgIG1vcnBoZG9tKCBub2RlRWwsIG5ld0VsSHRtbCApXHJcbiAgfVxyXG5cclxuICBsZXQgZHJvcEhhbmRsZXJcclxuXHJcbiAgY29uc3Qgb25kcm9wID0gKCAuLi5hcmdzICkgPT4ge1xyXG4gICAgaWYoIGRyb3BIYW5kbGVyICkgZHJvcEhhbmRsZXIoIC4uLmFyZ3MgKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgZHJha2VEZXBzID0geyBkcmFndWxhLCB1cGRhdGVOb2RlLCBmaW5kLCBvbmRyb3AgfVxyXG5cclxuICBjb25zdCBkcmFrZSA9IERyYWtlKCBkcmFrZURlcHMgKVxyXG5cclxuICBjb25zdCBhcGkgPSB7XHJcbiAgICByZW1vdmU6ICgpID0+IGNvbXBvc2VyVmlldy5pbm5lckhUTUwgPSAnJyxcclxuICAgIHRyZWU6ICgpID0+IHRyZWUsXHJcbiAgICBpZE1hcDogKCkgPT4gaWRNYXAsXHJcbiAgICBkcm9wSGFuZGxlcjogaGFuZGxlciA9PiB7XHJcbiAgICAgIGlmKCB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJyApXHJcbiAgICAgICAgZHJvcEhhbmRsZXIgPSBoYW5kbGVyXHJcblxyXG4gICAgICByZXR1cm4gZHJvcEhhbmRsZXJcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBhcGlcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb21wb3NlclxyXG4iLCIndXNlIHN0cmljdCdcclxuXHJcbmNvbnN0IENvbXBvc2VyID0gcmVxdWlyZSggJy4vY29tcG9zZXInIClcclxuXHJcbnJlcXVpcmUoICcuL3BvbHlmaWxscycgKVxyXG5cclxud2luZG93Lm1vanVsZSA9IHsgQ29tcG9zZXIgfVxyXG5cclxuLypcclxuVE9ETyB0aGlzIGlzIHRlc3QgY29kZSB0byBnZXQgdGhlIGNvbXBvc2VyIHVwIGFuZCBydW5uaW5nLCBuZWVkcyB0byBiZSBpbml0J2VkXHJcbnByb3Blcmx5IGFzIGFuZCB3aGVyZSBuZWVkZWRcclxuKi9cclxuXHJcbi8vY29uc3QgVHJlZSA9IHJlcXVpcmUoICcxdHJlZScgKVxyXG5jb25zdCBUcmVlRmFjdG9yeSA9IHJlcXVpcmUoICcxdHJlZS1mYWN0b3J5JyApXHJcblxyXG4vL2luIHJlYWxpdHkgdGhpcyB3b3VsZCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgc3BlY2lmaWMgdHJlZSB0eXBlLCB0aGlzIGlzIGp1c3QgYVxyXG4vL2hhY2sgZm9yIHRlc3RpbmdcclxuY29uc3QgaXNFbXB0eVBsdWdpbiA9IGZuID0+IHtcclxuICBjb25zdCBpc0VtcHR5ID0gKCBmbiwgbm9kZSApID0+IHtcclxuICAgIGNvbnN0IHZhbHVlID0gZm4udmFsdWUoIG5vZGUgKVxyXG5cclxuICAgIHJldHVybiB2YWx1ZS5ub2RlVHlwZSA9PT0gJ2ZpbGUnIHx8IHZhbHVlLm5vZGVUeXBlID09PSAndGV4dCdcclxuICB9XHJcblxyXG4gIGlzRW1wdHkuZGVmID0gZm4uaXNFbXB0eS5kZWZcclxuXHJcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oIGZuLCB7IGlzRW1wdHkgfSApXHJcbn1cclxuXHJcbmNvbnN0IFRyZWUgPSBUcmVlRmFjdG9yeSggaXNFbXB0eVBsdWdpbiApXHJcblxyXG5jb25zdCBjb21wb25lbnREZXBlbmRlbmNpZXMgPSByZXF1aXJlKCAnLi4vLi4vZGlzdC9kZXBlbmRlbmNpZXMuanNvbicgKVxyXG5jb25zdCBSZW5kZXJOb2RlID0gcmVxdWlyZSggJy4uL2NvbXBvc2VyLXRyZWUvcmVuZGVyTm9kZScgKVxyXG5jb25zdCByZW5kZXJOb2RlID0gUmVuZGVyTm9kZSggY29tcG9uZW50RGVwZW5kZW5jaWVzIClcclxuXHJcbmNvbnN0IHRyZWVSYXcgPSBjb21wb25lbnREZXBlbmRlbmNpZXMuZGF0YXNbICdkYXRhLXNtYWxsJyBdXHJcbmNvbnN0IHRyZWUgPSBUcmVlKCB0cmVlUmF3IClcclxuXHJcbmNvbnN0IGNvbXBvc2VyQXBpID0gQ29tcG9zZXIoIHRyZWUsIHJlbmRlck5vZGUgKVxyXG4iLCIoZnVuY3Rpb24gKEVsZW1lbnRQcm90bykge1xuXHRpZiAodHlwZW9mIEVsZW1lbnRQcm90by5tYXRjaGVzICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0RWxlbWVudFByb3RvLm1hdGNoZXMgPSBFbGVtZW50UHJvdG8ubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudFByb3RvLm1vek1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50UHJvdG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGZ1bmN0aW9uIG1hdGNoZXMoc2VsZWN0b3IpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gdGhpcztcblx0XHRcdHZhciBlbGVtZW50cyA9IChlbGVtZW50LmRvY3VtZW50IHx8IGVsZW1lbnQub3duZXJEb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cdFx0XHR2YXIgaW5kZXggPSAwO1xuXG5cdFx0XHR3aGlsZSAoZWxlbWVudHNbaW5kZXhdICYmIGVsZW1lbnRzW2luZGV4XSAhPT0gZWxlbWVudCkge1xuXHRcdFx0XHQrK2luZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gQm9vbGVhbihlbGVtZW50c1tpbmRleF0pO1xuXHRcdH07XG5cdH1cblxuXHRpZiAodHlwZW9mIEVsZW1lbnRQcm90by5jbG9zZXN0ICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0RWxlbWVudFByb3RvLmNsb3Nlc3QgPSBmdW5jdGlvbiBjbG9zZXN0KHNlbGVjdG9yKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IHRoaXM7XG5cblx0XHRcdHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcblx0XHRcdFx0aWYgKGVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcikpIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbWVudDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdH1cbn0pKHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZSk7IiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFJlbmRlckNzcyA9IGRlcGVuZGVuY2llcyA9PiB7XG4gIGNvbnN0IHsgc3R5bGVzLCB0cmFuc2Zvcm1Dc3MgfSA9IGRlcGVuZGVuY2llc1xuXG4gIGNvbnN0IHJlbmRlckNzcyA9IHJvb3QgPT4ge1xuICAgIGxldCBjc3MgPSAnJ1xuXG4gICAgY29uc3QgYWxyZWFkeUFkZGVkID0gbmV3IFNldCgpXG5cbiAgICByb290LndhbGsoIG5vZGUgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBub2RlLnZhbHVlKClcbiAgICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSB2YWx1ZS5uYW1lXG5cbiAgICAgIGlmKCBhbHJlYWR5QWRkZWQuaGFzKCBjb21wb25lbnROYW1lICkgKVxuICAgICAgICByZXR1cm5cblxuICAgICAgYWxyZWFkeUFkZGVkLmFkZCggY29tcG9uZW50TmFtZSApXG5cbiAgICAgIGNvbnN0IHN0eWxlID0gc3R5bGVzWyBjb21wb25lbnROYW1lIF1cblxuICAgICAgaWYoIHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycgKXtcbiAgICAgICAgY3NzICs9IHN0eWxlXG4gICAgICAgIGNzcyArPSAnICdcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYoIHR5cGVvZiB0cmFuc2Zvcm1Dc3MgPT09ICdmdW5jdGlvbicgKVxuICAgICAgY3NzID0gdHJhbnNmb3JtQ3NzKCBjc3MgKVxuXG4gICAgcmV0dXJuIGNzc1xuICB9XG5cbiAgcmV0dXJuIHJlbmRlckNzc1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlckNzc1xuIiwiJ3VzZSBzdHJpY3QnXHJcblxyXG5jb25zdCBUZW1wbGF0ZXMgPSByZXF1aXJlKCAnLi4vLi4vdGVtcGxhdGVzJyApXHJcbmNvbnN0IFJlbmRlckNzcyA9IHJlcXVpcmUoICcuL3JlbmRlckNzcycgKVxyXG5cclxuY29uc3QgUmVuZGVyTm9kZSA9IGRlcGVuZGVuY2llcyA9PiB7XHJcbiAgY29uc3QgcmVuZGVyQ3NzID0gUmVuZGVyQ3NzKCBkZXBlbmRlbmNpZXMgKVxyXG4gIGNvbnN0IHsgY29uZmlncyB9ID0gZGVwZW5kZW5jaWVzXHJcbiAgY29uc3QgeyByZW5kZXJDb21wb25lbnQgfSA9IFRlbXBsYXRlcyggZGVwZW5kZW5jaWVzIClcclxuXHJcbiAgY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcclxuICAgIGNvbnRhaW5lclNlbGVjdG9yOiBcIltkYXRhLWNvbnRhaW5lcl1cIlxyXG4gIH1cclxuXHJcbiAgY29uc3QgYWRkQ3NzVG9Eb2N1bWVudEhlYWQgPSBub2RlID0+IHtcclxuICAgIGNvbnN0IHZhbHVlID0gbm9kZS52YWx1ZSgpXHJcbiAgICBjb25zdCBjb21wb25lbnROYW1lID0gdmFsdWUubmFtZVxyXG4gICAgY29uc3QgY29tcG9uZW50TW9kZWwgPSB2YWx1ZS5tb2RlbFxyXG5cclxuICAgIGNvbnN0IGNzcyA9IHJlbmRlckNzcyggbm9kZSApXHJcblxyXG4gICAgaWYoICFBcnJheS5pc0FycmF5KCBjb21wb25lbnRNb2RlbC5oZWFkU3R5bGVzICkgKVxyXG4gICAgICBjb21wb25lbnRNb2RlbC5oZWFkU3R5bGVzID0gW11cclxuXHJcbiAgICBjb21wb25lbnRNb2RlbC5oZWFkU3R5bGVzLnB1c2goe1xyXG4gICAgICB0ZXh0OiBjc3NcclxuICAgIH0pXHJcblxyXG4gICAgbm9kZS52YWx1ZSggdmFsdWUgKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgcmVuZGVyTm9kZSA9IG5vZGUgPT4ge1xyXG4gICAgY29uc3QgdmFsdWUgPSBub2RlLnZhbHVlKClcclxuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSB2YWx1ZS5uYW1lXHJcbiAgICBjb25zdCBjb21wb25lbnRNb2RlbCA9IHZhbHVlLm1vZGVsXHJcblxyXG4gICAgaWYoIGNvbXBvbmVudE5hbWUgPT09ICdkb2N1bWVudCcgKXtcclxuICAgICAgYWRkQ3NzVG9Eb2N1bWVudEhlYWQoIG5vZGUgKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRvbSA9IHJlbmRlckNvbXBvbmVudCggY29tcG9uZW50TmFtZSwgY29tcG9uZW50TW9kZWwgKVxyXG4gICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbigge30sIGRlZmF1bHRDb25maWcsIGNvbmZpZ3NbIGNvbXBvbmVudE5hbWUgXSApXHJcbiAgICBjb25zdCBjaGlsZENvbnRhaW5lciA9IGRvbS5zZWxlY3QoIGNvbmZpZy5jb250YWluZXJTZWxlY3RvciApXHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKVxyXG5cclxuICAgIGlmKCBjaGlsZENvbnRhaW5lciAmJiBjaGlsZHJlbi5sZW5ndGggKXtcclxuICAgICAgY2hpbGRyZW4uZm9yRWFjaCggY2hpbGROb2RlID0+IHtcclxuICAgICAgICBjb25zdCBjaGlsZERvbSA9IHJlbmRlck5vZGUoIGNoaWxkTm9kZSApXHJcblxyXG4gICAgICAgIGlmKCBjaGlsZENvbnRhaW5lci5ub2RlTmFtZSgpID09PSAndWwnIHx8IGNoaWxkQ29udGFpbmVyLm5vZGVOYW1lKCkgPT09ICdvbCcgKXtcclxuICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIGRvbS5wYXJzZSBhbHdheXMgcmV0dXJucyBhIGZyYWdtZW50LCBiZWNhdXNlIHRoZSBodG1sIHN0cmluZyBjb3VsZFxyXG4gICAgICAgICAgICBjb250YWluIG11bHRpcGxlIGVsZW1lbnRzXHJcblxyXG4gICAgICAgICAgICBwZXJoYXBzIGlmIHdlIHNlZSBpdCBvbmx5IGhhcyBvbmUgZWxlbWVudCwgd2Ugc2hvdWxkIHJldHVybiB0aGF0XHJcbiAgICAgICAgICAgIHJhdGhlciB0aGFuIGEgZG9jdW1lbnRGcmFnbWVudCB3aXRoIGEgc2luZ2xlIGNoaWxkLCBidXQgY29udGludWUgdG9cclxuICAgICAgICAgICAgdXNlIGN1cnJlbnQgYmVoYXZpb3VyIGlmIHRoZSBmcmFnbWVudCBoYXMgbXVsdGlwbGUgY2hpbGRyZW4/XHJcbiAgICAgICAgICAqL1xyXG4gICAgICAgICAgY29uc3QgbGlOb2RlID0gZG9tLnBhcnNlKCAnPGxpPjwvbGk+JyApLnNlbGVjdCggJ2xpJyApXHJcblxyXG4gICAgICAgICAgbGlOb2RlLmFwcGVuZCggY2hpbGREb20gKVxyXG4gICAgICAgICAgY2hpbGRDb250YWluZXIuYXBwZW5kKCBsaU5vZGUgKVxyXG5cclxuICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hpbGRDb250YWluZXIuYXBwZW5kKCBjaGlsZERvbSApXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRvbVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlbmRlck5vZGVcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJOb2RlXHJcbiIsIid1c2Ugc3RyaWN0J1xyXG5cclxuY29uc3QgdHJlZVNjaGVtYSA9IHJlcXVpcmUoICcxdHJlZS1zY2hlbWEnIClcclxuY29uc3QgdHJlZUpzb24gPSByZXF1aXJlKCAnMXRyZWUtanNvbicgKVxyXG5jb25zdCB0cmFuc2Zvcm1NYXBwZXIgPSByZXF1aXJlKCAnbW9qdWxlLXRyYW5zZm9ybScgKVxyXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoICdtb2p1bGUtdXRpbHMnIClcclxuXHJcbmNvbnN0IHsgY2xvbmUgfSA9IHV0aWxzXHJcblxyXG5jb25zdCBtYXBDb21wb25lbnRzID0gKCBkZXBlbmRlbmNpZXMsIGNvbXBvbmVudE5hbWUsIG1vZGVsICkgPT4ge1xyXG4gIG1vZGVsID0gY2xvbmUoIG1vZGVsIClcclxuXHJcbiAgY29uc3QgbW9kZWxUcmVlID0gdHJlZUpzb24udG9UcmVlKCBtb2RlbCApXHJcblxyXG4gIGNvbnN0IHsgY29tcG9uZW50TmFtZXMsIHNjaGVtYXMsIHRyYW5zZm9ybXMgfSA9IGRlcGVuZGVuY2llc1xyXG5cclxuICBjb25zdCBzY2hlbWFOYW1lcyA9IE9iamVjdC5rZXlzKCBzY2hlbWFzIClcclxuXHJcbiAgY29uc3QgZmluZFJlZkNvbXBvbmVudHMgPSBzY2hlbWFOb2RlID0+XHJcbiAgICBzY2hlbWFOb2RlLmZpbmRBbGwoIG4gPT5cclxuICAgICAgY29tcG9uZW50TmFtZXMuaW5jbHVkZXMoIG4udmFsdWUoKS4kcmVmIClcclxuICAgIClcclxuXHJcbiAgY29uc3QgdHJhbnNmb3JtID0gdHJhbnNmb3Jtc1sgY29tcG9uZW50TmFtZSBdXHJcbiAgY29uc3QgY29tcG9uZW50U2NoZW1hID0gc2NoZW1hc1sgY29tcG9uZW50TmFtZSBdXHJcblxyXG4gIGlmKCB0cmFuc2Zvcm0gJiYgIWNvbXBvbmVudFNjaGVtYSApe1xyXG4gICAgcmV0dXJuIHRyYW5zZm9ybU1hcHBlciggbW9kZWwsIHRyYW5zZm9ybSApXHJcbiAgfVxyXG5cclxuICBpZiggIXRyYW5zZm9ybSAmJiAhY29tcG9uZW50U2NoZW1hICl7XHJcbiAgICByZXR1cm4gbW9kZWxcclxuICB9XHJcblxyXG4gIGNvbnN0IGNvbXBvbmVudFNjaGVtYVRyZWUgPSB0cmVlU2NoZW1hLnRvVHJlZSggY29tcG9uZW50U2NoZW1hIClcclxuICBjb25zdCByZWZDb21wb25lbnRzID0gZmluZFJlZkNvbXBvbmVudHMoIGNvbXBvbmVudFNjaGVtYVRyZWUgKVxyXG5cclxuICByZWZDb21wb25lbnRzLmZvckVhY2goIHJlZkNvbXBvbmVudE5vZGUgPT4ge1xyXG4gICAgY29uc3QgdmFsdWUgPSByZWZDb21wb25lbnROb2RlLnZhbHVlKClcclxuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSB2YWx1ZS4kcmVmXHJcbiAgICBjb25zdCBjb21wb25lbnRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1zWyBjb21wb25lbnROYW1lIF1cclxuXHJcbiAgICBpZiggIWNvbXBvbmVudFRyYW5zZm9ybSApIHJldHVyblxyXG5cclxuICAgIGNvbnN0IHJlZk5vZGVQYXRoID0gdHJlZVNjaGVtYS5wYXRoRnJvbU5vZGUoIHJlZkNvbXBvbmVudE5vZGUgKVxyXG4gICAgY29uc3QgbW9kZWxOb2RlID0gdHJlZUpzb24ubm9kZUZyb21QYXRoKCBtb2RlbFRyZWUsIHJlZk5vZGVQYXRoIClcclxuXHJcbiAgICBpZiggIW1vZGVsTm9kZSApIHJldHVyblxyXG5cclxuICAgIGNvbnN0IG1vZGVsTm9kZVZhbHVlID0gbW9kZWxOb2RlLnZhbHVlKClcclxuXHJcbiAgICBpZiggdmFsdWUuYXJyYXlJdGVtICl7XHJcbiAgICAgIGNvbnN0IG1vZGVsQXJyYXkgPSB0cmVlSnNvbi50b0pzb24oIG1vZGVsTm9kZSApXHJcblxyXG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IG1vZGVsQXJyYXkubWFwKCBpdGVtID0+XHJcbiAgICAgICAgbWFwQ29tcG9uZW50cyggZGVwZW5kZW5jaWVzLCBjb21wb25lbnROYW1lLCBpdGVtIClcclxuICAgICAgKVxyXG5cclxuICAgICAgY29uc3QgdHJhbnNmb3JtZWROb2RlID0gdHJlZUpzb24udG9UcmVlKCB0cmFuc2Zvcm1lZCApXHJcbiAgICAgIGNvbnN0IG1vZGVsTm9kZVBhcmVudCA9IG1vZGVsTm9kZS5nZXRQYXJlbnQoKVxyXG5cclxuICAgICAgaWYoIG1vZGVsTm9kZVZhbHVlLnByb3BlcnR5TmFtZSApe1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkTm9kZVZhbHVlID0gdHJhbnNmb3JtZWROb2RlLnZhbHVlKClcclxuICAgICAgICB0cmFuc2Zvcm1lZE5vZGVWYWx1ZS5wcm9wZXJ0eU5hbWUgPSBtb2RlbE5vZGVWYWx1ZS5wcm9wZXJ0eU5hbWVcclxuICAgICAgICB0cmFuc2Zvcm1lZE5vZGUudmFsdWUoIHRyYW5zZm9ybWVkTm9kZVZhbHVlIClcclxuICAgICAgfVxyXG5cclxuICAgICAgbW9kZWxOb2RlUGFyZW50LnJlcGxhY2VDaGlsZCggdHJhbnNmb3JtZWROb2RlLCBtb2RlbE5vZGUgIClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvciggJ05vbiBhcnJheWl0ZW0gbm90IGltcGxlbWVudGVkIHlldCcgKVxyXG4gICAgfVxyXG4gIH0pXHJcblxyXG4gIG1vZGVsID0gdHJlZUpzb24udG9Kc29uKCBtb2RlbFRyZWUgKVxyXG5cclxuICBpZiggdHJhbnNmb3JtIClcclxuICAgIG1vZGVsID0gdHJhbnNmb3JtTWFwcGVyKCBtb2RlbCwgdHJhbnNmb3JtIClcclxuXHJcbiAgcmV0dXJuIG1vZGVsXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbWFwQ29tcG9uZW50c1xyXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgVHJlZSA9IHJlcXVpcmUoICcxdHJlZScgKVxuY29uc3Qgbm9kZVRvTW9kZWwgPSByZXF1aXJlKCAnLi9kZWZhdWx0Tm9kZVRvTW9kZWwnIClcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGRlcHRoOiAwLFxuICBjcmVhdGVOb2RlOiBUcmVlLmNyZWF0ZVJvb3QsXG4gIGFsd2F5c1JlbmRlckNoaWxkcmVuOiBmYWxzZSxcbiAgbm9kZVRvTW9kZWxcbn1cblxuY29uc3Qgbm9kZVRvQ29tcG9zZXJOb2RlID0gKCBub2RlLCBvcHRpb25zICkgPT4ge1xuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbigge30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zIClcblxuICBjb25zdCB7IGRlcHRoLCBjcmVhdGVOb2RlLCBub2RlVG9Nb2RlbCwgYWx3YXlzUmVuZGVyQ2hpbGRyZW4gfSA9IG9wdGlvbnNcblxuICBjb25zdCBtb2RlbCA9IG5vZGVUb01vZGVsKCBub2RlLCB7IGRlcHRoIH0gKVxuXG4gIGNvbnN0IHZhbHVlID0ge1xuICAgIG5hbWU6ICdjb21wb3Nlci1ub2RlJyxcbiAgICBtb2RlbFxuICB9XG5cbiAgY29uc3QgY29tcG9uZW50Tm9kZSA9IGNyZWF0ZU5vZGUoIHZhbHVlIClcblxuICBjb25zdCBzaG91bGRSZW5kZXJDaGlsZHJlbiA9IGFsd2F5c1JlbmRlckNoaWxkcmVuIHx8ICFtb2RlbC5pc0NoaWxkcmVuQ29sbGFwc2VkXG5cbiAgaWYoIHNob3VsZFJlbmRlckNoaWxkcmVuICkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpXG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKCBjaGlsZE5vZGUgPT4ge1xuICAgICAgY29uc3QgY2hpbGRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHtcbiAgICAgICAgICBkZXB0aDogZGVwdGggKyAxXG4gICAgICAgIH1cbiAgICAgIClcblxuICAgICAgY29uc3QgY29tcG9uZW50Q2hpbGROb2RlID0gbm9kZVRvQ29tcG9zZXJOb2RlKCBjaGlsZE5vZGUsIGNoaWxkT3B0aW9ucyApXG5cbiAgICAgIGNvbXBvbmVudE5vZGUuYXBwZW5kKCBjb21wb25lbnRDaGlsZE5vZGUgKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gY29tcG9uZW50Tm9kZVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVRvQ29tcG9zZXJOb2RlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBlc2NhcGVIdG1sIH0gPSByZXF1aXJlKCAnbW9qdWxlLXV0aWxzJyApXG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBkZXB0aDogMFxufVxuXG5jb25zdCBub2RlVG9Nb2RlbCA9ICggbm9kZSwgb3B0aW9ucyApID0+IHtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oIHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyApXG5cbiAgY29uc3QgeyBkZXB0aCB9ID0gb3B0aW9uc1xuXG4gIGNvbnN0IHZhbHVlID0gbm9kZS52YWx1ZSgpXG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpXG5cbiAgY29uc3QgaWQgPSBub2RlLmlkKClcbiAgY29uc3QgbmFtZSA9IHZhbHVlLm5hbWUgfHwgJydcbiAgY29uc3QgdHJlZVR5cGUgPSAnMXRyZWUnXG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS5ub2RlVHlwZSgpXG4gIGNvbnN0IHRpdGxlID0gYCR7IGRlcHRoIH06ICR7IG5hbWUgfSAkeyBub2RlVHlwZSB9IFsgJHsgY2hpbGRyZW4ubGVuZ3RoIH0gXWBcbiAgY29uc3QgaXNFbXB0eSA9IG5vZGUuaXNFbXB0eSgpXG5cbiAgbGV0IGlzQ29sbGFwc2VkID0gbm9kZS5tZXRhKCAnaXNDb2xsYXBzZWQnIClcblxuICBpc0NvbGxhcHNlZCA9IHR5cGVvZiBpc0NvbGxhcHNlZCA9PT0gJ2Jvb2xlYW4nID8gaXNDb2xsYXBzZWQgOiBkZXB0aCA+IDBcblxuICBjb25zdCBpc0NoaWxkcmVuQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQgfHwgISFub2RlLm1ldGEoICdpc0NoaWxkcmVuQ29sbGFwc2VkJyApXG5cbiAgY29uc3QgcHJldmlldyA9IGVzY2FwZUh0bWwoIEpTT04uc3RyaW5naWZ5KCB2YWx1ZSApIClcbiAgY29uc3QgY2hpbGRyZW5UaXRsZSA9IGAkeyBkZXB0aCB9OiBjaGlsZHJlbmBcblxuICBjb25zdCBtb2RlbCA9IHtcbiAgICBpZCwgdGl0bGUsIHRyZWVUeXBlLCBub2RlVHlwZSwgZGVwdGgsIGlzRW1wdHksIGlzQ29sbGFwc2VkLFxuICAgIGlzQ2hpbGRyZW5Db2xsYXBzZWQsIHByZXZpZXcsIGNoaWxkcmVuVGl0bGVcbiAgfVxuXG4gIHJldHVybiBtb2RlbFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVUb01vZGVsXG4iLCIndXNlIHN0cmljdCdcclxuXHJcbmNvbnN0IFRyZWUgPSByZXF1aXJlKCAnMXRyZWUnIClcclxuY29uc3Qgbm9kZVRvTW9kZWwgPSByZXF1aXJlKCAnLi9kZWZhdWx0Tm9kZVRvTW9kZWwnIClcclxuY29uc3Qgbm9kZVRvQ29tcG9zZXJOb2RlID0gcmVxdWlyZSggJy4vZGVmYXVsdE5vZGVUb0NvbXBvc2VyTm9kZScgKVxyXG5jb25zdCBDb21wb25lbnRSZW5kZXJOb2RlID0gcmVxdWlyZSggJy4uL2NvbXBvbmVudHMvY29tcG9uZW50LXRyZWUvcmVuZGVyTm9kZScgKVxyXG5cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgZGVwdGg6IDAsXHJcbiAgY3JlYXRlTm9kZTogVHJlZS5jcmVhdGVSb290LFxyXG4gIG5vZGVUb01vZGVsLFxyXG4gIG5vZGVUb0NvbXBvc2VyTm9kZVxyXG59XHJcblxyXG5jb25zdCBSZW5kZXJOb2RlID0gZGVwZW5kZW5jaWVzID0+IHtcclxuICBjb25zdCBjb21wb25lbnRSZW5kZXJOb2RlID0gQ29tcG9uZW50UmVuZGVyTm9kZSggZGVwZW5kZW5jaWVzIClcclxuXHJcbiAgY29uc3QgcmVuZGVyTm9kZSA9ICggbm9kZSwgb3B0aW9ucyApID0+IHtcclxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKCB7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgKVxyXG5cclxuICAgIGNvbnN0IHsgbm9kZVRvTW9kZWwsIG5vZGVUb0NvbXBvc2VyTm9kZSwgZGVwdGgsIGNyZWF0ZU5vZGUgfSA9IG9wdGlvbnNcclxuXHJcbiAgICBjb25zdCB0b0NvbXBvc2VyTm9kZU9wdGlvbnMgPSB7IGRlcHRoLCBjcmVhdGVOb2RlLCBub2RlVG9Nb2RlbCB9XHJcbiAgICBjb25zdCBjb21wb3Nlck5vZGUgPSBub2RlVG9Db21wb3Nlck5vZGUoIG5vZGUsIHRvQ29tcG9zZXJOb2RlT3B0aW9ucyApXHJcbiAgICBjb25zdCBjb21wb25lbnROb2RlID0gY29tcG9uZW50UmVuZGVyTm9kZSggY29tcG9zZXJOb2RlIClcclxuXHJcbiAgICByZXR1cm4gY29tcG9uZW50Tm9kZVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlbmRlck5vZGVcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJOb2RlXHJcbiIsIid1c2Ugc3RyaWN0J1xyXG5cclxuY29uc3QgVGVtcGxhdGluZyA9IHJlcXVpcmUoICdtb2p1bGUtdGVtcGxhdGluZycgKVxyXG5jb25zdCBWYWxpZGF0b3IgPSByZXF1aXJlKCAnbXR5cGUtdHY0JyApXHJcbmNvbnN0IGNvbXBvbmVudFRyYW5zZm9ybU1hcHBlciA9IHJlcXVpcmUoICcuLi9jb21wb25lbnRzL2NvbXBvbmVudFRyYW5zZm9ybU1hcHBlcicgKVxyXG5cclxuY29uc3QgZW5zdXJlTW9kZWwgPSAoIHZhbGlkYXRvciwgbW9kZWwsIG5hbWUgKSA9PiB7XHJcbiAgY29uc3Qgc2NoZW1hTmFtZXMgPSB2YWxpZGF0b3IuZ2V0U2NoZW1hVXJpcygpXHJcblxyXG4gIGlmKCAhc2NoZW1hTmFtZXMuaW5jbHVkZXMoIG5hbWUgKSApIHJldHVyblxyXG5cclxuICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IudmFsaWRhdGVNdWx0aXBsZSggbW9kZWwsIG5hbWUgKVxyXG5cclxuICBpZiggcmVzdWx0LnZhbGlkICkgcmV0dXJuXHJcblxyXG4gIGNvbnN0IG1lc3NhZ2UgPSBgVGVtcGxhdGUgbW9kZWwgdmFsaWRhdGlvbiBmYWlsZWQgZm9yICR7IG5hbWUgfTogJHsgSlNPTi5zdHJpbmdpZnkoIHJlc3VsdC5lcnJvcnMgKSB9YFxyXG4gIHRocm93IG5ldyBFcnJvciggbWVzc2FnZSApXHJcbn1cclxuXHJcbmNvbnN0IFRlbXBsYXRlcyA9IGRlcGVuZGVuY2llcyA9PiB7XHJcbiAgY29uc3QgeyBjb21wb25lbnRzLCB0ZW1wbGF0ZXMsIGRlZmF1bHRNb2RlbHMsIHNjaGVtYXMgfSA9IGRlcGVuZGVuY2llc1xyXG5cclxuICBjb25zdCB0ZW1wbGF0aW5nID0gVGVtcGxhdGluZyggdGVtcGxhdGVzIClcclxuICBjb25zdCB2YWxpZGF0b3IgPSBWYWxpZGF0b3IoIHNjaGVtYXMgKVxyXG5cclxuICBjb25zdCByZW5kZXJDb21wb25lbnQgPSAoIG5hbWUsIG1vZGVsICkgPT4ge1xyXG4gICAgY29uc3QgdGVtcGxhdGVNb2RlbCA9IE9iamVjdC5hc3NpZ24oIHt9LCBkZWZhdWx0TW9kZWxzWyBuYW1lIF0gfHwge30sIG1vZGVsIClcclxuXHJcbiAgICBlbnN1cmVNb2RlbCggdmFsaWRhdG9yLCB0ZW1wbGF0ZU1vZGVsLCBuYW1lIClcclxuXHJcbiAgICBjb25zdCB2aWV3TW9kZWwgPSBjb21wb25lbnRUcmFuc2Zvcm1NYXBwZXIoIGRlcGVuZGVuY2llcywgbmFtZSwgdGVtcGxhdGVNb2RlbCApXHJcblxyXG4gICAgcmV0dXJuIHRlbXBsYXRpbmcoIG5hbWUsIHZpZXdNb2RlbCApXHJcbiAgfVxyXG5cclxuICAvL1RPRE8gSSBiZWxpZXZlIHRoYXQgdGhpcyBkb2Vzbid0IG5lZWQgdG8gdXNlIGNhbGxiYWNrcyBhbnltb3JlXHJcbiAgY29uc3QgcmVuZGVyVGVtcGxhdGUgPSAoIG5hbWUsIG1vZGVsLCBjYWxsYmFjayApID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRvY3VtZW50TW9kZWwgPSBPYmplY3QuYXNzaWduKCB7fSwgZGVmYXVsdE1vZGVscy5kb2N1bWVudCwgbW9kZWwgKVxyXG5cclxuICAgICAgaWYoIG5hbWUgIT09ICdkb2N1bWVudCcgKXtcclxuICAgICAgICBjb25zdCBib2R5ID0gcmVuZGVyQ29tcG9uZW50KCBuYW1lLCBtb2RlbCApLnN0cmluZ2lmeSgpXHJcblxyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oIGRvY3VtZW50TW9kZWwsIHsgYm9keSB9IClcclxuICAgICAgfVxyXG5cclxuICAgICAgZW5zdXJlTW9kZWwoIHZhbGlkYXRvciwgZG9jdW1lbnRNb2RlbCwgJ2RvY3VtZW50JyApXHJcblxyXG4gICAgICBjb25zdCB2aWV3TW9kZWwgPSBjb21wb25lbnRUcmFuc2Zvcm1NYXBwZXIoIGRlcGVuZGVuY2llcywgJ2RvY3VtZW50JywgZG9jdW1lbnRNb2RlbCApXHJcblxyXG4gICAgICBjb25zdCBkb20gPSB0ZW1wbGF0aW5nKCAnZG9jdW1lbnQnLCB2aWV3TW9kZWwgKVxyXG5cclxuICAgICAgY2FsbGJhY2soIG51bGwsIGRvbSApXHJcbiAgICB9IGNhdGNoKCBlICl7XHJcbiAgICAgIGNhbGxiYWNrKCBlIClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7IHJlbmRlclRlbXBsYXRlLCByZW5kZXJDb21wb25lbnQgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRlbXBsYXRlc1xyXG4iXX0=
